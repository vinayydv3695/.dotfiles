/*! For license information please see extensionWeb.js.LICENSE.txt */
!function(e,n){if("object"==typeof exports&&"object"==typeof module)module.exports=n();else if("function"==typeof define&&define.amd)define([],n);else{var t=n();for(var r in t)("object"==typeof exports?exports:e)[r]=t[r]}}(self,(()=>(()=>{var __webpack_modules__={"./node_modules/diff-match-patch/index.js":module=>{eval("/**\n * Diff Match and Patch\n * Copyright 2018 The diff-match-patch Authors.\n * https://github.com/google/diff-match-patch\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Computes the difference between two texts to create a patch.\n * Applies the patch onto another text, allowing for errors.\n * @author fraser@google.com (Neil Fraser)\n */\n\n/**\n * Class containing the diff, match and patch methods.\n * @constructor\n */\nvar diff_match_patch = function() {\n\n  // Defaults.\n  // Redefine these in your program to override the defaults.\n\n  // Number of seconds to map a diff before giving up (0 for infinity).\n  this.Diff_Timeout = 1.0;\n  // Cost of an empty edit operation in terms of edit characters.\n  this.Diff_EditCost = 4;\n  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).\n  this.Match_Threshold = 0.5;\n  // How far to search for a match (0 = exact location, 1000+ = broad match).\n  // A match this many characters away from the expected location will add\n  // 1.0 to the score (0.0 is a perfect match).\n  this.Match_Distance = 1000;\n  // When deleting a large block of text (over ~64 characters), how close do\n  // the contents have to be to match the expected contents. (0.0 = perfection,\n  // 1.0 = very loose).  Note that Match_Threshold controls how closely the\n  // end points of a delete need to match.\n  this.Patch_DeleteThreshold = 0.5;\n  // Chunk size for context length.\n  this.Patch_Margin = 4;\n\n  // The number of bits in an int.\n  this.Match_MaxBits = 32;\n};\n\n\n//  DIFF FUNCTIONS\n\n\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */\nvar DIFF_DELETE = -1;\nvar DIFF_INSERT = 1;\nvar DIFF_EQUAL = 0;\n\n/**\n * Class representing one diff tuple.\n * ~Attempts to look like a two-element array (which is what this used to be).~\n * Constructor returns an actual two-element array, to allow destructing @JackuB\n * See https://github.com/JackuB/diff-match-patch/issues/14 for details\n * @param {number} op Operation, one of: DIFF_DELETE, DIFF_INSERT, DIFF_EQUAL.\n * @param {string} text Text to be deleted, inserted, or retained.\n * @constructor\n */\ndiff_match_patch.Diff = function(op, text) {\n  return [op, text];\n};\n\n/**\n * Find the differences between two texts.  Simplifies the problem by stripping\n * any common prefix or suffix off the texts before diffing.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean=} opt_checklines Optional speedup flag. If present and false,\n *     then don't run a line-level diff first to identify the changed areas.\n *     Defaults to true, which does a faster, slightly less optimal diff.\n * @param {number=} opt_deadline Optional time when the diff should be complete\n *     by.  Used internally for recursive calls.  Users should set DiffTimeout\n *     instead.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,\n    opt_deadline) {\n  // Set a deadline by which time the diff must be complete.\n  if (typeof opt_deadline == 'undefined') {\n    if (this.Diff_Timeout <= 0) {\n      opt_deadline = Number.MAX_VALUE;\n    } else {\n      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;\n    }\n  }\n  var deadline = opt_deadline;\n\n  // Check for null inputs.\n  if (text1 == null || text2 == null) {\n    throw new Error('Null input. (diff_main)');\n  }\n\n  // Check for equality (speedup).\n  if (text1 == text2) {\n    if (text1) {\n      return [new diff_match_patch.Diff(DIFF_EQUAL, text1)];\n    }\n    return [];\n  }\n\n  if (typeof opt_checklines == 'undefined') {\n    opt_checklines = true;\n  }\n  var checklines = opt_checklines;\n\n  // Trim off common prefix (speedup).\n  var commonlength = this.diff_commonPrefix(text1, text2);\n  var commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength);\n  text2 = text2.substring(commonlength);\n\n  // Trim off common suffix (speedup).\n  commonlength = this.diff_commonSuffix(text1, text2);\n  var commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength);\n  text2 = text2.substring(0, text2.length - commonlength);\n\n  // Compute the diff on the middle block.\n  var diffs = this.diff_compute_(text1, text2, checklines, deadline);\n\n  // Restore the prefix and suffix.\n  if (commonprefix) {\n    diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, commonprefix));\n  }\n  if (commonsuffix) {\n    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, commonsuffix));\n  }\n  this.diff_cleanupMerge(diffs);\n  return diffs;\n};\n\n\n/**\n * Find the differences between two texts.  Assumes that the texts do not\n * have any common prefix or suffix.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean} checklines Speedup flag.  If false, then don't run a\n *     line-level diff first to identify the changed areas.\n *     If true, then run a faster, slightly less optimal diff.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,\n    deadline) {\n  var diffs;\n\n  if (!text1) {\n    // Just add some text (speedup).\n    return [new diff_match_patch.Diff(DIFF_INSERT, text2)];\n  }\n\n  if (!text2) {\n    // Just delete some text (speedup).\n    return [new diff_match_patch.Diff(DIFF_DELETE, text1)];\n  }\n\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  var i = longtext.indexOf(shorttext);\n  if (i != -1) {\n    // Shorter text is inside the longer text (speedup).\n    diffs = [new diff_match_patch.Diff(DIFF_INSERT, longtext.substring(0, i)),\n             new diff_match_patch.Diff(DIFF_EQUAL, shorttext),\n             new diff_match_patch.Diff(DIFF_INSERT,\n                 longtext.substring(i + shorttext.length))];\n    // Swap insertions for deletions if diff is reversed.\n    if (text1.length > text2.length) {\n      diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n    }\n    return diffs;\n  }\n\n  if (shorttext.length == 1) {\n    // Single character string.\n    // After the previous speedup, the character can't be an equality.\n    return [new diff_match_patch.Diff(DIFF_DELETE, text1),\n            new diff_match_patch.Diff(DIFF_INSERT, text2)];\n  }\n\n  // Check to see if the problem can be split in two.\n  var hm = this.diff_halfMatch_(text1, text2);\n  if (hm) {\n    // A half-match was found, sort out the return data.\n    var text1_a = hm[0];\n    var text1_b = hm[1];\n    var text2_a = hm[2];\n    var text2_b = hm[3];\n    var mid_common = hm[4];\n    // Send both pairs off for separate processing.\n    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);\n    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);\n    // Merge the results.\n    return diffs_a.concat([new diff_match_patch.Diff(DIFF_EQUAL, mid_common)],\n                          diffs_b);\n  }\n\n  if (checklines && text1.length > 100 && text2.length > 100) {\n    return this.diff_lineMode_(text1, text2, deadline);\n  }\n\n  return this.diff_bisect_(text1, text2, deadline);\n};\n\n\n/**\n * Do a quick line-level diff on both strings, then rediff the parts for\n * greater accuracy.\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {\n  // Scan the text on a line-by-line basis first.\n  var a = this.diff_linesToChars_(text1, text2);\n  text1 = a.chars1;\n  text2 = a.chars2;\n  var linearray = a.lineArray;\n\n  var diffs = this.diff_main(text1, text2, false, deadline);\n\n  // Convert the diff back to original text.\n  this.diff_charsToLines_(diffs, linearray);\n  // Eliminate freak matches (e.g. blank lines)\n  this.diff_cleanupSemantic(diffs);\n\n  // Rediff any replacement blocks, this time character-by-character.\n  // Add a dummy entry at the end.\n  diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ''));\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete >= 1 && count_insert >= 1) {\n          // Delete the offending records and add the merged ones.\n          diffs.splice(pointer - count_delete - count_insert,\n                       count_delete + count_insert);\n          pointer = pointer - count_delete - count_insert;\n          var subDiff =\n              this.diff_main(text_delete, text_insert, false, deadline);\n          for (var j = subDiff.length - 1; j >= 0; j--) {\n            diffs.splice(pointer, 0, subDiff[j]);\n          }\n          pointer = pointer + subDiff.length;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n    pointer++;\n  }\n  diffs.pop();  // Remove the dummy entry at the end.\n\n  return diffs;\n};\n\n\n/**\n * Find the 'middle snake' of a diff, split the problem in two\n * and return the recursively constructed diff.\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  var max_d = Math.ceil((text1_length + text2_length) / 2);\n  var v_offset = max_d;\n  var v_length = 2 * max_d;\n  var v1 = new Array(v_length);\n  var v2 = new Array(v_length);\n  // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n  // integers and undefined.\n  for (var x = 0; x < v_length; x++) {\n    v1[x] = -1;\n    v2[x] = -1;\n  }\n  v1[v_offset + 1] = 0;\n  v2[v_offset + 1] = 0;\n  var delta = text1_length - text2_length;\n  // If the total number of characters is odd, then the front path will collide\n  // with the reverse path.\n  var front = (delta % 2 != 0);\n  // Offsets for start and end of k loop.\n  // Prevents mapping of space beyond the grid.\n  var k1start = 0;\n  var k1end = 0;\n  var k2start = 0;\n  var k2end = 0;\n  for (var d = 0; d < max_d; d++) {\n    // Bail out if deadline is reached.\n    if ((new Date()).getTime() > deadline) {\n      break;\n    }\n\n    // Walk the front path one step.\n    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      var k1_offset = v_offset + k1;\n      var x1;\n      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {\n        x1 = v1[k1_offset + 1];\n      } else {\n        x1 = v1[k1_offset - 1] + 1;\n      }\n      var y1 = x1 - k1;\n      while (x1 < text1_length && y1 < text2_length &&\n             text1.charAt(x1) == text2.charAt(y1)) {\n        x1++;\n        y1++;\n      }\n      v1[k1_offset] = x1;\n      if (x1 > text1_length) {\n        // Ran off the right of the graph.\n        k1end += 2;\n      } else if (y1 > text2_length) {\n        // Ran off the bottom of the graph.\n        k1start += 2;\n      } else if (front) {\n        var k2_offset = v_offset + delta - k1;\n        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {\n          // Mirror x2 onto top-left coordinate system.\n          var x2 = text1_length - v2[k2_offset];\n          if (x1 >= x2) {\n            // Overlap detected.\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n          }\n        }\n      }\n    }\n\n    // Walk the reverse path one step.\n    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      var k2_offset = v_offset + k2;\n      var x2;\n      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {\n        x2 = v2[k2_offset + 1];\n      } else {\n        x2 = v2[k2_offset - 1] + 1;\n      }\n      var y2 = x2 - k2;\n      while (x2 < text1_length && y2 < text2_length &&\n             text1.charAt(text1_length - x2 - 1) ==\n             text2.charAt(text2_length - y2 - 1)) {\n        x2++;\n        y2++;\n      }\n      v2[k2_offset] = x2;\n      if (x2 > text1_length) {\n        // Ran off the left of the graph.\n        k2end += 2;\n      } else if (y2 > text2_length) {\n        // Ran off the top of the graph.\n        k2start += 2;\n      } else if (!front) {\n        var k1_offset = v_offset + delta - k2;\n        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {\n          var x1 = v1[k1_offset];\n          var y1 = v_offset + x1 - k1_offset;\n          // Mirror x2 onto top-left coordinate system.\n          x2 = text1_length - x2;\n          if (x1 >= x2) {\n            // Overlap detected.\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n          }\n        }\n      }\n    }\n  }\n  // Diff took too long and hit the deadline or\n  // number of diffs equals number of characters, no commonality at all.\n  return [new diff_match_patch.Diff(DIFF_DELETE, text1),\n          new diff_match_patch.Diff(DIFF_INSERT, text2)];\n};\n\n\n/**\n * Given the location of the 'middle snake', split the diff in two parts\n * and recurse.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} x Index of split point in text1.\n * @param {number} y Index of split point in text2.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,\n    deadline) {\n  var text1a = text1.substring(0, x);\n  var text2a = text2.substring(0, y);\n  var text1b = text1.substring(x);\n  var text2b = text2.substring(y);\n\n  // Compute both diffs serially.\n  var diffs = this.diff_main(text1a, text2a, false, deadline);\n  var diffsb = this.diff_main(text1b, text2b, false, deadline);\n\n  return diffs.concat(diffsb);\n};\n\n\n/**\n * Split two texts into an array of strings.  Reduce the texts to a string of\n * hashes where each Unicode character represents one line.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n *     An object containing the encoded text1, the encoded text2 and\n *     the array of unique strings.\n *     The zeroth element of the array of unique strings is intentionally blank.\n * @private\n */\ndiff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {\n  var lineArray = [];  // e.g. lineArray[4] == 'Hello\\n'\n  var lineHash = {};   // e.g. lineHash['Hello\\n'] == 4\n\n  // '\\x00' is a valid character, but various debuggers don't like it.\n  // So we'll insert a junk entry to avoid generating a null character.\n  lineArray[0] = '';\n\n  /**\n   * Split a text into an array of strings.  Reduce the texts to a string of\n   * hashes where each Unicode character represents one line.\n   * Modifies linearray and linehash through being a closure.\n   * @param {string} text String to encode.\n   * @return {string} Encoded string.\n   * @private\n   */\n  function diff_linesToCharsMunge_(text) {\n    var chars = '';\n    // Walk the text, pulling out a substring for each line.\n    // text.split('\\n') would would temporarily double our memory footprint.\n    // Modifying text would create many large strings to garbage collect.\n    var lineStart = 0;\n    var lineEnd = -1;\n    // Keeping our own length variable is faster than looking it up.\n    var lineArrayLength = lineArray.length;\n    while (lineEnd < text.length - 1) {\n      lineEnd = text.indexOf('\\n', lineStart);\n      if (lineEnd == -1) {\n        lineEnd = text.length - 1;\n      }\n      var line = text.substring(lineStart, lineEnd + 1);\n\n      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :\n          (lineHash[line] !== undefined)) {\n        chars += String.fromCharCode(lineHash[line]);\n      } else {\n        if (lineArrayLength == maxLines) {\n          // Bail out at 65535 because\n          // String.fromCharCode(65536) == String.fromCharCode(0)\n          line = text.substring(lineStart);\n          lineEnd = text.length;\n        }\n        chars += String.fromCharCode(lineArrayLength);\n        lineHash[line] = lineArrayLength;\n        lineArray[lineArrayLength++] = line;\n      }\n      lineStart = lineEnd + 1;\n    }\n    return chars;\n  }\n  // Allocate 2/3rds of the space for text1, the rest for text2.\n  var maxLines = 40000;\n  var chars1 = diff_linesToCharsMunge_(text1);\n  maxLines = 65535;\n  var chars2 = diff_linesToCharsMunge_(text2);\n  return {chars1: chars1, chars2: chars2, lineArray: lineArray};\n};\n\n\n/**\n * Rehydrate the text in a diff from a string of line hashes to real lines of\n * text.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @param {!Array.<string>} lineArray Array of unique strings.\n * @private\n */\ndiff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {\n  for (var i = 0; i < diffs.length; i++) {\n    var chars = diffs[i][1];\n    var text = [];\n    for (var j = 0; j < chars.length; j++) {\n      text[j] = lineArray[chars.charCodeAt(j)];\n    }\n    diffs[i][1] = text.join('');\n  }\n};\n\n\n/**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */\ndiff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerstart = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(pointerstart, pointermid) ==\n        text2.substring(pointerstart, pointermid)) {\n      pointermin = pointermid;\n      pointerstart = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */\ndiff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 ||\n      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerend = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==\n        text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n      pointermin = pointermid;\n      pointerend = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine if the suffix of one string is the prefix of another.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of the first\n *     string and the start of the second string.\n * @private\n */\ndiff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  // Eliminate the null case.\n  if (text1_length == 0 || text2_length == 0) {\n    return 0;\n  }\n  // Truncate the longer string.\n  if (text1_length > text2_length) {\n    text1 = text1.substring(text1_length - text2_length);\n  } else if (text1_length < text2_length) {\n    text2 = text2.substring(0, text1_length);\n  }\n  var text_length = Math.min(text1_length, text2_length);\n  // Quick check for the worst case.\n  if (text1 == text2) {\n    return text_length;\n  }\n\n  // Start by looking for a single character match\n  // and increase length until no match is found.\n  // Performance analysis: https://neil.fraser.name/news/2010/11/04/\n  var best = 0;\n  var length = 1;\n  while (true) {\n    var pattern = text1.substring(text_length - length);\n    var found = text2.indexOf(pattern);\n    if (found == -1) {\n      return best;\n    }\n    length += found;\n    if (found == 0 || text1.substring(text_length - length) ==\n        text2.substring(0, length)) {\n      best = length;\n      length++;\n    }\n  }\n};\n\n\n/**\n * Do the two texts share a substring which is at least half the length of the\n * longer text?\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {Array.<string>} Five element Array, containing the prefix of\n *     text1, the suffix of text1, the prefix of text2, the suffix of\n *     text2 and the common middle.  Or null if there was no match.\n * @private\n */\ndiff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {\n  if (this.Diff_Timeout <= 0) {\n    // Don't risk returning a non-optimal diff if we have unlimited time.\n    return null;\n  }\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n    return null;  // Pointless.\n  }\n  var dmp = this;  // 'this' becomes 'window' in a closure.\n\n  /**\n   * Does a substring of shorttext exist within longtext such that the substring\n   * is at least half the length of longtext?\n   * Closure, but does not reference any external variables.\n   * @param {string} longtext Longer string.\n   * @param {string} shorttext Shorter string.\n   * @param {number} i Start index of quarter length substring within longtext.\n   * @return {Array.<string>} Five element Array, containing the prefix of\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n   *     of shorttext and the common middle.  Or null if there was no match.\n   * @private\n   */\n  function diff_halfMatchI_(longtext, shorttext, i) {\n    // Start with a 1/4 length substring at position i as a seed.\n    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n    var j = -1;\n    var best_common = '';\n    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\n    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {\n      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),\n                                               shorttext.substring(j));\n      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),\n                                               shorttext.substring(0, j));\n      if (best_common.length < suffixLength + prefixLength) {\n        best_common = shorttext.substring(j - suffixLength, j) +\n            shorttext.substring(j, j + prefixLength);\n        best_longtext_a = longtext.substring(0, i - suffixLength);\n        best_longtext_b = longtext.substring(i + prefixLength);\n        best_shorttext_a = shorttext.substring(0, j - suffixLength);\n        best_shorttext_b = shorttext.substring(j + prefixLength);\n      }\n    }\n    if (best_common.length * 2 >= longtext.length) {\n      return [best_longtext_a, best_longtext_b,\n              best_shorttext_a, best_shorttext_b, best_common];\n    } else {\n      return null;\n    }\n  }\n\n  // First check if the second quarter is the seed for a half-match.\n  var hm1 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 4));\n  // Check again based on the third quarter.\n  var hm2 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 2));\n  var hm;\n  if (!hm1 && !hm2) {\n    return null;\n  } else if (!hm2) {\n    hm = hm1;\n  } else if (!hm1) {\n    hm = hm2;\n  } else {\n    // Both matched.  Select the longest.\n    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n  }\n\n  // A half-match was found, sort out the return data.\n  var text1_a, text1_b, text2_a, text2_b;\n  if (text1.length > text2.length) {\n    text1_a = hm[0];\n    text1_b = hm[1];\n    text2_a = hm[2];\n    text2_b = hm[3];\n  } else {\n    text2_a = hm[0];\n    text2_b = hm[1];\n    text1_a = hm[2];\n    text1_b = hm[3];\n  }\n  var mid_common = hm[4];\n  return [text1_a, text1_b, text2_a, text2_b, mid_common];\n};\n\n\n/**\n * Reduce the number of edits by eliminating semantically trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {\n  var changes = false;\n  var equalities = [];  // Stack of indices where equalities are found.\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastEquality = null;\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  var pointer = 0;  // Index of current position.\n  // Number of characters that changed prior to the equality.\n  var length_insertions1 = 0;\n  var length_deletions1 = 0;\n  // Number of characters that changed after the equality.\n  var length_insertions2 = 0;\n  var length_deletions2 = 0;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n      equalities[equalitiesLength++] = pointer;\n      length_insertions1 = length_insertions2;\n      length_deletions1 = length_deletions2;\n      length_insertions2 = 0;\n      length_deletions2 = 0;\n      lastEquality = diffs[pointer][1];\n    } else {  // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_INSERT) {\n        length_insertions2 += diffs[pointer][1].length;\n      } else {\n        length_deletions2 += diffs[pointer][1].length;\n      }\n      // Eliminate an equality that is smaller or equal to the edits on both\n      // sides of it.\n      if (lastEquality && (lastEquality.length <=\n          Math.max(length_insertions1, length_deletions1)) &&\n          (lastEquality.length <= Math.max(length_insertions2,\n                                           length_deletions2))) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0,\n                     new diff_match_patch.Diff(DIFF_DELETE, lastEquality));\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        // Throw away the equality we just deleted.\n        equalitiesLength--;\n        // Throw away the previous equality (it needs to be reevaluated).\n        equalitiesLength--;\n        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n        length_insertions1 = 0;  // Reset the counters.\n        length_deletions1 = 0;\n        length_insertions2 = 0;\n        length_deletions2 = 0;\n        lastEquality = null;\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  // Normalize the diff.\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n  this.diff_cleanupSemanticLossless(diffs);\n\n  // Find any overlaps between deletions and insertions.\n  // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n  //   -> <del>abc</del>xxx<ins>def</ins>\n  // e.g: <del>xxxabc</del><ins>defxxx</ins>\n  //   -> <ins>def</ins>xxx<del>abc</del>\n  // Only extract an overlap if it is as big as the edit ahead or behind it.\n  pointer = 1;\n  while (pointer < diffs.length) {\n    if (diffs[pointer - 1][0] == DIFF_DELETE &&\n        diffs[pointer][0] == DIFF_INSERT) {\n      var deletion = diffs[pointer - 1][1];\n      var insertion = diffs[pointer][1];\n      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);\n      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);\n      if (overlap_length1 >= overlap_length2) {\n        if (overlap_length1 >= deletion.length / 2 ||\n            overlap_length1 >= insertion.length / 2) {\n          // Overlap found.  Insert an equality and trim the surrounding edits.\n          diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL,\n              insertion.substring(0, overlap_length1)));\n          diffs[pointer - 1][1] =\n              deletion.substring(0, deletion.length - overlap_length1);\n          diffs[pointer + 1][1] = insertion.substring(overlap_length1);\n          pointer++;\n        }\n      } else {\n        if (overlap_length2 >= deletion.length / 2 ||\n            overlap_length2 >= insertion.length / 2) {\n          // Reverse overlap found.\n          // Insert an equality and swap and trim the surrounding edits.\n          diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL,\n              deletion.substring(0, overlap_length2)));\n          diffs[pointer - 1][0] = DIFF_INSERT;\n          diffs[pointer - 1][1] =\n              insertion.substring(0, insertion.length - overlap_length2);\n          diffs[pointer + 1][0] = DIFF_DELETE;\n          diffs[pointer + 1][1] =\n              deletion.substring(overlap_length2);\n          pointer++;\n        }\n      }\n      pointer++;\n    }\n    pointer++;\n  }\n};\n\n\n/**\n * Look for single edits surrounded on both sides by equalities\n * which can be shifted sideways to align the edit to a word boundary.\n * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {\n  /**\n   * Given two strings, compute a score representing whether the internal\n   * boundary falls on logical boundaries.\n   * Scores range from 6 (best) to 0 (worst).\n   * Closure, but does not reference any external variables.\n   * @param {string} one First string.\n   * @param {string} two Second string.\n   * @return {number} The score.\n   * @private\n   */\n  function diff_cleanupSemanticScore_(one, two) {\n    if (!one || !two) {\n      // Edges are the best.\n      return 6;\n    }\n\n    // Each port of this function behaves slightly differently due to\n    // subtle differences in each language's definition of things like\n    // 'whitespace'.  Since this function's purpose is largely cosmetic,\n    // the choice has been made to use each language's native features\n    // rather than force total conformity.\n    var char1 = one.charAt(one.length - 1);\n    var char2 = two.charAt(0);\n    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);\n    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);\n    var whitespace1 = nonAlphaNumeric1 &&\n        char1.match(diff_match_patch.whitespaceRegex_);\n    var whitespace2 = nonAlphaNumeric2 &&\n        char2.match(diff_match_patch.whitespaceRegex_);\n    var lineBreak1 = whitespace1 &&\n        char1.match(diff_match_patch.linebreakRegex_);\n    var lineBreak2 = whitespace2 &&\n        char2.match(diff_match_patch.linebreakRegex_);\n    var blankLine1 = lineBreak1 &&\n        one.match(diff_match_patch.blanklineEndRegex_);\n    var blankLine2 = lineBreak2 &&\n        two.match(diff_match_patch.blanklineStartRegex_);\n\n    if (blankLine1 || blankLine2) {\n      // Five points for blank lines.\n      return 5;\n    } else if (lineBreak1 || lineBreak2) {\n      // Four points for line breaks.\n      return 4;\n    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n      // Three points for end of sentences.\n      return 3;\n    } else if (whitespace1 || whitespace2) {\n      // Two points for whitespace.\n      return 2;\n    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n      // One point for non-alphanumeric.\n      return 1;\n    }\n    return 0;\n  }\n\n  var pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      var equality1 = diffs[pointer - 1][1];\n      var edit = diffs[pointer][1];\n      var equality2 = diffs[pointer + 1][1];\n\n      // First, shift the edit as far left as possible.\n      var commonOffset = this.diff_commonSuffix(equality1, edit);\n      if (commonOffset) {\n        var commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset);\n        edit = commonString + edit.substring(0, edit.length - commonOffset);\n        equality2 = commonString + equality2;\n      }\n\n      // Second, step character by character right, looking for the best fit.\n      var bestEquality1 = equality1;\n      var bestEdit = edit;\n      var bestEquality2 = equality2;\n      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +\n          diff_cleanupSemanticScore_(edit, equality2);\n      while (edit.charAt(0) === equality2.charAt(0)) {\n        equality1 += edit.charAt(0);\n        edit = edit.substring(1) + equality2.charAt(0);\n        equality2 = equality2.substring(1);\n        var score = diff_cleanupSemanticScore_(equality1, edit) +\n            diff_cleanupSemanticScore_(edit, equality2);\n        // The >= encourages trailing rather than leading whitespace on edits.\n        if (score >= bestScore) {\n          bestScore = score;\n          bestEquality1 = equality1;\n          bestEdit = edit;\n          bestEquality2 = equality2;\n        }\n      }\n\n      if (diffs[pointer - 1][1] != bestEquality1) {\n        // We have an improvement, save it back to the diff.\n        if (bestEquality1) {\n          diffs[pointer - 1][1] = bestEquality1;\n        } else {\n          diffs.splice(pointer - 1, 1);\n          pointer--;\n        }\n        diffs[pointer][1] = bestEdit;\n        if (bestEquality2) {\n          diffs[pointer + 1][1] = bestEquality2;\n        } else {\n          diffs.splice(pointer + 1, 1);\n          pointer--;\n        }\n      }\n    }\n    pointer++;\n  }\n};\n\n// Define some regex patterns for matching boundaries.\ndiff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;\ndiff_match_patch.whitespaceRegex_ = /\\s/;\ndiff_match_patch.linebreakRegex_ = /[\\r\\n]/;\ndiff_match_patch.blanklineEndRegex_ = /\\n\\r?\\n$/;\ndiff_match_patch.blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\n\n/**\n * Reduce the number of edits by eliminating operationally trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {\n  var changes = false;\n  var equalities = [];  // Stack of indices where equalities are found.\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastEquality = null;\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  var pointer = 0;  // Index of current position.\n  // Is there an insertion operation before the last equality.\n  var pre_ins = false;\n  // Is there a deletion operation before the last equality.\n  var pre_del = false;\n  // Is there an insertion operation after the last equality.\n  var post_ins = false;\n  // Is there a deletion operation after the last equality.\n  var post_del = false;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n      if (diffs[pointer][1].length < this.Diff_EditCost &&\n          (post_ins || post_del)) {\n        // Candidate found.\n        equalities[equalitiesLength++] = pointer;\n        pre_ins = post_ins;\n        pre_del = post_del;\n        lastEquality = diffs[pointer][1];\n      } else {\n        // Not a candidate, and can never become one.\n        equalitiesLength = 0;\n        lastEquality = null;\n      }\n      post_ins = post_del = false;\n    } else {  // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_DELETE) {\n        post_del = true;\n      } else {\n        post_ins = true;\n      }\n      /*\n       * Five types to be split:\n       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n       * <ins>A</ins>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<ins>C</ins>\n       * <ins>A</del>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<del>C</del>\n       */\n      if (lastEquality && ((pre_ins && pre_del && post_ins && post_del) ||\n                           ((lastEquality.length < this.Diff_EditCost / 2) &&\n                            (pre_ins + pre_del + post_ins + post_del) == 3))) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0,\n                     new diff_match_patch.Diff(DIFF_DELETE, lastEquality));\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        equalitiesLength--;  // Throw away the equality we just deleted;\n        lastEquality = null;\n        if (pre_ins && pre_del) {\n          // No changes made which could affect previous entry, keep going.\n          post_ins = post_del = true;\n          equalitiesLength = 0;\n        } else {\n          equalitiesLength--;  // Throw away the previous equality.\n          pointer = equalitiesLength > 0 ?\n              equalities[equalitiesLength - 1] : -1;\n          post_ins = post_del = false;\n        }\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n};\n\n\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupMerge = function(diffs) {\n  // Add a dummy entry at the end.\n  diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ''));\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  var commonlength;\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete + count_insert > 1) {\n          if (count_delete !== 0 && count_insert !== 0) {\n            // Factor out any common prefixies.\n            commonlength = this.diff_commonPrefix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              if ((pointer - count_delete - count_insert) > 0 &&\n                  diffs[pointer - count_delete - count_insert - 1][0] ==\n                  DIFF_EQUAL) {\n                diffs[pointer - count_delete - count_insert - 1][1] +=\n                    text_insert.substring(0, commonlength);\n              } else {\n                diffs.splice(0, 0, new diff_match_patch.Diff(DIFF_EQUAL,\n                    text_insert.substring(0, commonlength)));\n                pointer++;\n              }\n              text_insert = text_insert.substring(commonlength);\n              text_delete = text_delete.substring(commonlength);\n            }\n            // Factor out any common suffixies.\n            commonlength = this.diff_commonSuffix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              diffs[pointer][1] = text_insert.substring(text_insert.length -\n                  commonlength) + diffs[pointer][1];\n              text_insert = text_insert.substring(0, text_insert.length -\n                  commonlength);\n              text_delete = text_delete.substring(0, text_delete.length -\n                  commonlength);\n            }\n          }\n          // Delete the offending records and add the merged ones.\n          pointer -= count_delete + count_insert;\n          diffs.splice(pointer, count_delete + count_insert);\n          if (text_delete.length) {\n            diffs.splice(pointer, 0,\n                new diff_match_patch.Diff(DIFF_DELETE, text_delete));\n            pointer++;\n          }\n          if (text_insert.length) {\n            diffs.splice(pointer, 0,\n                new diff_match_patch.Diff(DIFF_INSERT, text_insert));\n            pointer++;\n          }\n          pointer++;\n        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\n          // Merge this equality with the previous one.\n          diffs[pointer - 1][1] += diffs[pointer][1];\n          diffs.splice(pointer, 1);\n        } else {\n          pointer++;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n  }\n  if (diffs[diffs.length - 1][1] === '') {\n    diffs.pop();  // Remove the dummy entry at the end.\n  }\n\n  // Second pass: look for single edits surrounded on both sides by equalities\n  // which can be shifted sideways to eliminate an equality.\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n  var changes = false;\n  pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      if (diffs[pointer][1].substring(diffs[pointer][1].length -\n          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\n        // Shift the edit over the previous equality.\n        diffs[pointer][1] = diffs[pointer - 1][1] +\n            diffs[pointer][1].substring(0, diffs[pointer][1].length -\n                                        diffs[pointer - 1][1].length);\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n        diffs.splice(pointer - 1, 1);\n        changes = true;\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\n          diffs[pointer + 1][1]) {\n        // Shift the edit over the next equality.\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n        diffs[pointer][1] =\n            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\n            diffs[pointer + 1][1];\n        diffs.splice(pointer + 1, 1);\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  // If shifts were made, the diff needs reordering and another shift sweep.\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n};\n\n\n/**\n * loc is a location in text1, compute and return the equivalent location in\n * text2.\n * e.g. 'The cat' vs 'The big cat', 1->1, 5->8\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @param {number} loc Location within text1.\n * @return {number} Location within text2.\n */\ndiff_match_patch.prototype.diff_xIndex = function(diffs, loc) {\n  var chars1 = 0;\n  var chars2 = 0;\n  var last_chars1 = 0;\n  var last_chars2 = 0;\n  var x;\n  for (x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.\n      chars1 += diffs[x][1].length;\n    }\n    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.\n      chars2 += diffs[x][1].length;\n    }\n    if (chars1 > loc) {  // Overshot the location.\n      break;\n    }\n    last_chars1 = chars1;\n    last_chars2 = chars2;\n  }\n  // Was the location was deleted?\n  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {\n    return last_chars2;\n  }\n  // Add the remaining character length.\n  return last_chars2 + (loc - last_chars1);\n};\n\n\n/**\n * Convert a diff array into a pretty HTML report.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} HTML representation.\n */\ndiff_match_patch.prototype.diff_prettyHtml = function(diffs) {\n  var html = [];\n  var pattern_amp = /&/g;\n  var pattern_lt = /</g;\n  var pattern_gt = />/g;\n  var pattern_para = /\\n/g;\n  for (var x = 0; x < diffs.length; x++) {\n    var op = diffs[x][0];    // Operation (insert, delete, equal)\n    var data = diffs[x][1];  // Text of change.\n    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')\n        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');\n    switch (op) {\n      case DIFF_INSERT:\n        html[x] = '<ins style=\"background:#e6ffe6;\">' + text + '</ins>';\n        break;\n      case DIFF_DELETE:\n        html[x] = '<del style=\"background:#ffe6e6;\">' + text + '</del>';\n        break;\n      case DIFF_EQUAL:\n        html[x] = '<span>' + text + '</span>';\n        break;\n    }\n  }\n  return html.join('');\n};\n\n\n/**\n * Compute and return the source text (all equalities and deletions).\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Source text.\n */\ndiff_match_patch.prototype.diff_text1 = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {\n      text[x] = diffs[x][1];\n    }\n  }\n  return text.join('');\n};\n\n\n/**\n * Compute and return the destination text (all equalities and insertions).\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Destination text.\n */\ndiff_match_patch.prototype.diff_text2 = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_DELETE) {\n      text[x] = diffs[x][1];\n    }\n  }\n  return text.join('');\n};\n\n\n/**\n * Compute the Levenshtein distance; the number of inserted, deleted or\n * substituted characters.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {number} Number of changes.\n */\ndiff_match_patch.prototype.diff_levenshtein = function(diffs) {\n  var levenshtein = 0;\n  var insertions = 0;\n  var deletions = 0;\n  for (var x = 0; x < diffs.length; x++) {\n    var op = diffs[x][0];\n    var data = diffs[x][1];\n    switch (op) {\n      case DIFF_INSERT:\n        insertions += data.length;\n        break;\n      case DIFF_DELETE:\n        deletions += data.length;\n        break;\n      case DIFF_EQUAL:\n        // A deletion and an insertion is one substitution.\n        levenshtein += Math.max(insertions, deletions);\n        insertions = 0;\n        deletions = 0;\n        break;\n    }\n  }\n  levenshtein += Math.max(insertions, deletions);\n  return levenshtein;\n};\n\n\n/**\n * Crush the diff into an encoded string which describes the operations\n * required to transform text1 into text2.\n * E.g. =3\\t-2\\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.\n * Operations are tab-separated.  Inserted text is escaped using %xx notation.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Delta text.\n */\ndiff_match_patch.prototype.diff_toDelta = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    switch (diffs[x][0]) {\n      case DIFF_INSERT:\n        text[x] = '+' + encodeURI(diffs[x][1]);\n        break;\n      case DIFF_DELETE:\n        text[x] = '-' + diffs[x][1].length;\n        break;\n      case DIFF_EQUAL:\n        text[x] = '=' + diffs[x][1].length;\n        break;\n    }\n  }\n  return text.join('\\t').replace(/%20/g, ' ');\n};\n\n\n/**\n * Given the original text1, and an encoded string which describes the\n * operations required to transform text1 into text2, compute the full diff.\n * @param {string} text1 Source string for the diff.\n * @param {string} delta Delta text.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @throws {!Error} If invalid input.\n */\ndiff_match_patch.prototype.diff_fromDelta = function(text1, delta) {\n  var diffs = [];\n  var diffsLength = 0;  // Keeping our own length var is faster in JS.\n  var pointer = 0;  // Cursor in text1\n  var tokens = delta.split(/\\t/g);\n  for (var x = 0; x < tokens.length; x++) {\n    // Each token begins with a one character parameter which specifies the\n    // operation of this token (delete, insert, equality).\n    var param = tokens[x].substring(1);\n    switch (tokens[x].charAt(0)) {\n      case '+':\n        try {\n          diffs[diffsLength++] =\n              new diff_match_patch.Diff(DIFF_INSERT, decodeURI(param));\n        } catch (ex) {\n          // Malformed URI sequence.\n          throw new Error('Illegal escape in diff_fromDelta: ' + param);\n        }\n        break;\n      case '-':\n        // Fall through.\n      case '=':\n        var n = parseInt(param, 10);\n        if (isNaN(n) || n < 0) {\n          throw new Error('Invalid number in diff_fromDelta: ' + param);\n        }\n        var text = text1.substring(pointer, pointer += n);\n        if (tokens[x].charAt(0) == '=') {\n          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_EQUAL, text);\n        } else {\n          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_DELETE, text);\n        }\n        break;\n      default:\n        // Blank tokens are ok (from a trailing \\t).\n        // Anything else is an error.\n        if (tokens[x]) {\n          throw new Error('Invalid diff operation in diff_fromDelta: ' +\n                          tokens[x]);\n        }\n    }\n  }\n  if (pointer != text1.length) {\n    throw new Error('Delta length (' + pointer +\n        ') does not equal source text length (' + text1.length + ').');\n  }\n  return diffs;\n};\n\n\n//  MATCH FUNCTIONS\n\n\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc'.\n * @param {string} text The text to search.\n * @param {string} pattern The pattern to search for.\n * @param {number} loc The location to search around.\n * @return {number} Best match index or -1.\n */\ndiff_match_patch.prototype.match_main = function(text, pattern, loc) {\n  // Check for null inputs.\n  if (text == null || pattern == null || loc == null) {\n    throw new Error('Null input. (match_main)');\n  }\n\n  loc = Math.max(0, Math.min(loc, text.length));\n  if (text == pattern) {\n    // Shortcut (potentially not guaranteed by the algorithm)\n    return 0;\n  } else if (!text.length) {\n    // Nothing to match.\n    return -1;\n  } else if (text.substring(loc, loc + pattern.length) == pattern) {\n    // Perfect match at the perfect spot!  (Includes case of null pattern)\n    return loc;\n  } else {\n    // Do a fuzzy compare.\n    return this.match_bitap_(text, pattern, loc);\n  }\n};\n\n\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc' using the\n * Bitap algorithm.\n * @param {string} text The text to search.\n * @param {string} pattern The pattern to search for.\n * @param {number} loc The location to search around.\n * @return {number} Best match index or -1.\n * @private\n */\ndiff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {\n  if (pattern.length > this.Match_MaxBits) {\n    throw new Error('Pattern too long for this browser.');\n  }\n\n  // Initialise the alphabet.\n  var s = this.match_alphabet_(pattern);\n\n  var dmp = this;  // 'this' becomes 'window' in a closure.\n\n  /**\n   * Compute and return the score for a match with e errors and x location.\n   * Accesses loc and pattern through being a closure.\n   * @param {number} e Number of errors in match.\n   * @param {number} x Location of match.\n   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).\n   * @private\n   */\n  function match_bitapScore_(e, x) {\n    var accuracy = e / pattern.length;\n    var proximity = Math.abs(loc - x);\n    if (!dmp.Match_Distance) {\n      // Dodge divide by zero error.\n      return proximity ? 1.0 : accuracy;\n    }\n    return accuracy + (proximity / dmp.Match_Distance);\n  }\n\n  // Highest score beyond which we give up.\n  var score_threshold = this.Match_Threshold;\n  // Is there a nearby exact match? (speedup)\n  var best_loc = text.indexOf(pattern, loc);\n  if (best_loc != -1) {\n    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);\n    // What about in the other direction? (speedup)\n    best_loc = text.lastIndexOf(pattern, loc + pattern.length);\n    if (best_loc != -1) {\n      score_threshold =\n          Math.min(match_bitapScore_(0, best_loc), score_threshold);\n    }\n  }\n\n  // Initialise the bit arrays.\n  var matchmask = 1 << (pattern.length - 1);\n  best_loc = -1;\n\n  var bin_min, bin_mid;\n  var bin_max = pattern.length + text.length;\n  var last_rd;\n  for (var d = 0; d < pattern.length; d++) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from 'loc' we can stray at this\n    // error level.\n    bin_min = 0;\n    bin_mid = bin_max;\n    while (bin_min < bin_mid) {\n      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {\n        bin_min = bin_mid;\n      } else {\n        bin_max = bin_mid;\n      }\n      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);\n    }\n    // Use the result from this iteration as the maximum for the next.\n    bin_max = bin_mid;\n    var start = Math.max(1, loc - bin_mid + 1);\n    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;\n\n    var rd = Array(finish + 2);\n    rd[finish + 1] = (1 << d) - 1;\n    for (var j = finish; j >= start; j--) {\n      // The alphabet (s) is a sparse hash, so the following line generates\n      // warnings.\n      var charMatch = s[text.charAt(j - 1)];\n      if (d === 0) {  // First pass: exact match.\n        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;\n      } else {  // Subsequent passes: fuzzy match.\n        rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |\n                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |\n                last_rd[j + 1];\n      }\n      if (rd[j] & matchmask) {\n        var score = match_bitapScore_(d, j - 1);\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (score <= score_threshold) {\n          // Told you so.\n          score_threshold = score;\n          best_loc = j - 1;\n          if (best_loc > loc) {\n            // When passing loc, don't exceed our current distance from loc.\n            start = Math.max(1, 2 * loc - best_loc);\n          } else {\n            // Already passed loc, downhill from here on in.\n            break;\n          }\n        }\n      }\n    }\n    // No hope for a (better) match at greater error levels.\n    if (match_bitapScore_(d + 1, loc) > score_threshold) {\n      break;\n    }\n    last_rd = rd;\n  }\n  return best_loc;\n};\n\n\n/**\n * Initialise the alphabet for the Bitap algorithm.\n * @param {string} pattern The text to encode.\n * @return {!Object} Hash of character locations.\n * @private\n */\ndiff_match_patch.prototype.match_alphabet_ = function(pattern) {\n  var s = {};\n  for (var i = 0; i < pattern.length; i++) {\n    s[pattern.charAt(i)] = 0;\n  }\n  for (var i = 0; i < pattern.length; i++) {\n    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);\n  }\n  return s;\n};\n\n\n//  PATCH FUNCTIONS\n\n\n/**\n * Increase the context until it is unique,\n * but don't let the pattern expand beyond Match_MaxBits.\n * @param {!diff_match_patch.patch_obj} patch The patch to grow.\n * @param {string} text Source text.\n * @private\n */\ndiff_match_patch.prototype.patch_addContext_ = function(patch, text) {\n  if (text.length == 0) {\n    return;\n  }\n  if (patch.start2 === null) {\n    throw Error('patch not initialized');\n  }\n  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);\n  var padding = 0;\n\n  // Look for the first and last matches of pattern in text.  If two different\n  // matches are found, increase the pattern length.\n  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&\n         pattern.length < this.Match_MaxBits - this.Patch_Margin -\n         this.Patch_Margin) {\n    padding += this.Patch_Margin;\n    pattern = text.substring(patch.start2 - padding,\n                             patch.start2 + patch.length1 + padding);\n  }\n  // Add one chunk for good luck.\n  padding += this.Patch_Margin;\n\n  // Add the prefix.\n  var prefix = text.substring(patch.start2 - padding, patch.start2);\n  if (prefix) {\n    patch.diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, prefix));\n  }\n  // Add the suffix.\n  var suffix = text.substring(patch.start2 + patch.length1,\n                              patch.start2 + patch.length1 + padding);\n  if (suffix) {\n    patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, suffix));\n  }\n\n  // Roll back the start points.\n  patch.start1 -= prefix.length;\n  patch.start2 -= prefix.length;\n  // Extend the lengths.\n  patch.length1 += prefix.length + suffix.length;\n  patch.length2 += prefix.length + suffix.length;\n};\n\n\n/**\n * Compute a list of patches to turn text1 into text2.\n * Use diffs if provided, otherwise compute it ourselves.\n * There are four ways to call this function, depending on what data is\n * available to the caller:\n * Method 1:\n * a = text1, b = text2\n * Method 2:\n * a = diffs\n * Method 3 (optimal):\n * a = text1, b = diffs\n * Method 4 (deprecated, use method 3):\n * a = text1, b = text2, c = diffs\n *\n * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or\n * Array of diff tuples for text1 to text2 (method 2).\n * @param {string|!Array.<!diff_match_patch.Diff>=} opt_b text2 (methods 1,4) or\n * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).\n * @param {string|!Array.<!diff_match_patch.Diff>=} opt_c Array of diff tuples\n * for text1 to text2 (method 4) or undefined (methods 1,2,3).\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {\n  var text1, diffs;\n  if (typeof a == 'string' && typeof opt_b == 'string' &&\n      typeof opt_c == 'undefined') {\n    // Method 1: text1, text2\n    // Compute diffs from text1 and text2.\n    text1 = /** @type {string} */(a);\n    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);\n    if (diffs.length > 2) {\n      this.diff_cleanupSemantic(diffs);\n      this.diff_cleanupEfficiency(diffs);\n    }\n  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&\n      typeof opt_c == 'undefined') {\n    // Method 2: diffs\n    // Compute text1 from diffs.\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);\n    text1 = this.diff_text1(diffs);\n  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&\n      typeof opt_c == 'undefined') {\n    // Method 3: text1, diffs\n    text1 = /** @type {string} */(a);\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);\n  } else if (typeof a == 'string' && typeof opt_b == 'string' &&\n      opt_c && typeof opt_c == 'object') {\n    // Method 4: text1, text2, diffs\n    // text2 is not used.\n    text1 = /** @type {string} */(a);\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);\n  } else {\n    throw new Error('Unknown call format to patch_make.');\n  }\n\n  if (diffs.length === 0) {\n    return [];  // Get rid of the null case.\n  }\n  var patches = [];\n  var patch = new diff_match_patch.patch_obj();\n  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.\n  var char_count1 = 0;  // Number of characters into the text1 string.\n  var char_count2 = 0;  // Number of characters into the text2 string.\n  // Start with text1 (prepatch_text) and apply the diffs until we arrive at\n  // text2 (postpatch_text).  We recreate the patches one by one to determine\n  // context info.\n  var prepatch_text = text1;\n  var postpatch_text = text1;\n  for (var x = 0; x < diffs.length; x++) {\n    var diff_type = diffs[x][0];\n    var diff_text = diffs[x][1];\n\n    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {\n      // A new patch starts here.\n      patch.start1 = char_count1;\n      patch.start2 = char_count2;\n    }\n\n    switch (diff_type) {\n      case DIFF_INSERT:\n        patch.diffs[patchDiffLength++] = diffs[x];\n        patch.length2 += diff_text.length;\n        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +\n                         postpatch_text.substring(char_count2);\n        break;\n      case DIFF_DELETE:\n        patch.length1 += diff_text.length;\n        patch.diffs[patchDiffLength++] = diffs[x];\n        postpatch_text = postpatch_text.substring(0, char_count2) +\n                         postpatch_text.substring(char_count2 +\n                             diff_text.length);\n        break;\n      case DIFF_EQUAL:\n        if (diff_text.length <= 2 * this.Patch_Margin &&\n            patchDiffLength && diffs.length != x + 1) {\n          // Small equality inside a patch.\n          patch.diffs[patchDiffLength++] = diffs[x];\n          patch.length1 += diff_text.length;\n          patch.length2 += diff_text.length;\n        } else if (diff_text.length >= 2 * this.Patch_Margin) {\n          // Time for a new patch.\n          if (patchDiffLength) {\n            this.patch_addContext_(patch, prepatch_text);\n            patches.push(patch);\n            patch = new diff_match_patch.patch_obj();\n            patchDiffLength = 0;\n            // Unlike Unidiff, our patch lists have a rolling context.\n            // https://github.com/google/diff-match-patch/wiki/Unidiff\n            // Update prepatch text & pos to reflect the application of the\n            // just completed patch.\n            prepatch_text = postpatch_text;\n            char_count1 = char_count2;\n          }\n        }\n        break;\n    }\n\n    // Update the current character count.\n    if (diff_type !== DIFF_INSERT) {\n      char_count1 += diff_text.length;\n    }\n    if (diff_type !== DIFF_DELETE) {\n      char_count2 += diff_text.length;\n    }\n  }\n  // Pick up the leftover patch if not empty.\n  if (patchDiffLength) {\n    this.patch_addContext_(patch, prepatch_text);\n    patches.push(patch);\n  }\n\n  return patches;\n};\n\n\n/**\n * Given an array of patches, return another array that is identical.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_deepCopy = function(patches) {\n  // Making deep copies is hard in JavaScript.\n  var patchesCopy = [];\n  for (var x = 0; x < patches.length; x++) {\n    var patch = patches[x];\n    var patchCopy = new diff_match_patch.patch_obj();\n    patchCopy.diffs = [];\n    for (var y = 0; y < patch.diffs.length; y++) {\n      patchCopy.diffs[y] =\n          new diff_match_patch.Diff(patch.diffs[y][0], patch.diffs[y][1]);\n    }\n    patchCopy.start1 = patch.start1;\n    patchCopy.start2 = patch.start2;\n    patchCopy.length1 = patch.length1;\n    patchCopy.length2 = patch.length2;\n    patchesCopy[x] = patchCopy;\n  }\n  return patchesCopy;\n};\n\n\n/**\n * Merge a set of patches onto the text.  Return a patched text, as well\n * as a list of true/false values indicating which patches were applied.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @param {string} text Old text.\n * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the\n *      new text and an array of boolean values.\n */\ndiff_match_patch.prototype.patch_apply = function(patches, text) {\n  if (patches.length == 0) {\n    return [text, []];\n  }\n\n  // Deep copy the patches so that no changes are made to originals.\n  patches = this.patch_deepCopy(patches);\n\n  var nullPadding = this.patch_addPadding(patches);\n  text = nullPadding + text + nullPadding;\n\n  this.patch_splitMax(patches);\n  // delta keeps track of the offset between the expected and actual location\n  // of the previous patch.  If there are patches expected at positions 10 and\n  // 20, but the first patch was found at 12, delta is 2 and the second patch\n  // has an effective expected position of 22.\n  var delta = 0;\n  var results = [];\n  for (var x = 0; x < patches.length; x++) {\n    var expected_loc = patches[x].start2 + delta;\n    var text1 = this.diff_text1(patches[x].diffs);\n    var start_loc;\n    var end_loc = -1;\n    if (text1.length > this.Match_MaxBits) {\n      // patch_splitMax will only provide an oversized pattern in the case of\n      // a monster delete.\n      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),\n                                  expected_loc);\n      if (start_loc != -1) {\n        end_loc = this.match_main(text,\n            text1.substring(text1.length - this.Match_MaxBits),\n            expected_loc + text1.length - this.Match_MaxBits);\n        if (end_loc == -1 || start_loc >= end_loc) {\n          // Can't find valid trailing context.  Drop this patch.\n          start_loc = -1;\n        }\n      }\n    } else {\n      start_loc = this.match_main(text, text1, expected_loc);\n    }\n    if (start_loc == -1) {\n      // No match found.  :(\n      results[x] = false;\n      // Subtract the delta for this failed patch from subsequent patches.\n      delta -= patches[x].length2 - patches[x].length1;\n    } else {\n      // Found a match.  :)\n      results[x] = true;\n      delta = start_loc - expected_loc;\n      var text2;\n      if (end_loc == -1) {\n        text2 = text.substring(start_loc, start_loc + text1.length);\n      } else {\n        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);\n      }\n      if (text1 == text2) {\n        // Perfect match, just shove the replacement text in.\n        text = text.substring(0, start_loc) +\n               this.diff_text2(patches[x].diffs) +\n               text.substring(start_loc + text1.length);\n      } else {\n        // Imperfect match.  Run a diff to get a framework of equivalent\n        // indices.\n        var diffs = this.diff_main(text1, text2, false);\n        if (text1.length > this.Match_MaxBits &&\n            this.diff_levenshtein(diffs) / text1.length >\n            this.Patch_DeleteThreshold) {\n          // The end points match, but the content is unacceptably bad.\n          results[x] = false;\n        } else {\n          this.diff_cleanupSemanticLossless(diffs);\n          var index1 = 0;\n          var index2;\n          for (var y = 0; y < patches[x].diffs.length; y++) {\n            var mod = patches[x].diffs[y];\n            if (mod[0] !== DIFF_EQUAL) {\n              index2 = this.diff_xIndex(diffs, index1);\n            }\n            if (mod[0] === DIFF_INSERT) {  // Insertion\n              text = text.substring(0, start_loc + index2) + mod[1] +\n                     text.substring(start_loc + index2);\n            } else if (mod[0] === DIFF_DELETE) {  // Deletion\n              text = text.substring(0, start_loc + index2) +\n                     text.substring(start_loc + this.diff_xIndex(diffs,\n                         index1 + mod[1].length));\n            }\n            if (mod[0] !== DIFF_DELETE) {\n              index1 += mod[1].length;\n            }\n          }\n        }\n      }\n    }\n  }\n  // Strip the padding off.\n  text = text.substring(nullPadding.length, text.length - nullPadding.length);\n  return [text, results];\n};\n\n\n/**\n * Add some padding on text start and end so that edges can match something.\n * Intended to be called only from within patch_apply.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {string} The padding string added to each side.\n */\ndiff_match_patch.prototype.patch_addPadding = function(patches) {\n  var paddingLength = this.Patch_Margin;\n  var nullPadding = '';\n  for (var x = 1; x <= paddingLength; x++) {\n    nullPadding += String.fromCharCode(x);\n  }\n\n  // Bump all the patches forward.\n  for (var x = 0; x < patches.length; x++) {\n    patches[x].start1 += paddingLength;\n    patches[x].start2 += paddingLength;\n  }\n\n  // Add some padding on start of first diff.\n  var patch = patches[0];\n  var diffs = patch.diffs;\n  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {\n    // Add nullPadding equality.\n    diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));\n    patch.start1 -= paddingLength;  // Should be 0.\n    patch.start2 -= paddingLength;  // Should be 0.\n    patch.length1 += paddingLength;\n    patch.length2 += paddingLength;\n  } else if (paddingLength > diffs[0][1].length) {\n    // Grow first equality.\n    var extraLength = paddingLength - diffs[0][1].length;\n    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];\n    patch.start1 -= extraLength;\n    patch.start2 -= extraLength;\n    patch.length1 += extraLength;\n    patch.length2 += extraLength;\n  }\n\n  // Add some padding on end of last diff.\n  patch = patches[patches.length - 1];\n  diffs = patch.diffs;\n  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {\n    // Add nullPadding equality.\n    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));\n    patch.length1 += paddingLength;\n    patch.length2 += paddingLength;\n  } else if (paddingLength > diffs[diffs.length - 1][1].length) {\n    // Grow last equality.\n    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;\n    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);\n    patch.length1 += extraLength;\n    patch.length2 += extraLength;\n  }\n\n  return nullPadding;\n};\n\n\n/**\n * Look through the patches and break up any which are longer than the maximum\n * limit of the match algorithm.\n * Intended to be called only from within patch_apply.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_splitMax = function(patches) {\n  var patch_size = this.Match_MaxBits;\n  for (var x = 0; x < patches.length; x++) {\n    if (patches[x].length1 <= patch_size) {\n      continue;\n    }\n    var bigpatch = patches[x];\n    // Remove the big old patch.\n    patches.splice(x--, 1);\n    var start1 = bigpatch.start1;\n    var start2 = bigpatch.start2;\n    var precontext = '';\n    while (bigpatch.diffs.length !== 0) {\n      // Create one of several smaller patches.\n      var patch = new diff_match_patch.patch_obj();\n      var empty = true;\n      patch.start1 = start1 - precontext.length;\n      patch.start2 = start2 - precontext.length;\n      if (precontext !== '') {\n        patch.length1 = patch.length2 = precontext.length;\n        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, precontext));\n      }\n      while (bigpatch.diffs.length !== 0 &&\n             patch.length1 < patch_size - this.Patch_Margin) {\n        var diff_type = bigpatch.diffs[0][0];\n        var diff_text = bigpatch.diffs[0][1];\n        if (diff_type === DIFF_INSERT) {\n          // Insertions are harmless.\n          patch.length2 += diff_text.length;\n          start2 += diff_text.length;\n          patch.diffs.push(bigpatch.diffs.shift());\n          empty = false;\n        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&\n                   patch.diffs[0][0] == DIFF_EQUAL &&\n                   diff_text.length > 2 * patch_size) {\n          // This is a large deletion.  Let it pass in one chunk.\n          patch.length1 += diff_text.length;\n          start1 += diff_text.length;\n          empty = false;\n          patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));\n          bigpatch.diffs.shift();\n        } else {\n          // Deletion or equality.  Only take as much as we can stomach.\n          diff_text = diff_text.substring(0,\n              patch_size - patch.length1 - this.Patch_Margin);\n          patch.length1 += diff_text.length;\n          start1 += diff_text.length;\n          if (diff_type === DIFF_EQUAL) {\n            patch.length2 += diff_text.length;\n            start2 += diff_text.length;\n          } else {\n            empty = false;\n          }\n          patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));\n          if (diff_text == bigpatch.diffs[0][1]) {\n            bigpatch.diffs.shift();\n          } else {\n            bigpatch.diffs[0][1] =\n                bigpatch.diffs[0][1].substring(diff_text.length);\n          }\n        }\n      }\n      // Compute the head context for the next patch.\n      precontext = this.diff_text2(patch.diffs);\n      precontext =\n          precontext.substring(precontext.length - this.Patch_Margin);\n      // Append the end context for this patch.\n      var postcontext = this.diff_text1(bigpatch.diffs)\n                            .substring(0, this.Patch_Margin);\n      if (postcontext !== '') {\n        patch.length1 += postcontext.length;\n        patch.length2 += postcontext.length;\n        if (patch.diffs.length !== 0 &&\n            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {\n          patch.diffs[patch.diffs.length - 1][1] += postcontext;\n        } else {\n          patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, postcontext));\n        }\n      }\n      if (!empty) {\n        patches.splice(++x, 0, patch);\n      }\n    }\n  }\n};\n\n\n/**\n * Take a list of patches and return a textual representation.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {string} Text representation of patches.\n */\ndiff_match_patch.prototype.patch_toText = function(patches) {\n  var text = [];\n  for (var x = 0; x < patches.length; x++) {\n    text[x] = patches[x];\n  }\n  return text.join('');\n};\n\n\n/**\n * Parse a textual representation of patches and return a list of Patch objects.\n * @param {string} textline Text representation of patches.\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n * @throws {!Error} If invalid input.\n */\ndiff_match_patch.prototype.patch_fromText = function(textline) {\n  var patches = [];\n  if (!textline) {\n    return patches;\n  }\n  var text = textline.split('\\n');\n  var textPointer = 0;\n  var patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\n  while (textPointer < text.length) {\n    var m = text[textPointer].match(patchHeader);\n    if (!m) {\n      throw new Error('Invalid patch string: ' + text[textPointer]);\n    }\n    var patch = new diff_match_patch.patch_obj();\n    patches.push(patch);\n    patch.start1 = parseInt(m[1], 10);\n    if (m[2] === '') {\n      patch.start1--;\n      patch.length1 = 1;\n    } else if (m[2] == '0') {\n      patch.length1 = 0;\n    } else {\n      patch.start1--;\n      patch.length1 = parseInt(m[2], 10);\n    }\n\n    patch.start2 = parseInt(m[3], 10);\n    if (m[4] === '') {\n      patch.start2--;\n      patch.length2 = 1;\n    } else if (m[4] == '0') {\n      patch.length2 = 0;\n    } else {\n      patch.start2--;\n      patch.length2 = parseInt(m[4], 10);\n    }\n    textPointer++;\n\n    while (textPointer < text.length) {\n      var sign = text[textPointer].charAt(0);\n      try {\n        var line = decodeURI(text[textPointer].substring(1));\n      } catch (ex) {\n        // Malformed URI sequence.\n        throw new Error('Illegal escape in patch_fromText: ' + line);\n      }\n      if (sign == '-') {\n        // Deletion.\n        patch.diffs.push(new diff_match_patch.Diff(DIFF_DELETE, line));\n      } else if (sign == '+') {\n        // Insertion.\n        patch.diffs.push(new diff_match_patch.Diff(DIFF_INSERT, line));\n      } else if (sign == ' ') {\n        // Minor equality.\n        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, line));\n      } else if (sign == '@') {\n        // Start of next patch.\n        break;\n      } else if (sign === '') {\n        // Blank line?  Whatever.\n      } else {\n        // WTF?\n        throw new Error('Invalid patch mode \"' + sign + '\" in: ' + line);\n      }\n      textPointer++;\n    }\n  }\n  return patches;\n};\n\n\n/**\n * Class representing one patch operation.\n * @constructor\n */\ndiff_match_patch.patch_obj = function() {\n  /** @type {!Array.<!diff_match_patch.Diff>} */\n  this.diffs = [];\n  /** @type {?number} */\n  this.start1 = null;\n  /** @type {?number} */\n  this.start2 = null;\n  /** @type {number} */\n  this.length1 = 0;\n  /** @type {number} */\n  this.length2 = 0;\n};\n\n\n/**\n * Emulate GNU diff's format.\n * Header: @@ -382,8 +481,9 @@\n * Indices are printed as 1-based, not 0-based.\n * @return {string} The GNU diff string.\n */\ndiff_match_patch.patch_obj.prototype.toString = function() {\n  var coords1, coords2;\n  if (this.length1 === 0) {\n    coords1 = this.start1 + ',0';\n  } else if (this.length1 == 1) {\n    coords1 = this.start1 + 1;\n  } else {\n    coords1 = (this.start1 + 1) + ',' + this.length1;\n  }\n  if (this.length2 === 0) {\n    coords2 = this.start2 + ',0';\n  } else if (this.length2 == 1) {\n    coords2 = this.start2 + 1;\n  } else {\n    coords2 = (this.start2 + 1) + ',' + this.length2;\n  }\n  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\\n'];\n  var op;\n  // Escape the body of the patch with %xx notation.\n  for (var x = 0; x < this.diffs.length; x++) {\n    switch (this.diffs[x][0]) {\n      case DIFF_INSERT:\n        op = '+';\n        break;\n      case DIFF_DELETE:\n        op = '-';\n        break;\n      case DIFF_EQUAL:\n        op = ' ';\n        break;\n    }\n    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\\n';\n  }\n  return text.join('').replace(/%20/g, ' ');\n};\n\n\n// The following export code was added by @ForbesLindesay\nmodule.exports = diff_match_patch;\nmodule.exports.diff_match_patch = diff_match_patch;\nmodule.exports.DIFF_DELETE = DIFF_DELETE;\nmodule.exports.DIFF_INSERT = DIFF_INSERT;\nmodule.exports.DIFF_EQUAL = DIFF_EQUAL;\n\n//# sourceURL=webpack://vim/./node_modules/diff-match-patch/index.js?")},"./node_modules/events/events.js":module=>{"use strict";eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function eventListener() {\n      if (errorListener !== undefined) {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n    var errorListener;\n\n    // Adding an error listener is not optional because\n    // if an error is thrown on an event emitter we cannot\n    // guarantee that the actual event we are waiting will\n    // be fired. The result could be a silent way to create\n    // memory or file descriptor leaks, which is something\n    // we should avoid.\n    if (name !== 'error') {\n      errorListener = function errorListener(err) {\n        emitter.removeListener(name, eventListener);\n        reject(err);\n      };\n\n      emitter.once('error', errorListener);\n    }\n\n    emitter.once(name, eventListener);\n  });\n}\n\n\n//# sourceURL=webpack://vim/./node_modules/events/events.js?")},"./node_modules/inherits/inherits_browser.js":module=>{eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n\n\n//# sourceURL=webpack://vim/./node_modules/inherits/inherits_browser.js?")},"./node_modules/lodash/lodash.js":function(module,exports,__webpack_require__){eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;/**\n * @license\n * Lodash <https://lodash.com/>\n * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n;(function() {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used as the semantic version number. */\n  var VERSION = '4.17.21';\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE = 200;\n\n  /** Error message constants. */\n  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',\n      FUNC_ERROR_TEXT = 'Expected a function',\n      INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';\n\n  /** Used to stand-in for `undefined` hash values. */\n  var HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n  /** Used as the maximum memoize cache size. */\n  var MAX_MEMOIZE_SIZE = 500;\n\n  /** Used as the internal argument placeholder. */\n  var PLACEHOLDER = '__lodash_placeholder__';\n\n  /** Used to compose bitmasks for cloning. */\n  var CLONE_DEEP_FLAG = 1,\n      CLONE_FLAT_FLAG = 2,\n      CLONE_SYMBOLS_FLAG = 4;\n\n  /** Used to compose bitmasks for value comparisons. */\n  var COMPARE_PARTIAL_FLAG = 1,\n      COMPARE_UNORDERED_FLAG = 2;\n\n  /** Used to compose bitmasks for function metadata. */\n  var WRAP_BIND_FLAG = 1,\n      WRAP_BIND_KEY_FLAG = 2,\n      WRAP_CURRY_BOUND_FLAG = 4,\n      WRAP_CURRY_FLAG = 8,\n      WRAP_CURRY_RIGHT_FLAG = 16,\n      WRAP_PARTIAL_FLAG = 32,\n      WRAP_PARTIAL_RIGHT_FLAG = 64,\n      WRAP_ARY_FLAG = 128,\n      WRAP_REARG_FLAG = 256,\n      WRAP_FLIP_FLAG = 512;\n\n  /** Used as default options for `_.truncate`. */\n  var DEFAULT_TRUNC_LENGTH = 30,\n      DEFAULT_TRUNC_OMISSION = '...';\n\n  /** Used to detect hot functions by number of calls within a span of milliseconds. */\n  var HOT_COUNT = 800,\n      HOT_SPAN = 16;\n\n  /** Used to indicate the type of lazy iteratees. */\n  var LAZY_FILTER_FLAG = 1,\n      LAZY_MAP_FLAG = 2,\n      LAZY_WHILE_FLAG = 3;\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY = 1 / 0,\n      MAX_SAFE_INTEGER = 9007199254740991,\n      MAX_INTEGER = 1.7976931348623157e+308,\n      NAN = 0 / 0;\n\n  /** Used as references for the maximum length and index of an array. */\n  var MAX_ARRAY_LENGTH = 4294967295,\n      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,\n      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n\n  /** Used to associate wrap methods with their bit flags. */\n  var wrapFlags = [\n    ['ary', WRAP_ARY_FLAG],\n    ['bind', WRAP_BIND_FLAG],\n    ['bindKey', WRAP_BIND_KEY_FLAG],\n    ['curry', WRAP_CURRY_FLAG],\n    ['curryRight', WRAP_CURRY_RIGHT_FLAG],\n    ['flip', WRAP_FLIP_FLAG],\n    ['partial', WRAP_PARTIAL_FLAG],\n    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],\n    ['rearg', WRAP_REARG_FLAG]\n  ];\n\n  /** `Object#toString` result references. */\n  var argsTag = '[object Arguments]',\n      arrayTag = '[object Array]',\n      asyncTag = '[object AsyncFunction]',\n      boolTag = '[object Boolean]',\n      dateTag = '[object Date]',\n      domExcTag = '[object DOMException]',\n      errorTag = '[object Error]',\n      funcTag = '[object Function]',\n      genTag = '[object GeneratorFunction]',\n      mapTag = '[object Map]',\n      numberTag = '[object Number]',\n      nullTag = '[object Null]',\n      objectTag = '[object Object]',\n      promiseTag = '[object Promise]',\n      proxyTag = '[object Proxy]',\n      regexpTag = '[object RegExp]',\n      setTag = '[object Set]',\n      stringTag = '[object String]',\n      symbolTag = '[object Symbol]',\n      undefinedTag = '[object Undefined]',\n      weakMapTag = '[object WeakMap]',\n      weakSetTag = '[object WeakSet]';\n\n  var arrayBufferTag = '[object ArrayBuffer]',\n      dataViewTag = '[object DataView]',\n      float32Tag = '[object Float32Array]',\n      float64Tag = '[object Float64Array]',\n      int8Tag = '[object Int8Array]',\n      int16Tag = '[object Int16Array]',\n      int32Tag = '[object Int32Array]',\n      uint8Tag = '[object Uint8Array]',\n      uint8ClampedTag = '[object Uint8ClampedArray]',\n      uint16Tag = '[object Uint16Array]',\n      uint32Tag = '[object Uint32Array]';\n\n  /** Used to match empty string literals in compiled template source. */\n  var reEmptyStringLeading = /\\b__p \\+= '';/g,\n      reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\n      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n\n  /** Used to match HTML entities and HTML characters. */\n  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,\n      reUnescapedHtml = /[&<>\"']/g,\n      reHasEscapedHtml = RegExp(reEscapedHtml.source),\n      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n\n  /** Used to match template delimiters. */\n  var reEscape = /<%-([\\s\\S]+?)%>/g,\n      reEvaluate = /<%([\\s\\S]+?)%>/g,\n      reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\n  /** Used to match property names within property paths. */\n  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n      reIsPlainProp = /^\\w*$/,\n      rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n  /**\n   * Used to match `RegExp`\n   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n   */\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n      reHasRegExpChar = RegExp(reRegExpChar.source);\n\n  /** Used to match leading whitespace. */\n  var reTrimStart = /^\\s+/;\n\n  /** Used to match a single whitespace character. */\n  var reWhitespace = /\\s/;\n\n  /** Used to match wrap detail comments. */\n  var reWrapComment = /\\{(?:\\n\\/\\* \\[wrapped with .+\\] \\*\\/)?\\n?/,\n      reWrapDetails = /\\{\\n\\/\\* \\[wrapped with (.+)\\] \\*/,\n      reSplitDetails = /,? & /;\n\n  /** Used to match words composed of alphanumeric characters. */\n  var reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n\n  /**\n   * Used to validate the `validate` option in `_.template` variable.\n   *\n   * Forbids characters which could potentially change the meaning of the function argument definition:\n   * - \"(),\" (modification of function parameters)\n   * - \"=\" (default value)\n   * - \"[]{}\" (destructuring of function parameters)\n   * - \"/\" (beginning of a comment)\n   * - whitespace\n   */\n  var reForbiddenIdentifierChars = /[()=,{}\\[\\]\\/\\s]/;\n\n  /** Used to match backslashes in property paths. */\n  var reEscapeChar = /\\\\(\\\\)?/g;\n\n  /**\n   * Used to match\n   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).\n   */\n  var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\n  /** Used to match `RegExp` flags from their coerced string values. */\n  var reFlags = /\\w*$/;\n\n  /** Used to detect bad signed hexadecimal string values. */\n  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n  /** Used to detect binary string values. */\n  var reIsBinary = /^0b[01]+$/i;\n\n  /** Used to detect host constructors (Safari). */\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n  /** Used to detect octal string values. */\n  var reIsOctal = /^0o[0-7]+$/i;\n\n  /** Used to detect unsigned integer values. */\n  var reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n  /** Used to match Latin Unicode letters (excluding mathematical operators). */\n  var reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\n\n  /** Used to ensure capturing order of template delimiters. */\n  var reNoMatch = /($^)/;\n\n  /** Used to match unescaped characters in compiled string literals. */\n  var reUnescapedString = /['\\n\\r\\u2028\\u2029\\\\]/g;\n\n  /** Used to compose unicode character classes. */\n  var rsAstralRange = '\\\\ud800-\\\\udfff',\n      rsComboMarksRange = '\\\\u0300-\\\\u036f',\n      reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n      rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n      rsDingbatRange = '\\\\u2700-\\\\u27bf',\n      rsLowerRange = 'a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff',\n      rsMathOpRange = '\\\\xac\\\\xb1\\\\xd7\\\\xf7',\n      rsNonCharRange = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf',\n      rsPunctuationRange = '\\\\u2000-\\\\u206f',\n      rsSpaceRange = ' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000',\n      rsUpperRange = 'A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde',\n      rsVarRange = '\\\\ufe0e\\\\ufe0f',\n      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n\n  /** Used to compose unicode capture groups. */\n  var rsApos = \"['\\u2019]\",\n      rsAstral = '[' + rsAstralRange + ']',\n      rsBreak = '[' + rsBreakRange + ']',\n      rsCombo = '[' + rsComboRange + ']',\n      rsDigits = '\\\\d+',\n      rsDingbat = '[' + rsDingbatRange + ']',\n      rsLower = '[' + rsLowerRange + ']',\n      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',\n      rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n      rsNonAstral = '[^' + rsAstralRange + ']',\n      rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n      rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n      rsUpper = '[' + rsUpperRange + ']',\n      rsZWJ = '\\\\u200d';\n\n  /** Used to compose unicode regexes. */\n  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',\n      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',\n      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',\n      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',\n      reOptMod = rsModifier + '?',\n      rsOptVar = '[' + rsVarRange + ']?',\n      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n      rsOrdLower = '\\\\d*(?:1st|2nd|3rd|(?![123])\\\\dth)(?=\\\\b|[A-Z_])',\n      rsOrdUpper = '\\\\d*(?:1ST|2ND|3RD|(?![123])\\\\dTH)(?=\\\\b|[a-z_])',\n      rsSeq = rsOptVar + reOptMod + rsOptJoin,\n      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,\n      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n  /** Used to match apostrophes. */\n  var reApos = RegExp(rsApos, 'g');\n\n  /**\n   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and\n   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).\n   */\n  var reComboMark = RegExp(rsCombo, 'g');\n\n  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\n  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n  /** Used to match complex or compound words. */\n  var reUnicodeWord = RegExp([\n    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',\n    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',\n    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,\n    rsUpper + '+' + rsOptContrUpper,\n    rsOrdUpper,\n    rsOrdLower,\n    rsDigits,\n    rsEmoji\n  ].join('|'), 'g');\n\n  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\n  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');\n\n  /** Used to detect strings that need a more robust regexp to match words. */\n  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\n\n  /** Used to assign default `context` object properties. */\n  var contextProps = [\n    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',\n    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',\n    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',\n    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',\n    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'\n  ];\n\n  /** Used to make template sourceURLs easier to identify. */\n  var templateCounter = -1;\n\n  /** Used to identify `toStringTag` values of typed arrays. */\n  var typedArrayTags = {};\n  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n  typedArrayTags[uint32Tag] = true;\n  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =\n  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\n  typedArrayTags[errorTag] = typedArrayTags[funcTag] =\n  typedArrayTags[mapTag] = typedArrayTags[numberTag] =\n  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =\n  typedArrayTags[setTag] = typedArrayTags[stringTag] =\n  typedArrayTags[weakMapTag] = false;\n\n  /** Used to identify `toStringTag` values supported by `_.clone`. */\n  var cloneableTags = {};\n  cloneableTags[argsTag] = cloneableTags[arrayTag] =\n  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\n  cloneableTags[boolTag] = cloneableTags[dateTag] =\n  cloneableTags[float32Tag] = cloneableTags[float64Tag] =\n  cloneableTags[int8Tag] = cloneableTags[int16Tag] =\n  cloneableTags[int32Tag] = cloneableTags[mapTag] =\n  cloneableTags[numberTag] = cloneableTags[objectTag] =\n  cloneableTags[regexpTag] = cloneableTags[setTag] =\n  cloneableTags[stringTag] = cloneableTags[symbolTag] =\n  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\n  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n  cloneableTags[errorTag] = cloneableTags[funcTag] =\n  cloneableTags[weakMapTag] = false;\n\n  /** Used to map Latin Unicode letters to basic Latin letters. */\n  var deburredLetters = {\n    // Latin-1 Supplement block.\n    '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\n    '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\n    '\\xc7': 'C',  '\\xe7': 'c',\n    '\\xd0': 'D',  '\\xf0': 'd',\n    '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\n    '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\n    '\\xcc': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\n    '\\xec': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\n    '\\xd1': 'N',  '\\xf1': 'n',\n    '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\n    '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\n    '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\n    '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\n    '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\n    '\\xc6': 'Ae', '\\xe6': 'ae',\n    '\\xde': 'Th', '\\xfe': 'th',\n    '\\xdf': 'ss',\n    // Latin Extended-A block.\n    '\\u0100': 'A',  '\\u0102': 'A', '\\u0104': 'A',\n    '\\u0101': 'a',  '\\u0103': 'a', '\\u0105': 'a',\n    '\\u0106': 'C',  '\\u0108': 'C', '\\u010a': 'C', '\\u010c': 'C',\n    '\\u0107': 'c',  '\\u0109': 'c', '\\u010b': 'c', '\\u010d': 'c',\n    '\\u010e': 'D',  '\\u0110': 'D', '\\u010f': 'd', '\\u0111': 'd',\n    '\\u0112': 'E',  '\\u0114': 'E', '\\u0116': 'E', '\\u0118': 'E', '\\u011a': 'E',\n    '\\u0113': 'e',  '\\u0115': 'e', '\\u0117': 'e', '\\u0119': 'e', '\\u011b': 'e',\n    '\\u011c': 'G',  '\\u011e': 'G', '\\u0120': 'G', '\\u0122': 'G',\n    '\\u011d': 'g',  '\\u011f': 'g', '\\u0121': 'g', '\\u0123': 'g',\n    '\\u0124': 'H',  '\\u0126': 'H', '\\u0125': 'h', '\\u0127': 'h',\n    '\\u0128': 'I',  '\\u012a': 'I', '\\u012c': 'I', '\\u012e': 'I', '\\u0130': 'I',\n    '\\u0129': 'i',  '\\u012b': 'i', '\\u012d': 'i', '\\u012f': 'i', '\\u0131': 'i',\n    '\\u0134': 'J',  '\\u0135': 'j',\n    '\\u0136': 'K',  '\\u0137': 'k', '\\u0138': 'k',\n    '\\u0139': 'L',  '\\u013b': 'L', '\\u013d': 'L', '\\u013f': 'L', '\\u0141': 'L',\n    '\\u013a': 'l',  '\\u013c': 'l', '\\u013e': 'l', '\\u0140': 'l', '\\u0142': 'l',\n    '\\u0143': 'N',  '\\u0145': 'N', '\\u0147': 'N', '\\u014a': 'N',\n    '\\u0144': 'n',  '\\u0146': 'n', '\\u0148': 'n', '\\u014b': 'n',\n    '\\u014c': 'O',  '\\u014e': 'O', '\\u0150': 'O',\n    '\\u014d': 'o',  '\\u014f': 'o', '\\u0151': 'o',\n    '\\u0154': 'R',  '\\u0156': 'R', '\\u0158': 'R',\n    '\\u0155': 'r',  '\\u0157': 'r', '\\u0159': 'r',\n    '\\u015a': 'S',  '\\u015c': 'S', '\\u015e': 'S', '\\u0160': 'S',\n    '\\u015b': 's',  '\\u015d': 's', '\\u015f': 's', '\\u0161': 's',\n    '\\u0162': 'T',  '\\u0164': 'T', '\\u0166': 'T',\n    '\\u0163': 't',  '\\u0165': 't', '\\u0167': 't',\n    '\\u0168': 'U',  '\\u016a': 'U', '\\u016c': 'U', '\\u016e': 'U', '\\u0170': 'U', '\\u0172': 'U',\n    '\\u0169': 'u',  '\\u016b': 'u', '\\u016d': 'u', '\\u016f': 'u', '\\u0171': 'u', '\\u0173': 'u',\n    '\\u0174': 'W',  '\\u0175': 'w',\n    '\\u0176': 'Y',  '\\u0177': 'y', '\\u0178': 'Y',\n    '\\u0179': 'Z',  '\\u017b': 'Z', '\\u017d': 'Z',\n    '\\u017a': 'z',  '\\u017c': 'z', '\\u017e': 'z',\n    '\\u0132': 'IJ', '\\u0133': 'ij',\n    '\\u0152': 'Oe', '\\u0153': 'oe',\n    '\\u0149': \"'n\", '\\u017f': 's'\n  };\n\n  /** Used to map characters to HTML entities. */\n  var htmlEscapes = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n\n  /** Used to map HTML entities to characters. */\n  var htmlUnescapes = {\n    '&amp;': '&',\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&#39;': \"'\"\n  };\n\n  /** Used to escape characters for inclusion in compiled string literals. */\n  var stringEscapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    '\\n': 'n',\n    '\\r': 'r',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  /** Built-in method references without a dependency on `root`. */\n  var freeParseFloat = parseFloat,\n      freeParseInt = parseInt;\n\n  /** Detect free variable `global` from Node.js. */\n  var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;\n\n  /** Detect free variable `self`. */\n  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n  /** Used as a reference to the global object. */\n  var root = freeGlobal || freeSelf || Function('return this')();\n\n  /** Detect free variable `exports`. */\n  var freeExports =  true && exports && !exports.nodeType && exports;\n\n  /** Detect free variable `module`. */\n  var freeModule = freeExports && \"object\" == 'object' && module && !module.nodeType && module;\n\n  /** Detect the popular CommonJS extension `module.exports`. */\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n\n  /** Detect free variable `process` from Node.js. */\n  var freeProcess = moduleExports && freeGlobal.process;\n\n  /** Used to access faster Node.js helpers. */\n  var nodeUtil = (function() {\n    try {\n      // Use `util.types` for Node.js 10+.\n      var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n      if (types) {\n        return types;\n      }\n\n      // Legacy `process.binding('util')` for Node.js < 10.\n      return freeProcess && freeProcess.binding && freeProcess.binding('util');\n    } catch (e) {}\n  }());\n\n  /* Node.js helper references. */\n  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,\n      nodeIsDate = nodeUtil && nodeUtil.isDate,\n      nodeIsMap = nodeUtil && nodeUtil.isMap,\n      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,\n      nodeIsSet = nodeUtil && nodeUtil.isSet,\n      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * A faster alternative to `Function#apply`, this function invokes `func`\n   * with the `this` binding of `thisArg` and the arguments of `args`.\n   *\n   * @private\n   * @param {Function} func The function to invoke.\n   * @param {*} thisArg The `this` binding of `func`.\n   * @param {Array} args The arguments to invoke `func` with.\n   * @returns {*} Returns the result of `func`.\n   */\n  function apply(func, thisArg, args) {\n    switch (args.length) {\n      case 0: return func.call(thisArg);\n      case 1: return func.call(thisArg, args[0]);\n      case 2: return func.call(thisArg, args[0], args[1]);\n      case 3: return func.call(thisArg, args[0], args[1], args[2]);\n    }\n    return func.apply(thisArg, args);\n  }\n\n  /**\n   * A specialized version of `baseAggregator` for arrays.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} setter The function to set `accumulator` values.\n   * @param {Function} iteratee The iteratee to transform keys.\n   * @param {Object} accumulator The initial aggregated object.\n   * @returns {Function} Returns `accumulator`.\n   */\n  function arrayAggregator(array, setter, iteratee, accumulator) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      var value = array[index];\n      setter(accumulator, value, iteratee(value), array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.forEach` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEach(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (iteratee(array[index], index, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.forEachRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEachRight(array, iteratee) {\n    var length = array == null ? 0 : array.length;\n\n    while (length--) {\n      if (iteratee(array[length], length, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.every` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if all elements pass the predicate check,\n   *  else `false`.\n   */\n  function arrayEvery(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (!predicate(array[index], index, array)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * A specialized version of `_.filter` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   */\n  function arrayFilter(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (predicate(value, index, array)) {\n        result[resIndex++] = value;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * A specialized version of `_.includes` for arrays without support for\n   * specifying an index to search from.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludes(array, value) {\n    var length = array == null ? 0 : array.length;\n    return !!length && baseIndexOf(array, value, 0) > -1;\n  }\n\n  /**\n   * This function is like `arrayIncludes` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludesWith(array, value, comparator) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (comparator(value, array[index])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * A specialized version of `_.map` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   */\n  function arrayMap(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        result = Array(length);\n\n    while (++index < length) {\n      result[index] = iteratee(array[index], index, array);\n    }\n    return result;\n  }\n\n  /**\n   * Appends the elements of `values` to `array`.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {Array} values The values to append.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayPush(array, values) {\n    var index = -1,\n        length = values.length,\n        offset = array.length;\n\n    while (++index < length) {\n      array[offset + index] = values[index];\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.reduce` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the first element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduce(array, iteratee, accumulator, initAccum) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    if (initAccum && length) {\n      accumulator = array[++index];\n    }\n    while (++index < length) {\n      accumulator = iteratee(accumulator, array[index], index, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.reduceRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the last element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduceRight(array, iteratee, accumulator, initAccum) {\n    var length = array == null ? 0 : array.length;\n    if (initAccum && length) {\n      accumulator = array[--length];\n    }\n    while (length--) {\n      accumulator = iteratee(accumulator, array[length], length, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.some` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if any element passes the predicate check,\n   *  else `false`.\n   */\n  function arraySome(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (predicate(array[index], index, array)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Gets the size of an ASCII `string`.\n   *\n   * @private\n   * @param {string} string The string inspect.\n   * @returns {number} Returns the string size.\n   */\n  var asciiSize = baseProperty('length');\n\n  /**\n   * Converts an ASCII `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function asciiToArray(string) {\n    return string.split('');\n  }\n\n  /**\n   * Splits an ASCII `string` into an array of its words.\n   *\n   * @private\n   * @param {string} The string to inspect.\n   * @returns {Array} Returns the words of `string`.\n   */\n  function asciiWords(string) {\n    return string.match(reAsciiWord) || [];\n  }\n\n  /**\n   * The base implementation of methods like `_.findKey` and `_.findLastKey`,\n   * without support for iteratee shorthands, which iterates over `collection`\n   * using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the found element or its key, else `undefined`.\n   */\n  function baseFindKey(collection, predicate, eachFunc) {\n    var result;\n    eachFunc(collection, function(value, key, collection) {\n      if (predicate(value, key, collection)) {\n        result = key;\n        return false;\n      }\n    });\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.findIndex` and `_.findLastIndex` without\n   * support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {number} fromIndex The index to search from.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseFindIndex(array, predicate, fromIndex, fromRight) {\n    var length = array.length,\n        index = fromIndex + (fromRight ? 1 : -1);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (predicate(array[index], index, array)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOf(array, value, fromIndex) {\n    return value === value\n      ? strictIndexOf(array, value, fromIndex)\n      : baseFindIndex(array, baseIsNaN, fromIndex);\n  }\n\n  /**\n   * This function is like `baseIndexOf` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOfWith(array, value, fromIndex, comparator) {\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (comparator(array[index], value)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.isNaN` without support for number objects.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n   */\n  function baseIsNaN(value) {\n    return value !== value;\n  }\n\n  /**\n   * The base implementation of `_.mean` and `_.meanBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the mean.\n   */\n  function baseMean(array, iteratee) {\n    var length = array == null ? 0 : array.length;\n    return length ? (baseSum(array, iteratee) / length) : NAN;\n  }\n\n  /**\n   * The base implementation of `_.property` without support for deep paths.\n   *\n   * @private\n   * @param {string} key The key of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function baseProperty(key) {\n    return function(object) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * The base implementation of `_.propertyOf` without support for deep paths.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function basePropertyOf(object) {\n    return function(key) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * The base implementation of `_.reduce` and `_.reduceRight`, without support\n   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} accumulator The initial value.\n   * @param {boolean} initAccum Specify using the first or last element of\n   *  `collection` as the initial value.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the accumulated value.\n   */\n  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n    eachFunc(collection, function(value, index, collection) {\n      accumulator = initAccum\n        ? (initAccum = false, value)\n        : iteratee(accumulator, value, index, collection);\n    });\n    return accumulator;\n  }\n\n  /**\n   * The base implementation of `_.sortBy` which uses `comparer` to define the\n   * sort order of `array` and replaces criteria objects with their corresponding\n   * values.\n   *\n   * @private\n   * @param {Array} array The array to sort.\n   * @param {Function} comparer The function to define sort order.\n   * @returns {Array} Returns `array`.\n   */\n  function baseSortBy(array, comparer) {\n    var length = array.length;\n\n    array.sort(comparer);\n    while (length--) {\n      array[length] = array[length].value;\n    }\n    return array;\n  }\n\n  /**\n   * The base implementation of `_.sum` and `_.sumBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the sum.\n   */\n  function baseSum(array, iteratee) {\n    var result,\n        index = -1,\n        length = array.length;\n\n    while (++index < length) {\n      var current = iteratee(array[index]);\n      if (current !== undefined) {\n        result = result === undefined ? current : (result + current);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.times` without support for iteratee shorthands\n   * or max array length checks.\n   *\n   * @private\n   * @param {number} n The number of times to invoke `iteratee`.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the array of results.\n   */\n  function baseTimes(n, iteratee) {\n    var index = -1,\n        result = Array(n);\n\n    while (++index < n) {\n      result[index] = iteratee(index);\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array\n   * of key-value pairs for `object` corresponding to the property names of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the key-value pairs.\n   */\n  function baseToPairs(object, props) {\n    return arrayMap(props, function(key) {\n      return [key, object[key]];\n    });\n  }\n\n  /**\n   * The base implementation of `_.trim`.\n   *\n   * @private\n   * @param {string} string The string to trim.\n   * @returns {string} Returns the trimmed string.\n   */\n  function baseTrim(string) {\n    return string\n      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n      : string;\n  }\n\n  /**\n   * The base implementation of `_.unary` without support for storing metadata.\n   *\n   * @private\n   * @param {Function} func The function to cap arguments for.\n   * @returns {Function} Returns the new capped function.\n   */\n  function baseUnary(func) {\n    return function(value) {\n      return func(value);\n    };\n  }\n\n  /**\n   * The base implementation of `_.values` and `_.valuesIn` which creates an\n   * array of `object` property values corresponding to the property names\n   * of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the array of property values.\n   */\n  function baseValues(object, props) {\n    return arrayMap(props, function(key) {\n      return object[key];\n    });\n  }\n\n  /**\n   * Checks if a `cache` value for `key` exists.\n   *\n   * @private\n   * @param {Object} cache The cache to query.\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function cacheHas(cache, key) {\n    return cache.has(key);\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the first unmatched string symbol.\n   */\n  function charsStartIndex(strSymbols, chrSymbols) {\n    var index = -1,\n        length = strSymbols.length;\n\n    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the last unmatched string symbol.\n   */\n  function charsEndIndex(strSymbols, chrSymbols) {\n    var index = strSymbols.length;\n\n    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  /**\n   * Gets the number of `placeholder` occurrences in `array`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} placeholder The placeholder to search for.\n   * @returns {number} Returns the placeholder count.\n   */\n  function countHolders(array, placeholder) {\n    var length = array.length,\n        result = 0;\n\n    while (length--) {\n      if (array[length] === placeholder) {\n        ++result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A\n   * letters to basic Latin letters.\n   *\n   * @private\n   * @param {string} letter The matched letter to deburr.\n   * @returns {string} Returns the deburred letter.\n   */\n  var deburrLetter = basePropertyOf(deburredLetters);\n\n  /**\n   * Used by `_.escape` to convert characters to HTML entities.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  var escapeHtmlChar = basePropertyOf(htmlEscapes);\n\n  /**\n   * Used by `_.template` to escape characters for inclusion in compiled string literals.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeStringChar(chr) {\n    return '\\\\' + stringEscapes[chr];\n  }\n\n  /**\n   * Gets the value at `key` of `object`.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {string} key The key of the property to get.\n   * @returns {*} Returns the property value.\n   */\n  function getValue(object, key) {\n    return object == null ? undefined : object[key];\n  }\n\n  /**\n   * Checks if `string` contains Unicode symbols.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n   */\n  function hasUnicode(string) {\n    return reHasUnicode.test(string);\n  }\n\n  /**\n   * Checks if `string` contains a word composed of Unicode symbols.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {boolean} Returns `true` if a word is found, else `false`.\n   */\n  function hasUnicodeWord(string) {\n    return reHasUnicodeWord.test(string);\n  }\n\n  /**\n   * Converts `iterator` to an array.\n   *\n   * @private\n   * @param {Object} iterator The iterator to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function iteratorToArray(iterator) {\n    var data,\n        result = [];\n\n    while (!(data = iterator.next()).done) {\n      result.push(data.value);\n    }\n    return result;\n  }\n\n  /**\n   * Converts `map` to its key-value pairs.\n   *\n   * @private\n   * @param {Object} map The map to convert.\n   * @returns {Array} Returns the key-value pairs.\n   */\n  function mapToArray(map) {\n    var index = -1,\n        result = Array(map.size);\n\n    map.forEach(function(value, key) {\n      result[++index] = [key, value];\n    });\n    return result;\n  }\n\n  /**\n   * Creates a unary function that invokes `func` with its argument transformed.\n   *\n   * @private\n   * @param {Function} func The function to wrap.\n   * @param {Function} transform The argument transform.\n   * @returns {Function} Returns the new function.\n   */\n  function overArg(func, transform) {\n    return function(arg) {\n      return func(transform(arg));\n    };\n  }\n\n  /**\n   * Replaces all `placeholder` elements in `array` with an internal placeholder\n   * and returns an array of their indexes.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {*} placeholder The placeholder to replace.\n   * @returns {Array} Returns the new array of placeholder indexes.\n   */\n  function replaceHolders(array, placeholder) {\n    var index = -1,\n        length = array.length,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (value === placeholder || value === PLACEHOLDER) {\n        array[index] = PLACEHOLDER;\n        result[resIndex++] = index;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Converts `set` to an array of its values.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the values.\n   */\n  function setToArray(set) {\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function(value) {\n      result[++index] = value;\n    });\n    return result;\n  }\n\n  /**\n   * Converts `set` to its value-value pairs.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the value-value pairs.\n   */\n  function setToPairs(set) {\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function(value) {\n      result[++index] = [value, value];\n    });\n    return result;\n  }\n\n  /**\n   * A specialized version of `_.indexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function strictIndexOf(array, value, fromIndex) {\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * A specialized version of `_.lastIndexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function strictLastIndexOf(array, value, fromIndex) {\n    var index = fromIndex + 1;\n    while (index--) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Gets the number of symbols in `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the string size.\n   */\n  function stringSize(string) {\n    return hasUnicode(string)\n      ? unicodeSize(string)\n      : asciiSize(string);\n  }\n\n  /**\n   * Converts `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function stringToArray(string) {\n    return hasUnicode(string)\n      ? unicodeToArray(string)\n      : asciiToArray(string);\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n   * character of `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the index of the last non-whitespace character.\n   */\n  function trimmedEndIndex(string) {\n    var index = string.length;\n\n    while (index-- && reWhitespace.test(string.charAt(index))) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.unescape` to convert HTML entities to characters.\n   *\n   * @private\n   * @param {string} chr The matched character to unescape.\n   * @returns {string} Returns the unescaped character.\n   */\n  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);\n\n  /**\n   * Gets the size of a Unicode `string`.\n   *\n   * @private\n   * @param {string} string The string inspect.\n   * @returns {number} Returns the string size.\n   */\n  function unicodeSize(string) {\n    var result = reUnicode.lastIndex = 0;\n    while (reUnicode.test(string)) {\n      ++result;\n    }\n    return result;\n  }\n\n  /**\n   * Converts a Unicode `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function unicodeToArray(string) {\n    return string.match(reUnicode) || [];\n  }\n\n  /**\n   * Splits a Unicode `string` into an array of its words.\n   *\n   * @private\n   * @param {string} The string to inspect.\n   * @returns {Array} Returns the words of `string`.\n   */\n  function unicodeWords(string) {\n    return string.match(reUnicodeWord) || [];\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Create a new pristine `lodash` function using the `context` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 1.1.0\n   * @category Util\n   * @param {Object} [context=root] The context object.\n   * @returns {Function} Returns a new `lodash` function.\n   * @example\n   *\n   * _.mixin({ 'foo': _.constant('foo') });\n   *\n   * var lodash = _.runInContext();\n   * lodash.mixin({ 'bar': lodash.constant('bar') });\n   *\n   * _.isFunction(_.foo);\n   * // => true\n   * _.isFunction(_.bar);\n   * // => false\n   *\n   * lodash.isFunction(lodash.foo);\n   * // => false\n   * lodash.isFunction(lodash.bar);\n   * // => true\n   *\n   * // Create a suped-up `defer` in Node.js.\n   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;\n   */\n  var runInContext = (function runInContext(context) {\n    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));\n\n    /** Built-in constructor references. */\n    var Array = context.Array,\n        Date = context.Date,\n        Error = context.Error,\n        Function = context.Function,\n        Math = context.Math,\n        Object = context.Object,\n        RegExp = context.RegExp,\n        String = context.String,\n        TypeError = context.TypeError;\n\n    /** Used for built-in method references. */\n    var arrayProto = Array.prototype,\n        funcProto = Function.prototype,\n        objectProto = Object.prototype;\n\n    /** Used to detect overreaching core-js shims. */\n    var coreJsData = context['__core-js_shared__'];\n\n    /** Used to resolve the decompiled source of functions. */\n    var funcToString = funcProto.toString;\n\n    /** Used to check objects for own properties. */\n    var hasOwnProperty = objectProto.hasOwnProperty;\n\n    /** Used to generate unique IDs. */\n    var idCounter = 0;\n\n    /** Used to detect methods masquerading as native. */\n    var maskSrcKey = (function() {\n      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n      return uid ? ('Symbol(src)_1.' + uid) : '';\n    }());\n\n    /**\n     * Used to resolve the\n     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n     * of values.\n     */\n    var nativeObjectToString = objectProto.toString;\n\n    /** Used to infer the `Object` constructor. */\n    var objectCtorString = funcToString.call(Object);\n\n    /** Used to restore the original `_` reference in `_.noConflict`. */\n    var oldDash = root._;\n\n    /** Used to detect if a method is native. */\n    var reIsNative = RegExp('^' +\n      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n      .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n    );\n\n    /** Built-in value references. */\n    var Buffer = moduleExports ? context.Buffer : undefined,\n        Symbol = context.Symbol,\n        Uint8Array = context.Uint8Array,\n        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,\n        getPrototype = overArg(Object.getPrototypeOf, Object),\n        objectCreate = Object.create,\n        propertyIsEnumerable = objectProto.propertyIsEnumerable,\n        splice = arrayProto.splice,\n        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,\n        symIterator = Symbol ? Symbol.iterator : undefined,\n        symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n    var defineProperty = (function() {\n      try {\n        var func = getNative(Object, 'defineProperty');\n        func({}, '', {});\n        return func;\n      } catch (e) {}\n    }());\n\n    /** Mocked built-ins. */\n    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,\n        ctxNow = Date && Date.now !== root.Date.now && Date.now,\n        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;\n\n    /* Built-in method references for those with the same name as other `lodash` methods. */\n    var nativeCeil = Math.ceil,\n        nativeFloor = Math.floor,\n        nativeGetSymbols = Object.getOwnPropertySymbols,\n        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n        nativeIsFinite = context.isFinite,\n        nativeJoin = arrayProto.join,\n        nativeKeys = overArg(Object.keys, Object),\n        nativeMax = Math.max,\n        nativeMin = Math.min,\n        nativeNow = Date.now,\n        nativeParseInt = context.parseInt,\n        nativeRandom = Math.random,\n        nativeReverse = arrayProto.reverse;\n\n    /* Built-in method references that are verified to be native. */\n    var DataView = getNative(context, 'DataView'),\n        Map = getNative(context, 'Map'),\n        Promise = getNative(context, 'Promise'),\n        Set = getNative(context, 'Set'),\n        WeakMap = getNative(context, 'WeakMap'),\n        nativeCreate = getNative(Object, 'create');\n\n    /** Used to store function metadata. */\n    var metaMap = WeakMap && new WeakMap;\n\n    /** Used to lookup unminified function names. */\n    var realNames = {};\n\n    /** Used to detect maps, sets, and weakmaps. */\n    var dataViewCtorString = toSource(DataView),\n        mapCtorString = toSource(Map),\n        promiseCtorString = toSource(Promise),\n        setCtorString = toSource(Set),\n        weakMapCtorString = toSource(WeakMap);\n\n    /** Used to convert symbols to primitives and strings. */\n    var symbolProto = Symbol ? Symbol.prototype : undefined,\n        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n        symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object which wraps `value` to enable implicit method\n     * chain sequences. Methods that operate on and return arrays, collections,\n     * and functions can be chained together. Methods that retrieve a single value\n     * or may return a primitive value will automatically end the chain sequence\n     * and return the unwrapped value. Otherwise, the value must be unwrapped\n     * with `_#value`.\n     *\n     * Explicit chain sequences, which must be unwrapped with `_#value`, may be\n     * enabled using `_.chain`.\n     *\n     * The execution of chained methods is lazy, that is, it's deferred until\n     * `_#value` is implicitly or explicitly called.\n     *\n     * Lazy evaluation allows several methods to support shortcut fusion.\n     * Shortcut fusion is an optimization to merge iteratee calls; this avoids\n     * the creation of intermediate arrays and can greatly reduce the number of\n     * iteratee executions. Sections of a chain sequence qualify for shortcut\n     * fusion if the section is applied to an array and iteratees accept only\n     * one argument. The heuristic for whether a section qualifies for shortcut\n     * fusion is subject to change.\n     *\n     * Chaining is supported in custom builds as long as the `_#value` method is\n     * directly or indirectly included in the build.\n     *\n     * In addition to lodash methods, wrappers have `Array` and `String` methods.\n     *\n     * The wrapper `Array` methods are:\n     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`\n     *\n     * The wrapper `String` methods are:\n     * `replace` and `split`\n     *\n     * The wrapper methods that support shortcut fusion are:\n     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,\n     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,\n     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`\n     *\n     * The chainable wrapper methods are:\n     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,\n     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,\n     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,\n     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,\n     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,\n     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,\n     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,\n     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,\n     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,\n     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,\n     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,\n     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,\n     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,\n     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,\n     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,\n     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,\n     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,\n     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,\n     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,\n     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,\n     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,\n     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,\n     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,\n     * `zipObject`, `zipObjectDeep`, and `zipWith`\n     *\n     * The wrapper methods that are **not** chainable by default are:\n     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,\n     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,\n     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,\n     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,\n     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,\n     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,\n     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,\n     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,\n     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,\n     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,\n     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,\n     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,\n     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,\n     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,\n     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,\n     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,\n     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,\n     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,\n     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,\n     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,\n     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,\n     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,\n     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,\n     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,\n     * `upperFirst`, `value`, and `words`\n     *\n     * @name _\n     * @constructor\n     * @category Seq\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2, 3]);\n     *\n     * // Returns an unwrapped value.\n     * wrapped.reduce(_.add);\n     * // => 6\n     *\n     * // Returns a wrapped value.\n     * var squares = wrapped.map(square);\n     *\n     * _.isArray(squares);\n     * // => false\n     *\n     * _.isArray(squares.value());\n     * // => true\n     */\n    function lodash(value) {\n      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {\n        if (value instanceof LodashWrapper) {\n          return value;\n        }\n        if (hasOwnProperty.call(value, '__wrapped__')) {\n          return wrapperClone(value);\n        }\n      }\n      return new LodashWrapper(value);\n    }\n\n    /**\n     * The base implementation of `_.create` without support for assigning\n     * properties to the created object.\n     *\n     * @private\n     * @param {Object} proto The object to inherit from.\n     * @returns {Object} Returns the new object.\n     */\n    var baseCreate = (function() {\n      function object() {}\n      return function(proto) {\n        if (!isObject(proto)) {\n          return {};\n        }\n        if (objectCreate) {\n          return objectCreate(proto);\n        }\n        object.prototype = proto;\n        var result = new object;\n        object.prototype = undefined;\n        return result;\n      };\n    }());\n\n    /**\n     * The function whose prototype chain sequence wrappers inherit from.\n     *\n     * @private\n     */\n    function baseLodash() {\n      // No operation performed.\n    }\n\n    /**\n     * The base constructor for creating `lodash` wrapper objects.\n     *\n     * @private\n     * @param {*} value The value to wrap.\n     * @param {boolean} [chainAll] Enable explicit method chain sequences.\n     */\n    function LodashWrapper(value, chainAll) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__chain__ = !!chainAll;\n      this.__index__ = 0;\n      this.__values__ = undefined;\n    }\n\n    /**\n     * By default, the template delimiters used by lodash are like those in\n     * embedded Ruby (ERB) as well as ES2015 template strings. Change the\n     * following template settings to use alternative delimiters.\n     *\n     * @static\n     * @memberOf _\n     * @type {Object}\n     */\n    lodash.templateSettings = {\n\n      /**\n       * Used to detect `data` property values to be HTML-escaped.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'escape': reEscape,\n\n      /**\n       * Used to detect code to be evaluated.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'evaluate': reEvaluate,\n\n      /**\n       * Used to detect `data` property values to inject.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'interpolate': reInterpolate,\n\n      /**\n       * Used to reference the data object in the template text.\n       *\n       * @memberOf _.templateSettings\n       * @type {string}\n       */\n      'variable': '',\n\n      /**\n       * Used to import variables into the compiled template.\n       *\n       * @memberOf _.templateSettings\n       * @type {Object}\n       */\n      'imports': {\n\n        /**\n         * A reference to the `lodash` function.\n         *\n         * @memberOf _.templateSettings.imports\n         * @type {Function}\n         */\n        '_': lodash\n      }\n    };\n\n    // Ensure wrappers are instances of `baseLodash`.\n    lodash.prototype = baseLodash.prototype;\n    lodash.prototype.constructor = lodash;\n\n    LodashWrapper.prototype = baseCreate(baseLodash.prototype);\n    LodashWrapper.prototype.constructor = LodashWrapper;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.\n     *\n     * @private\n     * @constructor\n     * @param {*} value The value to wrap.\n     */\n    function LazyWrapper(value) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__dir__ = 1;\n      this.__filtered__ = false;\n      this.__iteratees__ = [];\n      this.__takeCount__ = MAX_ARRAY_LENGTH;\n      this.__views__ = [];\n    }\n\n    /**\n     * Creates a clone of the lazy wrapper object.\n     *\n     * @private\n     * @name clone\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the cloned `LazyWrapper` object.\n     */\n    function lazyClone() {\n      var result = new LazyWrapper(this.__wrapped__);\n      result.__actions__ = copyArray(this.__actions__);\n      result.__dir__ = this.__dir__;\n      result.__filtered__ = this.__filtered__;\n      result.__iteratees__ = copyArray(this.__iteratees__);\n      result.__takeCount__ = this.__takeCount__;\n      result.__views__ = copyArray(this.__views__);\n      return result;\n    }\n\n    /**\n     * Reverses the direction of lazy iteration.\n     *\n     * @private\n     * @name reverse\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the new reversed `LazyWrapper` object.\n     */\n    function lazyReverse() {\n      if (this.__filtered__) {\n        var result = new LazyWrapper(this);\n        result.__dir__ = -1;\n        result.__filtered__ = true;\n      } else {\n        result = this.clone();\n        result.__dir__ *= -1;\n      }\n      return result;\n    }\n\n    /**\n     * Extracts the unwrapped value from its lazy wrapper.\n     *\n     * @private\n     * @name value\n     * @memberOf LazyWrapper\n     * @returns {*} Returns the unwrapped value.\n     */\n    function lazyValue() {\n      var array = this.__wrapped__.value(),\n          dir = this.__dir__,\n          isArr = isArray(array),\n          isRight = dir < 0,\n          arrLength = isArr ? array.length : 0,\n          view = getView(0, arrLength, this.__views__),\n          start = view.start,\n          end = view.end,\n          length = end - start,\n          index = isRight ? end : (start - 1),\n          iteratees = this.__iteratees__,\n          iterLength = iteratees.length,\n          resIndex = 0,\n          takeCount = nativeMin(length, this.__takeCount__);\n\n      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {\n        return baseWrapperValue(array, this.__actions__);\n      }\n      var result = [];\n\n      outer:\n      while (length-- && resIndex < takeCount) {\n        index += dir;\n\n        var iterIndex = -1,\n            value = array[index];\n\n        while (++iterIndex < iterLength) {\n          var data = iteratees[iterIndex],\n              iteratee = data.iteratee,\n              type = data.type,\n              computed = iteratee(value);\n\n          if (type == LAZY_MAP_FLAG) {\n            value = computed;\n          } else if (!computed) {\n            if (type == LAZY_FILTER_FLAG) {\n              continue outer;\n            } else {\n              break outer;\n            }\n          }\n        }\n        result[resIndex++] = value;\n      }\n      return result;\n    }\n\n    // Ensure `LazyWrapper` is an instance of `baseLodash`.\n    LazyWrapper.prototype = baseCreate(baseLodash.prototype);\n    LazyWrapper.prototype.constructor = LazyWrapper;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a hash object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function Hash(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the hash.\n     *\n     * @private\n     * @name clear\n     * @memberOf Hash\n     */\n    function hashClear() {\n      this.__data__ = nativeCreate ? nativeCreate(null) : {};\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the hash.\n     *\n     * @private\n     * @name delete\n     * @memberOf Hash\n     * @param {Object} hash The hash to modify.\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function hashDelete(key) {\n      var result = this.has(key) && delete this.__data__[key];\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n\n    /**\n     * Gets the hash value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Hash\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function hashGet(key) {\n      var data = this.__data__;\n      if (nativeCreate) {\n        var result = data[key];\n        return result === HASH_UNDEFINED ? undefined : result;\n      }\n      return hasOwnProperty.call(data, key) ? data[key] : undefined;\n    }\n\n    /**\n     * Checks if a hash value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Hash\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function hashHas(key) {\n      var data = this.__data__;\n      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n    }\n\n    /**\n     * Sets the hash `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Hash\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the hash instance.\n     */\n    function hashSet(key, value) {\n      var data = this.__data__;\n      this.size += this.has(key) ? 0 : 1;\n      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n      return this;\n    }\n\n    // Add methods to `Hash`.\n    Hash.prototype.clear = hashClear;\n    Hash.prototype['delete'] = hashDelete;\n    Hash.prototype.get = hashGet;\n    Hash.prototype.has = hashHas;\n    Hash.prototype.set = hashSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an list cache object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function ListCache(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the list cache.\n     *\n     * @private\n     * @name clear\n     * @memberOf ListCache\n     */\n    function listCacheClear() {\n      this.__data__ = [];\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the list cache.\n     *\n     * @private\n     * @name delete\n     * @memberOf ListCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function listCacheDelete(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      if (index < 0) {\n        return false;\n      }\n      var lastIndex = data.length - 1;\n      if (index == lastIndex) {\n        data.pop();\n      } else {\n        splice.call(data, index, 1);\n      }\n      --this.size;\n      return true;\n    }\n\n    /**\n     * Gets the list cache value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf ListCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function listCacheGet(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      return index < 0 ? undefined : data[index][1];\n    }\n\n    /**\n     * Checks if a list cache value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf ListCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function listCacheHas(key) {\n      return assocIndexOf(this.__data__, key) > -1;\n    }\n\n    /**\n     * Sets the list cache `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf ListCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the list cache instance.\n     */\n    function listCacheSet(key, value) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      if (index < 0) {\n        ++this.size;\n        data.push([key, value]);\n      } else {\n        data[index][1] = value;\n      }\n      return this;\n    }\n\n    // Add methods to `ListCache`.\n    ListCache.prototype.clear = listCacheClear;\n    ListCache.prototype['delete'] = listCacheDelete;\n    ListCache.prototype.get = listCacheGet;\n    ListCache.prototype.has = listCacheHas;\n    ListCache.prototype.set = listCacheSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a map cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function MapCache(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the map.\n     *\n     * @private\n     * @name clear\n     * @memberOf MapCache\n     */\n    function mapCacheClear() {\n      this.size = 0;\n      this.__data__ = {\n        'hash': new Hash,\n        'map': new (Map || ListCache),\n        'string': new Hash\n      };\n    }\n\n    /**\n     * Removes `key` and its value from the map.\n     *\n     * @private\n     * @name delete\n     * @memberOf MapCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function mapCacheDelete(key) {\n      var result = getMapData(this, key)['delete'](key);\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n\n    /**\n     * Gets the map value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf MapCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function mapCacheGet(key) {\n      return getMapData(this, key).get(key);\n    }\n\n    /**\n     * Checks if a map value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf MapCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function mapCacheHas(key) {\n      return getMapData(this, key).has(key);\n    }\n\n    /**\n     * Sets the map `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf MapCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the map cache instance.\n     */\n    function mapCacheSet(key, value) {\n      var data = getMapData(this, key),\n          size = data.size;\n\n      data.set(key, value);\n      this.size += data.size == size ? 0 : 1;\n      return this;\n    }\n\n    // Add methods to `MapCache`.\n    MapCache.prototype.clear = mapCacheClear;\n    MapCache.prototype['delete'] = mapCacheDelete;\n    MapCache.prototype.get = mapCacheGet;\n    MapCache.prototype.has = mapCacheHas;\n    MapCache.prototype.set = mapCacheSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     *\n     * Creates an array cache object to store unique values.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [values] The values to cache.\n     */\n    function SetCache(values) {\n      var index = -1,\n          length = values == null ? 0 : values.length;\n\n      this.__data__ = new MapCache;\n      while (++index < length) {\n        this.add(values[index]);\n      }\n    }\n\n    /**\n     * Adds `value` to the array cache.\n     *\n     * @private\n     * @name add\n     * @memberOf SetCache\n     * @alias push\n     * @param {*} value The value to cache.\n     * @returns {Object} Returns the cache instance.\n     */\n    function setCacheAdd(value) {\n      this.__data__.set(value, HASH_UNDEFINED);\n      return this;\n    }\n\n    /**\n     * Checks if `value` is in the array cache.\n     *\n     * @private\n     * @name has\n     * @memberOf SetCache\n     * @param {*} value The value to search for.\n     * @returns {number} Returns `true` if `value` is found, else `false`.\n     */\n    function setCacheHas(value) {\n      return this.__data__.has(value);\n    }\n\n    // Add methods to `SetCache`.\n    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n    SetCache.prototype.has = setCacheHas;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a stack cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function Stack(entries) {\n      var data = this.__data__ = new ListCache(entries);\n      this.size = data.size;\n    }\n\n    /**\n     * Removes all key-value entries from the stack.\n     *\n     * @private\n     * @name clear\n     * @memberOf Stack\n     */\n    function stackClear() {\n      this.__data__ = new ListCache;\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the stack.\n     *\n     * @private\n     * @name delete\n     * @memberOf Stack\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function stackDelete(key) {\n      var data = this.__data__,\n          result = data['delete'](key);\n\n      this.size = data.size;\n      return result;\n    }\n\n    /**\n     * Gets the stack value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Stack\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function stackGet(key) {\n      return this.__data__.get(key);\n    }\n\n    /**\n     * Checks if a stack value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Stack\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function stackHas(key) {\n      return this.__data__.has(key);\n    }\n\n    /**\n     * Sets the stack `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Stack\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the stack cache instance.\n     */\n    function stackSet(key, value) {\n      var data = this.__data__;\n      if (data instanceof ListCache) {\n        var pairs = data.__data__;\n        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n          pairs.push([key, value]);\n          this.size = ++data.size;\n          return this;\n        }\n        data = this.__data__ = new MapCache(pairs);\n      }\n      data.set(key, value);\n      this.size = data.size;\n      return this;\n    }\n\n    // Add methods to `Stack`.\n    Stack.prototype.clear = stackClear;\n    Stack.prototype['delete'] = stackDelete;\n    Stack.prototype.get = stackGet;\n    Stack.prototype.has = stackHas;\n    Stack.prototype.set = stackSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of the enumerable property names of the array-like `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @param {boolean} inherited Specify returning inherited property names.\n     * @returns {Array} Returns the array of property names.\n     */\n    function arrayLikeKeys(value, inherited) {\n      var isArr = isArray(value),\n          isArg = !isArr && isArguments(value),\n          isBuff = !isArr && !isArg && isBuffer(value),\n          isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n          skipIndexes = isArr || isArg || isBuff || isType,\n          result = skipIndexes ? baseTimes(value.length, String) : [],\n          length = result.length;\n\n      for (var key in value) {\n        if ((inherited || hasOwnProperty.call(value, key)) &&\n            !(skipIndexes && (\n               // Safari 9 has enumerable `arguments.length` in strict mode.\n               key == 'length' ||\n               // Node.js 0.10 has enumerable non-index properties on buffers.\n               (isBuff && (key == 'offset' || key == 'parent')) ||\n               // PhantomJS 2 has enumerable non-index properties on typed arrays.\n               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n               // Skip index properties.\n               isIndex(key, length)\n            ))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `_.sample` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to sample.\n     * @returns {*} Returns the random element.\n     */\n    function arraySample(array) {\n      var length = array.length;\n      return length ? array[baseRandom(0, length - 1)] : undefined;\n    }\n\n    /**\n     * A specialized version of `_.sampleSize` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to sample.\n     * @param {number} n The number of elements to sample.\n     * @returns {Array} Returns the random elements.\n     */\n    function arraySampleSize(array, n) {\n      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));\n    }\n\n    /**\n     * A specialized version of `_.shuffle` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     */\n    function arrayShuffle(array) {\n      return shuffleSelf(copyArray(array));\n    }\n\n    /**\n     * This function is like `assignValue` except that it doesn't assign\n     * `undefined` values.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function assignMergeValue(object, key, value) {\n      if ((value !== undefined && !eq(object[key], value)) ||\n          (value === undefined && !(key in object))) {\n        baseAssignValue(object, key, value);\n      }\n    }\n\n    /**\n     * Assigns `value` to `key` of `object` if the existing value is not equivalent\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function assignValue(object, key, value) {\n      var objValue = object[key];\n      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n          (value === undefined && !(key in object))) {\n        baseAssignValue(object, key, value);\n      }\n    }\n\n    /**\n     * Gets the index at which the `key` is found in `array` of key-value pairs.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {*} key The key to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     */\n    function assocIndexOf(array, key) {\n      var length = array.length;\n      while (length--) {\n        if (eq(array[length][0], key)) {\n          return length;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Aggregates elements of `collection` on `accumulator` with keys transformed\n     * by `iteratee` and values set by `setter`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} setter The function to set `accumulator` values.\n     * @param {Function} iteratee The iteratee to transform keys.\n     * @param {Object} accumulator The initial aggregated object.\n     * @returns {Function} Returns `accumulator`.\n     */\n    function baseAggregator(collection, setter, iteratee, accumulator) {\n      baseEach(collection, function(value, key, collection) {\n        setter(accumulator, value, iteratee(value), collection);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `_.assign` without support for multiple sources\n     * or `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    function baseAssign(object, source) {\n      return object && copyObject(source, keys(source), object);\n    }\n\n    /**\n     * The base implementation of `_.assignIn` without support for multiple sources\n     * or `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    function baseAssignIn(object, source) {\n      return object && copyObject(source, keysIn(source), object);\n    }\n\n    /**\n     * The base implementation of `assignValue` and `assignMergeValue` without\n     * value checks.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function baseAssignValue(object, key, value) {\n      if (key == '__proto__' && defineProperty) {\n        defineProperty(object, key, {\n          'configurable': true,\n          'enumerable': true,\n          'value': value,\n          'writable': true\n        });\n      } else {\n        object[key] = value;\n      }\n    }\n\n    /**\n     * The base implementation of `_.at` without support for individual paths.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {string[]} paths The property paths to pick.\n     * @returns {Array} Returns the picked elements.\n     */\n    function baseAt(object, paths) {\n      var index = -1,\n          length = paths.length,\n          result = Array(length),\n          skip = object == null;\n\n      while (++index < length) {\n        result[index] = skip ? undefined : get(object, paths[index]);\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.clamp` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     */\n    function baseClamp(number, lower, upper) {\n      if (number === number) {\n        if (upper !== undefined) {\n          number = number <= upper ? number : upper;\n        }\n        if (lower !== undefined) {\n          number = number >= lower ? number : lower;\n        }\n      }\n      return number;\n    }\n\n    /**\n     * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n     * traversed objects.\n     *\n     * @private\n     * @param {*} value The value to clone.\n     * @param {boolean} bitmask The bitmask flags.\n     *  1 - Deep clone\n     *  2 - Flatten inherited properties\n     *  4 - Clone symbols\n     * @param {Function} [customizer] The function to customize cloning.\n     * @param {string} [key] The key of `value`.\n     * @param {Object} [object] The parent object of `value`.\n     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n     * @returns {*} Returns the cloned value.\n     */\n    function baseClone(value, bitmask, customizer, key, object, stack) {\n      var result,\n          isDeep = bitmask & CLONE_DEEP_FLAG,\n          isFlat = bitmask & CLONE_FLAT_FLAG,\n          isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n      if (customizer) {\n        result = object ? customizer(value, key, object, stack) : customizer(value);\n      }\n      if (result !== undefined) {\n        return result;\n      }\n      if (!isObject(value)) {\n        return value;\n      }\n      var isArr = isArray(value);\n      if (isArr) {\n        result = initCloneArray(value);\n        if (!isDeep) {\n          return copyArray(value, result);\n        }\n      } else {\n        var tag = getTag(value),\n            isFunc = tag == funcTag || tag == genTag;\n\n        if (isBuffer(value)) {\n          return cloneBuffer(value, isDeep);\n        }\n        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n          result = (isFlat || isFunc) ? {} : initCloneObject(value);\n          if (!isDeep) {\n            return isFlat\n              ? copySymbolsIn(value, baseAssignIn(result, value))\n              : copySymbols(value, baseAssign(result, value));\n          }\n        } else {\n          if (!cloneableTags[tag]) {\n            return object ? value : {};\n          }\n          result = initCloneByTag(value, tag, isDeep);\n        }\n      }\n      // Check for circular references and return its corresponding clone.\n      stack || (stack = new Stack);\n      var stacked = stack.get(value);\n      if (stacked) {\n        return stacked;\n      }\n      stack.set(value, result);\n\n      if (isSet(value)) {\n        value.forEach(function(subValue) {\n          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n        });\n      } else if (isMap(value)) {\n        value.forEach(function(subValue, key) {\n          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n        });\n      }\n\n      var keysFunc = isFull\n        ? (isFlat ? getAllKeysIn : getAllKeys)\n        : (isFlat ? keysIn : keys);\n\n      var props = isArr ? undefined : keysFunc(value);\n      arrayEach(props || value, function(subValue, key) {\n        if (props) {\n          key = subValue;\n          subValue = value[key];\n        }\n        // Recursively populate clone (susceptible to call stack limits).\n        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.conforms` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseConforms(source) {\n      var props = keys(source);\n      return function(object) {\n        return baseConformsTo(object, source, props);\n      };\n    }\n\n    /**\n     * The base implementation of `_.conformsTo` which accepts `props` to check.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n     */\n    function baseConformsTo(object, source, props) {\n      var length = props.length;\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (length--) {\n        var key = props[length],\n            predicate = source[key],\n            value = object[key];\n\n        if ((value === undefined && !(key in object)) || !predicate(value)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.delay` and `_.defer` which accepts `args`\n     * to provide to `func`.\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {Array} args The arguments to provide to `func`.\n     * @returns {number|Object} Returns the timer id or timeout object.\n     */\n    function baseDelay(func, wait, args) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return setTimeout(function() { func.apply(undefined, args); }, wait);\n    }\n\n    /**\n     * The base implementation of methods like `_.difference` without support\n     * for excluding multiple arrays or iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Array} values The values to exclude.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     */\n    function baseDifference(array, values, iteratee, comparator) {\n      var index = -1,\n          includes = arrayIncludes,\n          isCommon = true,\n          length = array.length,\n          result = [],\n          valuesLength = values.length;\n\n      if (!length) {\n        return result;\n      }\n      if (iteratee) {\n        values = arrayMap(values, baseUnary(iteratee));\n      }\n      if (comparator) {\n        includes = arrayIncludesWith;\n        isCommon = false;\n      }\n      else if (values.length >= LARGE_ARRAY_SIZE) {\n        includes = cacheHas;\n        isCommon = false;\n        values = new SetCache(values);\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee == null ? value : iteratee(value);\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n          var valuesIndex = valuesLength;\n          while (valuesIndex--) {\n            if (values[valuesIndex] === computed) {\n              continue outer;\n            }\n          }\n          result.push(value);\n        }\n        else if (!includes(values, computed, comparator)) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.forEach` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */\n    var baseEach = createBaseEach(baseForOwn);\n\n    /**\n     * The base implementation of `_.forEachRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */\n    var baseEachRight = createBaseEach(baseForOwnRight, true);\n\n    /**\n     * The base implementation of `_.every` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`\n     */\n    function baseEvery(collection, predicate) {\n      var result = true;\n      baseEach(collection, function(value, index, collection) {\n        result = !!predicate(value, index, collection);\n        return result;\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of methods like `_.max` and `_.min` which accepts a\n     * `comparator` to determine the extremum value.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The iteratee invoked per iteration.\n     * @param {Function} comparator The comparator used to compare values.\n     * @returns {*} Returns the extremum value.\n     */\n    function baseExtremum(array, iteratee, comparator) {\n      var index = -1,\n          length = array.length;\n\n      while (++index < length) {\n        var value = array[index],\n            current = iteratee(value);\n\n        if (current != null && (computed === undefined\n              ? (current === current && !isSymbol(current))\n              : comparator(current, computed)\n            )) {\n          var computed = current,\n              result = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.fill` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     */\n    function baseFill(array, value, start, end) {\n      var length = array.length;\n\n      start = toInteger(start);\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = (end === undefined || end > length) ? length : toInteger(end);\n      if (end < 0) {\n        end += length;\n      }\n      end = start > end ? 0 : toLength(end);\n      while (start < end) {\n        array[start++] = value;\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.filter` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     */\n    function baseFilter(collection, predicate) {\n      var result = [];\n      baseEach(collection, function(value, index, collection) {\n        if (predicate(value, index, collection)) {\n          result.push(value);\n        }\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.flatten` with support for restricting flattening.\n     *\n     * @private\n     * @param {Array} array The array to flatten.\n     * @param {number} depth The maximum recursion depth.\n     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n     * @param {Array} [result=[]] The initial result value.\n     * @returns {Array} Returns the new flattened array.\n     */\n    function baseFlatten(array, depth, predicate, isStrict, result) {\n      var index = -1,\n          length = array.length;\n\n      predicate || (predicate = isFlattenable);\n      result || (result = []);\n\n      while (++index < length) {\n        var value = array[index];\n        if (depth > 0 && predicate(value)) {\n          if (depth > 1) {\n            // Recursively flatten arrays (susceptible to call stack limits).\n            baseFlatten(value, depth - 1, predicate, isStrict, result);\n          } else {\n            arrayPush(result, value);\n          }\n        } else if (!isStrict) {\n          result[result.length] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `baseForOwn` which iterates over `object`\n     * properties returned by `keysFunc` and invokes `iteratee` for each property.\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseFor = createBaseFor();\n\n    /**\n     * This function is like `baseFor` except that it iterates over properties\n     * in the opposite order.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseForRight = createBaseFor(true);\n\n    /**\n     * The base implementation of `_.forOwn` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwn(object, iteratee) {\n      return object && baseFor(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwnRight(object, iteratee) {\n      return object && baseForRight(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.functions` which creates an array of\n     * `object` function property names filtered from `props`.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Array} props The property names to filter.\n     * @returns {Array} Returns the function names.\n     */\n    function baseFunctions(object, props) {\n      return arrayFilter(props, function(key) {\n        return isFunction(object[key]);\n      });\n    }\n\n    /**\n     * The base implementation of `_.get` without support for default values.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseGet(object, path) {\n      path = castPath(path, object);\n\n      var index = 0,\n          length = path.length;\n\n      while (object != null && index < length) {\n        object = object[toKey(path[index++])];\n      }\n      return (index && index == length) ? object : undefined;\n    }\n\n    /**\n     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n     * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n     * symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @param {Function} symbolsFunc The function to get the symbols of `object`.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n      var result = keysFunc(object);\n      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n    }\n\n    /**\n     * The base implementation of `getTag` without fallbacks for buggy environments.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n    function baseGetTag(value) {\n      if (value == null) {\n        return value === undefined ? undefinedTag : nullTag;\n      }\n      return (symToStringTag && symToStringTag in Object(value))\n        ? getRawTag(value)\n        : objectToString(value);\n    }\n\n    /**\n     * The base implementation of `_.gt` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n     *  else `false`.\n     */\n    function baseGt(value, other) {\n      return value > other;\n    }\n\n    /**\n     * The base implementation of `_.has` without support for deep paths.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */\n    function baseHas(object, key) {\n      return object != null && hasOwnProperty.call(object, key);\n    }\n\n    /**\n     * The base implementation of `_.hasIn` without support for deep paths.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */\n    function baseHasIn(object, key) {\n      return object != null && key in Object(object);\n    }\n\n    /**\n     * The base implementation of `_.inRange` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {number} number The number to check.\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     */\n    function baseInRange(number, start, end) {\n      return number >= nativeMin(start, end) && number < nativeMax(start, end);\n    }\n\n    /**\n     * The base implementation of methods like `_.intersection`, without support\n     * for iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of shared values.\n     */\n    function baseIntersection(arrays, iteratee, comparator) {\n      var includes = comparator ? arrayIncludesWith : arrayIncludes,\n          length = arrays[0].length,\n          othLength = arrays.length,\n          othIndex = othLength,\n          caches = Array(othLength),\n          maxLength = Infinity,\n          result = [];\n\n      while (othIndex--) {\n        var array = arrays[othIndex];\n        if (othIndex && iteratee) {\n          array = arrayMap(array, baseUnary(iteratee));\n        }\n        maxLength = nativeMin(array.length, maxLength);\n        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))\n          ? new SetCache(othIndex && array)\n          : undefined;\n      }\n      array = arrays[0];\n\n      var index = -1,\n          seen = caches[0];\n\n      outer:\n      while (++index < length && result.length < maxLength) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (!(seen\n              ? cacheHas(seen, computed)\n              : includes(result, computed, comparator)\n            )) {\n          othIndex = othLength;\n          while (--othIndex) {\n            var cache = caches[othIndex];\n            if (!(cache\n                  ? cacheHas(cache, computed)\n                  : includes(arrays[othIndex], computed, comparator))\n                ) {\n              continue outer;\n            }\n          }\n          if (seen) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.invert` and `_.invertBy` which inverts\n     * `object` with values transformed by `iteratee` and set by `setter`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} setter The function to set `accumulator` values.\n     * @param {Function} iteratee The iteratee to transform values.\n     * @param {Object} accumulator The initial inverted object.\n     * @returns {Function} Returns `accumulator`.\n     */\n    function baseInverter(object, setter, iteratee, accumulator) {\n      baseForOwn(object, function(value, key, object) {\n        setter(accumulator, iteratee(value), key, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `_.invoke` without support for individual\n     * method arguments.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {Array} args The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     */\n    function baseInvoke(object, path, args) {\n      path = castPath(path, object);\n      object = parent(object, path);\n      var func = object == null ? object : object[toKey(last(path))];\n      return func == null ? undefined : apply(func, object, args);\n    }\n\n    /**\n     * The base implementation of `_.isArguments`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     */\n    function baseIsArguments(value) {\n      return isObjectLike(value) && baseGetTag(value) == argsTag;\n    }\n\n    /**\n     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n     */\n    function baseIsArrayBuffer(value) {\n      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;\n    }\n\n    /**\n     * The base implementation of `_.isDate` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n     */\n    function baseIsDate(value) {\n      return isObjectLike(value) && baseGetTag(value) == dateTag;\n    }\n\n    /**\n     * The base implementation of `_.isEqual` which supports partial comparisons\n     * and tracks traversed objects.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {boolean} bitmask The bitmask flags.\n     *  1 - Unordered comparison\n     *  2 - Partial comparison\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     */\n    function baseIsEqual(value, other, bitmask, customizer, stack) {\n      if (value === other) {\n        return true;\n      }\n      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n        return value !== value && other !== other;\n      }\n      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n    }\n\n    /**\n     * A specialized version of `baseIsEqual` for arrays and objects which performs\n     * deep comparisons and tracks traversed objects enabling objects with circular\n     * references to be compared.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n      var objIsArr = isArray(object),\n          othIsArr = isArray(other),\n          objTag = objIsArr ? arrayTag : getTag(object),\n          othTag = othIsArr ? arrayTag : getTag(other);\n\n      objTag = objTag == argsTag ? objectTag : objTag;\n      othTag = othTag == argsTag ? objectTag : othTag;\n\n      var objIsObj = objTag == objectTag,\n          othIsObj = othTag == objectTag,\n          isSameTag = objTag == othTag;\n\n      if (isSameTag && isBuffer(object)) {\n        if (!isBuffer(other)) {\n          return false;\n        }\n        objIsArr = true;\n        objIsObj = false;\n      }\n      if (isSameTag && !objIsObj) {\n        stack || (stack = new Stack);\n        return (objIsArr || isTypedArray(object))\n          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n      }\n      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n        if (objIsWrapped || othIsWrapped) {\n          var objUnwrapped = objIsWrapped ? object.value() : object,\n              othUnwrapped = othIsWrapped ? other.value() : other;\n\n          stack || (stack = new Stack);\n          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n        }\n      }\n      if (!isSameTag) {\n        return false;\n      }\n      stack || (stack = new Stack);\n      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n    }\n\n    /**\n     * The base implementation of `_.isMap` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n     */\n    function baseIsMap(value) {\n      return isObjectLike(value) && getTag(value) == mapTag;\n    }\n\n    /**\n     * The base implementation of `_.isMatch` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Array} matchData The property names, values, and compare flags to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     */\n    function baseIsMatch(object, source, matchData, customizer) {\n      var index = matchData.length,\n          length = index,\n          noCustomizer = !customizer;\n\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (index--) {\n        var data = matchData[index];\n        if ((noCustomizer && data[2])\n              ? data[1] !== object[data[0]]\n              : !(data[0] in object)\n            ) {\n          return false;\n        }\n      }\n      while (++index < length) {\n        data = matchData[index];\n        var key = data[0],\n            objValue = object[key],\n            srcValue = data[1];\n\n        if (noCustomizer && data[2]) {\n          if (objValue === undefined && !(key in object)) {\n            return false;\n          }\n        } else {\n          var stack = new Stack;\n          if (customizer) {\n            var result = customizer(objValue, srcValue, key, object, source, stack);\n          }\n          if (!(result === undefined\n                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n                : result\n              )) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.isNative` without bad shim checks.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     */\n    function baseIsNative(value) {\n      if (!isObject(value) || isMasked(value)) {\n        return false;\n      }\n      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n      return pattern.test(toSource(value));\n    }\n\n    /**\n     * The base implementation of `_.isRegExp` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n     */\n    function baseIsRegExp(value) {\n      return isObjectLike(value) && baseGetTag(value) == regexpTag;\n    }\n\n    /**\n     * The base implementation of `_.isSet` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n     */\n    function baseIsSet(value) {\n      return isObjectLike(value) && getTag(value) == setTag;\n    }\n\n    /**\n     * The base implementation of `_.isTypedArray` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     */\n    function baseIsTypedArray(value) {\n      return isObjectLike(value) &&\n        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n    }\n\n    /**\n     * The base implementation of `_.iteratee`.\n     *\n     * @private\n     * @param {*} [value=_.identity] The value to convert to an iteratee.\n     * @returns {Function} Returns the iteratee.\n     */\n    function baseIteratee(value) {\n      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n      if (typeof value == 'function') {\n        return value;\n      }\n      if (value == null) {\n        return identity;\n      }\n      if (typeof value == 'object') {\n        return isArray(value)\n          ? baseMatchesProperty(value[0], value[1])\n          : baseMatches(value);\n      }\n      return property(value);\n    }\n\n    /**\n     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function baseKeys(object) {\n      if (!isPrototype(object)) {\n        return nativeKeys(object);\n      }\n      var result = [];\n      for (var key in Object(object)) {\n        if (hasOwnProperty.call(object, key) && key != 'constructor') {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function baseKeysIn(object) {\n      if (!isObject(object)) {\n        return nativeKeysIn(object);\n      }\n      var isProto = isPrototype(object),\n          result = [];\n\n      for (var key in object) {\n        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.lt` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\n     *  else `false`.\n     */\n    function baseLt(value, other) {\n      return value < other;\n    }\n\n    /**\n     * The base implementation of `_.map` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     */\n    function baseMap(collection, iteratee) {\n      var index = -1,\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value, key, collection) {\n        result[++index] = iteratee(value, key, collection);\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.matches` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseMatches(source) {\n      var matchData = getMatchData(source);\n      if (matchData.length == 1 && matchData[0][2]) {\n        return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n      }\n      return function(object) {\n        return object === source || baseIsMatch(object, source, matchData);\n      };\n    }\n\n    /**\n     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n     *\n     * @private\n     * @param {string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseMatchesProperty(path, srcValue) {\n      if (isKey(path) && isStrictComparable(srcValue)) {\n        return matchesStrictComparable(toKey(path), srcValue);\n      }\n      return function(object) {\n        var objValue = get(object, path);\n        return (objValue === undefined && objValue === srcValue)\n          ? hasIn(object, path)\n          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n      };\n    }\n\n    /**\n     * The base implementation of `_.merge` without support for multiple sources.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {number} srcIndex The index of `source`.\n     * @param {Function} [customizer] The function to customize merged values.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     */\n    function baseMerge(object, source, srcIndex, customizer, stack) {\n      if (object === source) {\n        return;\n      }\n      baseFor(source, function(srcValue, key) {\n        stack || (stack = new Stack);\n        if (isObject(srcValue)) {\n          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n        }\n        else {\n          var newValue = customizer\n            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)\n            : undefined;\n\n          if (newValue === undefined) {\n            newValue = srcValue;\n          }\n          assignMergeValue(object, key, newValue);\n        }\n      }, keysIn);\n    }\n\n    /**\n     * A specialized version of `baseMerge` for arrays and objects which performs\n     * deep merges and tracks traversed objects enabling objects with circular\n     * references to be merged.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {string} key The key of the value to merge.\n     * @param {number} srcIndex The index of `source`.\n     * @param {Function} mergeFunc The function to merge values.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     */\n    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n      var objValue = safeGet(object, key),\n          srcValue = safeGet(source, key),\n          stacked = stack.get(srcValue);\n\n      if (stacked) {\n        assignMergeValue(object, key, stacked);\n        return;\n      }\n      var newValue = customizer\n        ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n        : undefined;\n\n      var isCommon = newValue === undefined;\n\n      if (isCommon) {\n        var isArr = isArray(srcValue),\n            isBuff = !isArr && isBuffer(srcValue),\n            isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\n        newValue = srcValue;\n        if (isArr || isBuff || isTyped) {\n          if (isArray(objValue)) {\n            newValue = objValue;\n          }\n          else if (isArrayLikeObject(objValue)) {\n            newValue = copyArray(objValue);\n          }\n          else if (isBuff) {\n            isCommon = false;\n            newValue = cloneBuffer(srcValue, true);\n          }\n          else if (isTyped) {\n            isCommon = false;\n            newValue = cloneTypedArray(srcValue, true);\n          }\n          else {\n            newValue = [];\n          }\n        }\n        else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n          newValue = objValue;\n          if (isArguments(objValue)) {\n            newValue = toPlainObject(objValue);\n          }\n          else if (!isObject(objValue) || isFunction(objValue)) {\n            newValue = initCloneObject(srcValue);\n          }\n        }\n        else {\n          isCommon = false;\n        }\n      }\n      if (isCommon) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, newValue);\n        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n        stack['delete'](srcValue);\n      }\n      assignMergeValue(object, key, newValue);\n    }\n\n    /**\n     * The base implementation of `_.nth` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {number} n The index of the element to return.\n     * @returns {*} Returns the nth element of `array`.\n     */\n    function baseNth(array, n) {\n      var length = array.length;\n      if (!length) {\n        return;\n      }\n      n += n < 0 ? length : 0;\n      return isIndex(n, length) ? array[n] : undefined;\n    }\n\n    /**\n     * The base implementation of `_.orderBy` without param guards.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n     * @param {string[]} orders The sort orders of `iteratees`.\n     * @returns {Array} Returns the new sorted array.\n     */\n    function baseOrderBy(collection, iteratees, orders) {\n      if (iteratees.length) {\n        iteratees = arrayMap(iteratees, function(iteratee) {\n          if (isArray(iteratee)) {\n            return function(value) {\n              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);\n            }\n          }\n          return iteratee;\n        });\n      } else {\n        iteratees = [identity];\n      }\n\n      var index = -1;\n      iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\n\n      var result = baseMap(collection, function(value, key, collection) {\n        var criteria = arrayMap(iteratees, function(iteratee) {\n          return iteratee(value);\n        });\n        return { 'criteria': criteria, 'index': ++index, 'value': value };\n      });\n\n      return baseSortBy(result, function(object, other) {\n        return compareMultiple(object, other, orders);\n      });\n    }\n\n    /**\n     * The base implementation of `_.pick` without support for individual\n     * property identifiers.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} paths The property paths to pick.\n     * @returns {Object} Returns the new object.\n     */\n    function basePick(object, paths) {\n      return basePickBy(object, paths, function(value, path) {\n        return hasIn(object, path);\n      });\n    }\n\n    /**\n     * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} paths The property paths to pick.\n     * @param {Function} predicate The function invoked per property.\n     * @returns {Object} Returns the new object.\n     */\n    function basePickBy(object, paths, predicate) {\n      var index = -1,\n          length = paths.length,\n          result = {};\n\n      while (++index < length) {\n        var path = paths[index],\n            value = baseGet(object, path);\n\n        if (predicate(value, path)) {\n          baseSet(result, castPath(path, object), value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseProperty` which supports deep paths.\n     *\n     * @private\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     */\n    function basePropertyDeep(path) {\n      return function(object) {\n        return baseGet(object, path);\n      };\n    }\n\n    /**\n     * The base implementation of `_.pullAllBy` without support for iteratee\n     * shorthands.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAll(array, values, iteratee, comparator) {\n      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,\n          index = -1,\n          length = values.length,\n          seen = array;\n\n      if (array === values) {\n        values = copyArray(values);\n      }\n      if (iteratee) {\n        seen = arrayMap(array, baseUnary(iteratee));\n      }\n      while (++index < length) {\n        var fromIndex = 0,\n            value = values[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {\n          if (seen !== array) {\n            splice.call(seen, fromIndex, 1);\n          }\n          splice.call(array, fromIndex, 1);\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.pullAt` without support for individual\n     * indexes or capturing the removed elements.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {number[]} indexes The indexes of elements to remove.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAt(array, indexes) {\n      var length = array ? indexes.length : 0,\n          lastIndex = length - 1;\n\n      while (length--) {\n        var index = indexes[length];\n        if (length == lastIndex || index !== previous) {\n          var previous = index;\n          if (isIndex(index)) {\n            splice.call(array, index, 1);\n          } else {\n            baseUnset(array, index);\n          }\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.random` without support for returning\n     * floating-point numbers.\n     *\n     * @private\n     * @param {number} lower The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the random number.\n     */\n    function baseRandom(lower, upper) {\n      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));\n    }\n\n    /**\n     * The base implementation of `_.range` and `_.rangeRight` which doesn't\n     * coerce arguments.\n     *\n     * @private\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} step The value to increment or decrement by.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the range of numbers.\n     */\n    function baseRange(start, end, step, fromRight) {\n      var index = -1,\n          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n          result = Array(length);\n\n      while (length--) {\n        result[fromRight ? length : ++index] = start;\n        start += step;\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.repeat` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {string} string The string to repeat.\n     * @param {number} n The number of times to repeat the string.\n     * @returns {string} Returns the repeated string.\n     */\n    function baseRepeat(string, n) {\n      var result = '';\n      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {\n        return result;\n      }\n      // Leverage the exponentiation by squaring algorithm for a faster repeat.\n      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.\n      do {\n        if (n % 2) {\n          result += string;\n        }\n        n = nativeFloor(n / 2);\n        if (n) {\n          string += string;\n        }\n      } while (n);\n\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     */\n    function baseRest(func, start) {\n      return setToString(overRest(func, start, identity), func + '');\n    }\n\n    /**\n     * The base implementation of `_.sample`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to sample.\n     * @returns {*} Returns the random element.\n     */\n    function baseSample(collection) {\n      return arraySample(values(collection));\n    }\n\n    /**\n     * The base implementation of `_.sampleSize` without param guards.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to sample.\n     * @param {number} n The number of elements to sample.\n     * @returns {Array} Returns the random elements.\n     */\n    function baseSampleSize(collection, n) {\n      var array = values(collection);\n      return shuffleSelf(array, baseClamp(n, 0, array.length));\n    }\n\n    /**\n     * The base implementation of `_.set`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize path creation.\n     * @returns {Object} Returns `object`.\n     */\n    function baseSet(object, path, value, customizer) {\n      if (!isObject(object)) {\n        return object;\n      }\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length,\n          lastIndex = length - 1,\n          nested = object;\n\n      while (nested != null && ++index < length) {\n        var key = toKey(path[index]),\n            newValue = value;\n\n        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\n          return object;\n        }\n\n        if (index != lastIndex) {\n          var objValue = nested[key];\n          newValue = customizer ? customizer(objValue, key, nested) : undefined;\n          if (newValue === undefined) {\n            newValue = isObject(objValue)\n              ? objValue\n              : (isIndex(path[index + 1]) ? [] : {});\n          }\n        }\n        assignValue(nested, key, newValue);\n        nested = nested[key];\n      }\n      return object;\n    }\n\n    /**\n     * The base implementation of `setData` without support for hot loop shorting.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetData = !metaMap ? identity : function(func, data) {\n      metaMap.set(func, data);\n      return func;\n    };\n\n    /**\n     * The base implementation of `setToString` without support for hot loop shorting.\n     *\n     * @private\n     * @param {Function} func The function to modify.\n     * @param {Function} string The `toString` result.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetToString = !defineProperty ? identity : function(func, string) {\n      return defineProperty(func, 'toString', {\n        'configurable': true,\n        'enumerable': false,\n        'value': constant(string),\n        'writable': true\n      });\n    };\n\n    /**\n     * The base implementation of `_.shuffle`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     */\n    function baseShuffle(collection) {\n      return shuffleSelf(values(collection));\n    }\n\n    /**\n     * The base implementation of `_.slice` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseSlice(array, start, end) {\n      var index = -1,\n          length = array.length;\n\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = end > length ? length : end;\n      if (end < 0) {\n        end += length;\n      }\n      length = start > end ? 0 : ((end - start) >>> 0);\n      start >>>= 0;\n\n      var result = Array(length);\n      while (++index < length) {\n        result[index] = array[index + start];\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.some` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     */\n    function baseSome(collection, predicate) {\n      var result;\n\n      baseEach(collection, function(value, index, collection) {\n        result = predicate(value, index, collection);\n        return !result;\n      });\n      return !!result;\n    }\n\n    /**\n     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which\n     * performs a binary search of `array` to determine the index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function baseSortedIndex(array, value, retHighest) {\n      var low = 0,\n          high = array == null ? low : array.length;\n\n      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n        while (low < high) {\n          var mid = (low + high) >>> 1,\n              computed = array[mid];\n\n          if (computed !== null && !isSymbol(computed) &&\n              (retHighest ? (computed <= value) : (computed < value))) {\n            low = mid + 1;\n          } else {\n            high = mid;\n          }\n        }\n        return high;\n      }\n      return baseSortedIndexBy(array, value, identity, retHighest);\n    }\n\n    /**\n     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`\n     * which invokes `iteratee` for `value` and each element of `array` to compute\n     * their sort ranking. The iteratee is invoked with one argument; (value).\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} iteratee The iteratee invoked per element.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function baseSortedIndexBy(array, value, iteratee, retHighest) {\n      var low = 0,\n          high = array == null ? 0 : array.length;\n      if (high === 0) {\n        return 0;\n      }\n\n      value = iteratee(value);\n      var valIsNaN = value !== value,\n          valIsNull = value === null,\n          valIsSymbol = isSymbol(value),\n          valIsUndefined = value === undefined;\n\n      while (low < high) {\n        var mid = nativeFloor((low + high) / 2),\n            computed = iteratee(array[mid]),\n            othIsDefined = computed !== undefined,\n            othIsNull = computed === null,\n            othIsReflexive = computed === computed,\n            othIsSymbol = isSymbol(computed);\n\n        if (valIsNaN) {\n          var setLow = retHighest || othIsReflexive;\n        } else if (valIsUndefined) {\n          setLow = othIsReflexive && (retHighest || othIsDefined);\n        } else if (valIsNull) {\n          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);\n        } else if (valIsSymbol) {\n          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);\n        } else if (othIsNull || othIsSymbol) {\n          setLow = false;\n        } else {\n          setLow = retHighest ? (computed <= value) : (computed < value);\n        }\n        if (setLow) {\n          low = mid + 1;\n        } else {\n          high = mid;\n        }\n      }\n      return nativeMin(high, MAX_ARRAY_INDEX);\n    }\n\n    /**\n     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without\n     * support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */\n    function baseSortedUniq(array, iteratee) {\n      var index = -1,\n          length = array.length,\n          resIndex = 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        if (!index || !eq(computed, seen)) {\n          var seen = computed;\n          result[resIndex++] = value === 0 ? 0 : value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.toNumber` which doesn't ensure correct\n     * conversions of binary, hexadecimal, or octal string values.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     */\n    function baseToNumber(value) {\n      if (typeof value == 'number') {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      return +value;\n    }\n\n    /**\n     * The base implementation of `_.toString` which doesn't convert nullish\n     * values to empty strings.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {string} Returns the string.\n     */\n    function baseToString(value) {\n      // Exit early for strings to avoid a performance hit in some environments.\n      if (typeof value == 'string') {\n        return value;\n      }\n      if (isArray(value)) {\n        // Recursively convert values (susceptible to call stack limits).\n        return arrayMap(value, baseToString) + '';\n      }\n      if (isSymbol(value)) {\n        return symbolToString ? symbolToString.call(value) : '';\n      }\n      var result = (value + '');\n      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n    }\n\n    /**\n     * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */\n    function baseUniq(array, iteratee, comparator) {\n      var index = -1,\n          includes = arrayIncludes,\n          length = array.length,\n          isCommon = true,\n          result = [],\n          seen = result;\n\n      if (comparator) {\n        isCommon = false;\n        includes = arrayIncludesWith;\n      }\n      else if (length >= LARGE_ARRAY_SIZE) {\n        var set = iteratee ? null : createSet(array);\n        if (set) {\n          return setToArray(set);\n        }\n        isCommon = false;\n        includes = cacheHas;\n        seen = new SetCache;\n      }\n      else {\n        seen = iteratee ? [] : result;\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n          var seenIndex = seen.length;\n          while (seenIndex--) {\n            if (seen[seenIndex] === computed) {\n              continue outer;\n            }\n          }\n          if (iteratee) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n        else if (!includes(seen, computed, comparator)) {\n          if (seen !== result) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.unset`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The property path to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     */\n    function baseUnset(object, path) {\n      path = castPath(path, object);\n      object = parent(object, path);\n      return object == null || delete object[toKey(last(path))];\n    }\n\n    /**\n     * The base implementation of `_.update`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to update.\n     * @param {Function} updater The function to produce the updated value.\n     * @param {Function} [customizer] The function to customize path creation.\n     * @returns {Object} Returns `object`.\n     */\n    function baseUpdate(object, path, updater, customizer) {\n      return baseSet(object, path, updater(baseGet(object, path)), customizer);\n    }\n\n    /**\n     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`\n     * without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {Function} predicate The function invoked per iteration.\n     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseWhile(array, predicate, isDrop, fromRight) {\n      var length = array.length,\n          index = fromRight ? length : -1;\n\n      while ((fromRight ? index-- : ++index < length) &&\n        predicate(array[index], index, array)) {}\n\n      return isDrop\n        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))\n        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));\n    }\n\n    /**\n     * The base implementation of `wrapperValue` which returns the result of\n     * performing a sequence of actions on the unwrapped `value`, where each\n     * successive action is supplied the return value of the previous.\n     *\n     * @private\n     * @param {*} value The unwrapped value.\n     * @param {Array} actions Actions to perform to resolve the unwrapped value.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseWrapperValue(value, actions) {\n      var result = value;\n      if (result instanceof LazyWrapper) {\n        result = result.value();\n      }\n      return arrayReduce(actions, function(result, action) {\n        return action.func.apply(action.thisArg, arrayPush([result], action.args));\n      }, result);\n    }\n\n    /**\n     * The base implementation of methods like `_.xor`, without support for\n     * iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of values.\n     */\n    function baseXor(arrays, iteratee, comparator) {\n      var length = arrays.length;\n      if (length < 2) {\n        return length ? baseUniq(arrays[0]) : [];\n      }\n      var index = -1,\n          result = Array(length);\n\n      while (++index < length) {\n        var array = arrays[index],\n            othIndex = -1;\n\n        while (++othIndex < length) {\n          if (othIndex != index) {\n            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);\n          }\n        }\n      }\n      return baseUniq(baseFlatten(result, 1), iteratee, comparator);\n    }\n\n    /**\n     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.\n     *\n     * @private\n     * @param {Array} props The property identifiers.\n     * @param {Array} values The property values.\n     * @param {Function} assignFunc The function to assign values.\n     * @returns {Object} Returns the new object.\n     */\n    function baseZipObject(props, values, assignFunc) {\n      var index = -1,\n          length = props.length,\n          valsLength = values.length,\n          result = {};\n\n      while (++index < length) {\n        var value = index < valsLength ? values[index] : undefined;\n        assignFunc(result, props[index], value);\n      }\n      return result;\n    }\n\n    /**\n     * Casts `value` to an empty array if it's not an array like object.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Array|Object} Returns the cast array-like object.\n     */\n    function castArrayLikeObject(value) {\n      return isArrayLikeObject(value) ? value : [];\n    }\n\n    /**\n     * Casts `value` to `identity` if it's not a function.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Function} Returns cast function.\n     */\n    function castFunction(value) {\n      return typeof value == 'function' ? value : identity;\n    }\n\n    /**\n     * Casts `value` to a path array if it's not one.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {Array} Returns the cast property path array.\n     */\n    function castPath(value, object) {\n      if (isArray(value)) {\n        return value;\n      }\n      return isKey(value, object) ? [value] : stringToPath(toString(value));\n    }\n\n    /**\n     * A `baseRest` alias which can be replaced with `identity` by module\n     * replacement plugins.\n     *\n     * @private\n     * @type {Function}\n     * @param {Function} func The function to apply a rest parameter to.\n     * @returns {Function} Returns the new function.\n     */\n    var castRest = baseRest;\n\n    /**\n     * Casts `array` to a slice if it's needed.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {number} start The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the cast slice.\n     */\n    function castSlice(array, start, end) {\n      var length = array.length;\n      end = end === undefined ? length : end;\n      return (!start && end >= length) ? array : baseSlice(array, start, end);\n    }\n\n    /**\n     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).\n     *\n     * @private\n     * @param {number|Object} id The timer id or timeout object of the timer to clear.\n     */\n    var clearTimeout = ctxClearTimeout || function(id) {\n      return root.clearTimeout(id);\n    };\n\n    /**\n     * Creates a clone of  `buffer`.\n     *\n     * @private\n     * @param {Buffer} buffer The buffer to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Buffer} Returns the cloned buffer.\n     */\n    function cloneBuffer(buffer, isDeep) {\n      if (isDeep) {\n        return buffer.slice();\n      }\n      var length = buffer.length,\n          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n      buffer.copy(result);\n      return result;\n    }\n\n    /**\n     * Creates a clone of `arrayBuffer`.\n     *\n     * @private\n     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n     * @returns {ArrayBuffer} Returns the cloned array buffer.\n     */\n    function cloneArrayBuffer(arrayBuffer) {\n      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n      new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n      return result;\n    }\n\n    /**\n     * Creates a clone of `dataView`.\n     *\n     * @private\n     * @param {Object} dataView The data view to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned data view.\n     */\n    function cloneDataView(dataView, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n    }\n\n    /**\n     * Creates a clone of `regexp`.\n     *\n     * @private\n     * @param {Object} regexp The regexp to clone.\n     * @returns {Object} Returns the cloned regexp.\n     */\n    function cloneRegExp(regexp) {\n      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n      result.lastIndex = regexp.lastIndex;\n      return result;\n    }\n\n    /**\n     * Creates a clone of the `symbol` object.\n     *\n     * @private\n     * @param {Object} symbol The symbol object to clone.\n     * @returns {Object} Returns the cloned symbol object.\n     */\n    function cloneSymbol(symbol) {\n      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n    }\n\n    /**\n     * Creates a clone of `typedArray`.\n     *\n     * @private\n     * @param {Object} typedArray The typed array to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned typed array.\n     */\n    function cloneTypedArray(typedArray, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n    }\n\n    /**\n     * Compares values to sort them in ascending order.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {number} Returns the sort order indicator for `value`.\n     */\n    function compareAscending(value, other) {\n      if (value !== other) {\n        var valIsDefined = value !== undefined,\n            valIsNull = value === null,\n            valIsReflexive = value === value,\n            valIsSymbol = isSymbol(value);\n\n        var othIsDefined = other !== undefined,\n            othIsNull = other === null,\n            othIsReflexive = other === other,\n            othIsSymbol = isSymbol(other);\n\n        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n            (valIsNull && othIsDefined && othIsReflexive) ||\n            (!valIsDefined && othIsReflexive) ||\n            !valIsReflexive) {\n          return 1;\n        }\n        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n            (othIsNull && valIsDefined && valIsReflexive) ||\n            (!othIsDefined && valIsReflexive) ||\n            !othIsReflexive) {\n          return -1;\n        }\n      }\n      return 0;\n    }\n\n    /**\n     * Used by `_.orderBy` to compare multiple properties of a value to another\n     * and stable sort them.\n     *\n     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n     * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n     * of corresponding values.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {boolean[]|string[]} orders The order to sort by for each property.\n     * @returns {number} Returns the sort order indicator for `object`.\n     */\n    function compareMultiple(object, other, orders) {\n      var index = -1,\n          objCriteria = object.criteria,\n          othCriteria = other.criteria,\n          length = objCriteria.length,\n          ordersLength = orders.length;\n\n      while (++index < length) {\n        var result = compareAscending(objCriteria[index], othCriteria[index]);\n        if (result) {\n          if (index >= ordersLength) {\n            return result;\n          }\n          var order = orders[index];\n          return result * (order == 'desc' ? -1 : 1);\n        }\n      }\n      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n      // that causes it, under certain circumstances, to provide the same value for\n      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n      // for more details.\n      //\n      // This also ensures a stable sort in V8 and other engines.\n      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n      return object.index - other.index;\n    }\n\n    /**\n     * Creates an array that is the composition of partially applied arguments,\n     * placeholders, and provided arguments into a single array of arguments.\n     *\n     * @private\n     * @param {Array} args The provided arguments.\n     * @param {Array} partials The arguments to prepend to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @params {boolean} [isCurried] Specify composing for a curried function.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgs(args, partials, holders, isCurried) {\n      var argsIndex = -1,\n          argsLength = args.length,\n          holdersLength = holders.length,\n          leftIndex = -1,\n          leftLength = partials.length,\n          rangeLength = nativeMax(argsLength - holdersLength, 0),\n          result = Array(leftLength + rangeLength),\n          isUncurried = !isCurried;\n\n      while (++leftIndex < leftLength) {\n        result[leftIndex] = partials[leftIndex];\n      }\n      while (++argsIndex < holdersLength) {\n        if (isUncurried || argsIndex < argsLength) {\n          result[holders[argsIndex]] = args[argsIndex];\n        }\n      }\n      while (rangeLength--) {\n        result[leftIndex++] = args[argsIndex++];\n      }\n      return result;\n    }\n\n    /**\n     * This function is like `composeArgs` except that the arguments composition\n     * is tailored for `_.partialRight`.\n     *\n     * @private\n     * @param {Array} args The provided arguments.\n     * @param {Array} partials The arguments to append to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @params {boolean} [isCurried] Specify composing for a curried function.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgsRight(args, partials, holders, isCurried) {\n      var argsIndex = -1,\n          argsLength = args.length,\n          holdersIndex = -1,\n          holdersLength = holders.length,\n          rightIndex = -1,\n          rightLength = partials.length,\n          rangeLength = nativeMax(argsLength - holdersLength, 0),\n          result = Array(rangeLength + rightLength),\n          isUncurried = !isCurried;\n\n      while (++argsIndex < rangeLength) {\n        result[argsIndex] = args[argsIndex];\n      }\n      var offset = argsIndex;\n      while (++rightIndex < rightLength) {\n        result[offset + rightIndex] = partials[rightIndex];\n      }\n      while (++holdersIndex < holdersLength) {\n        if (isUncurried || argsIndex < argsLength) {\n          result[offset + holders[holdersIndex]] = args[argsIndex++];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Copies the values of `source` to `array`.\n     *\n     * @private\n     * @param {Array} source The array to copy values from.\n     * @param {Array} [array=[]] The array to copy values to.\n     * @returns {Array} Returns `array`.\n     */\n    function copyArray(source, array) {\n      var index = -1,\n          length = source.length;\n\n      array || (array = Array(length));\n      while (++index < length) {\n        array[index] = source[index];\n      }\n      return array;\n    }\n\n    /**\n     * Copies properties of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy properties from.\n     * @param {Array} props The property identifiers to copy.\n     * @param {Object} [object={}] The object to copy properties to.\n     * @param {Function} [customizer] The function to customize copied values.\n     * @returns {Object} Returns `object`.\n     */\n    function copyObject(source, props, object, customizer) {\n      var isNew = !object;\n      object || (object = {});\n\n      var index = -1,\n          length = props.length;\n\n      while (++index < length) {\n        var key = props[index];\n\n        var newValue = customizer\n          ? customizer(object[key], source[key], key, object, source)\n          : undefined;\n\n        if (newValue === undefined) {\n          newValue = source[key];\n        }\n        if (isNew) {\n          baseAssignValue(object, key, newValue);\n        } else {\n          assignValue(object, key, newValue);\n        }\n      }\n      return object;\n    }\n\n    /**\n     * Copies own symbols of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy symbols from.\n     * @param {Object} [object={}] The object to copy symbols to.\n     * @returns {Object} Returns `object`.\n     */\n    function copySymbols(source, object) {\n      return copyObject(source, getSymbols(source), object);\n    }\n\n    /**\n     * Copies own and inherited symbols of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy symbols from.\n     * @param {Object} [object={}] The object to copy symbols to.\n     * @returns {Object} Returns `object`.\n     */\n    function copySymbolsIn(source, object) {\n      return copyObject(source, getSymbolsIn(source), object);\n    }\n\n    /**\n     * Creates a function like `_.groupBy`.\n     *\n     * @private\n     * @param {Function} setter The function to set accumulator values.\n     * @param {Function} [initializer] The accumulator object initializer.\n     * @returns {Function} Returns the new aggregator function.\n     */\n    function createAggregator(setter, initializer) {\n      return function(collection, iteratee) {\n        var func = isArray(collection) ? arrayAggregator : baseAggregator,\n            accumulator = initializer ? initializer() : {};\n\n        return func(collection, setter, getIteratee(iteratee, 2), accumulator);\n      };\n    }\n\n    /**\n     * Creates a function like `_.assign`.\n     *\n     * @private\n     * @param {Function} assigner The function to assign values.\n     * @returns {Function} Returns the new assigner function.\n     */\n    function createAssigner(assigner) {\n      return baseRest(function(object, sources) {\n        var index = -1,\n            length = sources.length,\n            customizer = length > 1 ? sources[length - 1] : undefined,\n            guard = length > 2 ? sources[2] : undefined;\n\n        customizer = (assigner.length > 3 && typeof customizer == 'function')\n          ? (length--, customizer)\n          : undefined;\n\n        if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n          customizer = length < 3 ? undefined : customizer;\n          length = 1;\n        }\n        object = Object(object);\n        while (++index < length) {\n          var source = sources[index];\n          if (source) {\n            assigner(object, source, index, customizer);\n          }\n        }\n        return object;\n      });\n    }\n\n    /**\n     * Creates a `baseEach` or `baseEachRight` function.\n     *\n     * @private\n     * @param {Function} eachFunc The function to iterate over a collection.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseEach(eachFunc, fromRight) {\n      return function(collection, iteratee) {\n        if (collection == null) {\n          return collection;\n        }\n        if (!isArrayLike(collection)) {\n          return eachFunc(collection, iteratee);\n        }\n        var length = collection.length,\n            index = fromRight ? length : -1,\n            iterable = Object(collection);\n\n        while ((fromRight ? index-- : ++index < length)) {\n          if (iteratee(iterable[index], index, iterable) === false) {\n            break;\n          }\n        }\n        return collection;\n      };\n    }\n\n    /**\n     * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseFor(fromRight) {\n      return function(object, iteratee, keysFunc) {\n        var index = -1,\n            iterable = Object(object),\n            props = keysFunc(object),\n            length = props.length;\n\n        while (length--) {\n          var key = props[fromRight ? length : ++index];\n          if (iteratee(iterable[key], key, iterable) === false) {\n            break;\n          }\n        }\n        return object;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with the optional `this`\n     * binding of `thisArg`.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createBind(func, bitmask, thisArg) {\n      var isBind = bitmask & WRAP_BIND_FLAG,\n          Ctor = createCtor(func);\n\n      function wrapper() {\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return fn.apply(isBind ? thisArg : this, arguments);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a function like `_.lowerFirst`.\n     *\n     * @private\n     * @param {string} methodName The name of the `String` case method to use.\n     * @returns {Function} Returns the new case function.\n     */\n    function createCaseFirst(methodName) {\n      return function(string) {\n        string = toString(string);\n\n        var strSymbols = hasUnicode(string)\n          ? stringToArray(string)\n          : undefined;\n\n        var chr = strSymbols\n          ? strSymbols[0]\n          : string.charAt(0);\n\n        var trailing = strSymbols\n          ? castSlice(strSymbols, 1).join('')\n          : string.slice(1);\n\n        return chr[methodName]() + trailing;\n      };\n    }\n\n    /**\n     * Creates a function like `_.camelCase`.\n     *\n     * @private\n     * @param {Function} callback The function to combine each word.\n     * @returns {Function} Returns the new compounder function.\n     */\n    function createCompounder(callback) {\n      return function(string) {\n        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');\n      };\n    }\n\n    /**\n     * Creates a function that produces an instance of `Ctor` regardless of\n     * whether it was invoked as part of a `new` expression or by `call` or `apply`.\n     *\n     * @private\n     * @param {Function} Ctor The constructor to wrap.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCtor(Ctor) {\n      return function() {\n        // Use a `switch` statement to work with class constructors. See\n        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist\n        // for more details.\n        var args = arguments;\n        switch (args.length) {\n          case 0: return new Ctor;\n          case 1: return new Ctor(args[0]);\n          case 2: return new Ctor(args[0], args[1]);\n          case 3: return new Ctor(args[0], args[1], args[2]);\n          case 4: return new Ctor(args[0], args[1], args[2], args[3]);\n          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);\n          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);\n          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n        }\n        var thisBinding = baseCreate(Ctor.prototype),\n            result = Ctor.apply(thisBinding, args);\n\n        // Mimic the constructor's `return` behavior.\n        // See https://es5.github.io/#x13.2.2 for more details.\n        return isObject(result) ? result : thisBinding;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to enable currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {number} arity The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCurry(func, bitmask, arity) {\n      var Ctor = createCtor(func);\n\n      function wrapper() {\n        var length = arguments.length,\n            args = Array(length),\n            index = length,\n            placeholder = getHolder(wrapper);\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)\n          ? []\n          : replaceHolders(args, placeholder);\n\n        length -= holders.length;\n        if (length < arity) {\n          return createRecurry(\n            func, bitmask, createHybrid, wrapper.placeholder, undefined,\n            args, holders, undefined, undefined, arity - length);\n        }\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return apply(fn, this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.find` or `_.findLast` function.\n     *\n     * @private\n     * @param {Function} findIndexFunc The function to find the collection index.\n     * @returns {Function} Returns the new find function.\n     */\n    function createFind(findIndexFunc) {\n      return function(collection, predicate, fromIndex) {\n        var iterable = Object(collection);\n        if (!isArrayLike(collection)) {\n          var iteratee = getIteratee(predicate, 3);\n          collection = keys(collection);\n          predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n        }\n        var index = findIndexFunc(collection, predicate, fromIndex);\n        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n      };\n    }\n\n    /**\n     * Creates a `_.flow` or `_.flowRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new flow function.\n     */\n    function createFlow(fromRight) {\n      return flatRest(function(funcs) {\n        var length = funcs.length,\n            index = length,\n            prereq = LodashWrapper.prototype.thru;\n\n        if (fromRight) {\n          funcs.reverse();\n        }\n        while (index--) {\n          var func = funcs[index];\n          if (typeof func != 'function') {\n            throw new TypeError(FUNC_ERROR_TEXT);\n          }\n          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {\n            var wrapper = new LodashWrapper([], true);\n          }\n        }\n        index = wrapper ? index : length;\n        while (++index < length) {\n          func = funcs[index];\n\n          var funcName = getFuncName(func),\n              data = funcName == 'wrapper' ? getData(func) : undefined;\n\n          if (data && isLaziable(data[0]) &&\n                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&\n                !data[4].length && data[9] == 1\n              ) {\n            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);\n          } else {\n            wrapper = (func.length == 1 && isLaziable(func))\n              ? wrapper[funcName]()\n              : wrapper.thru(func);\n          }\n        }\n        return function() {\n          var args = arguments,\n              value = args[0];\n\n          if (wrapper && args.length == 1 && isArray(value)) {\n            return wrapper.plant(value).value();\n          }\n          var index = 0,\n              result = length ? funcs[index].apply(this, args) : value;\n\n          while (++index < length) {\n            result = funcs[index].call(this, result);\n          }\n          return result;\n        };\n      });\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with optional `this`\n     * binding of `thisArg`, partial application, and currying.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to\n     *  the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [partialsRight] The arguments to append to those provided\n     *  to the new function.\n     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {\n      var isAry = bitmask & WRAP_ARY_FLAG,\n          isBind = bitmask & WRAP_BIND_FLAG,\n          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,\n          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),\n          isFlip = bitmask & WRAP_FLIP_FLAG,\n          Ctor = isBindKey ? undefined : createCtor(func);\n\n      function wrapper() {\n        var length = arguments.length,\n            args = Array(length),\n            index = length;\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        if (isCurried) {\n          var placeholder = getHolder(wrapper),\n              holdersCount = countHolders(args, placeholder);\n        }\n        if (partials) {\n          args = composeArgs(args, partials, holders, isCurried);\n        }\n        if (partialsRight) {\n          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);\n        }\n        length -= holdersCount;\n        if (isCurried && length < arity) {\n          var newHolders = replaceHolders(args, placeholder);\n          return createRecurry(\n            func, bitmask, createHybrid, wrapper.placeholder, thisArg,\n            args, newHolders, argPos, ary, arity - length\n          );\n        }\n        var thisBinding = isBind ? thisArg : this,\n            fn = isBindKey ? thisBinding[func] : func;\n\n        length = args.length;\n        if (argPos) {\n          args = reorder(args, argPos);\n        } else if (isFlip && length > 1) {\n          args.reverse();\n        }\n        if (isAry && ary < length) {\n          args.length = ary;\n        }\n        if (this && this !== root && this instanceof wrapper) {\n          fn = Ctor || createCtor(fn);\n        }\n        return fn.apply(thisBinding, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a function like `_.invertBy`.\n     *\n     * @private\n     * @param {Function} setter The function to set accumulator values.\n     * @param {Function} toIteratee The function to resolve iteratees.\n     * @returns {Function} Returns the new inverter function.\n     */\n    function createInverter(setter, toIteratee) {\n      return function(object, iteratee) {\n        return baseInverter(object, setter, toIteratee(iteratee), {});\n      };\n    }\n\n    /**\n     * Creates a function that performs a mathematical operation on two values.\n     *\n     * @private\n     * @param {Function} operator The function to perform the operation.\n     * @param {number} [defaultValue] The value used for `undefined` arguments.\n     * @returns {Function} Returns the new mathematical operation function.\n     */\n    function createMathOperation(operator, defaultValue) {\n      return function(value, other) {\n        var result;\n        if (value === undefined && other === undefined) {\n          return defaultValue;\n        }\n        if (value !== undefined) {\n          result = value;\n        }\n        if (other !== undefined) {\n          if (result === undefined) {\n            return other;\n          }\n          if (typeof value == 'string' || typeof other == 'string') {\n            value = baseToString(value);\n            other = baseToString(other);\n          } else {\n            value = baseToNumber(value);\n            other = baseToNumber(other);\n          }\n          result = operator(value, other);\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function like `_.over`.\n     *\n     * @private\n     * @param {Function} arrayFunc The function to iterate over iteratees.\n     * @returns {Function} Returns the new over function.\n     */\n    function createOver(arrayFunc) {\n      return flatRest(function(iteratees) {\n        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\n        return baseRest(function(args) {\n          var thisArg = this;\n          return arrayFunc(iteratees, function(iteratee) {\n            return apply(iteratee, thisArg, args);\n          });\n        });\n      });\n    }\n\n    /**\n     * Creates the padding for `string` based on `length`. The `chars` string\n     * is truncated if the number of characters exceeds `length`.\n     *\n     * @private\n     * @param {number} length The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padding for `string`.\n     */\n    function createPadding(length, chars) {\n      chars = chars === undefined ? ' ' : baseToString(chars);\n\n      var charsLength = chars.length;\n      if (charsLength < 2) {\n        return charsLength ? baseRepeat(chars, length) : chars;\n      }\n      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));\n      return hasUnicode(chars)\n        ? castSlice(stringToArray(result), 0, length).join('')\n        : result.slice(0, length);\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with the `this` binding\n     * of `thisArg` and `partials` prepended to the arguments it receives.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {Array} partials The arguments to prepend to those provided to\n     *  the new function.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createPartial(func, bitmask, thisArg, partials) {\n      var isBind = bitmask & WRAP_BIND_FLAG,\n          Ctor = createCtor(func);\n\n      function wrapper() {\n        var argsIndex = -1,\n            argsLength = arguments.length,\n            leftIndex = -1,\n            leftLength = partials.length,\n            args = Array(leftLength + argsLength),\n            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n\n        while (++leftIndex < leftLength) {\n          args[leftIndex] = partials[leftIndex];\n        }\n        while (argsLength--) {\n          args[leftIndex++] = arguments[++argsIndex];\n        }\n        return apply(fn, isBind ? thisArg : this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.range` or `_.rangeRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new range function.\n     */\n    function createRange(fromRight) {\n      return function(start, end, step) {\n        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {\n          end = step = undefined;\n        }\n        // Ensure the sign of `-0` is preserved.\n        start = toFinite(start);\n        if (end === undefined) {\n          end = start;\n          start = 0;\n        } else {\n          end = toFinite(end);\n        }\n        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);\n        return baseRange(start, end, step, fromRight);\n      };\n    }\n\n    /**\n     * Creates a function that performs a relational operation on two values.\n     *\n     * @private\n     * @param {Function} operator The function to perform the operation.\n     * @returns {Function} Returns the new relational operation function.\n     */\n    function createRelationalOperation(operator) {\n      return function(value, other) {\n        if (!(typeof value == 'string' && typeof other == 'string')) {\n          value = toNumber(value);\n          other = toNumber(other);\n        }\n        return operator(value, other);\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to continue currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {Function} wrapFunc The function to create the `func` wrapper.\n     * @param {*} placeholder The placeholder value.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to\n     *  the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {\n      var isCurry = bitmask & WRAP_CURRY_FLAG,\n          newHolders = isCurry ? holders : undefined,\n          newHoldersRight = isCurry ? undefined : holders,\n          newPartials = isCurry ? partials : undefined,\n          newPartialsRight = isCurry ? undefined : partials;\n\n      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);\n      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);\n\n      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {\n        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);\n      }\n      var newData = [\n        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,\n        newHoldersRight, argPos, ary, arity\n      ];\n\n      var result = wrapFunc.apply(undefined, newData);\n      if (isLaziable(func)) {\n        setData(result, newData);\n      }\n      result.placeholder = placeholder;\n      return setWrapToString(result, func, bitmask);\n    }\n\n    /**\n     * Creates a function like `_.round`.\n     *\n     * @private\n     * @param {string} methodName The name of the `Math` method to use when rounding.\n     * @returns {Function} Returns the new round function.\n     */\n    function createRound(methodName) {\n      var func = Math[methodName];\n      return function(number, precision) {\n        number = toNumber(number);\n        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);\n        if (precision && nativeIsFinite(number)) {\n          // Shift with exponential notation to avoid floating-point issues.\n          // See [MDN](https://mdn.io/round#Examples) for more details.\n          var pair = (toString(number) + 'e').split('e'),\n              value = func(pair[0] + 'e' + (+pair[1] + precision));\n\n          pair = (toString(value) + 'e').split('e');\n          return +(pair[0] + 'e' + (+pair[1] - precision));\n        }\n        return func(number);\n      };\n    }\n\n    /**\n     * Creates a set object of `values`.\n     *\n     * @private\n     * @param {Array} values The values to add to the set.\n     * @returns {Object} Returns the new set.\n     */\n    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n      return new Set(values);\n    };\n\n    /**\n     * Creates a `_.toPairs` or `_.toPairsIn` function.\n     *\n     * @private\n     * @param {Function} keysFunc The function to get the keys of a given object.\n     * @returns {Function} Returns the new pairs function.\n     */\n    function createToPairs(keysFunc) {\n      return function(object) {\n        var tag = getTag(object);\n        if (tag == mapTag) {\n          return mapToArray(object);\n        }\n        if (tag == setTag) {\n          return setToPairs(object);\n        }\n        return baseToPairs(object, keysFunc(object));\n      };\n    }\n\n    /**\n     * Creates a function that either curries or invokes `func` with optional\n     * `this` binding and partially applied arguments.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask flags.\n     *    1 - `_.bind`\n     *    2 - `_.bindKey`\n     *    4 - `_.curry` or `_.curryRight` of a bound function\n     *    8 - `_.curry`\n     *   16 - `_.curryRight`\n     *   32 - `_.partial`\n     *   64 - `_.partialRight`\n     *  128 - `_.rearg`\n     *  256 - `_.ary`\n     *  512 - `_.flip`\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to be partially applied.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {\n      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;\n      if (!isBindKey && typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var length = partials ? partials.length : 0;\n      if (!length) {\n        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);\n        partials = holders = undefined;\n      }\n      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);\n      arity = arity === undefined ? arity : toInteger(arity);\n      length -= holders ? holders.length : 0;\n\n      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {\n        var partialsRight = partials,\n            holdersRight = holders;\n\n        partials = holders = undefined;\n      }\n      var data = isBindKey ? undefined : getData(func);\n\n      var newData = [\n        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,\n        argPos, ary, arity\n      ];\n\n      if (data) {\n        mergeData(newData, data);\n      }\n      func = newData[0];\n      bitmask = newData[1];\n      thisArg = newData[2];\n      partials = newData[3];\n      holders = newData[4];\n      arity = newData[9] = newData[9] === undefined\n        ? (isBindKey ? 0 : func.length)\n        : nativeMax(newData[9] - length, 0);\n\n      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {\n        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);\n      }\n      if (!bitmask || bitmask == WRAP_BIND_FLAG) {\n        var result = createBind(func, bitmask, thisArg);\n      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {\n        result = createCurry(func, bitmask, arity);\n      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {\n        result = createPartial(func, bitmask, thisArg, partials);\n      } else {\n        result = createHybrid.apply(undefined, newData);\n      }\n      var setter = data ? baseSetData : setData;\n      return setWrapToString(setter(result, newData), func, bitmask);\n    }\n\n    /**\n     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties\n     * of source objects to the destination object for all destination properties\n     * that resolve to `undefined`.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to assign.\n     * @param {Object} object The parent object of `objValue`.\n     * @returns {*} Returns the value to assign.\n     */\n    function customDefaultsAssignIn(objValue, srcValue, key, object) {\n      if (objValue === undefined ||\n          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n        return srcValue;\n      }\n      return objValue;\n    }\n\n    /**\n     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source\n     * objects into destination objects that are passed thru.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to merge.\n     * @param {Object} object The parent object of `objValue`.\n     * @param {Object} source The parent object of `srcValue`.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     * @returns {*} Returns the value to assign.\n     */\n    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {\n      if (isObject(objValue) && isObject(srcValue)) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, objValue);\n        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);\n        stack['delete'](srcValue);\n      }\n      return objValue;\n    }\n\n    /**\n     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain\n     * objects.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @param {string} key The key of the property to inspect.\n     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.\n     */\n    function customOmitClone(value) {\n      return isPlainObject(value) ? undefined : value;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for arrays with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Array} array The array to compare.\n     * @param {Array} other The other array to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `array` and `other` objects.\n     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n     */\n    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n          arrLength = array.length,\n          othLength = other.length;\n\n      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n        return false;\n      }\n      // Check that cyclic values are equal.\n      var arrStacked = stack.get(array);\n      var othStacked = stack.get(other);\n      if (arrStacked && othStacked) {\n        return arrStacked == other && othStacked == array;\n      }\n      var index = -1,\n          result = true,\n          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n      stack.set(array, other);\n      stack.set(other, array);\n\n      // Ignore non-index properties.\n      while (++index < arrLength) {\n        var arrValue = array[index],\n            othValue = other[index];\n\n        if (customizer) {\n          var compared = isPartial\n            ? customizer(othValue, arrValue, index, other, array, stack)\n            : customizer(arrValue, othValue, index, array, other, stack);\n        }\n        if (compared !== undefined) {\n          if (compared) {\n            continue;\n          }\n          result = false;\n          break;\n        }\n        // Recursively compare arrays (susceptible to call stack limits).\n        if (seen) {\n          if (!arraySome(other, function(othValue, othIndex) {\n                if (!cacheHas(seen, othIndex) &&\n                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n                  return seen.push(othIndex);\n                }\n              })) {\n            result = false;\n            break;\n          }\n        } else if (!(\n              arrValue === othValue ||\n                equalFunc(arrValue, othValue, bitmask, customizer, stack)\n            )) {\n          result = false;\n          break;\n        }\n      }\n      stack['delete'](array);\n      stack['delete'](other);\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for comparing objects of\n     * the same `toStringTag`.\n     *\n     * **Note:** This function only supports comparing values with tags of\n     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {string} tag The `toStringTag` of the objects to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n      switch (tag) {\n        case dataViewTag:\n          if ((object.byteLength != other.byteLength) ||\n              (object.byteOffset != other.byteOffset)) {\n            return false;\n          }\n          object = object.buffer;\n          other = other.buffer;\n\n        case arrayBufferTag:\n          if ((object.byteLength != other.byteLength) ||\n              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n            return false;\n          }\n          return true;\n\n        case boolTag:\n        case dateTag:\n        case numberTag:\n          // Coerce booleans to `1` or `0` and dates to milliseconds.\n          // Invalid dates are coerced to `NaN`.\n          return eq(+object, +other);\n\n        case errorTag:\n          return object.name == other.name && object.message == other.message;\n\n        case regexpTag:\n        case stringTag:\n          // Coerce regexes to strings and treat strings, primitives and objects,\n          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n          // for more details.\n          return object == (other + '');\n\n        case mapTag:\n          var convert = mapToArray;\n\n        case setTag:\n          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n          convert || (convert = setToArray);\n\n          if (object.size != other.size && !isPartial) {\n            return false;\n          }\n          // Assume cyclic values are equal.\n          var stacked = stack.get(object);\n          if (stacked) {\n            return stacked == other;\n          }\n          bitmask |= COMPARE_UNORDERED_FLAG;\n\n          // Recursively compare objects (susceptible to call stack limits).\n          stack.set(object, other);\n          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n          stack['delete'](object);\n          return result;\n\n        case symbolTag:\n          if (symbolValueOf) {\n            return symbolValueOf.call(object) == symbolValueOf.call(other);\n          }\n      }\n      return false;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for objects with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n          objProps = getAllKeys(object),\n          objLength = objProps.length,\n          othProps = getAllKeys(other),\n          othLength = othProps.length;\n\n      if (objLength != othLength && !isPartial) {\n        return false;\n      }\n      var index = objLength;\n      while (index--) {\n        var key = objProps[index];\n        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n          return false;\n        }\n      }\n      // Check that cyclic values are equal.\n      var objStacked = stack.get(object);\n      var othStacked = stack.get(other);\n      if (objStacked && othStacked) {\n        return objStacked == other && othStacked == object;\n      }\n      var result = true;\n      stack.set(object, other);\n      stack.set(other, object);\n\n      var skipCtor = isPartial;\n      while (++index < objLength) {\n        key = objProps[index];\n        var objValue = object[key],\n            othValue = other[key];\n\n        if (customizer) {\n          var compared = isPartial\n            ? customizer(othValue, objValue, key, other, object, stack)\n            : customizer(objValue, othValue, key, object, other, stack);\n        }\n        // Recursively compare objects (susceptible to call stack limits).\n        if (!(compared === undefined\n              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n              : compared\n            )) {\n          result = false;\n          break;\n        }\n        skipCtor || (skipCtor = key == 'constructor');\n      }\n      if (result && !skipCtor) {\n        var objCtor = object.constructor,\n            othCtor = other.constructor;\n\n        // Non `Object` object instances with different constructors are not equal.\n        if (objCtor != othCtor &&\n            ('constructor' in object && 'constructor' in other) &&\n            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n              typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n          result = false;\n        }\n      }\n      stack['delete'](object);\n      stack['delete'](other);\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseRest` which flattens the rest array.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @returns {Function} Returns the new function.\n     */\n    function flatRest(func) {\n      return setToString(overRest(func, undefined, flatten), func + '');\n    }\n\n    /**\n     * Creates an array of own enumerable property names and symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function getAllKeys(object) {\n      return baseGetAllKeys(object, keys, getSymbols);\n    }\n\n    /**\n     * Creates an array of own and inherited enumerable property names and\n     * symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function getAllKeysIn(object) {\n      return baseGetAllKeys(object, keysIn, getSymbolsIn);\n    }\n\n    /**\n     * Gets metadata for `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {*} Returns the metadata for `func`.\n     */\n    var getData = !metaMap ? noop : function(func) {\n      return metaMap.get(func);\n    };\n\n    /**\n     * Gets the name of `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {string} Returns the function name.\n     */\n    function getFuncName(func) {\n      var result = (func.name + ''),\n          array = realNames[result],\n          length = hasOwnProperty.call(realNames, result) ? array.length : 0;\n\n      while (length--) {\n        var data = array[length],\n            otherFunc = data.func;\n        if (otherFunc == null || otherFunc == func) {\n          return data.name;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Gets the argument placeholder value for `func`.\n     *\n     * @private\n     * @param {Function} func The function to inspect.\n     * @returns {*} Returns the placeholder value.\n     */\n    function getHolder(func) {\n      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;\n      return object.placeholder;\n    }\n\n    /**\n     * Gets the appropriate \"iteratee\" function. If `_.iteratee` is customized,\n     * this function returns the custom method, otherwise it returns `baseIteratee`.\n     * If arguments are provided, the chosen function is invoked with them and\n     * its result is returned.\n     *\n     * @private\n     * @param {*} [value] The value to convert to an iteratee.\n     * @param {number} [arity] The arity of the created iteratee.\n     * @returns {Function} Returns the chosen function or its result.\n     */\n    function getIteratee() {\n      var result = lodash.iteratee || iteratee;\n      result = result === iteratee ? baseIteratee : result;\n      return arguments.length ? result(arguments[0], arguments[1]) : result;\n    }\n\n    /**\n     * Gets the data for `map`.\n     *\n     * @private\n     * @param {Object} map The map to query.\n     * @param {string} key The reference key.\n     * @returns {*} Returns the map data.\n     */\n    function getMapData(map, key) {\n      var data = map.__data__;\n      return isKeyable(key)\n        ? data[typeof key == 'string' ? 'string' : 'hash']\n        : data.map;\n    }\n\n    /**\n     * Gets the property names, values, and compare flags of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the match data of `object`.\n     */\n    function getMatchData(object) {\n      var result = keys(object),\n          length = result.length;\n\n      while (length--) {\n        var key = result[length],\n            value = object[key];\n\n        result[length] = [key, value, isStrictComparable(value)];\n      }\n      return result;\n    }\n\n    /**\n     * Gets the native function at `key` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the method to get.\n     * @returns {*} Returns the function if it's native, else `undefined`.\n     */\n    function getNative(object, key) {\n      var value = getValue(object, key);\n      return baseIsNative(value) ? value : undefined;\n    }\n\n    /**\n     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the raw `toStringTag`.\n     */\n    function getRawTag(value) {\n      var isOwn = hasOwnProperty.call(value, symToStringTag),\n          tag = value[symToStringTag];\n\n      try {\n        value[symToStringTag] = undefined;\n        var unmasked = true;\n      } catch (e) {}\n\n      var result = nativeObjectToString.call(value);\n      if (unmasked) {\n        if (isOwn) {\n          value[symToStringTag] = tag;\n        } else {\n          delete value[symToStringTag];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array of the own enumerable symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */\n    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n      if (object == null) {\n        return [];\n      }\n      object = Object(object);\n      return arrayFilter(nativeGetSymbols(object), function(symbol) {\n        return propertyIsEnumerable.call(object, symbol);\n      });\n    };\n\n    /**\n     * Creates an array of the own and inherited enumerable symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */\n    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n      var result = [];\n      while (object) {\n        arrayPush(result, getSymbols(object));\n        object = getPrototype(object);\n      }\n      return result;\n    };\n\n    /**\n     * Gets the `toStringTag` of `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n    var getTag = baseGetTag;\n\n    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\n    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n        (Map && getTag(new Map) != mapTag) ||\n        (Promise && getTag(Promise.resolve()) != promiseTag) ||\n        (Set && getTag(new Set) != setTag) ||\n        (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n      getTag = function(value) {\n        var result = baseGetTag(value),\n            Ctor = result == objectTag ? value.constructor : undefined,\n            ctorString = Ctor ? toSource(Ctor) : '';\n\n        if (ctorString) {\n          switch (ctorString) {\n            case dataViewCtorString: return dataViewTag;\n            case mapCtorString: return mapTag;\n            case promiseCtorString: return promiseTag;\n            case setCtorString: return setTag;\n            case weakMapCtorString: return weakMapTag;\n          }\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Gets the view, applying any `transforms` to the `start` and `end` positions.\n     *\n     * @private\n     * @param {number} start The start of the view.\n     * @param {number} end The end of the view.\n     * @param {Array} transforms The transformations to apply to the view.\n     * @returns {Object} Returns an object containing the `start` and `end`\n     *  positions of the view.\n     */\n    function getView(start, end, transforms) {\n      var index = -1,\n          length = transforms.length;\n\n      while (++index < length) {\n        var data = transforms[index],\n            size = data.size;\n\n        switch (data.type) {\n          case 'drop':      start += size; break;\n          case 'dropRight': end -= size; break;\n          case 'take':      end = nativeMin(end, start + size); break;\n          case 'takeRight': start = nativeMax(start, end - size); break;\n        }\n      }\n      return { 'start': start, 'end': end };\n    }\n\n    /**\n     * Extracts wrapper details from the `source` body comment.\n     *\n     * @private\n     * @param {string} source The source to inspect.\n     * @returns {Array} Returns the wrapper details.\n     */\n    function getWrapDetails(source) {\n      var match = source.match(reWrapDetails);\n      return match ? match[1].split(reSplitDetails) : [];\n    }\n\n    /**\n     * Checks if `path` exists on `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @param {Function} hasFunc The function to check properties.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     */\n    function hasPath(object, path, hasFunc) {\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length,\n          result = false;\n\n      while (++index < length) {\n        var key = toKey(path[index]);\n        if (!(result = object != null && hasFunc(object, key))) {\n          break;\n        }\n        object = object[key];\n      }\n      if (result || ++index != length) {\n        return result;\n      }\n      length = object == null ? 0 : object.length;\n      return !!length && isLength(length) && isIndex(key, length) &&\n        (isArray(object) || isArguments(object));\n    }\n\n    /**\n     * Initializes an array clone.\n     *\n     * @private\n     * @param {Array} array The array to clone.\n     * @returns {Array} Returns the initialized clone.\n     */\n    function initCloneArray(array) {\n      var length = array.length,\n          result = new array.constructor(length);\n\n      // Add properties assigned by `RegExp#exec`.\n      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n        result.index = array.index;\n        result.input = array.input;\n      }\n      return result;\n    }\n\n    /**\n     * Initializes an object clone.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneObject(object) {\n      return (typeof object.constructor == 'function' && !isPrototype(object))\n        ? baseCreate(getPrototype(object))\n        : {};\n    }\n\n    /**\n     * Initializes an object clone based on its `toStringTag`.\n     *\n     * **Note:** This function only supports cloning values with tags of\n     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @param {string} tag The `toStringTag` of the object to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneByTag(object, tag, isDeep) {\n      var Ctor = object.constructor;\n      switch (tag) {\n        case arrayBufferTag:\n          return cloneArrayBuffer(object);\n\n        case boolTag:\n        case dateTag:\n          return new Ctor(+object);\n\n        case dataViewTag:\n          return cloneDataView(object, isDeep);\n\n        case float32Tag: case float64Tag:\n        case int8Tag: case int16Tag: case int32Tag:\n        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n          return cloneTypedArray(object, isDeep);\n\n        case mapTag:\n          return new Ctor;\n\n        case numberTag:\n        case stringTag:\n          return new Ctor(object);\n\n        case regexpTag:\n          return cloneRegExp(object);\n\n        case setTag:\n          return new Ctor;\n\n        case symbolTag:\n          return cloneSymbol(object);\n      }\n    }\n\n    /**\n     * Inserts wrapper `details` in a comment at the top of the `source` body.\n     *\n     * @private\n     * @param {string} source The source to modify.\n     * @returns {Array} details The details to insert.\n     * @returns {string} Returns the modified source.\n     */\n    function insertWrapDetails(source, details) {\n      var length = details.length;\n      if (!length) {\n        return source;\n      }\n      var lastIndex = length - 1;\n      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];\n      details = details.join(length > 2 ? ', ' : ' ');\n      return source.replace(reWrapComment, '{\\n/* [wrapped with ' + details + '] */\\n');\n    }\n\n    /**\n     * Checks if `value` is a flattenable `arguments` object or array.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n     */\n    function isFlattenable(value) {\n      return isArray(value) || isArguments(value) ||\n        !!(spreadableSymbol && value && value[spreadableSymbol]);\n    }\n\n    /**\n     * Checks if `value` is a valid array-like index.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n     */\n    function isIndex(value, length) {\n      var type = typeof value;\n      length = length == null ? MAX_SAFE_INTEGER : length;\n\n      return !!length &&\n        (type == 'number' ||\n          (type != 'symbol' && reIsUint.test(value))) &&\n            (value > -1 && value % 1 == 0 && value < length);\n    }\n\n    /**\n     * Checks if the given arguments are from an iteratee call.\n     *\n     * @private\n     * @param {*} value The potential iteratee value argument.\n     * @param {*} index The potential iteratee index or key argument.\n     * @param {*} object The potential iteratee object argument.\n     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n     *  else `false`.\n     */\n    function isIterateeCall(value, index, object) {\n      if (!isObject(object)) {\n        return false;\n      }\n      var type = typeof index;\n      if (type == 'number'\n            ? (isArrayLike(object) && isIndex(index, object.length))\n            : (type == 'string' && index in object)\n          ) {\n        return eq(object[index], value);\n      }\n      return false;\n    }\n\n    /**\n     * Checks if `value` is a property name and not a property path.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n     */\n    function isKey(value, object) {\n      if (isArray(value)) {\n        return false;\n      }\n      var type = typeof value;\n      if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n          value == null || isSymbol(value)) {\n        return true;\n      }\n      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n        (object != null && value in Object(object));\n    }\n\n    /**\n     * Checks if `value` is suitable for use as unique object key.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n     */\n    function isKeyable(value) {\n      var type = typeof value;\n      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n        ? (value !== '__proto__')\n        : (value === null);\n    }\n\n    /**\n     * Checks if `func` has a lazy counterpart.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,\n     *  else `false`.\n     */\n    function isLaziable(func) {\n      var funcName = getFuncName(func),\n          other = lodash[funcName];\n\n      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {\n        return false;\n      }\n      if (func === other) {\n        return true;\n      }\n      var data = getData(other);\n      return !!data && func === data[0];\n    }\n\n    /**\n     * Checks if `func` has its source masked.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n     */\n    function isMasked(func) {\n      return !!maskSrcKey && (maskSrcKey in func);\n    }\n\n    /**\n     * Checks if `func` is capable of being masked.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.\n     */\n    var isMaskable = coreJsData ? isFunction : stubFalse;\n\n    /**\n     * Checks if `value` is likely a prototype object.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n     */\n    function isPrototype(value) {\n      var Ctor = value && value.constructor,\n          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n      return value === proto;\n    }\n\n    /**\n     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` if suitable for strict\n     *  equality comparisons, else `false`.\n     */\n    function isStrictComparable(value) {\n      return value === value && !isObject(value);\n    }\n\n    /**\n     * A specialized version of `matchesProperty` for source values suitable\n     * for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {string} key The key of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function matchesStrictComparable(key, srcValue) {\n      return function(object) {\n        if (object == null) {\n          return false;\n        }\n        return object[key] === srcValue &&\n          (srcValue !== undefined || (key in Object(object)));\n      };\n    }\n\n    /**\n     * A specialized version of `_.memoize` which clears the memoized function's\n     * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n     *\n     * @private\n     * @param {Function} func The function to have its output memoized.\n     * @returns {Function} Returns the new memoized function.\n     */\n    function memoizeCapped(func) {\n      var result = memoize(func, function(key) {\n        if (cache.size === MAX_MEMOIZE_SIZE) {\n          cache.clear();\n        }\n        return key;\n      });\n\n      var cache = result.cache;\n      return result;\n    }\n\n    /**\n     * Merges the function metadata of `source` into `data`.\n     *\n     * Merging metadata reduces the number of wrappers used to invoke a function.\n     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`\n     * may be applied regardless of execution order. Methods like `_.ary` and\n     * `_.rearg` modify function arguments, making the order in which they are\n     * executed important, preventing the merging of metadata. However, we make\n     * an exception for a safe combined case where curried functions have `_.ary`\n     * and or `_.rearg` applied.\n     *\n     * @private\n     * @param {Array} data The destination metadata.\n     * @param {Array} source The source metadata.\n     * @returns {Array} Returns `data`.\n     */\n    function mergeData(data, source) {\n      var bitmask = data[1],\n          srcBitmask = source[1],\n          newBitmask = bitmask | srcBitmask,\n          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);\n\n      var isCombo =\n        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||\n        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||\n        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));\n\n      // Exit early if metadata can't be merged.\n      if (!(isCommon || isCombo)) {\n        return data;\n      }\n      // Use source `thisArg` if available.\n      if (srcBitmask & WRAP_BIND_FLAG) {\n        data[2] = source[2];\n        // Set when currying a bound function.\n        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;\n      }\n      // Compose partial arguments.\n      var value = source[3];\n      if (value) {\n        var partials = data[3];\n        data[3] = partials ? composeArgs(partials, value, source[4]) : value;\n        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];\n      }\n      // Compose partial right arguments.\n      value = source[5];\n      if (value) {\n        partials = data[5];\n        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;\n        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];\n      }\n      // Use source `argPos` if available.\n      value = source[7];\n      if (value) {\n        data[7] = value;\n      }\n      // Use source `ary` if it's smaller.\n      if (srcBitmask & WRAP_ARY_FLAG) {\n        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);\n      }\n      // Use source `arity` if one is not provided.\n      if (data[9] == null) {\n        data[9] = source[9];\n      }\n      // Use source `func` and merge bitmasks.\n      data[0] = source[0];\n      data[1] = newBitmask;\n\n      return data;\n    }\n\n    /**\n     * This function is like\n     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n     * except that it includes inherited enumerable properties.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function nativeKeysIn(object) {\n      var result = [];\n      if (object != null) {\n        for (var key in Object(object)) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to a string using `Object.prototype.toString`.\n     *\n     * @private\n     * @param {*} value The value to convert.\n     * @returns {string} Returns the converted string.\n     */\n    function objectToString(value) {\n      return nativeObjectToString.call(value);\n    }\n\n    /**\n     * A specialized version of `baseRest` which transforms the rest array.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @param {Function} transform The rest array transform.\n     * @returns {Function} Returns the new function.\n     */\n    function overRest(func, start, transform) {\n      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n      return function() {\n        var args = arguments,\n            index = -1,\n            length = nativeMax(args.length - start, 0),\n            array = Array(length);\n\n        while (++index < length) {\n          array[index] = args[start + index];\n        }\n        index = -1;\n        var otherArgs = Array(start + 1);\n        while (++index < start) {\n          otherArgs[index] = args[index];\n        }\n        otherArgs[start] = transform(array);\n        return apply(func, this, otherArgs);\n      };\n    }\n\n    /**\n     * Gets the parent value at `path` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array} path The path to get the parent value of.\n     * @returns {*} Returns the parent value.\n     */\n    function parent(object, path) {\n      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));\n    }\n\n    /**\n     * Reorder `array` according to the specified indexes where the element at\n     * the first index is assigned as the first element, the element at\n     * the second index is assigned as the second element, and so on.\n     *\n     * @private\n     * @param {Array} array The array to reorder.\n     * @param {Array} indexes The arranged array indexes.\n     * @returns {Array} Returns `array`.\n     */\n    function reorder(array, indexes) {\n      var arrLength = array.length,\n          length = nativeMin(indexes.length, arrLength),\n          oldArray = copyArray(array);\n\n      while (length--) {\n        var index = indexes[length];\n        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;\n      }\n      return array;\n    }\n\n    /**\n     * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the property to get.\n     * @returns {*} Returns the property value.\n     */\n    function safeGet(object, key) {\n      if (key === 'constructor' && typeof object[key] === 'function') {\n        return;\n      }\n\n      if (key == '__proto__') {\n        return;\n      }\n\n      return object[key];\n    }\n\n    /**\n     * Sets metadata for `func`.\n     *\n     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short\n     * period of time, it will trip its breaker and transition to an identity\n     * function to avoid garbage collection pauses in V8. See\n     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)\n     * for more details.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var setData = shortOut(baseSetData);\n\n    /**\n     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @returns {number|Object} Returns the timer id or timeout object.\n     */\n    var setTimeout = ctxSetTimeout || function(func, wait) {\n      return root.setTimeout(func, wait);\n    };\n\n    /**\n     * Sets the `toString` method of `func` to return `string`.\n     *\n     * @private\n     * @param {Function} func The function to modify.\n     * @param {Function} string The `toString` result.\n     * @returns {Function} Returns `func`.\n     */\n    var setToString = shortOut(baseSetToString);\n\n    /**\n     * Sets the `toString` method of `wrapper` to mimic the source of `reference`\n     * with wrapper details in a comment at the top of the source body.\n     *\n     * @private\n     * @param {Function} wrapper The function to modify.\n     * @param {Function} reference The reference function.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @returns {Function} Returns `wrapper`.\n     */\n    function setWrapToString(wrapper, reference, bitmask) {\n      var source = (reference + '');\n      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));\n    }\n\n    /**\n     * Creates a function that'll short out and invoke `identity` instead\n     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n     * milliseconds.\n     *\n     * @private\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new shortable function.\n     */\n    function shortOut(func) {\n      var count = 0,\n          lastCalled = 0;\n\n      return function() {\n        var stamp = nativeNow(),\n            remaining = HOT_SPAN - (stamp - lastCalled);\n\n        lastCalled = stamp;\n        if (remaining > 0) {\n          if (++count >= HOT_COUNT) {\n            return arguments[0];\n          }\n        } else {\n          count = 0;\n        }\n        return func.apply(undefined, arguments);\n      };\n    }\n\n    /**\n     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.\n     *\n     * @private\n     * @param {Array} array The array to shuffle.\n     * @param {number} [size=array.length] The size of `array`.\n     * @returns {Array} Returns `array`.\n     */\n    function shuffleSelf(array, size) {\n      var index = -1,\n          length = array.length,\n          lastIndex = length - 1;\n\n      size = size === undefined ? length : size;\n      while (++index < size) {\n        var rand = baseRandom(index, lastIndex),\n            value = array[rand];\n\n        array[rand] = array[index];\n        array[index] = value;\n      }\n      array.length = size;\n      return array;\n    }\n\n    /**\n     * Converts `string` to a property path array.\n     *\n     * @private\n     * @param {string} string The string to convert.\n     * @returns {Array} Returns the property path array.\n     */\n    var stringToPath = memoizeCapped(function(string) {\n      var result = [];\n      if (string.charCodeAt(0) === 46 /* . */) {\n        result.push('');\n      }\n      string.replace(rePropName, function(match, number, quote, subString) {\n        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n      });\n      return result;\n    });\n\n    /**\n     * Converts `value` to a string key if it's not a string or symbol.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {string|symbol} Returns the key.\n     */\n    function toKey(value) {\n      if (typeof value == 'string' || isSymbol(value)) {\n        return value;\n      }\n      var result = (value + '');\n      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n    }\n\n    /**\n     * Converts `func` to its source code.\n     *\n     * @private\n     * @param {Function} func The function to convert.\n     * @returns {string} Returns the source code.\n     */\n    function toSource(func) {\n      if (func != null) {\n        try {\n          return funcToString.call(func);\n        } catch (e) {}\n        try {\n          return (func + '');\n        } catch (e) {}\n      }\n      return '';\n    }\n\n    /**\n     * Updates wrapper `details` based on `bitmask` flags.\n     *\n     * @private\n     * @returns {Array} details The details to modify.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @returns {Array} Returns `details`.\n     */\n    function updateWrapDetails(details, bitmask) {\n      arrayEach(wrapFlags, function(pair) {\n        var value = '_.' + pair[0];\n        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {\n          details.push(value);\n        }\n      });\n      return details.sort();\n    }\n\n    /**\n     * Creates a clone of `wrapper`.\n     *\n     * @private\n     * @param {Object} wrapper The wrapper to clone.\n     * @returns {Object} Returns the cloned wrapper.\n     */\n    function wrapperClone(wrapper) {\n      if (wrapper instanceof LazyWrapper) {\n        return wrapper.clone();\n      }\n      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);\n      result.__actions__ = copyArray(wrapper.__actions__);\n      result.__index__  = wrapper.__index__;\n      result.__values__ = wrapper.__values__;\n      return result;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of elements split into groups the length of `size`.\n     * If `array` can't be split evenly, the final chunk will be the remaining\n     * elements.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to process.\n     * @param {number} [size=1] The length of each chunk\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the new array of chunks.\n     * @example\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 2);\n     * // => [['a', 'b'], ['c', 'd']]\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 3);\n     * // => [['a', 'b', 'c'], ['d']]\n     */\n    function chunk(array, size, guard) {\n      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {\n        size = 1;\n      } else {\n        size = nativeMax(toInteger(size), 0);\n      }\n      var length = array == null ? 0 : array.length;\n      if (!length || size < 1) {\n        return [];\n      }\n      var index = 0,\n          resIndex = 0,\n          result = Array(nativeCeil(length / size));\n\n      while (index < length) {\n        result[resIndex++] = baseSlice(array, index, (index += size));\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array with all falsey values removed. The values `false`, `null`,\n     * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to compact.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.compact([0, 1, false, 2, '', 3]);\n     * // => [1, 2, 3]\n     */\n    function compact(array) {\n      var index = -1,\n          length = array == null ? 0 : array.length,\n          resIndex = 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n        if (value) {\n          result[resIndex++] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates a new array concatenating `array` with any additional arrays\n     * and/or values.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to concatenate.\n     * @param {...*} [values] The values to concatenate.\n     * @returns {Array} Returns the new concatenated array.\n     * @example\n     *\n     * var array = [1];\n     * var other = _.concat(array, 2, [3], [[4]]);\n     *\n     * console.log(other);\n     * // => [1, 2, 3, [4]]\n     *\n     * console.log(array);\n     * // => [1]\n     */\n    function concat() {\n      var length = arguments.length;\n      if (!length) {\n        return [];\n      }\n      var args = Array(length - 1),\n          array = arguments[0],\n          index = length;\n\n      while (index--) {\n        args[index - 1] = arguments[index];\n      }\n      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));\n    }\n\n    /**\n     * Creates an array of `array` values not included in the other given arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. The order and references of result values are\n     * determined by the first array.\n     *\n     * **Note:** Unlike `_.pullAll`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.without, _.xor\n     * @example\n     *\n     * _.difference([2, 1], [2, 3]);\n     * // => [1]\n     */\n    var difference = baseRest(function(array, values) {\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))\n        : [];\n    });\n\n    /**\n     * This method is like `_.difference` except that it accepts `iteratee` which\n     * is invoked for each element of `array` and `values` to generate the criterion\n     * by which they're compared. The order and references of result values are\n     * determined by the first array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */\n    var differenceBy = baseRest(function(array, values) {\n      var iteratee = last(values);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))\n        : [];\n    });\n\n    /**\n     * This method is like `_.difference` except that it accepts `comparator`\n     * which is invoked to compare elements of `array` to `values`. The order and\n     * references of result values are determined by the first array. The comparator\n     * is invoked with two arguments: (arrVal, othVal).\n     *\n     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     *\n     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }]\n     */\n    var differenceWith = baseRest(function(array, values) {\n      var comparator = last(values);\n      if (isArrayLikeObject(comparator)) {\n        comparator = undefined;\n      }\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)\n        : [];\n    });\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.drop([1, 2, 3]);\n     * // => [2, 3]\n     *\n     * _.drop([1, 2, 3], 2);\n     * // => [3]\n     *\n     * _.drop([1, 2, 3], 5);\n     * // => []\n     *\n     * _.drop([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function drop(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the end.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.dropRight([1, 2, 3]);\n     * // => [1, 2]\n     *\n     * _.dropRight([1, 2, 3], 2);\n     * // => [1]\n     *\n     * _.dropRight([1, 2, 3], 5);\n     * // => []\n     *\n     * _.dropRight([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function dropRight(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the end.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.dropRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.dropRightWhile(users, ['active', false]);\n     * // => objects for ['barney']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.dropRightWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */\n    function dropRightWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), true, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the beginning.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.dropWhile(users, function(o) { return !o.active; });\n     * // => objects for ['pebbles']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.dropWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.dropWhile(users, ['active', false]);\n     * // => objects for ['pebbles']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.dropWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */\n    function dropWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), true)\n        : [];\n    }\n\n    /**\n     * Fills elements of `array` with `value` from `start` up to, but not\n     * including, `end`.\n     *\n     * **Note:** This method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Array\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.fill(array, 'a');\n     * console.log(array);\n     * // => ['a', 'a', 'a']\n     *\n     * _.fill(Array(3), 2);\n     * // => [2, 2, 2]\n     *\n     * _.fill([4, 6, 8, 10], '*', 1, 3);\n     * // => [4, '*', '*', 10]\n     */\n    function fill(array, value, start, end) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {\n        start = 0;\n        end = length;\n      }\n      return baseFill(array, value, start, end);\n    }\n\n    /**\n     * This method is like `_.find` except that it returns the index of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.findIndex(users, function(o) { return o.user == 'barney'; });\n     * // => 0\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findIndex(users, { 'user': 'fred', 'active': false });\n     * // => 1\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findIndex(users, ['active', false]);\n     * // => 0\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findIndex(users, 'active');\n     * // => 2\n     */\n    function findIndex(array, predicate, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax(length + index, 0);\n      }\n      return baseFindIndex(array, getIteratee(predicate, 3), index);\n    }\n\n    /**\n     * This method is like `_.findIndex` except that it iterates over elements\n     * of `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });\n     * // => 2\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findLastIndex(users, { 'user': 'barney', 'active': true });\n     * // => 0\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findLastIndex(users, ['active', false]);\n     * // => 2\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findLastIndex(users, 'active');\n     * // => 0\n     */\n    function findLastIndex(array, predicate, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = length - 1;\n      if (fromIndex !== undefined) {\n        index = toInteger(fromIndex);\n        index = fromIndex < 0\n          ? nativeMax(length + index, 0)\n          : nativeMin(index, length - 1);\n      }\n      return baseFindIndex(array, getIteratee(predicate, 3), index, true);\n    }\n\n    /**\n     * Flattens `array` a single level deep.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flatten([1, [2, [3, [4]], 5]]);\n     * // => [1, 2, [3, [4]], 5]\n     */\n    function flatten(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseFlatten(array, 1) : [];\n    }\n\n    /**\n     * Recursively flattens `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flattenDeep([1, [2, [3, [4]], 5]]);\n     * // => [1, 2, 3, 4, 5]\n     */\n    function flattenDeep(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseFlatten(array, INFINITY) : [];\n    }\n\n    /**\n     * Recursively flatten `array` up to `depth` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.4.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @param {number} [depth=1] The maximum recursion depth.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * var array = [1, [2, [3, [4]], 5]];\n     *\n     * _.flattenDepth(array, 1);\n     * // => [1, 2, [3, [4]], 5]\n     *\n     * _.flattenDepth(array, 2);\n     * // => [1, 2, 3, [4], 5]\n     */\n    function flattenDepth(array, depth) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      depth = depth === undefined ? 1 : toInteger(depth);\n      return baseFlatten(array, depth);\n    }\n\n    /**\n     * The inverse of `_.toPairs`; this method returns an object composed\n     * from key-value `pairs`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} pairs The key-value pairs.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.fromPairs([['a', 1], ['b', 2]]);\n     * // => { 'a': 1, 'b': 2 }\n     */\n    function fromPairs(pairs) {\n      var index = -1,\n          length = pairs == null ? 0 : pairs.length,\n          result = {};\n\n      while (++index < length) {\n        var pair = pairs[index];\n        result[pair[0]] = pair[1];\n      }\n      return result;\n    }\n\n    /**\n     * Gets the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @alias first\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the first element of `array`.\n     * @example\n     *\n     * _.head([1, 2, 3]);\n     * // => 1\n     *\n     * _.head([]);\n     * // => undefined\n     */\n    function head(array) {\n      return (array && array.length) ? array[0] : undefined;\n    }\n\n    /**\n     * Gets the index at which the first occurrence of `value` is found in `array`\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. If `fromIndex` is negative, it's used as the\n     * offset from the end of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.indexOf([1, 2, 1, 2], 2);\n     * // => 1\n     *\n     * // Search from the `fromIndex`.\n     * _.indexOf([1, 2, 1, 2], 2, 2);\n     * // => 3\n     */\n    function indexOf(array, value, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax(length + index, 0);\n      }\n      return baseIndexOf(array, value, index);\n    }\n\n    /**\n     * Gets all but the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.initial([1, 2, 3]);\n     * // => [1, 2]\n     */\n    function initial(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseSlice(array, 0, -1) : [];\n    }\n\n    /**\n     * Creates an array of unique values that are included in all given arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. The order and references of result values are\n     * determined by the first array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * _.intersection([2, 1], [2, 3]);\n     * // => [2]\n     */\n    var intersection = baseRest(function(arrays) {\n      var mapped = arrayMap(arrays, castArrayLikeObject);\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped)\n        : [];\n    });\n\n    /**\n     * This method is like `_.intersection` except that it accepts `iteratee`\n     * which is invoked for each element of each `arrays` to generate the criterion\n     * by which they're compared. The order and references of result values are\n     * determined by the first array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [2.1]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }]\n     */\n    var intersectionBy = baseRest(function(arrays) {\n      var iteratee = last(arrays),\n          mapped = arrayMap(arrays, castArrayLikeObject);\n\n      if (iteratee === last(mapped)) {\n        iteratee = undefined;\n      } else {\n        mapped.pop();\n      }\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped, getIteratee(iteratee, 2))\n        : [];\n    });\n\n    /**\n     * This method is like `_.intersection` except that it accepts `comparator`\n     * which is invoked to compare elements of `arrays`. The order and references\n     * of result values are determined by the first array. The comparator is\n     * invoked with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.intersectionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }]\n     */\n    var intersectionWith = baseRest(function(arrays) {\n      var comparator = last(arrays),\n          mapped = arrayMap(arrays, castArrayLikeObject);\n\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      if (comparator) {\n        mapped.pop();\n      }\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped, undefined, comparator)\n        : [];\n    });\n\n    /**\n     * Converts all elements in `array` into a string separated by `separator`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to convert.\n     * @param {string} [separator=','] The element separator.\n     * @returns {string} Returns the joined string.\n     * @example\n     *\n     * _.join(['a', 'b', 'c'], '~');\n     * // => 'a~b~c'\n     */\n    function join(array, separator) {\n      return array == null ? '' : nativeJoin.call(array, separator);\n    }\n\n    /**\n     * Gets the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the last element of `array`.\n     * @example\n     *\n     * _.last([1, 2, 3]);\n     * // => 3\n     */\n    function last(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? array[length - 1] : undefined;\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it iterates over elements of\n     * `array` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.lastIndexOf([1, 2, 1, 2], 2);\n     * // => 3\n     *\n     * // Search from the `fromIndex`.\n     * _.lastIndexOf([1, 2, 1, 2], 2, 2);\n     * // => 1\n     */\n    function lastIndexOf(array, value, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = length;\n      if (fromIndex !== undefined) {\n        index = toInteger(fromIndex);\n        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);\n      }\n      return value === value\n        ? strictLastIndexOf(array, value, index)\n        : baseFindIndex(array, baseIsNaN, index, true);\n    }\n\n    /**\n     * Gets the element at index `n` of `array`. If `n` is negative, the nth\n     * element from the end is returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.11.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=0] The index of the element to return.\n     * @returns {*} Returns the nth element of `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'd'];\n     *\n     * _.nth(array, 1);\n     * // => 'b'\n     *\n     * _.nth(array, -2);\n     * // => 'c';\n     */\n    function nth(array, n) {\n      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;\n    }\n\n    /**\n     * Removes all given values from `array` using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`\n     * to remove elements from an array by predicate.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...*} [values] The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n     *\n     * _.pull(array, 'a', 'c');\n     * console.log(array);\n     * // => ['b', 'b']\n     */\n    var pull = baseRest(pullAll);\n\n    /**\n     * This method is like `_.pull` except that it accepts an array of values to remove.\n     *\n     * **Note:** Unlike `_.difference`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n     *\n     * _.pullAll(array, ['a', 'c']);\n     * console.log(array);\n     * // => ['b', 'b']\n     */\n    function pullAll(array, values) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values)\n        : array;\n    }\n\n    /**\n     * This method is like `_.pullAll` except that it accepts `iteratee` which is\n     * invoked for each element of `array` and `values` to generate the criterion\n     * by which they're compared. The iteratee is invoked with one argument: (value).\n     *\n     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];\n     *\n     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');\n     * console.log(array);\n     * // => [{ 'x': 2 }]\n     */\n    function pullAllBy(array, values, iteratee) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values, getIteratee(iteratee, 2))\n        : array;\n    }\n\n    /**\n     * This method is like `_.pullAll` except that it accepts `comparator` which\n     * is invoked to compare elements of `array` to `values`. The comparator is\n     * invoked with two arguments: (arrVal, othVal).\n     *\n     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];\n     *\n     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);\n     * console.log(array);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]\n     */\n    function pullAllWith(array, values, comparator) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values, undefined, comparator)\n        : array;\n    }\n\n    /**\n     * Removes elements from `array` corresponding to `indexes` and returns an\n     * array of removed elements.\n     *\n     * **Note:** Unlike `_.at`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...(number|number[])} [indexes] The indexes of elements to remove.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'd'];\n     * var pulled = _.pullAt(array, [1, 3]);\n     *\n     * console.log(array);\n     * // => ['a', 'c']\n     *\n     * console.log(pulled);\n     * // => ['b', 'd']\n     */\n    var pullAt = flatRest(function(array, indexes) {\n      var length = array == null ? 0 : array.length,\n          result = baseAt(array, indexes);\n\n      basePullAt(array, arrayMap(indexes, function(index) {\n        return isIndex(index, length) ? +index : index;\n      }).sort(compareAscending));\n\n      return result;\n    });\n\n    /**\n     * Removes all elements from `array` that `predicate` returns truthy for\n     * and returns an array of the removed elements. The predicate is invoked\n     * with three arguments: (value, index, array).\n     *\n     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`\n     * to pull elements from an array by value.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = [1, 2, 3, 4];\n     * var evens = _.remove(array, function(n) {\n     *   return n % 2 == 0;\n     * });\n     *\n     * console.log(array);\n     * // => [1, 3]\n     *\n     * console.log(evens);\n     * // => [2, 4]\n     */\n    function remove(array, predicate) {\n      var result = [];\n      if (!(array && array.length)) {\n        return result;\n      }\n      var index = -1,\n          indexes = [],\n          length = array.length;\n\n      predicate = getIteratee(predicate, 3);\n      while (++index < length) {\n        var value = array[index];\n        if (predicate(value, index, array)) {\n          result.push(value);\n          indexes.push(index);\n        }\n      }\n      basePullAt(array, indexes);\n      return result;\n    }\n\n    /**\n     * Reverses `array` so that the first element becomes the last, the second\n     * element becomes the second to last, and so on.\n     *\n     * **Note:** This method mutates `array` and is based on\n     * [`Array#reverse`](https://mdn.io/Array/reverse).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.reverse(array);\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function reverse(array) {\n      return array == null ? array : nativeReverse.call(array);\n    }\n\n    /**\n     * Creates a slice of `array` from `start` up to, but not including, `end`.\n     *\n     * **Note:** This method is used instead of\n     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are\n     * returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function slice(array, start, end) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {\n        start = 0;\n        end = length;\n      }\n      else {\n        start = start == null ? 0 : toInteger(start);\n        end = end === undefined ? length : toInteger(end);\n      }\n      return baseSlice(array, start, end);\n    }\n\n    /**\n     * Uses a binary search to determine the lowest index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedIndex([30, 50], 40);\n     * // => 1\n     */\n    function sortedIndex(array, value) {\n      return baseSortedIndex(array, value);\n    }\n\n    /**\n     * This method is like `_.sortedIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n     *\n     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n     * // => 0\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');\n     * // => 0\n     */\n    function sortedIndexBy(array, value, iteratee) {\n      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);\n     * // => 1\n     */\n    function sortedIndexOf(array, value) {\n      var length = array == null ? 0 : array.length;\n      if (length) {\n        var index = baseSortedIndex(array, value);\n        if (index < length && eq(array[index], value)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.sortedIndex` except that it returns the highest\n     * index at which `value` should be inserted into `array` in order to\n     * maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);\n     * // => 4\n     */\n    function sortedLastIndex(array, value) {\n      return baseSortedIndex(array, value, true);\n    }\n\n    /**\n     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n     *\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n     * // => 1\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');\n     * // => 1\n     */\n    function sortedLastIndexBy(array, value, iteratee) {\n      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);\n    }\n\n    /**\n     * This method is like `_.lastIndexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);\n     * // => 3\n     */\n    function sortedLastIndexOf(array, value) {\n      var length = array == null ? 0 : array.length;\n      if (length) {\n        var index = baseSortedIndex(array, value, true) - 1;\n        if (eq(array[index], value)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.uniq` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniq([1, 1, 2]);\n     * // => [1, 2]\n     */\n    function sortedUniq(array) {\n      return (array && array.length)\n        ? baseSortedUniq(array)\n        : [];\n    }\n\n    /**\n     * This method is like `_.uniqBy` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);\n     * // => [1.1, 2.3]\n     */\n    function sortedUniqBy(array, iteratee) {\n      return (array && array.length)\n        ? baseSortedUniq(array, getIteratee(iteratee, 2))\n        : [];\n    }\n\n    /**\n     * Gets all but the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.tail([1, 2, 3]);\n     * // => [2, 3]\n     */\n    function tail(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseSlice(array, 1, length) : [];\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.take([1, 2, 3]);\n     * // => [1]\n     *\n     * _.take([1, 2, 3], 2);\n     * // => [1, 2]\n     *\n     * _.take([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.take([1, 2, 3], 0);\n     * // => []\n     */\n    function take(array, n, guard) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the end.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.takeRight([1, 2, 3]);\n     * // => [3]\n     *\n     * _.takeRight([1, 2, 3], 2);\n     * // => [2, 3]\n     *\n     * _.takeRight([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.takeRight([1, 2, 3], 0);\n     * // => []\n     */\n    function takeRight(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the end. Elements are\n     * taken until `predicate` returns falsey. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.takeRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['pebbles']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.takeRightWhile(users, ['active', false]);\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.takeRightWhile(users, 'active');\n     * // => []\n     */\n    function takeRightWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), false, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the beginning. Elements\n     * are taken until `predicate` returns falsey. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.takeWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.takeWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.takeWhile(users, ['active', false]);\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.takeWhile(users, 'active');\n     * // => []\n     */\n    function takeWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3))\n        : [];\n    }\n\n    /**\n     * Creates an array of unique values, in order, from all given arrays using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.union([2], [1, 2]);\n     * // => [2, 1]\n     */\n    var union = baseRest(function(arrays) {\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));\n    });\n\n    /**\n     * This method is like `_.union` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by\n     * which uniqueness is computed. Result values are chosen from the first\n     * array in which the value occurs. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.unionBy([2.1], [1.2, 2.3], Math.floor);\n     * // => [2.1, 1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    var unionBy = baseRest(function(arrays) {\n      var iteratee = last(arrays);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));\n    });\n\n    /**\n     * This method is like `_.union` except that it accepts `comparator` which\n     * is invoked to compare elements of `arrays`. Result values are chosen from\n     * the first array in which the value occurs. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.unionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */\n    var unionWith = baseRest(function(arrays) {\n      var comparator = last(arrays);\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);\n    });\n\n    /**\n     * Creates a duplicate-free version of an array, using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons, in which only the first occurrence of each element\n     * is kept. The order of result values is determined by the order they occur\n     * in the array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniq([2, 1, 2]);\n     * // => [2, 1]\n     */\n    function uniq(array) {\n      return (array && array.length) ? baseUniq(array) : [];\n    }\n\n    /**\n     * This method is like `_.uniq` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * uniqueness is computed. The order of result values is determined by the\n     * order they occur in the array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n     * // => [2.1, 1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    function uniqBy(array, iteratee) {\n      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];\n    }\n\n    /**\n     * This method is like `_.uniq` except that it accepts `comparator` which\n     * is invoked to compare elements of `array`. The order of result values is\n     * determined by the order they occur in the array.The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.uniqWith(objects, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]\n     */\n    function uniqWith(array, comparator) {\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts an array of grouped\n     * elements and creates an array regrouping the elements to their pre-zip\n     * configuration.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.2.0\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);\n     * // => [['a', 1, true], ['b', 2, false]]\n     *\n     * _.unzip(zipped);\n     * // => [['a', 'b'], [1, 2], [true, false]]\n     */\n    function unzip(array) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var length = 0;\n      array = arrayFilter(array, function(group) {\n        if (isArrayLikeObject(group)) {\n          length = nativeMax(group.length, length);\n          return true;\n        }\n      });\n      return baseTimes(length, function(index) {\n        return arrayMap(array, baseProperty(index));\n      });\n    }\n\n    /**\n     * This method is like `_.unzip` except that it accepts `iteratee` to specify\n     * how regrouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @param {Function} [iteratee=_.identity] The function to combine\n     *  regrouped values.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);\n     * // => [[1, 10, 100], [2, 20, 200]]\n     *\n     * _.unzipWith(zipped, _.add);\n     * // => [3, 30, 300]\n     */\n    function unzipWith(array, iteratee) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var result = unzip(array);\n      if (iteratee == null) {\n        return result;\n      }\n      return arrayMap(result, function(group) {\n        return apply(iteratee, undefined, group);\n      });\n    }\n\n    /**\n     * Creates an array excluding all given values using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.pull`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...*} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.difference, _.xor\n     * @example\n     *\n     * _.without([2, 1, 2, 3], 1, 2);\n     * // => [3]\n     */\n    var without = baseRest(function(array, values) {\n      return isArrayLikeObject(array)\n        ? baseDifference(array, values)\n        : [];\n    });\n\n    /**\n     * Creates an array of unique values that is the\n     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)\n     * of the given arrays. The order of result values is determined by the order\n     * they occur in the arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.difference, _.without\n     * @example\n     *\n     * _.xor([2, 1], [2, 3]);\n     * // => [1, 3]\n     */\n    var xor = baseRest(function(arrays) {\n      return baseXor(arrayFilter(arrays, isArrayLikeObject));\n    });\n\n    /**\n     * This method is like `_.xor` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by\n     * which by which they're compared. The order of result values is determined\n     * by the order they occur in the arrays. The iteratee is invoked with one\n     * argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [1.2, 3.4]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */\n    var xorBy = baseRest(function(arrays) {\n      var iteratee = last(arrays);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));\n    });\n\n    /**\n     * This method is like `_.xor` except that it accepts `comparator` which is\n     * invoked to compare elements of `arrays`. The order of result values is\n     * determined by the order they occur in the arrays. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.xorWith(objects, others, _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */\n    var xorWith = baseRest(function(arrays) {\n      var comparator = last(arrays);\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);\n    });\n\n    /**\n     * Creates an array of grouped elements, the first of which contains the\n     * first elements of the given arrays, the second of which contains the\n     * second elements of the given arrays, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zip(['a', 'b'], [1, 2], [true, false]);\n     * // => [['a', 1, true], ['b', 2, false]]\n     */\n    var zip = baseRest(unzip);\n\n    /**\n     * This method is like `_.fromPairs` except that it accepts two arrays,\n     * one of property identifiers and one of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.4.0\n     * @category Array\n     * @param {Array} [props=[]] The property identifiers.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObject(['a', 'b'], [1, 2]);\n     * // => { 'a': 1, 'b': 2 }\n     */\n    function zipObject(props, values) {\n      return baseZipObject(props || [], values || [], assignValue);\n    }\n\n    /**\n     * This method is like `_.zipObject` except that it supports property paths.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.1.0\n     * @category Array\n     * @param {Array} [props=[]] The property identifiers.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);\n     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }\n     */\n    function zipObjectDeep(props, values) {\n      return baseZipObject(props || [], values || [], baseSet);\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts `iteratee` to specify\n     * how grouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @param {Function} [iteratee=_.identity] The function to combine\n     *  grouped values.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {\n     *   return a + b + c;\n     * });\n     * // => [111, 222]\n     */\n    var zipWith = baseRest(function(arrays) {\n      var length = arrays.length,\n          iteratee = length > 1 ? arrays[length - 1] : undefined;\n\n      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;\n      return unzipWith(arrays, iteratee);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` wrapper instance that wraps `value` with explicit method\n     * chain sequences enabled. The result of such sequences must be unwrapped\n     * with `_#value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.3.0\n     * @category Seq\n     * @param {*} value The value to wrap.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36 },\n     *   { 'user': 'fred',    'age': 40 },\n     *   { 'user': 'pebbles', 'age': 1 }\n     * ];\n     *\n     * var youngest = _\n     *   .chain(users)\n     *   .sortBy('age')\n     *   .map(function(o) {\n     *     return o.user + ' is ' + o.age;\n     *   })\n     *   .head()\n     *   .value();\n     * // => 'pebbles is 1'\n     */\n    function chain(value) {\n      var result = lodash(value);\n      result.__chain__ = true;\n      return result;\n    }\n\n    /**\n     * This method invokes `interceptor` and returns `value`. The interceptor\n     * is invoked with one argument; (value). The purpose of this method is to\n     * \"tap into\" a method chain sequence in order to modify intermediate results.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * _([1, 2, 3])\n     *  .tap(function(array) {\n     *    // Mutate input array.\n     *    array.pop();\n     *  })\n     *  .reverse()\n     *  .value();\n     * // => [2, 1]\n     */\n    function tap(value, interceptor) {\n      interceptor(value);\n      return value;\n    }\n\n    /**\n     * This method is like `_.tap` except that it returns the result of `interceptor`.\n     * The purpose of this method is to \"pass thru\" values replacing intermediate\n     * results in a method chain sequence.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns the result of `interceptor`.\n     * @example\n     *\n     * _('  abc  ')\n     *  .chain()\n     *  .trim()\n     *  .thru(function(value) {\n     *    return [value];\n     *  })\n     *  .value();\n     * // => ['abc']\n     */\n    function thru(value, interceptor) {\n      return interceptor(value);\n    }\n\n    /**\n     * This method is the wrapper version of `_.at`.\n     *\n     * @name at\n     * @memberOf _\n     * @since 1.0.0\n     * @category Seq\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _(object).at(['a[0].b.c', 'a[1]']).value();\n     * // => [3, 4]\n     */\n    var wrapperAt = flatRest(function(paths) {\n      var length = paths.length,\n          start = length ? paths[0] : 0,\n          value = this.__wrapped__,\n          interceptor = function(object) { return baseAt(object, paths); };\n\n      if (length > 1 || this.__actions__.length ||\n          !(value instanceof LazyWrapper) || !isIndex(start)) {\n        return this.thru(interceptor);\n      }\n      value = value.slice(start, +start + (length ? 1 : 0));\n      value.__actions__.push({\n        'func': thru,\n        'args': [interceptor],\n        'thisArg': undefined\n      });\n      return new LodashWrapper(value, this.__chain__).thru(function(array) {\n        if (length && !array.length) {\n          array.push(undefined);\n        }\n        return array;\n      });\n    });\n\n    /**\n     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.\n     *\n     * @name chain\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * // A sequence without explicit chaining.\n     * _(users).head();\n     * // => { 'user': 'barney', 'age': 36 }\n     *\n     * // A sequence with explicit chaining.\n     * _(users)\n     *   .chain()\n     *   .head()\n     *   .pick('user')\n     *   .value();\n     * // => { 'user': 'barney' }\n     */\n    function wrapperChain() {\n      return chain(this);\n    }\n\n    /**\n     * Executes the chain sequence and returns the wrapped result.\n     *\n     * @name commit\n     * @memberOf _\n     * @since 3.2.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2];\n     * var wrapped = _(array).push(3);\n     *\n     * console.log(array);\n     * // => [1, 2]\n     *\n     * wrapped = wrapped.commit();\n     * console.log(array);\n     * // => [1, 2, 3]\n     *\n     * wrapped.last();\n     * // => 3\n     *\n     * console.log(array);\n     * // => [1, 2, 3]\n     */\n    function wrapperCommit() {\n      return new LodashWrapper(this.value(), this.__chain__);\n    }\n\n    /**\n     * Gets the next value on a wrapped object following the\n     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).\n     *\n     * @name next\n     * @memberOf _\n     * @since 4.0.0\n     * @category Seq\n     * @returns {Object} Returns the next iterator value.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 1 }\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 2 }\n     *\n     * wrapped.next();\n     * // => { 'done': true, 'value': undefined }\n     */\n    function wrapperNext() {\n      if (this.__values__ === undefined) {\n        this.__values__ = toArray(this.value());\n      }\n      var done = this.__index__ >= this.__values__.length,\n          value = done ? undefined : this.__values__[this.__index__++];\n\n      return { 'done': done, 'value': value };\n    }\n\n    /**\n     * Enables the wrapper to be iterable.\n     *\n     * @name Symbol.iterator\n     * @memberOf _\n     * @since 4.0.0\n     * @category Seq\n     * @returns {Object} Returns the wrapper object.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped[Symbol.iterator]() === wrapped;\n     * // => true\n     *\n     * Array.from(wrapped);\n     * // => [1, 2]\n     */\n    function wrapperToIterator() {\n      return this;\n    }\n\n    /**\n     * Creates a clone of the chain sequence planting `value` as the wrapped value.\n     *\n     * @name plant\n     * @memberOf _\n     * @since 3.2.0\n     * @category Seq\n     * @param {*} value The value to plant.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2]).map(square);\n     * var other = wrapped.plant([3, 4]);\n     *\n     * other.value();\n     * // => [9, 16]\n     *\n     * wrapped.value();\n     * // => [1, 4]\n     */\n    function wrapperPlant(value) {\n      var result,\n          parent = this;\n\n      while (parent instanceof baseLodash) {\n        var clone = wrapperClone(parent);\n        clone.__index__ = 0;\n        clone.__values__ = undefined;\n        if (result) {\n          previous.__wrapped__ = clone;\n        } else {\n          result = clone;\n        }\n        var previous = clone;\n        parent = parent.__wrapped__;\n      }\n      previous.__wrapped__ = value;\n      return result;\n    }\n\n    /**\n     * This method is the wrapper version of `_.reverse`.\n     *\n     * **Note:** This method mutates the wrapped array.\n     *\n     * @name reverse\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _(array).reverse().value()\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function wrapperReverse() {\n      var value = this.__wrapped__;\n      if (value instanceof LazyWrapper) {\n        var wrapped = value;\n        if (this.__actions__.length) {\n          wrapped = new LazyWrapper(this);\n        }\n        wrapped = wrapped.reverse();\n        wrapped.__actions__.push({\n          'func': thru,\n          'args': [reverse],\n          'thisArg': undefined\n        });\n        return new LodashWrapper(wrapped, this.__chain__);\n      }\n      return this.thru(reverse);\n    }\n\n    /**\n     * Executes the chain sequence to resolve the unwrapped value.\n     *\n     * @name value\n     * @memberOf _\n     * @since 0.1.0\n     * @alias toJSON, valueOf\n     * @category Seq\n     * @returns {*} Returns the resolved unwrapped value.\n     * @example\n     *\n     * _([1, 2, 3]).value();\n     * // => [1, 2, 3]\n     */\n    function wrapperValue() {\n      return baseWrapperValue(this.__wrapped__, this.__actions__);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The corresponding value of\n     * each key is the number of times the key was returned by `iteratee`. The\n     * iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.countBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': 1, '6': 2 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.countBy(['one', 'two', 'three'], 'length');\n     * // => { '3': 2, '5': 1 }\n     */\n    var countBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        ++result[key];\n      } else {\n        baseAssignValue(result, key, 1);\n      }\n    });\n\n    /**\n     * Checks if `predicate` returns truthy for **all** elements of `collection`.\n     * Iteration is stopped once `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * **Note:** This method returns `true` for\n     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because\n     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of\n     * elements of empty collections.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.every([true, 1, null, 'yes'], Boolean);\n     * // => false\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.every(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.every(users, ['active', false]);\n     * // => true\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.every(users, 'active');\n     * // => false\n     */\n    function every(collection, predicate, guard) {\n      var func = isArray(collection) ? arrayEvery : baseEvery;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = undefined;\n      }\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning an array of all elements\n     * `predicate` returns truthy for. The predicate is invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * **Note:** Unlike `_.remove`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @see _.reject\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * _.filter(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.filter(users, { 'age': 36, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.filter(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.filter(users, 'active');\n     * // => objects for ['barney']\n     *\n     * // Combining several predicates using `_.overEvery` or `_.overSome`.\n     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));\n     * // => objects for ['fred', 'barney']\n     */\n    function filter(collection, predicate) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning the first element\n     * `predicate` returns truthy for. The predicate is invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': true },\n     *   { 'user': 'fred',    'age': 40, 'active': false },\n     *   { 'user': 'pebbles', 'age': 1,  'active': true }\n     * ];\n     *\n     * _.find(users, function(o) { return o.age < 40; });\n     * // => object for 'barney'\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.find(users, { 'age': 1, 'active': true });\n     * // => object for 'pebbles'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.find(users, ['active', false]);\n     * // => object for 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.find(users, 'active');\n     * // => object for 'barney'\n     */\n    var find = createFind(findIndex);\n\n    /**\n     * This method is like `_.find` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=collection.length-1] The index to search from.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * _.findLast([1, 2, 3, 4], function(n) {\n     *   return n % 2 == 1;\n     * });\n     * // => 3\n     */\n    var findLast = createFind(findLastIndex);\n\n    /**\n     * Creates a flattened array of values by running each element in `collection`\n     * thru `iteratee` and flattening the mapped results. The iteratee is invoked\n     * with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [n, n];\n     * }\n     *\n     * _.flatMap([1, 2], duplicate);\n     * // => [1, 1, 2, 2]\n     */\n    function flatMap(collection, iteratee) {\n      return baseFlatten(map(collection, iteratee), 1);\n    }\n\n    /**\n     * This method is like `_.flatMap` except that it recursively flattens the\n     * mapped results.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [[[n, n]]];\n     * }\n     *\n     * _.flatMapDeep([1, 2], duplicate);\n     * // => [1, 1, 2, 2]\n     */\n    function flatMapDeep(collection, iteratee) {\n      return baseFlatten(map(collection, iteratee), INFINITY);\n    }\n\n    /**\n     * This method is like `_.flatMap` except that it recursively flattens the\n     * mapped results up to `depth` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {number} [depth=1] The maximum recursion depth.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [[[n, n]]];\n     * }\n     *\n     * _.flatMapDepth([1, 2], duplicate, 2);\n     * // => [[1, 1], [2, 2]]\n     */\n    function flatMapDepth(collection, iteratee, depth) {\n      depth = depth === undefined ? 1 : toInteger(depth);\n      return baseFlatten(map(collection, iteratee), depth);\n    }\n\n    /**\n     * Iterates over elements of `collection` and invokes `iteratee` for each element.\n     * The iteratee is invoked with three arguments: (value, index|key, collection).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n     * property are iterated like arrays. To avoid this behavior use `_.forIn`\n     * or `_.forOwn` for object iteration.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @alias each\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @see _.forEachRight\n     * @example\n     *\n     * _.forEach([1, 2], function(value) {\n     *   console.log(value);\n     * });\n     * // => Logs `1` then `2`.\n     *\n     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n     */\n    function forEach(collection, iteratee) {\n      var func = isArray(collection) ? arrayEach : baseEach;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.forEach` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @alias eachRight\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @see _.forEach\n     * @example\n     *\n     * _.forEachRight([1, 2], function(value) {\n     *   console.log(value);\n     * });\n     * // => Logs `2` then `1`.\n     */\n    function forEachRight(collection, iteratee) {\n      var func = isArray(collection) ? arrayEachRight : baseEachRight;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The order of grouped values\n     * is determined by the order they occur in `collection`. The corresponding\n     * value of each key is an array of elements responsible for generating the\n     * key. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': [4.2], '6': [6.1, 6.3] }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.groupBy(['one', 'two', 'three'], 'length');\n     * // => { '3': ['one', 'two'], '5': ['three'] }\n     */\n    var groupBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        result[key].push(value);\n      } else {\n        baseAssignValue(result, key, [value]);\n      }\n    });\n\n    /**\n     * Checks if `value` is in `collection`. If `collection` is a string, it's\n     * checked for a substring of `value`, otherwise\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * is used for equality comparisons. If `fromIndex` is negative, it's used as\n     * the offset from the end of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n     * @returns {boolean} Returns `true` if `value` is found, else `false`.\n     * @example\n     *\n     * _.includes([1, 2, 3], 1);\n     * // => true\n     *\n     * _.includes([1, 2, 3], 1, 2);\n     * // => false\n     *\n     * _.includes({ 'a': 1, 'b': 2 }, 1);\n     * // => true\n     *\n     * _.includes('abcd', 'bc');\n     * // => true\n     */\n    function includes(collection, value, fromIndex, guard) {\n      collection = isArrayLike(collection) ? collection : values(collection);\n      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\n\n      var length = collection.length;\n      if (fromIndex < 0) {\n        fromIndex = nativeMax(length + fromIndex, 0);\n      }\n      return isString(collection)\n        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\n        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\n    }\n\n    /**\n     * Invokes the method at `path` of each element in `collection`, returning\n     * an array of the results of each invoked method. Any additional arguments\n     * are provided to each invoked method. If `path` is a function, it's invoked\n     * for, and `this` bound to, each element in `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Array|Function|string} path The path of the method to invoke or\n     *  the function invoked per iteration.\n     * @param {...*} [args] The arguments to invoke each method with.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');\n     * // => [[1, 5, 7], [1, 2, 3]]\n     *\n     * _.invokeMap([123, 456], String.prototype.split, '');\n     * // => [['1', '2', '3'], ['4', '5', '6']]\n     */\n    var invokeMap = baseRest(function(collection, path, args) {\n      var index = -1,\n          isFunc = typeof path == 'function',\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value) {\n        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);\n      });\n      return result;\n    });\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The corresponding value of\n     * each key is the last element responsible for generating the key. The\n     * iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * var array = [\n     *   { 'dir': 'left', 'code': 97 },\n     *   { 'dir': 'right', 'code': 100 }\n     * ];\n     *\n     * _.keyBy(array, function(o) {\n     *   return String.fromCharCode(o.code);\n     * });\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.keyBy(array, 'dir');\n     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n     */\n    var keyBy = createAggregator(function(result, value, key) {\n      baseAssignValue(result, key, value);\n    });\n\n    /**\n     * Creates an array of values by running each element in `collection` thru\n     * `iteratee`. The iteratee is invoked with three arguments:\n     * (value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n     *\n     * The guarded methods are:\n     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * _.map([4, 8], square);\n     * // => [16, 64]\n     *\n     * _.map({ 'a': 4, 'b': 8 }, square);\n     * // => [16, 64] (iteration order is not guaranteed)\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.map(users, 'user');\n     * // => ['barney', 'fred']\n     */\n    function map(collection, iteratee) {\n      var func = isArray(collection) ? arrayMap : baseMap;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.sortBy` except that it allows specifying the sort\n     * orders of the iteratees to sort by. If `orders` is unspecified, all values\n     * are sorted in ascending order. Otherwise, specify an order of \"desc\" for\n     * descending or \"asc\" for ascending sort order of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]\n     *  The iteratees to sort by.\n     * @param {string[]} [orders] The sort orders of `iteratees`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 34 },\n     *   { 'user': 'fred',   'age': 40 },\n     *   { 'user': 'barney', 'age': 36 }\n     * ];\n     *\n     * // Sort by `user` in ascending order and by `age` in descending order.\n     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n     */\n    function orderBy(collection, iteratees, orders, guard) {\n      if (collection == null) {\n        return [];\n      }\n      if (!isArray(iteratees)) {\n        iteratees = iteratees == null ? [] : [iteratees];\n      }\n      orders = guard ? undefined : orders;\n      if (!isArray(orders)) {\n        orders = orders == null ? [] : [orders];\n      }\n      return baseOrderBy(collection, iteratees, orders);\n    }\n\n    /**\n     * Creates an array of elements split into two groups, the first of which\n     * contains elements `predicate` returns truthy for, the second of which\n     * contains elements `predicate` returns falsey for. The predicate is\n     * invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of grouped elements.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': false },\n     *   { 'user': 'fred',    'age': 40, 'active': true },\n     *   { 'user': 'pebbles', 'age': 1,  'active': false }\n     * ];\n     *\n     * _.partition(users, function(o) { return o.active; });\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.partition(users, { 'age': 1, 'active': false });\n     * // => objects for [['pebbles'], ['barney', 'fred']]\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.partition(users, ['active', false]);\n     * // => objects for [['barney', 'pebbles'], ['fred']]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.partition(users, 'active');\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     */\n    var partition = createAggregator(function(result, value, key) {\n      result[key ? 0 : 1].push(value);\n    }, function() { return [[], []]; });\n\n    /**\n     * Reduces `collection` to a value which is the accumulated result of running\n     * each element in `collection` thru `iteratee`, where each successive\n     * invocation is supplied the return value of the previous. If `accumulator`\n     * is not given, the first element of `collection` is used as the initial\n     * value. The iteratee is invoked with four arguments:\n     * (accumulator, value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.reduce`, `_.reduceRight`, and `_.transform`.\n     *\n     * The guarded methods are:\n     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n     * and `sortBy`\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @see _.reduceRight\n     * @example\n     *\n     * _.reduce([1, 2], function(sum, n) {\n     *   return sum + n;\n     * }, 0);\n     * // => 3\n     *\n     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     *   return result;\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n     */\n    function reduce(collection, iteratee, accumulator) {\n      var func = isArray(collection) ? arrayReduce : baseReduce,\n          initAccum = arguments.length < 3;\n\n      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);\n    }\n\n    /**\n     * This method is like `_.reduce` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @see _.reduce\n     * @example\n     *\n     * var array = [[0, 1], [2, 3], [4, 5]];\n     *\n     * _.reduceRight(array, function(flattened, other) {\n     *   return flattened.concat(other);\n     * }, []);\n     * // => [4, 5, 2, 3, 0, 1]\n     */\n    function reduceRight(collection, iteratee, accumulator) {\n      var func = isArray(collection) ? arrayReduceRight : baseReduce,\n          initAccum = arguments.length < 3;\n\n      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);\n    }\n\n    /**\n     * The opposite of `_.filter`; this method returns the elements of `collection`\n     * that `predicate` does **not** return truthy for.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @see _.filter\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': true }\n     * ];\n     *\n     * _.reject(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.reject(users, { 'age': 40, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.reject(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.reject(users, 'active');\n     * // => objects for ['barney']\n     */\n    function reject(collection, predicate) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      return func(collection, negate(getIteratee(predicate, 3)));\n    }\n\n    /**\n     * Gets a random element from `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @returns {*} Returns the random element.\n     * @example\n     *\n     * _.sample([1, 2, 3, 4]);\n     * // => 2\n     */\n    function sample(collection) {\n      var func = isArray(collection) ? arraySample : baseSample;\n      return func(collection);\n    }\n\n    /**\n     * Gets `n` random elements at unique keys from `collection` up to the\n     * size of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @param {number} [n=1] The number of elements to sample.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the random elements.\n     * @example\n     *\n     * _.sampleSize([1, 2, 3], 2);\n     * // => [3, 1]\n     *\n     * _.sampleSize([1, 2, 3], 4);\n     * // => [2, 3, 1]\n     */\n    function sampleSize(collection, n, guard) {\n      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {\n        n = 1;\n      } else {\n        n = toInteger(n);\n      }\n      var func = isArray(collection) ? arraySampleSize : baseSampleSize;\n      return func(collection, n);\n    }\n\n    /**\n     * Creates an array of shuffled values, using a version of the\n     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     * @example\n     *\n     * _.shuffle([1, 2, 3, 4]);\n     * // => [4, 1, 3, 2]\n     */\n    function shuffle(collection) {\n      var func = isArray(collection) ? arrayShuffle : baseShuffle;\n      return func(collection);\n    }\n\n    /**\n     * Gets the size of `collection` by returning its length for array-like\n     * values or the number of own enumerable string keyed properties for objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @returns {number} Returns the collection size.\n     * @example\n     *\n     * _.size([1, 2, 3]);\n     * // => 3\n     *\n     * _.size({ 'a': 1, 'b': 2 });\n     * // => 2\n     *\n     * _.size('pebbles');\n     * // => 7\n     */\n    function size(collection) {\n      if (collection == null) {\n        return 0;\n      }\n      if (isArrayLike(collection)) {\n        return isString(collection) ? stringSize(collection) : collection.length;\n      }\n      var tag = getTag(collection);\n      if (tag == mapTag || tag == setTag) {\n        return collection.size;\n      }\n      return baseKeys(collection).length;\n    }\n\n    /**\n     * Checks if `predicate` returns truthy for **any** element of `collection`.\n     * Iteration is stopped once `predicate` returns truthy. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.some([null, 0, 'yes', false], Boolean);\n     * // => true\n     *\n     * var users = [\n     *   { 'user': 'barney', 'active': true },\n     *   { 'user': 'fred',   'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.some(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.some(users, ['active', false]);\n     * // => true\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.some(users, 'active');\n     * // => true\n     */\n    function some(collection, predicate, guard) {\n      var func = isArray(collection) ? arraySome : baseSome;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = undefined;\n      }\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Creates an array of elements, sorted in ascending order by the results of\n     * running each element in a collection thru each iteratee. This method\n     * performs a stable sort, that is, it preserves the original sort order of\n     * equal elements. The iteratees are invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n     *  The iteratees to sort by.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 30 },\n     *   { 'user': 'barney', 'age': 34 }\n     * ];\n     *\n     * _.sortBy(users, [function(o) { return o.user; }]);\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]\n     *\n     * _.sortBy(users, ['user', 'age']);\n     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]\n     */\n    var sortBy = baseRest(function(collection, iteratees) {\n      if (collection == null) {\n        return [];\n      }\n      var length = iteratees.length;\n      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n        iteratees = [];\n      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n        iteratees = [iteratees[0]];\n      }\n      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Gets the timestamp of the number of milliseconds that have elapsed since\n     * the Unix epoch (1 January 1970 00:00:00 UTC).\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Date\n     * @returns {number} Returns the timestamp.\n     * @example\n     *\n     * _.defer(function(stamp) {\n     *   console.log(_.now() - stamp);\n     * }, _.now());\n     * // => Logs the number of milliseconds it took for the deferred invocation.\n     */\n    var now = ctxNow || function() {\n      return root.Date.now();\n    };\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The opposite of `_.before`; this method creates a function that invokes\n     * `func` once it's called `n` or more times.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {number} n The number of calls before `func` is invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var saves = ['profile', 'settings'];\n     *\n     * var done = _.after(saves.length, function() {\n     *   console.log('done saving!');\n     * });\n     *\n     * _.forEach(saves, function(type) {\n     *   asyncSave({ 'type': type, 'complete': done });\n     * });\n     * // => Logs 'done saving!' after the two async saves have completed.\n     */\n    function after(n, func) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      n = toInteger(n);\n      return function() {\n        if (--n < 1) {\n          return func.apply(this, arguments);\n        }\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func`, with up to `n` arguments,\n     * ignoring any additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @param {number} [n=func.length] The arity cap.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new capped function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.ary(parseInt, 1));\n     * // => [6, 8, 10]\n     */\n    function ary(func, n, guard) {\n      n = guard ? undefined : n;\n      n = (func && n == null) ? func.length : n;\n      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);\n    }\n\n    /**\n     * Creates a function that invokes `func`, with the `this` binding and arguments\n     * of the created function, while it's called less than `n` times. Subsequent\n     * calls to the created function return the result of the last `func` invocation.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {number} n The number of calls at which `func` is no longer invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * jQuery(element).on('click', _.before(5, addContactToList));\n     * // => Allows adding up to 4 contacts to the list.\n     */\n    function before(n, func) {\n      var result;\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      n = toInteger(n);\n      return function() {\n        if (--n > 0) {\n          result = func.apply(this, arguments);\n        }\n        if (n <= 1) {\n          func = undefined;\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of `thisArg`\n     * and `partials` prepended to the arguments it receives.\n     *\n     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** Unlike native `Function#bind`, this method doesn't set the \"length\"\n     * property of bound functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to bind.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * function greet(greeting, punctuation) {\n     *   return greeting + ' ' + this.user + punctuation;\n     * }\n     *\n     * var object = { 'user': 'fred' };\n     *\n     * var bound = _.bind(greet, object, 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * // Bound with placeholders.\n     * var bound = _.bind(greet, object, _, '!');\n     * bound('hi');\n     * // => 'hi fred!'\n     */\n    var bind = baseRest(function(func, thisArg, partials) {\n      var bitmask = WRAP_BIND_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, getHolder(bind));\n        bitmask |= WRAP_PARTIAL_FLAG;\n      }\n      return createWrap(func, bitmask, thisArg, partials, holders);\n    });\n\n    /**\n     * Creates a function that invokes the method at `object[key]` with `partials`\n     * prepended to the arguments it receives.\n     *\n     * This method differs from `_.bind` by allowing bound functions to reference\n     * methods that may be redefined or don't yet exist. See\n     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)\n     * for more details.\n     *\n     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.10.0\n     * @category Function\n     * @param {Object} object The object to invoke the method on.\n     * @param {string} key The key of the method.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var object = {\n     *   'user': 'fred',\n     *   'greet': function(greeting, punctuation) {\n     *     return greeting + ' ' + this.user + punctuation;\n     *   }\n     * };\n     *\n     * var bound = _.bindKey(object, 'greet', 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * object.greet = function(greeting, punctuation) {\n     *   return greeting + 'ya ' + this.user + punctuation;\n     * };\n     *\n     * bound('!');\n     * // => 'hiya fred!'\n     *\n     * // Bound with placeholders.\n     * var bound = _.bindKey(object, 'greet', _, '!');\n     * bound('hi');\n     * // => 'hiya fred!'\n     */\n    var bindKey = baseRest(function(object, key, partials) {\n      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, getHolder(bindKey));\n        bitmask |= WRAP_PARTIAL_FLAG;\n      }\n      return createWrap(key, bitmask, object, partials, holders);\n    });\n\n    /**\n     * Creates a function that accepts arguments of `func` and either invokes\n     * `func` returning its result, if at least `arity` number of arguments have\n     * been provided, or returns a function that accepts the remaining `func`\n     * arguments, and so on. The arity of `func` may be specified if `func.length`\n     * is not sufficient.\n     *\n     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curry(abc);\n     *\n     * curried(1)(2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // Curried with placeholders.\n     * curried(1)(_, 3)(2);\n     * // => [1, 2, 3]\n     */\n    function curry(func, arity, guard) {\n      arity = guard ? undefined : arity;\n      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n      result.placeholder = curry.placeholder;\n      return result;\n    }\n\n    /**\n     * This method is like `_.curry` except that arguments are applied to `func`\n     * in the manner of `_.partialRight` instead of `_.partial`.\n     *\n     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curryRight(abc);\n     *\n     * curried(3)(2)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(2, 3)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // Curried with placeholders.\n     * curried(3)(1, _)(2);\n     * // => [1, 2, 3]\n     */\n    function curryRight(func, arity, guard) {\n      arity = guard ? undefined : arity;\n      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n      result.placeholder = curryRight.placeholder;\n      return result;\n    }\n\n    /**\n     * Creates a debounced function that delays invoking `func` until after `wait`\n     * milliseconds have elapsed since the last time the debounced function was\n     * invoked. The debounced function comes with a `cancel` method to cancel\n     * delayed `func` invocations and a `flush` method to immediately invoke them.\n     * Provide `options` to indicate whether `func` should be invoked on the\n     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n     * with the last arguments provided to the debounced function. Subsequent\n     * calls to the debounced function return the result of the last `func`\n     * invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n     * invoked on the trailing edge of the timeout only if the debounced function\n     * is invoked more than once during the `wait` timeout.\n     *\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n     *\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n     * for details over the differences between `_.debounce` and `_.throttle`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to debounce.\n     * @param {number} [wait=0] The number of milliseconds to delay.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.leading=false]\n     *  Specify invoking on the leading edge of the timeout.\n     * @param {number} [options.maxWait]\n     *  The maximum time `func` is allowed to be delayed before it's invoked.\n     * @param {boolean} [options.trailing=true]\n     *  Specify invoking on the trailing edge of the timeout.\n     * @returns {Function} Returns the new debounced function.\n     * @example\n     *\n     * // Avoid costly calculations while the window size is in flux.\n     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n     *\n     * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n     * jQuery(element).on('click', _.debounce(sendMail, 300, {\n     *   'leading': true,\n     *   'trailing': false\n     * }));\n     *\n     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n     * var source = new EventSource('/stream');\n     * jQuery(source).on('message', debounced);\n     *\n     * // Cancel the trailing debounced invocation.\n     * jQuery(window).on('popstate', debounced.cancel);\n     */\n    function debounce(func, wait, options) {\n      var lastArgs,\n          lastThis,\n          maxWait,\n          result,\n          timerId,\n          lastCallTime,\n          lastInvokeTime = 0,\n          leading = false,\n          maxing = false,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      wait = toNumber(wait) || 0;\n      if (isObject(options)) {\n        leading = !!options.leading;\n        maxing = 'maxWait' in options;\n        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n\n      function invokeFunc(time) {\n        var args = lastArgs,\n            thisArg = lastThis;\n\n        lastArgs = lastThis = undefined;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n      }\n\n      function leadingEdge(time) {\n        // Reset any `maxWait` timer.\n        lastInvokeTime = time;\n        // Start the timer for the trailing edge.\n        timerId = setTimeout(timerExpired, wait);\n        // Invoke the leading edge.\n        return leading ? invokeFunc(time) : result;\n      }\n\n      function remainingWait(time) {\n        var timeSinceLastCall = time - lastCallTime,\n            timeSinceLastInvoke = time - lastInvokeTime,\n            timeWaiting = wait - timeSinceLastCall;\n\n        return maxing\n          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n          : timeWaiting;\n      }\n\n      function shouldInvoke(time) {\n        var timeSinceLastCall = time - lastCallTime,\n            timeSinceLastInvoke = time - lastInvokeTime;\n\n        // Either this is the first call, activity has stopped and we're at the\n        // trailing edge, the system time has gone backwards and we're treating\n        // it as the trailing edge, or we've hit the `maxWait` limit.\n        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n      }\n\n      function timerExpired() {\n        var time = now();\n        if (shouldInvoke(time)) {\n          return trailingEdge(time);\n        }\n        // Restart the timer.\n        timerId = setTimeout(timerExpired, remainingWait(time));\n      }\n\n      function trailingEdge(time) {\n        timerId = undefined;\n\n        // Only invoke if we have `lastArgs` which means `func` has been\n        // debounced at least once.\n        if (trailing && lastArgs) {\n          return invokeFunc(time);\n        }\n        lastArgs = lastThis = undefined;\n        return result;\n      }\n\n      function cancel() {\n        if (timerId !== undefined) {\n          clearTimeout(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\n      }\n\n      function flush() {\n        return timerId === undefined ? result : trailingEdge(now());\n      }\n\n      function debounced() {\n        var time = now(),\n            isInvoking = shouldInvoke(time);\n\n        lastArgs = arguments;\n        lastThis = this;\n        lastCallTime = time;\n\n        if (isInvoking) {\n          if (timerId === undefined) {\n            return leadingEdge(lastCallTime);\n          }\n          if (maxing) {\n            // Handle invocations in a tight loop.\n            clearTimeout(timerId);\n            timerId = setTimeout(timerExpired, wait);\n            return invokeFunc(lastCallTime);\n          }\n        }\n        if (timerId === undefined) {\n          timerId = setTimeout(timerExpired, wait);\n        }\n        return result;\n      }\n      debounced.cancel = cancel;\n      debounced.flush = flush;\n      return debounced;\n    }\n\n    /**\n     * Defers invoking the `func` until the current call stack has cleared. Any\n     * additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to defer.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.defer(function(text) {\n     *   console.log(text);\n     * }, 'deferred');\n     * // => Logs 'deferred' after one millisecond.\n     */\n    var defer = baseRest(function(func, args) {\n      return baseDelay(func, 1, args);\n    });\n\n    /**\n     * Invokes `func` after `wait` milliseconds. Any additional arguments are\n     * provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.delay(function(text) {\n     *   console.log(text);\n     * }, 1000, 'later');\n     * // => Logs 'later' after one second.\n     */\n    var delay = baseRest(function(func, wait, args) {\n      return baseDelay(func, toNumber(wait) || 0, args);\n    });\n\n    /**\n     * Creates a function that invokes `func` with arguments reversed.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to flip arguments for.\n     * @returns {Function} Returns the new flipped function.\n     * @example\n     *\n     * var flipped = _.flip(function() {\n     *   return _.toArray(arguments);\n     * });\n     *\n     * flipped('a', 'b', 'c', 'd');\n     * // => ['d', 'c', 'b', 'a']\n     */\n    function flip(func) {\n      return createWrap(func, WRAP_FLIP_FLAG);\n    }\n\n    /**\n     * Creates a function that memoizes the result of `func`. If `resolver` is\n     * provided, it determines the cache key for storing the result based on the\n     * arguments provided to the memoized function. By default, the first argument\n     * provided to the memoized function is used as the map cache key. The `func`\n     * is invoked with the `this` binding of the memoized function.\n     *\n     * **Note:** The cache is exposed as the `cache` property on the memoized\n     * function. Its creation may be customized by replacing the `_.memoize.Cache`\n     * constructor with one whose instances implement the\n     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n     * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to have its output memoized.\n     * @param {Function} [resolver] The function to resolve the cache key.\n     * @returns {Function} Returns the new memoized function.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     * var other = { 'c': 3, 'd': 4 };\n     *\n     * var values = _.memoize(_.values);\n     * values(object);\n     * // => [1, 2]\n     *\n     * values(other);\n     * // => [3, 4]\n     *\n     * object.a = 2;\n     * values(object);\n     * // => [1, 2]\n     *\n     * // Modify the result cache.\n     * values.cache.set(object, ['a', 'b']);\n     * values(object);\n     * // => ['a', 'b']\n     *\n     * // Replace `_.memoize.Cache`.\n     * _.memoize.Cache = WeakMap;\n     */\n    function memoize(func, resolver) {\n      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var memoized = function() {\n        var args = arguments,\n            key = resolver ? resolver.apply(this, args) : args[0],\n            cache = memoized.cache;\n\n        if (cache.has(key)) {\n          return cache.get(key);\n        }\n        var result = func.apply(this, args);\n        memoized.cache = cache.set(key, result) || cache;\n        return result;\n      };\n      memoized.cache = new (memoize.Cache || MapCache);\n      return memoized;\n    }\n\n    // Expose `MapCache`.\n    memoize.Cache = MapCache;\n\n    /**\n     * Creates a function that negates the result of the predicate `func`. The\n     * `func` predicate is invoked with the `this` binding and arguments of the\n     * created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} predicate The predicate to negate.\n     * @returns {Function} Returns the new negated function.\n     * @example\n     *\n     * function isEven(n) {\n     *   return n % 2 == 0;\n     * }\n     *\n     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n     * // => [1, 3, 5]\n     */\n    function negate(predicate) {\n      if (typeof predicate != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return function() {\n        var args = arguments;\n        switch (args.length) {\n          case 0: return !predicate.call(this);\n          case 1: return !predicate.call(this, args[0]);\n          case 2: return !predicate.call(this, args[0], args[1]);\n          case 3: return !predicate.call(this, args[0], args[1], args[2]);\n        }\n        return !predicate.apply(this, args);\n      };\n    }\n\n    /**\n     * Creates a function that is restricted to invoking `func` once. Repeat calls\n     * to the function return the value of the first invocation. The `func` is\n     * invoked with the `this` binding and arguments of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var initialize = _.once(createApplication);\n     * initialize();\n     * initialize();\n     * // => `createApplication` is invoked once\n     */\n    function once(func) {\n      return before(2, func);\n    }\n\n    /**\n     * Creates a function that invokes `func` with its arguments transformed.\n     *\n     * @static\n     * @since 4.0.0\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to wrap.\n     * @param {...(Function|Function[])} [transforms=[_.identity]]\n     *  The argument transforms.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function doubled(n) {\n     *   return n * 2;\n     * }\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var func = _.overArgs(function(x, y) {\n     *   return [x, y];\n     * }, [square, doubled]);\n     *\n     * func(9, 3);\n     * // => [81, 6]\n     *\n     * func(10, 5);\n     * // => [100, 10]\n     */\n    var overArgs = castRest(function(func, transforms) {\n      transforms = (transforms.length == 1 && isArray(transforms[0]))\n        ? arrayMap(transforms[0], baseUnary(getIteratee()))\n        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));\n\n      var funcsLength = transforms.length;\n      return baseRest(function(args) {\n        var index = -1,\n            length = nativeMin(args.length, funcsLength);\n\n        while (++index < length) {\n          args[index] = transforms[index].call(this, args[index]);\n        }\n        return apply(func, this, args);\n      });\n    });\n\n    /**\n     * Creates a function that invokes `func` with `partials` prepended to the\n     * arguments it receives. This method is like `_.bind` except it does **not**\n     * alter the `this` binding.\n     *\n     * The `_.partial.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.2.0\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * function greet(greeting, name) {\n     *   return greeting + ' ' + name;\n     * }\n     *\n     * var sayHelloTo = _.partial(greet, 'hello');\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     *\n     * // Partially applied with placeholders.\n     * var greetFred = _.partial(greet, _, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     */\n    var partial = baseRest(function(func, partials) {\n      var holders = replaceHolders(partials, getHolder(partial));\n      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);\n    });\n\n    /**\n     * This method is like `_.partial` except that partially applied arguments\n     * are appended to the arguments it receives.\n     *\n     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * function greet(greeting, name) {\n     *   return greeting + ' ' + name;\n     * }\n     *\n     * var greetFred = _.partialRight(greet, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     *\n     * // Partially applied with placeholders.\n     * var sayHelloTo = _.partialRight(greet, 'hello', _);\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     */\n    var partialRight = baseRest(function(func, partials) {\n      var holders = replaceHolders(partials, getHolder(partialRight));\n      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);\n    });\n\n    /**\n     * Creates a function that invokes `func` with arguments arranged according\n     * to the specified `indexes` where the argument value at the first index is\n     * provided as the first argument, the argument value at the second index is\n     * provided as the second argument, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to rearrange arguments for.\n     * @param {...(number|number[])} indexes The arranged argument indexes.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var rearged = _.rearg(function(a, b, c) {\n     *   return [a, b, c];\n     * }, [2, 0, 1]);\n     *\n     * rearged('b', 'c', 'a')\n     * // => ['a', 'b', 'c']\n     */\n    var rearg = flatRest(function(func, indexes) {\n      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);\n    });\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * created function and arguments from `start` and beyond provided as\n     * an array.\n     *\n     * **Note:** This method is based on the\n     * [rest parameter](https://mdn.io/rest_parameters).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.rest(function(what, names) {\n     *   return what + ' ' + _.initial(names).join(', ') +\n     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n     * });\n     *\n     * say('hello', 'fred', 'barney', 'pebbles');\n     * // => 'hello fred, barney, & pebbles'\n     */\n    function rest(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = start === undefined ? start : toInteger(start);\n      return baseRest(func, start);\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * create function and an array of arguments much like\n     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).\n     *\n     * **Note:** This method is based on the\n     * [spread operator](https://mdn.io/spread_operator).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Function\n     * @param {Function} func The function to spread arguments over.\n     * @param {number} [start=0] The start position of the spread.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.spread(function(who, what) {\n     *   return who + ' says ' + what;\n     * });\n     *\n     * say(['fred', 'hello']);\n     * // => 'fred says hello'\n     *\n     * var numbers = Promise.all([\n     *   Promise.resolve(40),\n     *   Promise.resolve(36)\n     * ]);\n     *\n     * numbers.then(_.spread(function(x, y) {\n     *   return x + y;\n     * }));\n     * // => a Promise of 76\n     */\n    function spread(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = start == null ? 0 : nativeMax(toInteger(start), 0);\n      return baseRest(function(args) {\n        var array = args[start],\n            otherArgs = castSlice(args, 0, start);\n\n        if (array) {\n          arrayPush(otherArgs, array);\n        }\n        return apply(func, this, otherArgs);\n      });\n    }\n\n    /**\n     * Creates a throttled function that only invokes `func` at most once per\n     * every `wait` milliseconds. The throttled function comes with a `cancel`\n     * method to cancel delayed `func` invocations and a `flush` method to\n     * immediately invoke them. Provide `options` to indicate whether `func`\n     * should be invoked on the leading and/or trailing edge of the `wait`\n     * timeout. The `func` is invoked with the last arguments provided to the\n     * throttled function. Subsequent calls to the throttled function return the\n     * result of the last `func` invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n     * invoked on the trailing edge of the timeout only if the throttled function\n     * is invoked more than once during the `wait` timeout.\n     *\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n     *\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n     * for details over the differences between `_.throttle` and `_.debounce`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to throttle.\n     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.leading=true]\n     *  Specify invoking on the leading edge of the timeout.\n     * @param {boolean} [options.trailing=true]\n     *  Specify invoking on the trailing edge of the timeout.\n     * @returns {Function} Returns the new throttled function.\n     * @example\n     *\n     * // Avoid excessively updating the position while scrolling.\n     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n     *\n     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n     * jQuery(element).on('click', throttled);\n     *\n     * // Cancel the trailing throttled invocation.\n     * jQuery(window).on('popstate', throttled.cancel);\n     */\n    function throttle(func, wait, options) {\n      var leading = true,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      if (isObject(options)) {\n        leading = 'leading' in options ? !!options.leading : leading;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n      return debounce(func, wait, {\n        'leading': leading,\n        'maxWait': wait,\n        'trailing': trailing\n      });\n    }\n\n    /**\n     * Creates a function that accepts up to one argument, ignoring any\n     * additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @returns {Function} Returns the new capped function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.unary(parseInt));\n     * // => [6, 8, 10]\n     */\n    function unary(func) {\n      return ary(func, 1);\n    }\n\n    /**\n     * Creates a function that provides `value` to `wrapper` as its first\n     * argument. Any additional arguments provided to the function are appended\n     * to those provided to the `wrapper`. The wrapper is invoked with the `this`\n     * binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {*} value The value to wrap.\n     * @param {Function} [wrapper=identity] The wrapper function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var p = _.wrap(_.escape, function(func, text) {\n     *   return '<p>' + func(text) + '</p>';\n     * });\n     *\n     * p('fred, barney, & pebbles');\n     * // => '<p>fred, barney, &amp; pebbles</p>'\n     */\n    function wrap(value, wrapper) {\n      return partial(castFunction(wrapper), value);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Casts `value` as an array if it's not one.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.4.0\n     * @category Lang\n     * @param {*} value The value to inspect.\n     * @returns {Array} Returns the cast array.\n     * @example\n     *\n     * _.castArray(1);\n     * // => [1]\n     *\n     * _.castArray({ 'a': 1 });\n     * // => [{ 'a': 1 }]\n     *\n     * _.castArray('abc');\n     * // => ['abc']\n     *\n     * _.castArray(null);\n     * // => [null]\n     *\n     * _.castArray(undefined);\n     * // => [undefined]\n     *\n     * _.castArray();\n     * // => []\n     *\n     * var array = [1, 2, 3];\n     * console.log(_.castArray(array) === array);\n     * // => true\n     */\n    function castArray() {\n      if (!arguments.length) {\n        return [];\n      }\n      var value = arguments[0];\n      return isArray(value) ? value : [value];\n    }\n\n    /**\n     * Creates a shallow clone of `value`.\n     *\n     * **Note:** This method is loosely based on the\n     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n     * and supports cloning arrays, array buffers, booleans, date objects, maps,\n     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n     * arrays. The own enumerable properties of `arguments` objects are cloned\n     * as plain objects. An empty object is returned for uncloneable values such\n     * as error objects, functions, DOM nodes, and WeakMaps.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @returns {*} Returns the cloned value.\n     * @see _.cloneDeep\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var shallow = _.clone(objects);\n     * console.log(shallow[0] === objects[0]);\n     * // => true\n     */\n    function clone(value) {\n      return baseClone(value, CLONE_SYMBOLS_FLAG);\n    }\n\n    /**\n     * This method is like `_.clone` except that it accepts `customizer` which\n     * is invoked to produce the cloned value. If `customizer` returns `undefined`,\n     * cloning is handled by the method instead. The `customizer` is invoked with\n     * up to four arguments; (value [, index|key, object, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the cloned value.\n     * @see _.cloneDeepWith\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(false);\n     *   }\n     * }\n     *\n     * var el = _.cloneWith(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 0\n     */\n    function cloneWith(value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);\n    }\n\n    /**\n     * This method is like `_.clone` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @returns {*} Returns the deep cloned value.\n     * @see _.clone\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var deep = _.cloneDeep(objects);\n     * console.log(deep[0] === objects[0]);\n     * // => false\n     */\n    function cloneDeep(value) {\n      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n    }\n\n    /**\n     * This method is like `_.cloneWith` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the deep cloned value.\n     * @see _.cloneWith\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(true);\n     *   }\n     * }\n     *\n     * var el = _.cloneDeepWith(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 20\n     */\n    function cloneDeepWith(value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);\n    }\n\n    /**\n     * Checks if `object` conforms to `source` by invoking the predicate\n     * properties of `source` with the corresponding property values of `object`.\n     *\n     * **Note:** This method is equivalent to `_.conforms` when `source` is\n     * partially applied.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.14.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     *\n     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });\n     * // => true\n     *\n     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });\n     * // => false\n     */\n    function conformsTo(object, source) {\n      return source == null || baseConformsTo(object, source, keys(source));\n    }\n\n    /**\n     * Performs a\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * comparison between two values to determine if they are equivalent.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     * var other = { 'a': 1 };\n     *\n     * _.eq(object, object);\n     * // => true\n     *\n     * _.eq(object, other);\n     * // => false\n     *\n     * _.eq('a', 'a');\n     * // => true\n     *\n     * _.eq('a', Object('a'));\n     * // => false\n     *\n     * _.eq(NaN, NaN);\n     * // => true\n     */\n    function eq(value, other) {\n      return value === other || (value !== value && other !== other);\n    }\n\n    /**\n     * Checks if `value` is greater than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n     *  else `false`.\n     * @see _.lt\n     * @example\n     *\n     * _.gt(3, 1);\n     * // => true\n     *\n     * _.gt(3, 3);\n     * // => false\n     *\n     * _.gt(1, 3);\n     * // => false\n     */\n    var gt = createRelationalOperation(baseGt);\n\n    /**\n     * Checks if `value` is greater than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than or equal to\n     *  `other`, else `false`.\n     * @see _.lte\n     * @example\n     *\n     * _.gte(3, 1);\n     * // => true\n     *\n     * _.gte(3, 3);\n     * // => true\n     *\n     * _.gte(1, 3);\n     * // => false\n     */\n    var gte = createRelationalOperation(function(value, other) {\n      return value >= other;\n    });\n\n    /**\n     * Checks if `value` is likely an `arguments` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArguments(function() { return arguments; }());\n     * // => true\n     *\n     * _.isArguments([1, 2, 3]);\n     * // => false\n     */\n    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n        !propertyIsEnumerable.call(value, 'callee');\n    };\n\n    /**\n     * Checks if `value` is classified as an `Array` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n     * @example\n     *\n     * _.isArray([1, 2, 3]);\n     * // => true\n     *\n     * _.isArray(document.body.children);\n     * // => false\n     *\n     * _.isArray('abc');\n     * // => false\n     *\n     * _.isArray(_.noop);\n     * // => false\n     */\n    var isArray = Array.isArray;\n\n    /**\n     * Checks if `value` is classified as an `ArrayBuffer` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n     * @example\n     *\n     * _.isArrayBuffer(new ArrayBuffer(2));\n     * // => true\n     *\n     * _.isArrayBuffer(new Array(2));\n     * // => false\n     */\n    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;\n\n    /**\n     * Checks if `value` is array-like. A value is considered array-like if it's\n     * not a function and has a `value.length` that's an integer greater than or\n     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n     * @example\n     *\n     * _.isArrayLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLike(document.body.children);\n     * // => true\n     *\n     * _.isArrayLike('abc');\n     * // => true\n     *\n     * _.isArrayLike(_.noop);\n     * // => false\n     */\n    function isArrayLike(value) {\n      return value != null && isLength(value.length) && !isFunction(value);\n    }\n\n    /**\n     * This method is like `_.isArrayLike` except that it also checks if `value`\n     * is an object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array-like object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArrayLikeObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLikeObject(document.body.children);\n     * // => true\n     *\n     * _.isArrayLikeObject('abc');\n     * // => false\n     *\n     * _.isArrayLikeObject(_.noop);\n     * // => false\n     */\n    function isArrayLikeObject(value) {\n      return isObjectLike(value) && isArrayLike(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a boolean primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.\n     * @example\n     *\n     * _.isBoolean(false);\n     * // => true\n     *\n     * _.isBoolean(null);\n     * // => false\n     */\n    function isBoolean(value) {\n      return value === true || value === false ||\n        (isObjectLike(value) && baseGetTag(value) == boolTag);\n    }\n\n    /**\n     * Checks if `value` is a buffer.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n     * @example\n     *\n     * _.isBuffer(new Buffer(2));\n     * // => true\n     *\n     * _.isBuffer(new Uint8Array(2));\n     * // => false\n     */\n    var isBuffer = nativeIsBuffer || stubFalse;\n\n    /**\n     * Checks if `value` is classified as a `Date` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n     * @example\n     *\n     * _.isDate(new Date);\n     * // => true\n     *\n     * _.isDate('Mon April 23 2012');\n     * // => false\n     */\n    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;\n\n    /**\n     * Checks if `value` is likely a DOM element.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.\n     * @example\n     *\n     * _.isElement(document.body);\n     * // => true\n     *\n     * _.isElement('<body>');\n     * // => false\n     */\n    function isElement(value) {\n      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);\n    }\n\n    /**\n     * Checks if `value` is an empty object, collection, map, or set.\n     *\n     * Objects are considered empty if they have no own enumerable string keyed\n     * properties.\n     *\n     * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n     * jQuery-like collections are considered empty if they have a `length` of `0`.\n     * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n     * @example\n     *\n     * _.isEmpty(null);\n     * // => true\n     *\n     * _.isEmpty(true);\n     * // => true\n     *\n     * _.isEmpty(1);\n     * // => true\n     *\n     * _.isEmpty([1, 2, 3]);\n     * // => false\n     *\n     * _.isEmpty({ 'a': 1 });\n     * // => false\n     */\n    function isEmpty(value) {\n      if (value == null) {\n        return true;\n      }\n      if (isArrayLike(value) &&\n          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||\n            isBuffer(value) || isTypedArray(value) || isArguments(value))) {\n        return !value.length;\n      }\n      var tag = getTag(value);\n      if (tag == mapTag || tag == setTag) {\n        return !value.size;\n      }\n      if (isPrototype(value)) {\n        return !baseKeys(value).length;\n      }\n      for (var key in value) {\n        if (hasOwnProperty.call(value, key)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Performs a deep comparison between two values to determine if they are\n     * equivalent.\n     *\n     * **Note:** This method supports comparing arrays, array buffers, booleans,\n     * date objects, error objects, maps, numbers, `Object` objects, regexes,\n     * sets, strings, symbols, and typed arrays. `Object` objects are compared\n     * by their own, not inherited, enumerable properties. Functions and DOM\n     * nodes are compared by strict equality, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     * var other = { 'a': 1 };\n     *\n     * _.isEqual(object, other);\n     * // => true\n     *\n     * object === other;\n     * // => false\n     */\n    function isEqual(value, other) {\n      return baseIsEqual(value, other);\n    }\n\n    /**\n     * This method is like `_.isEqual` except that it accepts `customizer` which\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n     * are handled by the method instead. The `customizer` is invoked with up to\n     * six arguments: (objValue, othValue [, index|key, object, other, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, othValue) {\n     *   if (isGreeting(objValue) && isGreeting(othValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var array = ['hello', 'goodbye'];\n     * var other = ['hi', 'goodbye'];\n     *\n     * _.isEqualWith(array, other, customizer);\n     * // => true\n     */\n    function isEqualWith(value, other, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      var result = customizer ? customizer(value, other) : undefined;\n      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;\n    }\n\n    /**\n     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,\n     * `SyntaxError`, `TypeError`, or `URIError` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.\n     * @example\n     *\n     * _.isError(new Error);\n     * // => true\n     *\n     * _.isError(Error);\n     * // => false\n     */\n    function isError(value) {\n      if (!isObjectLike(value)) {\n        return false;\n      }\n      var tag = baseGetTag(value);\n      return tag == errorTag || tag == domExcTag ||\n        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));\n    }\n\n    /**\n     * Checks if `value` is a finite primitive number.\n     *\n     * **Note:** This method is based on\n     * [`Number.isFinite`](https://mdn.io/Number/isFinite).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.\n     * @example\n     *\n     * _.isFinite(3);\n     * // => true\n     *\n     * _.isFinite(Number.MIN_VALUE);\n     * // => true\n     *\n     * _.isFinite(Infinity);\n     * // => false\n     *\n     * _.isFinite('3');\n     * // => false\n     */\n    function isFinite(value) {\n      return typeof value == 'number' && nativeIsFinite(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Function` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n     * @example\n     *\n     * _.isFunction(_);\n     * // => true\n     *\n     * _.isFunction(/abc/);\n     * // => false\n     */\n    function isFunction(value) {\n      if (!isObject(value)) {\n        return false;\n      }\n      // The use of `Object#toString` avoids issues with the `typeof` operator\n      // in Safari 9 which returns 'object' for typed arrays and other constructors.\n      var tag = baseGetTag(value);\n      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n    }\n\n    /**\n     * Checks if `value` is an integer.\n     *\n     * **Note:** This method is based on\n     * [`Number.isInteger`](https://mdn.io/Number/isInteger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.\n     * @example\n     *\n     * _.isInteger(3);\n     * // => true\n     *\n     * _.isInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isInteger(Infinity);\n     * // => false\n     *\n     * _.isInteger('3');\n     * // => false\n     */\n    function isInteger(value) {\n      return typeof value == 'number' && value == toInteger(value);\n    }\n\n    /**\n     * Checks if `value` is a valid array-like length.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n     * @example\n     *\n     * _.isLength(3);\n     * // => true\n     *\n     * _.isLength(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isLength(Infinity);\n     * // => false\n     *\n     * _.isLength('3');\n     * // => false\n     */\n    function isLength(value) {\n      return typeof value == 'number' &&\n        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is the\n     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n     * @example\n     *\n     * _.isObject({});\n     * // => true\n     *\n     * _.isObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isObject(_.noop);\n     * // => true\n     *\n     * _.isObject(null);\n     * // => false\n     */\n    function isObject(value) {\n      var type = typeof value;\n      return value != null && (type == 'object' || type == 'function');\n    }\n\n    /**\n     * Checks if `value` is object-like. A value is object-like if it's not `null`\n     * and has a `typeof` result of \"object\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n     * @example\n     *\n     * _.isObjectLike({});\n     * // => true\n     *\n     * _.isObjectLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isObjectLike(_.noop);\n     * // => false\n     *\n     * _.isObjectLike(null);\n     * // => false\n     */\n    function isObjectLike(value) {\n      return value != null && typeof value == 'object';\n    }\n\n    /**\n     * Checks if `value` is classified as a `Map` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n     * @example\n     *\n     * _.isMap(new Map);\n     * // => true\n     *\n     * _.isMap(new WeakMap);\n     * // => false\n     */\n    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\n    /**\n     * Performs a partial deep comparison between `object` and `source` to\n     * determine if `object` contains equivalent property values.\n     *\n     * **Note:** This method is equivalent to `_.matches` when `source` is\n     * partially applied.\n     *\n     * Partial comparisons will match empty array and empty object `source`\n     * values against any array or object value, respectively. See `_.isEqual`\n     * for a list of supported value comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     *\n     * _.isMatch(object, { 'b': 2 });\n     * // => true\n     *\n     * _.isMatch(object, { 'b': 1 });\n     * // => false\n     */\n    function isMatch(object, source) {\n      return object === source || baseIsMatch(object, source, getMatchData(source));\n    }\n\n    /**\n     * This method is like `_.isMatch` except that it accepts `customizer` which\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n     * are handled by the method instead. The `customizer` is invoked with five\n     * arguments: (objValue, srcValue, index|key, object, source).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (isGreeting(objValue) && isGreeting(srcValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var object = { 'greeting': 'hello' };\n     * var source = { 'greeting': 'hi' };\n     *\n     * _.isMatchWith(object, source, customizer);\n     * // => true\n     */\n    function isMatchWith(object, source, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseIsMatch(object, source, getMatchData(source), customizer);\n    }\n\n    /**\n     * Checks if `value` is `NaN`.\n     *\n     * **Note:** This method is based on\n     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as\n     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for\n     * `undefined` and other non-number values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n     * @example\n     *\n     * _.isNaN(NaN);\n     * // => true\n     *\n     * _.isNaN(new Number(NaN));\n     * // => true\n     *\n     * isNaN(undefined);\n     * // => true\n     *\n     * _.isNaN(undefined);\n     * // => false\n     */\n    function isNaN(value) {\n      // An `NaN` primitive is the only value that is not equal to itself.\n      // Perform the `toStringTag` check first to avoid errors with some\n      // ActiveX objects in IE.\n      return isNumber(value) && value != +value;\n    }\n\n    /**\n     * Checks if `value` is a pristine native function.\n     *\n     * **Note:** This method can't reliably detect native functions in the presence\n     * of the core-js package because core-js circumvents this kind of detection.\n     * Despite multiple requests, the core-js maintainer has made it clear: any\n     * attempt to fix the detection will be obstructed. As a result, we're left\n     * with little choice but to throw an error. Unfortunately, this also affects\n     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),\n     * which rely on core-js.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     * @example\n     *\n     * _.isNative(Array.prototype.push);\n     * // => true\n     *\n     * _.isNative(_);\n     * // => false\n     */\n    function isNative(value) {\n      if (isMaskable(value)) {\n        throw new Error(CORE_ERROR_TEXT);\n      }\n      return baseIsNative(value);\n    }\n\n    /**\n     * Checks if `value` is `null`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\n     * @example\n     *\n     * _.isNull(null);\n     * // => true\n     *\n     * _.isNull(void 0);\n     * // => false\n     */\n    function isNull(value) {\n      return value === null;\n    }\n\n    /**\n     * Checks if `value` is `null` or `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.\n     * @example\n     *\n     * _.isNil(null);\n     * // => true\n     *\n     * _.isNil(void 0);\n     * // => true\n     *\n     * _.isNil(NaN);\n     * // => false\n     */\n    function isNil(value) {\n      return value == null;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Number` primitive or object.\n     *\n     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are\n     * classified as numbers, use the `_.isFinite` method.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a number, else `false`.\n     * @example\n     *\n     * _.isNumber(3);\n     * // => true\n     *\n     * _.isNumber(Number.MIN_VALUE);\n     * // => true\n     *\n     * _.isNumber(Infinity);\n     * // => true\n     *\n     * _.isNumber('3');\n     * // => false\n     */\n    function isNumber(value) {\n      return typeof value == 'number' ||\n        (isObjectLike(value) && baseGetTag(value) == numberTag);\n    }\n\n    /**\n     * Checks if `value` is a plain object, that is, an object created by the\n     * `Object` constructor or one with a `[[Prototype]]` of `null`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.8.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * _.isPlainObject(new Foo);\n     * // => false\n     *\n     * _.isPlainObject([1, 2, 3]);\n     * // => false\n     *\n     * _.isPlainObject({ 'x': 0, 'y': 0 });\n     * // => true\n     *\n     * _.isPlainObject(Object.create(null));\n     * // => true\n     */\n    function isPlainObject(value) {\n      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n        return false;\n      }\n      var proto = getPrototype(value);\n      if (proto === null) {\n        return true;\n      }\n      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n      return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n        funcToString.call(Ctor) == objectCtorString;\n    }\n\n    /**\n     * Checks if `value` is classified as a `RegExp` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n     * @example\n     *\n     * _.isRegExp(/abc/);\n     * // => true\n     *\n     * _.isRegExp('/abc/');\n     * // => false\n     */\n    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n\n    /**\n     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754\n     * double precision number which isn't the result of a rounded unsafe integer.\n     *\n     * **Note:** This method is based on\n     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.\n     * @example\n     *\n     * _.isSafeInteger(3);\n     * // => true\n     *\n     * _.isSafeInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isSafeInteger(Infinity);\n     * // => false\n     *\n     * _.isSafeInteger('3');\n     * // => false\n     */\n    function isSafeInteger(value) {\n      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Set` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n     * @example\n     *\n     * _.isSet(new Set);\n     * // => true\n     *\n     * _.isSet(new WeakSet);\n     * // => false\n     */\n    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\n    /**\n     * Checks if `value` is classified as a `String` primitive or object.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n     * @example\n     *\n     * _.isString('abc');\n     * // => true\n     *\n     * _.isString(1);\n     * // => false\n     */\n    function isString(value) {\n      return typeof value == 'string' ||\n        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Symbol` primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n     * @example\n     *\n     * _.isSymbol(Symbol.iterator);\n     * // => true\n     *\n     * _.isSymbol('abc');\n     * // => false\n     */\n    function isSymbol(value) {\n      return typeof value == 'symbol' ||\n        (isObjectLike(value) && baseGetTag(value) == symbolTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a typed array.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     * @example\n     *\n     * _.isTypedArray(new Uint8Array);\n     * // => true\n     *\n     * _.isTypedArray([]);\n     * // => false\n     */\n    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n    /**\n     * Checks if `value` is `undefined`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n     * @example\n     *\n     * _.isUndefined(void 0);\n     * // => true\n     *\n     * _.isUndefined(null);\n     * // => false\n     */\n    function isUndefined(value) {\n      return value === undefined;\n    }\n\n    /**\n     * Checks if `value` is classified as a `WeakMap` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.\n     * @example\n     *\n     * _.isWeakMap(new WeakMap);\n     * // => true\n     *\n     * _.isWeakMap(new Map);\n     * // => false\n     */\n    function isWeakMap(value) {\n      return isObjectLike(value) && getTag(value) == weakMapTag;\n    }\n\n    /**\n     * Checks if `value` is classified as a `WeakSet` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.\n     * @example\n     *\n     * _.isWeakSet(new WeakSet);\n     * // => true\n     *\n     * _.isWeakSet(new Set);\n     * // => false\n     */\n    function isWeakSet(value) {\n      return isObjectLike(value) && baseGetTag(value) == weakSetTag;\n    }\n\n    /**\n     * Checks if `value` is less than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\n     *  else `false`.\n     * @see _.gt\n     * @example\n     *\n     * _.lt(1, 3);\n     * // => true\n     *\n     * _.lt(3, 3);\n     * // => false\n     *\n     * _.lt(3, 1);\n     * // => false\n     */\n    var lt = createRelationalOperation(baseLt);\n\n    /**\n     * Checks if `value` is less than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than or equal to\n     *  `other`, else `false`.\n     * @see _.gte\n     * @example\n     *\n     * _.lte(1, 3);\n     * // => true\n     *\n     * _.lte(3, 3);\n     * // => true\n     *\n     * _.lte(3, 1);\n     * // => false\n     */\n    var lte = createRelationalOperation(function(value, other) {\n      return value <= other;\n    });\n\n    /**\n     * Converts `value` to an array.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the converted array.\n     * @example\n     *\n     * _.toArray({ 'a': 1, 'b': 2 });\n     * // => [1, 2]\n     *\n     * _.toArray('abc');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toArray(1);\n     * // => []\n     *\n     * _.toArray(null);\n     * // => []\n     */\n    function toArray(value) {\n      if (!value) {\n        return [];\n      }\n      if (isArrayLike(value)) {\n        return isString(value) ? stringToArray(value) : copyArray(value);\n      }\n      if (symIterator && value[symIterator]) {\n        return iteratorToArray(value[symIterator]());\n      }\n      var tag = getTag(value),\n          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);\n\n      return func(value);\n    }\n\n    /**\n     * Converts `value` to a finite number.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.12.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted number.\n     * @example\n     *\n     * _.toFinite(3.2);\n     * // => 3.2\n     *\n     * _.toFinite(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toFinite(Infinity);\n     * // => 1.7976931348623157e+308\n     *\n     * _.toFinite('3.2');\n     * // => 3.2\n     */\n    function toFinite(value) {\n      if (!value) {\n        return value === 0 ? value : 0;\n      }\n      value = toNumber(value);\n      if (value === INFINITY || value === -INFINITY) {\n        var sign = (value < 0 ? -1 : 1);\n        return sign * MAX_INTEGER;\n      }\n      return value === value ? value : 0;\n    }\n\n    /**\n     * Converts `value` to an integer.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toInteger(3.2);\n     * // => 3\n     *\n     * _.toInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toInteger(Infinity);\n     * // => 1.7976931348623157e+308\n     *\n     * _.toInteger('3.2');\n     * // => 3\n     */\n    function toInteger(value) {\n      var result = toFinite(value),\n          remainder = result % 1;\n\n      return result === result ? (remainder ? result - remainder : result) : 0;\n    }\n\n    /**\n     * Converts `value` to an integer suitable for use as the length of an\n     * array-like object.\n     *\n     * **Note:** This method is based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toLength(3.2);\n     * // => 3\n     *\n     * _.toLength(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toLength(Infinity);\n     * // => 4294967295\n     *\n     * _.toLength('3.2');\n     * // => 3\n     */\n    function toLength(value) {\n      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;\n    }\n\n    /**\n     * Converts `value` to a number.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     * @example\n     *\n     * _.toNumber(3.2);\n     * // => 3.2\n     *\n     * _.toNumber(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toNumber(Infinity);\n     * // => Infinity\n     *\n     * _.toNumber('3.2');\n     * // => 3.2\n     */\n    function toNumber(value) {\n      if (typeof value == 'number') {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      if (isObject(value)) {\n        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n        value = isObject(other) ? (other + '') : other;\n      }\n      if (typeof value != 'string') {\n        return value === 0 ? value : +value;\n      }\n      value = baseTrim(value);\n      var isBinary = reIsBinary.test(value);\n      return (isBinary || reIsOctal.test(value))\n        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n        : (reIsBadHex.test(value) ? NAN : +value);\n    }\n\n    /**\n     * Converts `value` to a plain object flattening inherited enumerable string\n     * keyed properties of `value` to own properties of the plain object.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Object} Returns the converted plain object.\n     * @example\n     *\n     * function Foo() {\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.assign({ 'a': 1 }, new Foo);\n     * // => { 'a': 1, 'b': 2 }\n     *\n     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n     * // => { 'a': 1, 'b': 2, 'c': 3 }\n     */\n    function toPlainObject(value) {\n      return copyObject(value, keysIn(value));\n    }\n\n    /**\n     * Converts `value` to a safe integer. A safe integer can be compared and\n     * represented correctly.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toSafeInteger(3.2);\n     * // => 3\n     *\n     * _.toSafeInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toSafeInteger(Infinity);\n     * // => 9007199254740991\n     *\n     * _.toSafeInteger('3.2');\n     * // => 3\n     */\n    function toSafeInteger(value) {\n      return value\n        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)\n        : (value === 0 ? value : 0);\n    }\n\n    /**\n     * Converts `value` to a string. An empty string is returned for `null`\n     * and `undefined` values. The sign of `-0` is preserved.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.toString(null);\n     * // => ''\n     *\n     * _.toString(-0);\n     * // => '-0'\n     *\n     * _.toString([1, 2, 3]);\n     * // => '1,2,3'\n     */\n    function toString(value) {\n      return value == null ? '' : baseToString(value);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Assigns own enumerable string keyed properties of source objects to the\n     * destination object. Source objects are applied from left to right.\n     * Subsequent sources overwrite property assignments of previous sources.\n     *\n     * **Note:** This method mutates `object` and is loosely based on\n     * [`Object.assign`](https://mdn.io/Object/assign).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.10.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.assignIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * function Bar() {\n     *   this.c = 3;\n     * }\n     *\n     * Foo.prototype.b = 2;\n     * Bar.prototype.d = 4;\n     *\n     * _.assign({ 'a': 0 }, new Foo, new Bar);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    var assign = createAssigner(function(object, source) {\n      if (isPrototype(source) || isArrayLike(source)) {\n        copyObject(source, keys(source), object);\n        return;\n      }\n      for (var key in source) {\n        if (hasOwnProperty.call(source, key)) {\n          assignValue(object, key, source[key]);\n        }\n      }\n    });\n\n    /**\n     * This method is like `_.assign` except that it iterates over own and\n     * inherited source properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias extend\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.assign\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * function Bar() {\n     *   this.c = 3;\n     * }\n     *\n     * Foo.prototype.b = 2;\n     * Bar.prototype.d = 4;\n     *\n     * _.assignIn({ 'a': 0 }, new Foo, new Bar);\n     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }\n     */\n    var assignIn = createAssigner(function(object, source) {\n      copyObject(source, keysIn(source), object);\n    });\n\n    /**\n     * This method is like `_.assignIn` except that it accepts `customizer`\n     * which is invoked to produce the assigned values. If `customizer` returns\n     * `undefined`, assignment is handled by the method instead. The `customizer`\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias extendWith\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @see _.assignWith\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignInWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {\n      copyObject(source, keysIn(source), object, customizer);\n    });\n\n    /**\n     * This method is like `_.assign` except that it accepts `customizer`\n     * which is invoked to produce the assigned values. If `customizer` returns\n     * `undefined`, assignment is handled by the method instead. The `customizer`\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @see _.assignInWith\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {\n      copyObject(source, keys(source), object, customizer);\n    });\n\n    /**\n     * Creates an array of values corresponding to `paths` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Array} Returns the picked values.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _.at(object, ['a[0].b.c', 'a[1]']);\n     * // => [3, 4]\n     */\n    var at = flatRest(baseAt);\n\n    /**\n     * Creates an object that inherits from the `prototype` object. If a\n     * `properties` object is given, its own enumerable string keyed properties\n     * are assigned to the created object.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.3.0\n     * @category Object\n     * @param {Object} prototype The object to inherit from.\n     * @param {Object} [properties] The properties to assign to the object.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * function Circle() {\n     *   Shape.call(this);\n     * }\n     *\n     * Circle.prototype = _.create(Shape.prototype, {\n     *   'constructor': Circle\n     * });\n     *\n     * var circle = new Circle;\n     * circle instanceof Circle;\n     * // => true\n     *\n     * circle instanceof Shape;\n     * // => true\n     */\n    function create(prototype, properties) {\n      var result = baseCreate(prototype);\n      return properties == null ? result : baseAssign(result, properties);\n    }\n\n    /**\n     * Assigns own and inherited enumerable string keyed properties of source\n     * objects to the destination object for all destination properties that\n     * resolve to `undefined`. Source objects are applied from left to right.\n     * Once a property is set, additional values of the same property are ignored.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.defaultsDeep\n     * @example\n     *\n     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var defaults = baseRest(function(object, sources) {\n      object = Object(object);\n\n      var index = -1;\n      var length = sources.length;\n      var guard = length > 2 ? sources[2] : undefined;\n\n      if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n        length = 1;\n      }\n\n      while (++index < length) {\n        var source = sources[index];\n        var props = keysIn(source);\n        var propsIndex = -1;\n        var propsLength = props.length;\n\n        while (++propsIndex < propsLength) {\n          var key = props[propsIndex];\n          var value = object[key];\n\n          if (value === undefined ||\n              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n            object[key] = source[key];\n          }\n        }\n      }\n\n      return object;\n    });\n\n    /**\n     * This method is like `_.defaults` except that it recursively assigns\n     * default properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.defaults\n     * @example\n     *\n     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });\n     * // => { 'a': { 'b': 2, 'c': 3 } }\n     */\n    var defaultsDeep = baseRest(function(args) {\n      args.push(undefined, customDefaultsMerge);\n      return apply(mergeWith, undefined, args);\n    });\n\n    /**\n     * This method is like `_.find` except that it returns the key of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element,\n     *  else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findKey(users, function(o) { return o.age < 40; });\n     * // => 'barney' (iteration order is not guaranteed)\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findKey(users, { 'age': 1, 'active': true });\n     * // => 'pebbles'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findKey(users, 'active');\n     * // => 'barney'\n     */\n    function findKey(object, predicate) {\n      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);\n    }\n\n    /**\n     * This method is like `_.findKey` except that it iterates over elements of\n     * a collection in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element,\n     *  else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findLastKey(users, function(o) { return o.age < 40; });\n     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findLastKey(users, { 'age': 36, 'active': true });\n     * // => 'barney'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findLastKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findLastKey(users, 'active');\n     * // => 'pebbles'\n     */\n    function findLastKey(object, predicate) {\n      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);\n    }\n\n    /**\n     * Iterates over own and inherited enumerable string keyed properties of an\n     * object and invokes `iteratee` for each property. The iteratee is invoked\n     * with three arguments: (value, key, object). Iteratee functions may exit\n     * iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forInRight\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forIn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).\n     */\n    function forIn(object, iteratee) {\n      return object == null\n        ? object\n        : baseFor(object, getIteratee(iteratee, 3), keysIn);\n    }\n\n    /**\n     * This method is like `_.forIn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forInRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.\n     */\n    function forInRight(object, iteratee) {\n      return object == null\n        ? object\n        : baseForRight(object, getIteratee(iteratee, 3), keysIn);\n    }\n\n    /**\n     * Iterates over own enumerable string keyed properties of an object and\n     * invokes `iteratee` for each property. The iteratee is invoked with three\n     * arguments: (value, key, object). Iteratee functions may exit iteration\n     * early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forOwnRight\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n     */\n    function forOwn(object, iteratee) {\n      return object && baseForOwn(object, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.forOwn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forOwn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwnRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.\n     */\n    function forOwnRight(object, iteratee) {\n      return object && baseForOwnRight(object, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * Creates an array of function property names from own enumerable properties\n     * of `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the function names.\n     * @see _.functionsIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functions(new Foo);\n     * // => ['a', 'b']\n     */\n    function functions(object) {\n      return object == null ? [] : baseFunctions(object, keys(object));\n    }\n\n    /**\n     * Creates an array of function property names from own and inherited\n     * enumerable properties of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the function names.\n     * @see _.functions\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functionsIn(new Foo);\n     * // => ['a', 'b', 'c']\n     */\n    function functionsIn(object) {\n      return object == null ? [] : baseFunctions(object, keysIn(object));\n    }\n\n    /**\n     * Gets the value at `path` of `object`. If the resolved value is\n     * `undefined`, the `defaultValue` is returned in its place.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.get(object, 'a[0].b.c');\n     * // => 3\n     *\n     * _.get(object, ['a', '0', 'b', 'c']);\n     * // => 3\n     *\n     * _.get(object, 'a.b.c', 'default');\n     * // => 'default'\n     */\n    function get(object, path, defaultValue) {\n      var result = object == null ? undefined : baseGet(object, path);\n      return result === undefined ? defaultValue : result;\n    }\n\n    /**\n     * Checks if `path` is a direct property of `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = { 'a': { 'b': 2 } };\n     * var other = _.create({ 'a': _.create({ 'b': 2 }) });\n     *\n     * _.has(object, 'a');\n     * // => true\n     *\n     * _.has(object, 'a.b');\n     * // => true\n     *\n     * _.has(object, ['a', 'b']);\n     * // => true\n     *\n     * _.has(other, 'a');\n     * // => false\n     */\n    function has(object, path) {\n      return object != null && hasPath(object, path, baseHas);\n    }\n\n    /**\n     * Checks if `path` is a direct or inherited property of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n     *\n     * _.hasIn(object, 'a');\n     * // => true\n     *\n     * _.hasIn(object, 'a.b');\n     * // => true\n     *\n     * _.hasIn(object, ['a', 'b']);\n     * // => true\n     *\n     * _.hasIn(object, 'b');\n     * // => false\n     */\n    function hasIn(object, path) {\n      return object != null && hasPath(object, path, baseHasIn);\n    }\n\n    /**\n     * Creates an object composed of the inverted keys and values of `object`.\n     * If `object` contains duplicate values, subsequent values overwrite\n     * property assignments of previous values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.7.0\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invert(object);\n     * // => { '1': 'c', '2': 'b' }\n     */\n    var invert = createInverter(function(result, value, key) {\n      if (value != null &&\n          typeof value.toString != 'function') {\n        value = nativeObjectToString.call(value);\n      }\n\n      result[value] = key;\n    }, constant(identity));\n\n    /**\n     * This method is like `_.invert` except that the inverted object is generated\n     * from the results of running each element of `object` thru `iteratee`. The\n     * corresponding inverted value of each inverted key is an array of keys\n     * responsible for generating the inverted value. The iteratee is invoked\n     * with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.1.0\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invertBy(object);\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     *\n     * _.invertBy(object, function(value) {\n     *   return 'group' + value;\n     * });\n     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }\n     */\n    var invertBy = createInverter(function(result, value, key) {\n      if (value != null &&\n          typeof value.toString != 'function') {\n        value = nativeObjectToString.call(value);\n      }\n\n      if (hasOwnProperty.call(result, value)) {\n        result[value].push(key);\n      } else {\n        result[value] = [key];\n      }\n    }, getIteratee);\n\n    /**\n     * Invokes the method at `path` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };\n     *\n     * _.invoke(object, 'a[0].b.c.slice', 1, 3);\n     * // => [2, 3]\n     */\n    var invoke = baseRest(baseInvoke);\n\n    /**\n     * Creates an array of the own enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects. See the\n     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n     * for more details.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keys(new Foo);\n     * // => ['a', 'b'] (iteration order is not guaranteed)\n     *\n     * _.keys('hi');\n     * // => ['0', '1']\n     */\n    function keys(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keysIn(new Foo);\n     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n     */\n    function keysIn(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n    }\n\n    /**\n     * The opposite of `_.mapValues`; this method creates an object with the\n     * same values as `object` and keys generated by running each own enumerable\n     * string keyed property of `object` thru `iteratee`. The iteratee is invoked\n     * with three arguments: (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @see _.mapValues\n     * @example\n     *\n     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   return key + value;\n     * });\n     * // => { 'a1': 1, 'b2': 2 }\n     */\n    function mapKeys(object, iteratee) {\n      var result = {};\n      iteratee = getIteratee(iteratee, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        baseAssignValue(result, iteratee(value, key, object), value);\n      });\n      return result;\n    }\n\n    /**\n     * Creates an object with the same keys as `object` and values generated\n     * by running each own enumerable string keyed property of `object` thru\n     * `iteratee`. The iteratee is invoked with three arguments:\n     * (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @see _.mapKeys\n     * @example\n     *\n     * var users = {\n     *   'fred':    { 'user': 'fred',    'age': 40 },\n     *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n     * };\n     *\n     * _.mapValues(users, function(o) { return o.age; });\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.mapValues(users, 'age');\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     */\n    function mapValues(object, iteratee) {\n      var result = {};\n      iteratee = getIteratee(iteratee, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        baseAssignValue(result, key, iteratee(value, key, object));\n      });\n      return result;\n    }\n\n    /**\n     * This method is like `_.assign` except that it recursively merges own and\n     * inherited enumerable string keyed properties of source objects into the\n     * destination object. Source properties that resolve to `undefined` are\n     * skipped if a destination value exists. Array and plain object properties\n     * are merged recursively. Other objects and value types are overridden by\n     * assignment. Source objects are applied from left to right. Subsequent\n     * sources overwrite property assignments of previous sources.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {\n     *   'a': [{ 'b': 2 }, { 'd': 4 }]\n     * };\n     *\n     * var other = {\n     *   'a': [{ 'c': 3 }, { 'e': 5 }]\n     * };\n     *\n     * _.merge(object, other);\n     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n     */\n    var merge = createAssigner(function(object, source, srcIndex) {\n      baseMerge(object, source, srcIndex);\n    });\n\n    /**\n     * This method is like `_.merge` except that it accepts `customizer` which\n     * is invoked to produce the merged values of the destination and source\n     * properties. If `customizer` returns `undefined`, merging is handled by the\n     * method instead. The `customizer` is invoked with six arguments:\n     * (objValue, srcValue, key, object, source, stack).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} customizer The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (_.isArray(objValue)) {\n     *     return objValue.concat(srcValue);\n     *   }\n     * }\n     *\n     * var object = { 'a': [1], 'b': [2] };\n     * var other = { 'a': [3], 'b': [4] };\n     *\n     * _.mergeWith(object, other, customizer);\n     * // => { 'a': [1, 3], 'b': [2, 4] }\n     */\n    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {\n      baseMerge(object, source, srcIndex, customizer);\n    });\n\n    /**\n     * The opposite of `_.pick`; this method creates an object composed of the\n     * own and inherited enumerable property paths of `object` that are not omitted.\n     *\n     * **Note:** This method is considerably slower than `_.pick`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [paths] The property paths to omit.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omit(object, ['a', 'c']);\n     * // => { 'b': '2' }\n     */\n    var omit = flatRest(function(object, paths) {\n      var result = {};\n      if (object == null) {\n        return result;\n      }\n      var isDeep = false;\n      paths = arrayMap(paths, function(path) {\n        path = castPath(path, object);\n        isDeep || (isDeep = path.length > 1);\n        return path;\n      });\n      copyObject(object, getAllKeysIn(object), result);\n      if (isDeep) {\n        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);\n      }\n      var length = paths.length;\n      while (length--) {\n        baseUnset(result, paths[length]);\n      }\n      return result;\n    });\n\n    /**\n     * The opposite of `_.pickBy`; this method creates an object composed of\n     * the own and inherited enumerable string keyed properties of `object` that\n     * `predicate` doesn't return truthy for. The predicate is invoked with two\n     * arguments: (value, key).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omitBy(object, _.isNumber);\n     * // => { 'b': '2' }\n     */\n    function omitBy(object, predicate) {\n      return pickBy(object, negate(getIteratee(predicate)));\n    }\n\n    /**\n     * Creates an object composed of the picked `object` properties.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pick(object, ['a', 'c']);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    var pick = flatRest(function(object, paths) {\n      return object == null ? {} : basePick(object, paths);\n    });\n\n    /**\n     * Creates an object composed of the `object` properties `predicate` returns\n     * truthy for. The predicate is invoked with two arguments: (value, key).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pickBy(object, _.isNumber);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    function pickBy(object, predicate) {\n      if (object == null) {\n        return {};\n      }\n      var props = arrayMap(getAllKeysIn(object), function(prop) {\n        return [prop];\n      });\n      predicate = getIteratee(predicate);\n      return basePickBy(object, props, function(value, path) {\n        return predicate(value, path[0]);\n      });\n    }\n\n    /**\n     * This method is like `_.get` except that if the resolved value is a\n     * function it's invoked with the `this` binding of its parent object and\n     * its result is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to resolve.\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };\n     *\n     * _.result(object, 'a[0].b.c1');\n     * // => 3\n     *\n     * _.result(object, 'a[0].b.c2');\n     * // => 4\n     *\n     * _.result(object, 'a[0].b.c3', 'default');\n     * // => 'default'\n     *\n     * _.result(object, 'a[0].b.c3', _.constant('default'));\n     * // => 'default'\n     */\n    function result(object, path, defaultValue) {\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length;\n\n      // Ensure the loop is entered when path is empty.\n      if (!length) {\n        length = 1;\n        object = undefined;\n      }\n      while (++index < length) {\n        var value = object == null ? undefined : object[toKey(path[index])];\n        if (value === undefined) {\n          index = length;\n          value = defaultValue;\n        }\n        object = isFunction(value) ? value.call(object) : value;\n      }\n      return object;\n    }\n\n    /**\n     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n     * it's created. Arrays are created for missing index properties while objects\n     * are created for all other missing properties. Use `_.setWith` to customize\n     * `path` creation.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.set(object, 'a[0].b.c', 4);\n     * console.log(object.a[0].b.c);\n     * // => 4\n     *\n     * _.set(object, ['x', '0', 'y', 'z'], 5);\n     * console.log(object.x[0].y.z);\n     * // => 5\n     */\n    function set(object, path, value) {\n      return object == null ? object : baseSet(object, path, value);\n    }\n\n    /**\n     * This method is like `_.set` except that it accepts `customizer` which is\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n     * path creation is handled by the method instead. The `customizer` is invoked\n     * with three arguments: (nsValue, key, nsObject).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {};\n     *\n     * _.setWith(object, '[0][1]', 'a', Object);\n     * // => { '0': { '1': 'a' } }\n     */\n    function setWith(object, path, value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return object == null ? object : baseSet(object, path, value, customizer);\n    }\n\n    /**\n     * Creates an array of own enumerable string keyed-value pairs for `object`\n     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its\n     * entries are returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias entries\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairs(new Foo);\n     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)\n     */\n    var toPairs = createToPairs(keys);\n\n    /**\n     * Creates an array of own and inherited enumerable string keyed-value pairs\n     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map\n     * or set, its entries are returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias entriesIn\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairsIn(new Foo);\n     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)\n     */\n    var toPairsIn = createToPairs(keysIn);\n\n    /**\n     * An alternative to `_.reduce`; this method transforms `object` to a new\n     * `accumulator` object which is the result of running each of its own\n     * enumerable string keyed properties thru `iteratee`, with each invocation\n     * potentially mutating the `accumulator` object. If `accumulator` is not\n     * provided, a new object with the same `[[Prototype]]` will be used. The\n     * iteratee is invoked with four arguments: (accumulator, value, key, object).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The custom accumulator value.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * _.transform([2, 3, 4], function(result, n) {\n     *   result.push(n *= n);\n     *   return n % 2 == 0;\n     * }, []);\n     * // => [4, 9]\n     *\n     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     */\n    function transform(object, iteratee, accumulator) {\n      var isArr = isArray(object),\n          isArrLike = isArr || isBuffer(object) || isTypedArray(object);\n\n      iteratee = getIteratee(iteratee, 4);\n      if (accumulator == null) {\n        var Ctor = object && object.constructor;\n        if (isArrLike) {\n          accumulator = isArr ? new Ctor : [];\n        }\n        else if (isObject(object)) {\n          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};\n        }\n        else {\n          accumulator = {};\n        }\n      }\n      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {\n        return iteratee(accumulator, value, index, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * Removes the property at `path` of `object`.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 7 } }] };\n     * _.unset(object, 'a[0].b.c');\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     *\n     * _.unset(object, ['a', '0', 'b', 'c']);\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     */\n    function unset(object, path) {\n      return object == null ? true : baseUnset(object, path);\n    }\n\n    /**\n     * This method is like `_.set` except that accepts `updater` to produce the\n     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`\n     * is invoked with one argument: (value).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {Function} updater The function to produce the updated value.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.update(object, 'a[0].b.c', function(n) { return n * n; });\n     * console.log(object.a[0].b.c);\n     * // => 9\n     *\n     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });\n     * console.log(object.x[0].y.z);\n     * // => 0\n     */\n    function update(object, path, updater) {\n      return object == null ? object : baseUpdate(object, path, castFunction(updater));\n    }\n\n    /**\n     * This method is like `_.update` except that it accepts `customizer` which is\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n     * path creation is handled by the method instead. The `customizer` is invoked\n     * with three arguments: (nsValue, key, nsObject).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {Function} updater The function to produce the updated value.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {};\n     *\n     * _.updateWith(object, '[0][1]', _.constant('a'), Object);\n     * // => { '0': { '1': 'a' } }\n     */\n    function updateWith(object, path, updater, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);\n    }\n\n    /**\n     * Creates an array of the own enumerable string keyed property values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.values(new Foo);\n     * // => [1, 2] (iteration order is not guaranteed)\n     *\n     * _.values('hi');\n     * // => ['h', 'i']\n     */\n    function values(object) {\n      return object == null ? [] : baseValues(object, keys(object));\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable string keyed property\n     * values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.valuesIn(new Foo);\n     * // => [1, 2, 3] (iteration order is not guaranteed)\n     */\n    function valuesIn(object) {\n      return object == null ? [] : baseValues(object, keysIn(object));\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Clamps `number` within the inclusive `lower` and `upper` bounds.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Number\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     * @example\n     *\n     * _.clamp(-10, -5, 5);\n     * // => -5\n     *\n     * _.clamp(10, -5, 5);\n     * // => 5\n     */\n    function clamp(number, lower, upper) {\n      if (upper === undefined) {\n        upper = lower;\n        lower = undefined;\n      }\n      if (upper !== undefined) {\n        upper = toNumber(upper);\n        upper = upper === upper ? upper : 0;\n      }\n      if (lower !== undefined) {\n        lower = toNumber(lower);\n        lower = lower === lower ? lower : 0;\n      }\n      return baseClamp(toNumber(number), lower, upper);\n    }\n\n    /**\n     * Checks if `n` is between `start` and up to, but not including, `end`. If\n     * `end` is not specified, it's set to `start` with `start` then set to `0`.\n     * If `start` is greater than `end` the params are swapped to support\n     * negative ranges.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.3.0\n     * @category Number\n     * @param {number} number The number to check.\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     * @see _.range, _.rangeRight\n     * @example\n     *\n     * _.inRange(3, 2, 4);\n     * // => true\n     *\n     * _.inRange(4, 8);\n     * // => true\n     *\n     * _.inRange(4, 2);\n     * // => false\n     *\n     * _.inRange(2, 2);\n     * // => false\n     *\n     * _.inRange(1.2, 2);\n     * // => true\n     *\n     * _.inRange(5.2, 4);\n     * // => false\n     *\n     * _.inRange(-3, -2, -6);\n     * // => true\n     */\n    function inRange(number, start, end) {\n      start = toFinite(start);\n      if (end === undefined) {\n        end = start;\n        start = 0;\n      } else {\n        end = toFinite(end);\n      }\n      number = toNumber(number);\n      return baseInRange(number, start, end);\n    }\n\n    /**\n     * Produces a random number between the inclusive `lower` and `upper` bounds.\n     * If only one argument is provided a number between `0` and the given number\n     * is returned. If `floating` is `true`, or either `lower` or `upper` are\n     * floats, a floating-point number is returned instead of an integer.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.7.0\n     * @category Number\n     * @param {number} [lower=0] The lower bound.\n     * @param {number} [upper=1] The upper bound.\n     * @param {boolean} [floating] Specify returning a floating-point number.\n     * @returns {number} Returns the random number.\n     * @example\n     *\n     * _.random(0, 5);\n     * // => an integer between 0 and 5\n     *\n     * _.random(5);\n     * // => also an integer between 0 and 5\n     *\n     * _.random(5, true);\n     * // => a floating-point number between 0 and 5\n     *\n     * _.random(1.2, 5.2);\n     * // => a floating-point number between 1.2 and 5.2\n     */\n    function random(lower, upper, floating) {\n      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {\n        upper = floating = undefined;\n      }\n      if (floating === undefined) {\n        if (typeof upper == 'boolean') {\n          floating = upper;\n          upper = undefined;\n        }\n        else if (typeof lower == 'boolean') {\n          floating = lower;\n          lower = undefined;\n        }\n      }\n      if (lower === undefined && upper === undefined) {\n        lower = 0;\n        upper = 1;\n      }\n      else {\n        lower = toFinite(lower);\n        if (upper === undefined) {\n          upper = lower;\n          lower = 0;\n        } else {\n          upper = toFinite(upper);\n        }\n      }\n      if (lower > upper) {\n        var temp = lower;\n        lower = upper;\n        upper = temp;\n      }\n      if (floating || lower % 1 || upper % 1) {\n        var rand = nativeRandom();\n        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);\n      }\n      return baseRandom(lower, upper);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the camel cased string.\n     * @example\n     *\n     * _.camelCase('Foo Bar');\n     * // => 'fooBar'\n     *\n     * _.camelCase('--foo-bar--');\n     * // => 'fooBar'\n     *\n     * _.camelCase('__FOO_BAR__');\n     * // => 'fooBar'\n     */\n    var camelCase = createCompounder(function(result, word, index) {\n      word = word.toLowerCase();\n      return result + (index ? capitalize(word) : word);\n    });\n\n    /**\n     * Converts the first character of `string` to upper case and the remaining\n     * to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to capitalize.\n     * @returns {string} Returns the capitalized string.\n     * @example\n     *\n     * _.capitalize('FRED');\n     * // => 'Fred'\n     */\n    function capitalize(string) {\n      return upperFirst(toString(string).toLowerCase());\n    }\n\n    /**\n     * Deburrs `string` by converting\n     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)\n     * letters to basic Latin letters and removing\n     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to deburr.\n     * @returns {string} Returns the deburred string.\n     * @example\n     *\n     * _.deburr('dj vu');\n     * // => 'deja vu'\n     */\n    function deburr(string) {\n      string = toString(string);\n      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');\n    }\n\n    /**\n     * Checks if `string` ends with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=string.length] The position to search up to.\n     * @returns {boolean} Returns `true` if `string` ends with `target`,\n     *  else `false`.\n     * @example\n     *\n     * _.endsWith('abc', 'c');\n     * // => true\n     *\n     * _.endsWith('abc', 'b');\n     * // => false\n     *\n     * _.endsWith('abc', 'b', 2);\n     * // => true\n     */\n    function endsWith(string, target, position) {\n      string = toString(string);\n      target = baseToString(target);\n\n      var length = string.length;\n      position = position === undefined\n        ? length\n        : baseClamp(toInteger(position), 0, length);\n\n      var end = position;\n      position -= target.length;\n      return position >= 0 && string.slice(position, end) == target;\n    }\n\n    /**\n     * Converts the characters \"&\", \"<\", \">\", '\"', and \"'\" in `string` to their\n     * corresponding HTML entities.\n     *\n     * **Note:** No other characters are escaped. To escape additional\n     * characters use a third-party library like [_he_](https://mths.be/he).\n     *\n     * Though the \">\" character is escaped for symmetry, characters like\n     * \">\" and \"/\" don't need escaping in HTML and have no special meaning\n     * unless they're part of a tag or unquoted attribute value. See\n     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)\n     * (under \"semi-related fun fact\") for more details.\n     *\n     * When working with HTML you should always\n     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce\n     * XSS vectors.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escape('fred, barney, & pebbles');\n     * // => 'fred, barney, &amp; pebbles'\n     */\n    function escape(string) {\n      string = toString(string);\n      return (string && reHasUnescapedHtml.test(string))\n        ? string.replace(reUnescapedHtml, escapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Escapes the `RegExp` special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\",\n     * \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escapeRegExp('[lodash](https://lodash.com/)');\n     * // => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n     */\n    function escapeRegExp(string) {\n      string = toString(string);\n      return (string && reHasRegExpChar.test(string))\n        ? string.replace(reRegExpChar, '\\\\$&')\n        : string;\n    }\n\n    /**\n     * Converts `string` to\n     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the kebab cased string.\n     * @example\n     *\n     * _.kebabCase('Foo Bar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('fooBar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('__FOO_BAR__');\n     * // => 'foo-bar'\n     */\n    var kebabCase = createCompounder(function(result, word, index) {\n      return result + (index ? '-' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts `string`, as space separated words, to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.lowerCase('--Foo-Bar--');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('fooBar');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('__FOO_BAR__');\n     * // => 'foo bar'\n     */\n    var lowerCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts the first character of `string` to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.lowerFirst('Fred');\n     * // => 'fred'\n     *\n     * _.lowerFirst('FRED');\n     * // => 'fRED'\n     */\n    var lowerFirst = createCaseFirst('toLowerCase');\n\n    /**\n     * Pads `string` on the left and right sides if it's shorter than `length`.\n     * Padding characters are truncated if they can't be evenly divided by `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.pad('abc', 8);\n     * // => '  abc   '\n     *\n     * _.pad('abc', 8, '_-');\n     * // => '_-abc_-_'\n     *\n     * _.pad('abc', 3);\n     * // => 'abc'\n     */\n    function pad(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      if (!length || strLength >= length) {\n        return string;\n      }\n      var mid = (length - strLength) / 2;\n      return (\n        createPadding(nativeFloor(mid), chars) +\n        string +\n        createPadding(nativeCeil(mid), chars)\n      );\n    }\n\n    /**\n     * Pads `string` on the right side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padEnd('abc', 6);\n     * // => 'abc   '\n     *\n     * _.padEnd('abc', 6, '_-');\n     * // => 'abc_-_'\n     *\n     * _.padEnd('abc', 3);\n     * // => 'abc'\n     */\n    function padEnd(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      return (length && strLength < length)\n        ? (string + createPadding(length - strLength, chars))\n        : string;\n    }\n\n    /**\n     * Pads `string` on the left side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padStart('abc', 6);\n     * // => '   abc'\n     *\n     * _.padStart('abc', 6, '_-');\n     * // => '_-_abc'\n     *\n     * _.padStart('abc', 3);\n     * // => 'abc'\n     */\n    function padStart(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      return (length && strLength < length)\n        ? (createPadding(length - strLength, chars) + string)\n        : string;\n    }\n\n    /**\n     * Converts `string` to an integer of the specified radix. If `radix` is\n     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a\n     * hexadecimal, in which case a `radix` of `16` is used.\n     *\n     * **Note:** This method aligns with the\n     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category String\n     * @param {string} string The string to convert.\n     * @param {number} [radix=10] The radix to interpret `value` by.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.parseInt('08');\n     * // => 8\n     *\n     * _.map(['6', '08', '10'], _.parseInt);\n     * // => [6, 8, 10]\n     */\n    function parseInt(string, radix, guard) {\n      if (guard || radix == null) {\n        radix = 0;\n      } else if (radix) {\n        radix = +radix;\n      }\n      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);\n    }\n\n    /**\n     * Repeats the given string `n` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to repeat.\n     * @param {number} [n=1] The number of times to repeat the string.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the repeated string.\n     * @example\n     *\n     * _.repeat('*', 3);\n     * // => '***'\n     *\n     * _.repeat('abc', 2);\n     * // => 'abcabc'\n     *\n     * _.repeat('abc', 0);\n     * // => ''\n     */\n    function repeat(string, n, guard) {\n      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {\n        n = 1;\n      } else {\n        n = toInteger(n);\n      }\n      return baseRepeat(toString(string), n);\n    }\n\n    /**\n     * Replaces matches for `pattern` in `string` with `replacement`.\n     *\n     * **Note:** This method is based on\n     * [`String#replace`](https://mdn.io/String/replace).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to modify.\n     * @param {RegExp|string} pattern The pattern to replace.\n     * @param {Function|string} replacement The match replacement.\n     * @returns {string} Returns the modified string.\n     * @example\n     *\n     * _.replace('Hi Fred', 'Fred', 'Barney');\n     * // => 'Hi Barney'\n     */\n    function replace() {\n      var args = arguments,\n          string = toString(args[0]);\n\n      return args.length < 3 ? string : string.replace(args[1], args[2]);\n    }\n\n    /**\n     * Converts `string` to\n     * [snake case](https://en.wikipedia.org/wiki/Snake_case).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the snake cased string.\n     * @example\n     *\n     * _.snakeCase('Foo Bar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('fooBar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('--FOO-BAR--');\n     * // => 'foo_bar'\n     */\n    var snakeCase = createCompounder(function(result, word, index) {\n      return result + (index ? '_' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Splits `string` by `separator`.\n     *\n     * **Note:** This method is based on\n     * [`String#split`](https://mdn.io/String/split).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to split.\n     * @param {RegExp|string} separator The separator pattern to split by.\n     * @param {number} [limit] The length to truncate results to.\n     * @returns {Array} Returns the string segments.\n     * @example\n     *\n     * _.split('a-b-c', '-', 2);\n     * // => ['a', 'b']\n     */\n    function split(string, separator, limit) {\n      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {\n        separator = limit = undefined;\n      }\n      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;\n      if (!limit) {\n        return [];\n      }\n      string = toString(string);\n      if (string && (\n            typeof separator == 'string' ||\n            (separator != null && !isRegExp(separator))\n          )) {\n        separator = baseToString(separator);\n        if (!separator && hasUnicode(string)) {\n          return castSlice(stringToArray(string), 0, limit);\n        }\n      }\n      return string.split(separator, limit);\n    }\n\n    /**\n     * Converts `string` to\n     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.1.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the start cased string.\n     * @example\n     *\n     * _.startCase('--foo-bar--');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('fooBar');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('__FOO_BAR__');\n     * // => 'FOO BAR'\n     */\n    var startCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + upperFirst(word);\n    });\n\n    /**\n     * Checks if `string` starts with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=0] The position to search from.\n     * @returns {boolean} Returns `true` if `string` starts with `target`,\n     *  else `false`.\n     * @example\n     *\n     * _.startsWith('abc', 'a');\n     * // => true\n     *\n     * _.startsWith('abc', 'b');\n     * // => false\n     *\n     * _.startsWith('abc', 'b', 1);\n     * // => true\n     */\n    function startsWith(string, target, position) {\n      string = toString(string);\n      position = position == null\n        ? 0\n        : baseClamp(toInteger(position), 0, string.length);\n\n      target = baseToString(target);\n      return string.slice(position, position + target.length) == target;\n    }\n\n    /**\n     * Creates a compiled template function that can interpolate data properties\n     * in \"interpolate\" delimiters, HTML-escape interpolated data properties in\n     * \"escape\" delimiters, and execute JavaScript in \"evaluate\" delimiters. Data\n     * properties may be accessed as free variables in the template. If a setting\n     * object is given, it takes precedence over `_.templateSettings` values.\n     *\n     * **Note:** In the development build `_.template` utilizes\n     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)\n     * for easier debugging.\n     *\n     * For more information on precompiling templates see\n     * [lodash's custom builds documentation](https://lodash.com/custom-builds).\n     *\n     * For more information on Chrome extension sandboxes see\n     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The template string.\n     * @param {Object} [options={}] The options object.\n     * @param {RegExp} [options.escape=_.templateSettings.escape]\n     *  The HTML \"escape\" delimiter.\n     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]\n     *  The \"evaluate\" delimiter.\n     * @param {Object} [options.imports=_.templateSettings.imports]\n     *  An object to import into the template as free variables.\n     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]\n     *  The \"interpolate\" delimiter.\n     * @param {string} [options.sourceURL='lodash.templateSources[n]']\n     *  The sourceURL of the compiled template.\n     * @param {string} [options.variable='obj']\n     *  The data object variable name.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the compiled template function.\n     * @example\n     *\n     * // Use the \"interpolate\" delimiter to create a compiled template.\n     * var compiled = _.template('hello <%= user %>!');\n     * compiled({ 'user': 'fred' });\n     * // => 'hello fred!'\n     *\n     * // Use the HTML \"escape\" delimiter to escape data property values.\n     * var compiled = _.template('<b><%- value %></b>');\n     * compiled({ 'value': '<script>' });\n     * // => '<b>&lt;script&gt;</b>'\n     *\n     * // Use the \"evaluate\" delimiter to execute JavaScript and generate HTML.\n     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // Use the internal `print` function in \"evaluate\" delimiters.\n     * var compiled = _.template('<% print(\"hello \" + user); %>!');\n     * compiled({ 'user': 'barney' });\n     * // => 'hello barney!'\n     *\n     * // Use the ES template literal delimiter as an \"interpolate\" delimiter.\n     * // Disable support by replacing the \"interpolate\" delimiter.\n     * var compiled = _.template('hello ${ user }!');\n     * compiled({ 'user': 'pebbles' });\n     * // => 'hello pebbles!'\n     *\n     * // Use backslashes to treat delimiters as plain text.\n     * var compiled = _.template('<%= \"\\\\<%- value %\\\\>\" %>');\n     * compiled({ 'value': 'ignored' });\n     * // => '<%- value %>'\n     *\n     * // Use the `imports` option to import `jQuery` as `jq`.\n     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';\n     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // Use the `sourceURL` option to specify a custom sourceURL for the template.\n     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });\n     * compiled(data);\n     * // => Find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector.\n     *\n     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.\n     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });\n     * compiled.source;\n     * // => function(data) {\n     * //   var __t, __p = '';\n     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';\n     * //   return __p;\n     * // }\n     *\n     * // Use custom template delimiters.\n     * _.templateSettings.interpolate = /{{([\\s\\S]+?)}}/g;\n     * var compiled = _.template('hello {{ user }}!');\n     * compiled({ 'user': 'mustache' });\n     * // => 'hello mustache!'\n     *\n     * // Use the `source` property to inline compiled templates for meaningful\n     * // line numbers in error messages and stack traces.\n     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\\\n     *   var JST = {\\\n     *     \"main\": ' + _.template(mainText).source + '\\\n     *   };\\\n     * ');\n     */\n    function template(string, options, guard) {\n      // Based on John Resig's `tmpl` implementation\n      // (http://ejohn.org/blog/javascript-micro-templating/)\n      // and Laura Doktorova's doT.js (https://github.com/olado/doT).\n      var settings = lodash.templateSettings;\n\n      if (guard && isIterateeCall(string, options, guard)) {\n        options = undefined;\n      }\n      string = toString(string);\n      options = assignInWith({}, options, settings, customDefaultsAssignIn);\n\n      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),\n          importsKeys = keys(imports),\n          importsValues = baseValues(imports, importsKeys);\n\n      var isEscaping,\n          isEvaluating,\n          index = 0,\n          interpolate = options.interpolate || reNoMatch,\n          source = \"__p += '\";\n\n      // Compile the regexp to match each delimiter.\n      var reDelimiters = RegExp(\n        (options.escape || reNoMatch).source + '|' +\n        interpolate.source + '|' +\n        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\n        (options.evaluate || reNoMatch).source + '|$'\n      , 'g');\n\n      // Use a sourceURL for easier debugging.\n      // The sourceURL gets injected into the source that's eval-ed, so be careful\n      // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in\n      // and escape the comment, thus injecting code that gets evaled.\n      var sourceURL = '//# sourceURL=' +\n        (hasOwnProperty.call(options, 'sourceURL')\n          ? (options.sourceURL + '').replace(/\\s/g, ' ')\n          : ('lodash.templateSources[' + (++templateCounter) + ']')\n        ) + '\\n';\n\n      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n        interpolateValue || (interpolateValue = esTemplateValue);\n\n        // Escape characters that can't be included in string literals.\n        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n\n        // Replace delimiters with snippets.\n        if (escapeValue) {\n          isEscaping = true;\n          source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n        }\n        if (evaluateValue) {\n          isEvaluating = true;\n          source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n        }\n        if (interpolateValue) {\n          source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n        }\n        index = offset + match.length;\n\n        // The JS engine embedded in Adobe products needs `match` returned in\n        // order to produce the correct `offset` value.\n        return match;\n      });\n\n      source += \"';\\n\";\n\n      // If `variable` is not specified wrap a with-statement around the generated\n      // code to add the data object to the top of the scope chain.\n      var variable = hasOwnProperty.call(options, 'variable') && options.variable;\n      if (!variable) {\n        source = 'with (obj) {\\n' + source + '\\n}\\n';\n      }\n      // Throw an error if a forbidden character was found in `variable`, to prevent\n      // potential command injection attacks.\n      else if (reForbiddenIdentifierChars.test(variable)) {\n        throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);\n      }\n\n      // Cleanup code by stripping empty strings.\n      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\n        .replace(reEmptyStringMiddle, '$1')\n        .replace(reEmptyStringTrailing, '$1;');\n\n      // Frame code as the function body.\n      source = 'function(' + (variable || 'obj') + ') {\\n' +\n        (variable\n          ? ''\n          : 'obj || (obj = {});\\n'\n        ) +\n        \"var __t, __p = ''\" +\n        (isEscaping\n           ? ', __e = _.escape'\n           : ''\n        ) +\n        (isEvaluating\n          ? ', __j = Array.prototype.join;\\n' +\n            \"function print() { __p += __j.call(arguments, '') }\\n\"\n          : ';\\n'\n        ) +\n        source +\n        'return __p\\n}';\n\n      var result = attempt(function() {\n        return Function(importsKeys, sourceURL + 'return ' + source)\n          .apply(undefined, importsValues);\n      });\n\n      // Provide the compiled function's source by its `toString` method or\n      // the `source` property as a convenience for inlining compiled templates.\n      result.source = source;\n      if (isError(result)) {\n        throw result;\n      }\n      return result;\n    }\n\n    /**\n     * Converts `string`, as a whole, to lower case just like\n     * [String#toLowerCase](https://mdn.io/toLowerCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.toLower('--Foo-Bar--');\n     * // => '--foo-bar--'\n     *\n     * _.toLower('fooBar');\n     * // => 'foobar'\n     *\n     * _.toLower('__FOO_BAR__');\n     * // => '__foo_bar__'\n     */\n    function toLower(value) {\n      return toString(value).toLowerCase();\n    }\n\n    /**\n     * Converts `string`, as a whole, to upper case just like\n     * [String#toUpperCase](https://mdn.io/toUpperCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.toUpper('--foo-bar--');\n     * // => '--FOO-BAR--'\n     *\n     * _.toUpper('fooBar');\n     * // => 'FOOBAR'\n     *\n     * _.toUpper('__foo_bar__');\n     * // => '__FOO_BAR__'\n     */\n    function toUpper(value) {\n      return toString(value).toUpperCase();\n    }\n\n    /**\n     * Removes leading and trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trim('  abc  ');\n     * // => 'abc'\n     *\n     * _.trim('-_-abc-_-', '_-');\n     * // => 'abc'\n     *\n     * _.map(['  foo  ', '  bar  '], _.trim);\n     * // => ['foo', 'bar']\n     */\n    function trim(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return baseTrim(string);\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          chrSymbols = stringToArray(chars),\n          start = charsStartIndex(strSymbols, chrSymbols),\n          end = charsEndIndex(strSymbols, chrSymbols) + 1;\n\n      return castSlice(strSymbols, start, end).join('');\n    }\n\n    /**\n     * Removes trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimEnd('  abc  ');\n     * // => '  abc'\n     *\n     * _.trimEnd('-_-abc-_-', '_-');\n     * // => '-_-abc'\n     */\n    function trimEnd(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.slice(0, trimmedEndIndex(string) + 1);\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;\n\n      return castSlice(strSymbols, 0, end).join('');\n    }\n\n    /**\n     * Removes leading whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimStart('  abc  ');\n     * // => 'abc  '\n     *\n     * _.trimStart('-_-abc-_-', '_-');\n     * // => 'abc-_-'\n     */\n    function trimStart(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrimStart, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          start = charsStartIndex(strSymbols, stringToArray(chars));\n\n      return castSlice(strSymbols, start).join('');\n    }\n\n    /**\n     * Truncates `string` if it's longer than the given maximum string length.\n     * The last characters of the truncated string are replaced with the omission\n     * string which defaults to \"...\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to truncate.\n     * @param {Object} [options={}] The options object.\n     * @param {number} [options.length=30] The maximum string length.\n     * @param {string} [options.omission='...'] The string to indicate text is omitted.\n     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.\n     * @returns {string} Returns the truncated string.\n     * @example\n     *\n     * _.truncate('hi-diddly-ho there, neighborino');\n     * // => 'hi-diddly-ho there, neighbo...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': ' '\n     * });\n     * // => 'hi-diddly-ho there,...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': /,? +/\n     * });\n     * // => 'hi-diddly-ho there...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'omission': ' [...]'\n     * });\n     * // => 'hi-diddly-ho there, neig [...]'\n     */\n    function truncate(string, options) {\n      var length = DEFAULT_TRUNC_LENGTH,\n          omission = DEFAULT_TRUNC_OMISSION;\n\n      if (isObject(options)) {\n        var separator = 'separator' in options ? options.separator : separator;\n        length = 'length' in options ? toInteger(options.length) : length;\n        omission = 'omission' in options ? baseToString(options.omission) : omission;\n      }\n      string = toString(string);\n\n      var strLength = string.length;\n      if (hasUnicode(string)) {\n        var strSymbols = stringToArray(string);\n        strLength = strSymbols.length;\n      }\n      if (length >= strLength) {\n        return string;\n      }\n      var end = length - stringSize(omission);\n      if (end < 1) {\n        return omission;\n      }\n      var result = strSymbols\n        ? castSlice(strSymbols, 0, end).join('')\n        : string.slice(0, end);\n\n      if (separator === undefined) {\n        return result + omission;\n      }\n      if (strSymbols) {\n        end += (result.length - end);\n      }\n      if (isRegExp(separator)) {\n        if (string.slice(end).search(separator)) {\n          var match,\n              substring = result;\n\n          if (!separator.global) {\n            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');\n          }\n          separator.lastIndex = 0;\n          while ((match = separator.exec(substring))) {\n            var newEnd = match.index;\n          }\n          result = result.slice(0, newEnd === undefined ? end : newEnd);\n        }\n      } else if (string.indexOf(baseToString(separator), end) != end) {\n        var index = result.lastIndexOf(separator);\n        if (index > -1) {\n          result = result.slice(0, index);\n        }\n      }\n      return result + omission;\n    }\n\n    /**\n     * The inverse of `_.escape`; this method converts the HTML entities\n     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to\n     * their corresponding characters.\n     *\n     * **Note:** No other HTML entities are unescaped. To unescape additional\n     * HTML entities use a third-party library like [_he_](https://mths.be/he).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.6.0\n     * @category String\n     * @param {string} [string=''] The string to unescape.\n     * @returns {string} Returns the unescaped string.\n     * @example\n     *\n     * _.unescape('fred, barney, &amp; pebbles');\n     * // => 'fred, barney, & pebbles'\n     */\n    function unescape(string) {\n      string = toString(string);\n      return (string && reHasEscapedHtml.test(string))\n        ? string.replace(reEscapedHtml, unescapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Converts `string`, as space separated words, to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.upperCase('--foo-bar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('fooBar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('__foo_bar__');\n     * // => 'FOO BAR'\n     */\n    var upperCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + word.toUpperCase();\n    });\n\n    /**\n     * Converts the first character of `string` to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.upperFirst('fred');\n     * // => 'Fred'\n     *\n     * _.upperFirst('FRED');\n     * // => 'FRED'\n     */\n    var upperFirst = createCaseFirst('toUpperCase');\n\n    /**\n     * Splits `string` into an array of its words.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {RegExp|string} [pattern] The pattern to match words.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the words of `string`.\n     * @example\n     *\n     * _.words('fred, barney, & pebbles');\n     * // => ['fred', 'barney', 'pebbles']\n     *\n     * _.words('fred, barney, & pebbles', /[^, ]+/g);\n     * // => ['fred', 'barney', '&', 'pebbles']\n     */\n    function words(string, pattern, guard) {\n      string = toString(string);\n      pattern = guard ? undefined : pattern;\n\n      if (pattern === undefined) {\n        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n      }\n      return string.match(pattern) || [];\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Attempts to invoke `func`, returning either the result or the caught error\n     * object. Any additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Function} func The function to attempt.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {*} Returns the `func` result or error object.\n     * @example\n     *\n     * // Avoid throwing errors for invalid selectors.\n     * var elements = _.attempt(function(selector) {\n     *   return document.querySelectorAll(selector);\n     * }, '>_>');\n     *\n     * if (_.isError(elements)) {\n     *   elements = [];\n     * }\n     */\n    var attempt = baseRest(function(func, args) {\n      try {\n        return apply(func, undefined, args);\n      } catch (e) {\n        return isError(e) ? e : new Error(e);\n      }\n    });\n\n    /**\n     * Binds methods of an object to the object itself, overwriting the existing\n     * method.\n     *\n     * **Note:** This method doesn't set the \"length\" property of bound functions.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {Object} object The object to bind and assign the bound methods to.\n     * @param {...(string|string[])} methodNames The object method names to bind.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'click': function() {\n     *     console.log('clicked ' + this.label);\n     *   }\n     * };\n     *\n     * _.bindAll(view, ['click']);\n     * jQuery(element).on('click', view.click);\n     * // => Logs 'clicked docs' when clicked.\n     */\n    var bindAll = flatRest(function(object, methodNames) {\n      arrayEach(methodNames, function(key) {\n        key = toKey(key);\n        baseAssignValue(object, key, bind(object[key], object));\n      });\n      return object;\n    });\n\n    /**\n     * Creates a function that iterates over `pairs` and invokes the corresponding\n     * function of the first predicate to return truthy. The predicate-function\n     * pairs are invoked with the `this` binding and arguments of the created\n     * function.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {Array} pairs The predicate-function pairs.\n     * @returns {Function} Returns the new composite function.\n     * @example\n     *\n     * var func = _.cond([\n     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],\n     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],\n     *   [_.stubTrue,                      _.constant('no match')]\n     * ]);\n     *\n     * func({ 'a': 1, 'b': 2 });\n     * // => 'matches A'\n     *\n     * func({ 'a': 0, 'b': 1 });\n     * // => 'matches B'\n     *\n     * func({ 'a': '1', 'b': '2' });\n     * // => 'no match'\n     */\n    function cond(pairs) {\n      var length = pairs == null ? 0 : pairs.length,\n          toIteratee = getIteratee();\n\n      pairs = !length ? [] : arrayMap(pairs, function(pair) {\n        if (typeof pair[1] != 'function') {\n          throw new TypeError(FUNC_ERROR_TEXT);\n        }\n        return [toIteratee(pair[0]), pair[1]];\n      });\n\n      return baseRest(function(args) {\n        var index = -1;\n        while (++index < length) {\n          var pair = pairs[index];\n          if (apply(pair[0], this, args)) {\n            return apply(pair[1], this, args);\n          }\n        }\n      });\n    }\n\n    /**\n     * Creates a function that invokes the predicate properties of `source` with\n     * the corresponding property values of a given object, returning `true` if\n     * all predicates return truthy, else `false`.\n     *\n     * **Note:** The created function is equivalent to `_.conformsTo` with\n     * `source` partially applied.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 2, 'b': 1 },\n     *   { 'a': 1, 'b': 2 }\n     * ];\n     *\n     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));\n     * // => [{ 'a': 1, 'b': 2 }]\n     */\n    function conforms(source) {\n      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that returns `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Util\n     * @param {*} value The value to return from the new function.\n     * @returns {Function} Returns the new constant function.\n     * @example\n     *\n     * var objects = _.times(2, _.constant({ 'a': 1 }));\n     *\n     * console.log(objects);\n     * // => [{ 'a': 1 }, { 'a': 1 }]\n     *\n     * console.log(objects[0] === objects[1]);\n     * // => true\n     */\n    function constant(value) {\n      return function() {\n        return value;\n      };\n    }\n\n    /**\n     * Checks `value` to determine whether a default value should be returned in\n     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,\n     * or `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.14.0\n     * @category Util\n     * @param {*} value The value to check.\n     * @param {*} defaultValue The default value.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * _.defaultTo(1, 10);\n     * // => 1\n     *\n     * _.defaultTo(undefined, 10);\n     * // => 10\n     */\n    function defaultTo(value, defaultValue) {\n      return (value == null || value !== value) ? defaultValue : value;\n    }\n\n    /**\n     * Creates a function that returns the result of invoking the given functions\n     * with the `this` binding of the created function, where each successive\n     * invocation is supplied the return value of the previous.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n     * @returns {Function} Returns the new composite function.\n     * @see _.flowRight\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flow([_.add, square]);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flow = createFlow();\n\n    /**\n     * This method is like `_.flow` except that it creates a function that\n     * invokes the given functions from right to left.\n     *\n     * @static\n     * @since 3.0.0\n     * @memberOf _\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n     * @returns {Function} Returns the new composite function.\n     * @see _.flow\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flowRight([square, _.add]);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flowRight = createFlow(true);\n\n    /**\n     * This method returns the first argument it receives.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {*} value Any value.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     *\n     * console.log(_.identity(object) === object);\n     * // => true\n     */\n    function identity(value) {\n      return value;\n    }\n\n    /**\n     * Creates a function that invokes `func` with the arguments of the created\n     * function. If `func` is a property name, the created function returns the\n     * property value for a given element. If `func` is an array or object, the\n     * created function returns `true` for elements that contain the equivalent\n     * source properties, otherwise it returns `false`.\n     *\n     * @static\n     * @since 4.0.0\n     * @memberOf _\n     * @category Util\n     * @param {*} [func=_.identity] The value to convert to a callback.\n     * @returns {Function} Returns the callback.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));\n     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.filter(users, _.iteratee(['user', 'fred']));\n     * // => [{ 'user': 'fred', 'age': 40 }]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.map(users, _.iteratee('user'));\n     * // => ['barney', 'fred']\n     *\n     * // Create custom iteratee shorthands.\n     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {\n     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {\n     *     return func.test(string);\n     *   };\n     * });\n     *\n     * _.filter(['abc', 'def'], /ef/);\n     * // => ['def']\n     */\n    function iteratee(func) {\n      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that performs a partial deep comparison between a given\n     * object and `source`, returning `true` if the given object has equivalent\n     * property values, else `false`.\n     *\n     * **Note:** The created function is equivalent to `_.isMatch` with `source`\n     * partially applied.\n     *\n     * Partial comparisons will match empty array and empty object `source`\n     * values against any array or object value, respectively. See `_.isEqual`\n     * for a list of supported value comparisons.\n     *\n     * **Note:** Multiple values can be checked by combining several matchers\n     * using `_.overSome`\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 1, 'b': 2, 'c': 3 },\n     *   { 'a': 4, 'b': 5, 'c': 6 }\n     * ];\n     *\n     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));\n     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]\n     *\n     * // Checking for several possible values\n     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));\n     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]\n     */\n    function matches(source) {\n      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that performs a partial deep comparison between the\n     * value at `path` of a given object to `srcValue`, returning `true` if the\n     * object value is equivalent, else `false`.\n     *\n     * **Note:** Partial comparisons will match empty array and empty object\n     * `srcValue` values against any array or object value, respectively. See\n     * `_.isEqual` for a list of supported value comparisons.\n     *\n     * **Note:** Multiple values can be checked by combining several matchers\n     * using `_.overSome`\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 1, 'b': 2, 'c': 3 },\n     *   { 'a': 4, 'b': 5, 'c': 6 }\n     * ];\n     *\n     * _.find(objects, _.matchesProperty('a', 4));\n     * // => { 'a': 4, 'b': 5, 'c': 6 }\n     *\n     * // Checking for several possible values\n     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));\n     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]\n     */\n    function matchesProperty(path, srcValue) {\n      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that invokes the method at `path` of a given object.\n     * Any additional arguments are provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Util\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new invoker function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': _.constant(2) } },\n     *   { 'a': { 'b': _.constant(1) } }\n     * ];\n     *\n     * _.map(objects, _.method('a.b'));\n     * // => [2, 1]\n     *\n     * _.map(objects, _.method(['a', 'b']));\n     * // => [2, 1]\n     */\n    var method = baseRest(function(path, args) {\n      return function(object) {\n        return baseInvoke(object, path, args);\n      };\n    });\n\n    /**\n     * The opposite of `_.method`; this method creates a function that invokes\n     * the method at a given path of `object`. Any additional arguments are\n     * provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Util\n     * @param {Object} object The object to query.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new invoker function.\n     * @example\n     *\n     * var array = _.times(3, _.constant),\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.methodOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));\n     * // => [2, 0]\n     */\n    var methodOf = baseRest(function(object, args) {\n      return function(path) {\n        return baseInvoke(object, path, args);\n      };\n    });\n\n    /**\n     * Adds all own enumerable string keyed function properties of a source\n     * object to the destination object. If `object` is a function, then methods\n     * are added to its prototype as well.\n     *\n     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to\n     * avoid conflicts caused by modifying the original.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {Function|Object} [object=lodash] The destination object.\n     * @param {Object} source The object of functions to add.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.\n     * @returns {Function|Object} Returns `object`.\n     * @example\n     *\n     * function vowels(string) {\n     *   return _.filter(string, function(v) {\n     *     return /[aeiou]/i.test(v);\n     *   });\n     * }\n     *\n     * _.mixin({ 'vowels': vowels });\n     * _.vowels('fred');\n     * // => ['e']\n     *\n     * _('fred').vowels().value();\n     * // => ['e']\n     *\n     * _.mixin({ 'vowels': vowels }, { 'chain': false });\n     * _('fred').vowels();\n     * // => ['e']\n     */\n    function mixin(object, source, options) {\n      var props = keys(source),\n          methodNames = baseFunctions(source, props);\n\n      if (options == null &&\n          !(isObject(source) && (methodNames.length || !props.length))) {\n        options = source;\n        source = object;\n        object = this;\n        methodNames = baseFunctions(source, keys(source));\n      }\n      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,\n          isFunc = isFunction(object);\n\n      arrayEach(methodNames, function(methodName) {\n        var func = source[methodName];\n        object[methodName] = func;\n        if (isFunc) {\n          object.prototype[methodName] = function() {\n            var chainAll = this.__chain__;\n            if (chain || chainAll) {\n              var result = object(this.__wrapped__),\n                  actions = result.__actions__ = copyArray(this.__actions__);\n\n              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });\n              result.__chain__ = chainAll;\n              return result;\n            }\n            return func.apply(object, arrayPush([this.value()], arguments));\n          };\n        }\n      });\n\n      return object;\n    }\n\n    /**\n     * Reverts the `_` variable to its previous value and returns a reference to\n     * the `lodash` function.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @returns {Function} Returns the `lodash` function.\n     * @example\n     *\n     * var lodash = _.noConflict();\n     */\n    function noConflict() {\n      if (root._ === this) {\n        root._ = oldDash;\n      }\n      return this;\n    }\n\n    /**\n     * This method returns `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.3.0\n     * @category Util\n     * @example\n     *\n     * _.times(2, _.noop);\n     * // => [undefined, undefined]\n     */\n    function noop() {\n      // No operation performed.\n    }\n\n    /**\n     * Creates a function that gets the argument at index `n`. If `n` is negative,\n     * the nth argument from the end is returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {number} [n=0] The index of the argument to return.\n     * @returns {Function} Returns the new pass-thru function.\n     * @example\n     *\n     * var func = _.nthArg(1);\n     * func('a', 'b', 'c', 'd');\n     * // => 'b'\n     *\n     * var func = _.nthArg(-2);\n     * func('a', 'b', 'c', 'd');\n     * // => 'c'\n     */\n    function nthArg(n) {\n      n = toInteger(n);\n      return baseRest(function(args) {\n        return baseNth(args, n);\n      });\n    }\n\n    /**\n     * Creates a function that invokes `iteratees` with the arguments it receives\n     * and returns their results.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n     *  The iteratees to invoke.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.over([Math.max, Math.min]);\n     *\n     * func(1, 2, 3, 4);\n     * // => [4, 1]\n     */\n    var over = createOver(arrayMap);\n\n    /**\n     * Creates a function that checks if **all** of the `predicates` return\n     * truthy when invoked with the arguments it receives.\n     *\n     * Following shorthands are possible for providing predicates.\n     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.\n     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\n     *  The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overEvery([Boolean, isFinite]);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => false\n     *\n     * func(NaN);\n     * // => false\n     */\n    var overEvery = createOver(arrayEvery);\n\n    /**\n     * Creates a function that checks if **any** of the `predicates` return\n     * truthy when invoked with the arguments it receives.\n     *\n     * Following shorthands are possible for providing predicates.\n     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.\n     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\n     *  The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overSome([Boolean, isFinite]);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => true\n     *\n     * func(NaN);\n     * // => false\n     *\n     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])\n     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])\n     */\n    var overSome = createOver(arraySome);\n\n    /**\n     * Creates a function that returns the value at `path` of a given object.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': 2 } },\n     *   { 'a': { 'b': 1 } }\n     * ];\n     *\n     * _.map(objects, _.property('a.b'));\n     * // => [2, 1]\n     *\n     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n     * // => [1, 2]\n     */\n    function property(path) {\n      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n    }\n\n    /**\n     * The opposite of `_.property`; this method creates a function that returns\n     * the value at a given path of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Object} object The object to query.\n     * @returns {Function} Returns the new accessor function.\n     * @example\n     *\n     * var array = [0, 1, 2],\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));\n     * // => [2, 0]\n     */\n    function propertyOf(object) {\n      return function(path) {\n        return object == null ? undefined : baseGet(object, path);\n      };\n    }\n\n    /**\n     * Creates an array of numbers (positive and/or negative) progressing from\n     * `start` up to, but not including, `end`. A step of `-1` is used if a negative\n     * `start` is specified without an `end` or `step`. If `end` is not specified,\n     * it's set to `start` with `start` then set to `0`.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the range of numbers.\n     * @see _.inRange, _.rangeRight\n     * @example\n     *\n     * _.range(4);\n     * // => [0, 1, 2, 3]\n     *\n     * _.range(-4);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 5);\n     * // => [1, 2, 3, 4]\n     *\n     * _.range(0, 20, 5);\n     * // => [0, 5, 10, 15]\n     *\n     * _.range(0, -4, -1);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.range(0);\n     * // => []\n     */\n    var range = createRange();\n\n    /**\n     * This method is like `_.range` except that it populates values in\n     * descending order.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the range of numbers.\n     * @see _.inRange, _.range\n     * @example\n     *\n     * _.rangeRight(4);\n     * // => [3, 2, 1, 0]\n     *\n     * _.rangeRight(-4);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 5);\n     * // => [4, 3, 2, 1]\n     *\n     * _.rangeRight(0, 20, 5);\n     * // => [15, 10, 5, 0]\n     *\n     * _.rangeRight(0, -4, -1);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.rangeRight(0);\n     * // => []\n     */\n    var rangeRight = createRange(true);\n\n    /**\n     * This method returns a new empty array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {Array} Returns the new empty array.\n     * @example\n     *\n     * var arrays = _.times(2, _.stubArray);\n     *\n     * console.log(arrays);\n     * // => [[], []]\n     *\n     * console.log(arrays[0] === arrays[1]);\n     * // => false\n     */\n    function stubArray() {\n      return [];\n    }\n\n    /**\n     * This method returns `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {boolean} Returns `false`.\n     * @example\n     *\n     * _.times(2, _.stubFalse);\n     * // => [false, false]\n     */\n    function stubFalse() {\n      return false;\n    }\n\n    /**\n     * This method returns a new empty object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {Object} Returns the new empty object.\n     * @example\n     *\n     * var objects = _.times(2, _.stubObject);\n     *\n     * console.log(objects);\n     * // => [{}, {}]\n     *\n     * console.log(objects[0] === objects[1]);\n     * // => false\n     */\n    function stubObject() {\n      return {};\n    }\n\n    /**\n     * This method returns an empty string.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {string} Returns the empty string.\n     * @example\n     *\n     * _.times(2, _.stubString);\n     * // => ['', '']\n     */\n    function stubString() {\n      return '';\n    }\n\n    /**\n     * This method returns `true`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {boolean} Returns `true`.\n     * @example\n     *\n     * _.times(2, _.stubTrue);\n     * // => [true, true]\n     */\n    function stubTrue() {\n      return true;\n    }\n\n    /**\n     * Invokes the iteratee `n` times, returning an array of the results of\n     * each invocation. The iteratee is invoked with one argument; (index).\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {number} n The number of times to invoke `iteratee`.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.times(3, String);\n     * // => ['0', '1', '2']\n     *\n     *  _.times(4, _.constant(0));\n     * // => [0, 0, 0, 0]\n     */\n    function times(n, iteratee) {\n      n = toInteger(n);\n      if (n < 1 || n > MAX_SAFE_INTEGER) {\n        return [];\n      }\n      var index = MAX_ARRAY_LENGTH,\n          length = nativeMin(n, MAX_ARRAY_LENGTH);\n\n      iteratee = getIteratee(iteratee);\n      n -= MAX_ARRAY_LENGTH;\n\n      var result = baseTimes(length, iteratee);\n      while (++index < n) {\n        iteratee(index);\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to a property path array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the new property path array.\n     * @example\n     *\n     * _.toPath('a.b.c');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toPath('a[0].b.c');\n     * // => ['a', '0', 'b', 'c']\n     */\n    function toPath(value) {\n      if (isArray(value)) {\n        return arrayMap(value, toKey);\n      }\n      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));\n    }\n\n    /**\n     * Generates a unique ID. If `prefix` is given, the ID is appended to it.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {string} [prefix=''] The value to prefix the ID with.\n     * @returns {string} Returns the unique ID.\n     * @example\n     *\n     * _.uniqueId('contact_');\n     * // => 'contact_104'\n     *\n     * _.uniqueId();\n     * // => '105'\n     */\n    function uniqueId(prefix) {\n      var id = ++idCounter;\n      return toString(prefix) + id;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Adds two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.4.0\n     * @category Math\n     * @param {number} augend The first number in an addition.\n     * @param {number} addend The second number in an addition.\n     * @returns {number} Returns the total.\n     * @example\n     *\n     * _.add(6, 4);\n     * // => 10\n     */\n    var add = createMathOperation(function(augend, addend) {\n      return augend + addend;\n    }, 0);\n\n    /**\n     * Computes `number` rounded up to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round up.\n     * @param {number} [precision=0] The precision to round up to.\n     * @returns {number} Returns the rounded up number.\n     * @example\n     *\n     * _.ceil(4.006);\n     * // => 5\n     *\n     * _.ceil(6.004, 2);\n     * // => 6.01\n     *\n     * _.ceil(6040, -2);\n     * // => 6100\n     */\n    var ceil = createRound('ceil');\n\n    /**\n     * Divide two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {number} dividend The first number in a division.\n     * @param {number} divisor The second number in a division.\n     * @returns {number} Returns the quotient.\n     * @example\n     *\n     * _.divide(6, 4);\n     * // => 1.5\n     */\n    var divide = createMathOperation(function(dividend, divisor) {\n      return dividend / divisor;\n    }, 1);\n\n    /**\n     * Computes `number` rounded down to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round down.\n     * @param {number} [precision=0] The precision to round down to.\n     * @returns {number} Returns the rounded down number.\n     * @example\n     *\n     * _.floor(4.006);\n     * // => 4\n     *\n     * _.floor(0.046, 2);\n     * // => 0.04\n     *\n     * _.floor(4060, -2);\n     * // => 4000\n     */\n    var floor = createRound('floor');\n\n    /**\n     * Computes the maximum value of `array`. If `array` is empty or falsey,\n     * `undefined` is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * _.max([4, 2, 8, 6]);\n     * // => 8\n     *\n     * _.max([]);\n     * // => undefined\n     */\n    function max(array) {\n      return (array && array.length)\n        ? baseExtremum(array, identity, baseGt)\n        : undefined;\n    }\n\n    /**\n     * This method is like `_.max` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.maxBy(objects, function(o) { return o.n; });\n     * // => { 'n': 2 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.maxBy(objects, 'n');\n     * // => { 'n': 2 }\n     */\n    function maxBy(array, iteratee) {\n      return (array && array.length)\n        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)\n        : undefined;\n    }\n\n    /**\n     * Computes the mean of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the mean.\n     * @example\n     *\n     * _.mean([4, 2, 8, 6]);\n     * // => 5\n     */\n    function mean(array) {\n      return baseMean(array, identity);\n    }\n\n    /**\n     * This method is like `_.mean` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the value to be averaged.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the mean.\n     * @example\n     *\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n     *\n     * _.meanBy(objects, function(o) { return o.n; });\n     * // => 5\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.meanBy(objects, 'n');\n     * // => 5\n     */\n    function meanBy(array, iteratee) {\n      return baseMean(array, getIteratee(iteratee, 2));\n    }\n\n    /**\n     * Computes the minimum value of `array`. If `array` is empty or falsey,\n     * `undefined` is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * _.min([4, 2, 8, 6]);\n     * // => 2\n     *\n     * _.min([]);\n     * // => undefined\n     */\n    function min(array) {\n      return (array && array.length)\n        ? baseExtremum(array, identity, baseLt)\n        : undefined;\n    }\n\n    /**\n     * This method is like `_.min` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.minBy(objects, function(o) { return o.n; });\n     * // => { 'n': 1 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.minBy(objects, 'n');\n     * // => { 'n': 1 }\n     */\n    function minBy(array, iteratee) {\n      return (array && array.length)\n        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)\n        : undefined;\n    }\n\n    /**\n     * Multiply two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {number} multiplier The first number in a multiplication.\n     * @param {number} multiplicand The second number in a multiplication.\n     * @returns {number} Returns the product.\n     * @example\n     *\n     * _.multiply(6, 4);\n     * // => 24\n     */\n    var multiply = createMathOperation(function(multiplier, multiplicand) {\n      return multiplier * multiplicand;\n    }, 1);\n\n    /**\n     * Computes `number` rounded to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round.\n     * @param {number} [precision=0] The precision to round to.\n     * @returns {number} Returns the rounded number.\n     * @example\n     *\n     * _.round(4.006);\n     * // => 4\n     *\n     * _.round(4.006, 2);\n     * // => 4.01\n     *\n     * _.round(4060, -2);\n     * // => 4100\n     */\n    var round = createRound('round');\n\n    /**\n     * Subtract two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {number} minuend The first number in a subtraction.\n     * @param {number} subtrahend The second number in a subtraction.\n     * @returns {number} Returns the difference.\n     * @example\n     *\n     * _.subtract(6, 4);\n     * // => 2\n     */\n    var subtract = createMathOperation(function(minuend, subtrahend) {\n      return minuend - subtrahend;\n    }, 0);\n\n    /**\n     * Computes the sum of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.4.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * _.sum([4, 2, 8, 6]);\n     * // => 20\n     */\n    function sum(array) {\n      return (array && array.length)\n        ? baseSum(array, identity)\n        : 0;\n    }\n\n    /**\n     * This method is like `_.sum` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the value to be summed.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n     *\n     * _.sumBy(objects, function(o) { return o.n; });\n     * // => 20\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sumBy(objects, 'n');\n     * // => 20\n     */\n    function sumBy(array, iteratee) {\n      return (array && array.length)\n        ? baseSum(array, getIteratee(iteratee, 2))\n        : 0;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    // Add methods that return wrapped values in chain sequences.\n    lodash.after = after;\n    lodash.ary = ary;\n    lodash.assign = assign;\n    lodash.assignIn = assignIn;\n    lodash.assignInWith = assignInWith;\n    lodash.assignWith = assignWith;\n    lodash.at = at;\n    lodash.before = before;\n    lodash.bind = bind;\n    lodash.bindAll = bindAll;\n    lodash.bindKey = bindKey;\n    lodash.castArray = castArray;\n    lodash.chain = chain;\n    lodash.chunk = chunk;\n    lodash.compact = compact;\n    lodash.concat = concat;\n    lodash.cond = cond;\n    lodash.conforms = conforms;\n    lodash.constant = constant;\n    lodash.countBy = countBy;\n    lodash.create = create;\n    lodash.curry = curry;\n    lodash.curryRight = curryRight;\n    lodash.debounce = debounce;\n    lodash.defaults = defaults;\n    lodash.defaultsDeep = defaultsDeep;\n    lodash.defer = defer;\n    lodash.delay = delay;\n    lodash.difference = difference;\n    lodash.differenceBy = differenceBy;\n    lodash.differenceWith = differenceWith;\n    lodash.drop = drop;\n    lodash.dropRight = dropRight;\n    lodash.dropRightWhile = dropRightWhile;\n    lodash.dropWhile = dropWhile;\n    lodash.fill = fill;\n    lodash.filter = filter;\n    lodash.flatMap = flatMap;\n    lodash.flatMapDeep = flatMapDeep;\n    lodash.flatMapDepth = flatMapDepth;\n    lodash.flatten = flatten;\n    lodash.flattenDeep = flattenDeep;\n    lodash.flattenDepth = flattenDepth;\n    lodash.flip = flip;\n    lodash.flow = flow;\n    lodash.flowRight = flowRight;\n    lodash.fromPairs = fromPairs;\n    lodash.functions = functions;\n    lodash.functionsIn = functionsIn;\n    lodash.groupBy = groupBy;\n    lodash.initial = initial;\n    lodash.intersection = intersection;\n    lodash.intersectionBy = intersectionBy;\n    lodash.intersectionWith = intersectionWith;\n    lodash.invert = invert;\n    lodash.invertBy = invertBy;\n    lodash.invokeMap = invokeMap;\n    lodash.iteratee = iteratee;\n    lodash.keyBy = keyBy;\n    lodash.keys = keys;\n    lodash.keysIn = keysIn;\n    lodash.map = map;\n    lodash.mapKeys = mapKeys;\n    lodash.mapValues = mapValues;\n    lodash.matches = matches;\n    lodash.matchesProperty = matchesProperty;\n    lodash.memoize = memoize;\n    lodash.merge = merge;\n    lodash.mergeWith = mergeWith;\n    lodash.method = method;\n    lodash.methodOf = methodOf;\n    lodash.mixin = mixin;\n    lodash.negate = negate;\n    lodash.nthArg = nthArg;\n    lodash.omit = omit;\n    lodash.omitBy = omitBy;\n    lodash.once = once;\n    lodash.orderBy = orderBy;\n    lodash.over = over;\n    lodash.overArgs = overArgs;\n    lodash.overEvery = overEvery;\n    lodash.overSome = overSome;\n    lodash.partial = partial;\n    lodash.partialRight = partialRight;\n    lodash.partition = partition;\n    lodash.pick = pick;\n    lodash.pickBy = pickBy;\n    lodash.property = property;\n    lodash.propertyOf = propertyOf;\n    lodash.pull = pull;\n    lodash.pullAll = pullAll;\n    lodash.pullAllBy = pullAllBy;\n    lodash.pullAllWith = pullAllWith;\n    lodash.pullAt = pullAt;\n    lodash.range = range;\n    lodash.rangeRight = rangeRight;\n    lodash.rearg = rearg;\n    lodash.reject = reject;\n    lodash.remove = remove;\n    lodash.rest = rest;\n    lodash.reverse = reverse;\n    lodash.sampleSize = sampleSize;\n    lodash.set = set;\n    lodash.setWith = setWith;\n    lodash.shuffle = shuffle;\n    lodash.slice = slice;\n    lodash.sortBy = sortBy;\n    lodash.sortedUniq = sortedUniq;\n    lodash.sortedUniqBy = sortedUniqBy;\n    lodash.split = split;\n    lodash.spread = spread;\n    lodash.tail = tail;\n    lodash.take = take;\n    lodash.takeRight = takeRight;\n    lodash.takeRightWhile = takeRightWhile;\n    lodash.takeWhile = takeWhile;\n    lodash.tap = tap;\n    lodash.throttle = throttle;\n    lodash.thru = thru;\n    lodash.toArray = toArray;\n    lodash.toPairs = toPairs;\n    lodash.toPairsIn = toPairsIn;\n    lodash.toPath = toPath;\n    lodash.toPlainObject = toPlainObject;\n    lodash.transform = transform;\n    lodash.unary = unary;\n    lodash.union = union;\n    lodash.unionBy = unionBy;\n    lodash.unionWith = unionWith;\n    lodash.uniq = uniq;\n    lodash.uniqBy = uniqBy;\n    lodash.uniqWith = uniqWith;\n    lodash.unset = unset;\n    lodash.unzip = unzip;\n    lodash.unzipWith = unzipWith;\n    lodash.update = update;\n    lodash.updateWith = updateWith;\n    lodash.values = values;\n    lodash.valuesIn = valuesIn;\n    lodash.without = without;\n    lodash.words = words;\n    lodash.wrap = wrap;\n    lodash.xor = xor;\n    lodash.xorBy = xorBy;\n    lodash.xorWith = xorWith;\n    lodash.zip = zip;\n    lodash.zipObject = zipObject;\n    lodash.zipObjectDeep = zipObjectDeep;\n    lodash.zipWith = zipWith;\n\n    // Add aliases.\n    lodash.entries = toPairs;\n    lodash.entriesIn = toPairsIn;\n    lodash.extend = assignIn;\n    lodash.extendWith = assignInWith;\n\n    // Add methods to `lodash.prototype`.\n    mixin(lodash, lodash);\n\n    /*------------------------------------------------------------------------*/\n\n    // Add methods that return unwrapped values in chain sequences.\n    lodash.add = add;\n    lodash.attempt = attempt;\n    lodash.camelCase = camelCase;\n    lodash.capitalize = capitalize;\n    lodash.ceil = ceil;\n    lodash.clamp = clamp;\n    lodash.clone = clone;\n    lodash.cloneDeep = cloneDeep;\n    lodash.cloneDeepWith = cloneDeepWith;\n    lodash.cloneWith = cloneWith;\n    lodash.conformsTo = conformsTo;\n    lodash.deburr = deburr;\n    lodash.defaultTo = defaultTo;\n    lodash.divide = divide;\n    lodash.endsWith = endsWith;\n    lodash.eq = eq;\n    lodash.escape = escape;\n    lodash.escapeRegExp = escapeRegExp;\n    lodash.every = every;\n    lodash.find = find;\n    lodash.findIndex = findIndex;\n    lodash.findKey = findKey;\n    lodash.findLast = findLast;\n    lodash.findLastIndex = findLastIndex;\n    lodash.findLastKey = findLastKey;\n    lodash.floor = floor;\n    lodash.forEach = forEach;\n    lodash.forEachRight = forEachRight;\n    lodash.forIn = forIn;\n    lodash.forInRight = forInRight;\n    lodash.forOwn = forOwn;\n    lodash.forOwnRight = forOwnRight;\n    lodash.get = get;\n    lodash.gt = gt;\n    lodash.gte = gte;\n    lodash.has = has;\n    lodash.hasIn = hasIn;\n    lodash.head = head;\n    lodash.identity = identity;\n    lodash.includes = includes;\n    lodash.indexOf = indexOf;\n    lodash.inRange = inRange;\n    lodash.invoke = invoke;\n    lodash.isArguments = isArguments;\n    lodash.isArray = isArray;\n    lodash.isArrayBuffer = isArrayBuffer;\n    lodash.isArrayLike = isArrayLike;\n    lodash.isArrayLikeObject = isArrayLikeObject;\n    lodash.isBoolean = isBoolean;\n    lodash.isBuffer = isBuffer;\n    lodash.isDate = isDate;\n    lodash.isElement = isElement;\n    lodash.isEmpty = isEmpty;\n    lodash.isEqual = isEqual;\n    lodash.isEqualWith = isEqualWith;\n    lodash.isError = isError;\n    lodash.isFinite = isFinite;\n    lodash.isFunction = isFunction;\n    lodash.isInteger = isInteger;\n    lodash.isLength = isLength;\n    lodash.isMap = isMap;\n    lodash.isMatch = isMatch;\n    lodash.isMatchWith = isMatchWith;\n    lodash.isNaN = isNaN;\n    lodash.isNative = isNative;\n    lodash.isNil = isNil;\n    lodash.isNull = isNull;\n    lodash.isNumber = isNumber;\n    lodash.isObject = isObject;\n    lodash.isObjectLike = isObjectLike;\n    lodash.isPlainObject = isPlainObject;\n    lodash.isRegExp = isRegExp;\n    lodash.isSafeInteger = isSafeInteger;\n    lodash.isSet = isSet;\n    lodash.isString = isString;\n    lodash.isSymbol = isSymbol;\n    lodash.isTypedArray = isTypedArray;\n    lodash.isUndefined = isUndefined;\n    lodash.isWeakMap = isWeakMap;\n    lodash.isWeakSet = isWeakSet;\n    lodash.join = join;\n    lodash.kebabCase = kebabCase;\n    lodash.last = last;\n    lodash.lastIndexOf = lastIndexOf;\n    lodash.lowerCase = lowerCase;\n    lodash.lowerFirst = lowerFirst;\n    lodash.lt = lt;\n    lodash.lte = lte;\n    lodash.max = max;\n    lodash.maxBy = maxBy;\n    lodash.mean = mean;\n    lodash.meanBy = meanBy;\n    lodash.min = min;\n    lodash.minBy = minBy;\n    lodash.stubArray = stubArray;\n    lodash.stubFalse = stubFalse;\n    lodash.stubObject = stubObject;\n    lodash.stubString = stubString;\n    lodash.stubTrue = stubTrue;\n    lodash.multiply = multiply;\n    lodash.nth = nth;\n    lodash.noConflict = noConflict;\n    lodash.noop = noop;\n    lodash.now = now;\n    lodash.pad = pad;\n    lodash.padEnd = padEnd;\n    lodash.padStart = padStart;\n    lodash.parseInt = parseInt;\n    lodash.random = random;\n    lodash.reduce = reduce;\n    lodash.reduceRight = reduceRight;\n    lodash.repeat = repeat;\n    lodash.replace = replace;\n    lodash.result = result;\n    lodash.round = round;\n    lodash.runInContext = runInContext;\n    lodash.sample = sample;\n    lodash.size = size;\n    lodash.snakeCase = snakeCase;\n    lodash.some = some;\n    lodash.sortedIndex = sortedIndex;\n    lodash.sortedIndexBy = sortedIndexBy;\n    lodash.sortedIndexOf = sortedIndexOf;\n    lodash.sortedLastIndex = sortedLastIndex;\n    lodash.sortedLastIndexBy = sortedLastIndexBy;\n    lodash.sortedLastIndexOf = sortedLastIndexOf;\n    lodash.startCase = startCase;\n    lodash.startsWith = startsWith;\n    lodash.subtract = subtract;\n    lodash.sum = sum;\n    lodash.sumBy = sumBy;\n    lodash.template = template;\n    lodash.times = times;\n    lodash.toFinite = toFinite;\n    lodash.toInteger = toInteger;\n    lodash.toLength = toLength;\n    lodash.toLower = toLower;\n    lodash.toNumber = toNumber;\n    lodash.toSafeInteger = toSafeInteger;\n    lodash.toString = toString;\n    lodash.toUpper = toUpper;\n    lodash.trim = trim;\n    lodash.trimEnd = trimEnd;\n    lodash.trimStart = trimStart;\n    lodash.truncate = truncate;\n    lodash.unescape = unescape;\n    lodash.uniqueId = uniqueId;\n    lodash.upperCase = upperCase;\n    lodash.upperFirst = upperFirst;\n\n    // Add aliases.\n    lodash.each = forEach;\n    lodash.eachRight = forEachRight;\n    lodash.first = head;\n\n    mixin(lodash, (function() {\n      var source = {};\n      baseForOwn(lodash, function(func, methodName) {\n        if (!hasOwnProperty.call(lodash.prototype, methodName)) {\n          source[methodName] = func;\n        }\n      });\n      return source;\n    }()), { 'chain': false });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The semantic version number.\n     *\n     * @static\n     * @memberOf _\n     * @type {string}\n     */\n    lodash.VERSION = VERSION;\n\n    // Assign default placeholders.\n    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {\n      lodash[methodName].placeholder = lodash;\n    });\n\n    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.\n    arrayEach(['drop', 'take'], function(methodName, index) {\n      LazyWrapper.prototype[methodName] = function(n) {\n        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);\n\n        var result = (this.__filtered__ && !index)\n          ? new LazyWrapper(this)\n          : this.clone();\n\n        if (result.__filtered__) {\n          result.__takeCount__ = nativeMin(n, result.__takeCount__);\n        } else {\n          result.__views__.push({\n            'size': nativeMin(n, MAX_ARRAY_LENGTH),\n            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')\n          });\n        }\n        return result;\n      };\n\n      LazyWrapper.prototype[methodName + 'Right'] = function(n) {\n        return this.reverse()[methodName](n).reverse();\n      };\n    });\n\n    // Add `LazyWrapper` methods that accept an `iteratee` value.\n    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {\n      var type = index + 1,\n          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;\n\n      LazyWrapper.prototype[methodName] = function(iteratee) {\n        var result = this.clone();\n        result.__iteratees__.push({\n          'iteratee': getIteratee(iteratee, 3),\n          'type': type\n        });\n        result.__filtered__ = result.__filtered__ || isFilter;\n        return result;\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.head` and `_.last`.\n    arrayEach(['head', 'last'], function(methodName, index) {\n      var takeName = 'take' + (index ? 'Right' : '');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this[takeName](1).value()[0];\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.\n    arrayEach(['initial', 'tail'], function(methodName, index) {\n      var dropName = 'drop' + (index ? '' : 'Right');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);\n      };\n    });\n\n    LazyWrapper.prototype.compact = function() {\n      return this.filter(identity);\n    };\n\n    LazyWrapper.prototype.find = function(predicate) {\n      return this.filter(predicate).head();\n    };\n\n    LazyWrapper.prototype.findLast = function(predicate) {\n      return this.reverse().find(predicate);\n    };\n\n    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {\n      if (typeof path == 'function') {\n        return new LazyWrapper(this);\n      }\n      return this.map(function(value) {\n        return baseInvoke(value, path, args);\n      });\n    });\n\n    LazyWrapper.prototype.reject = function(predicate) {\n      return this.filter(negate(getIteratee(predicate)));\n    };\n\n    LazyWrapper.prototype.slice = function(start, end) {\n      start = toInteger(start);\n\n      var result = this;\n      if (result.__filtered__ && (start > 0 || end < 0)) {\n        return new LazyWrapper(result);\n      }\n      if (start < 0) {\n        result = result.takeRight(-start);\n      } else if (start) {\n        result = result.drop(start);\n      }\n      if (end !== undefined) {\n        end = toInteger(end);\n        result = end < 0 ? result.dropRight(-end) : result.take(end - start);\n      }\n      return result;\n    };\n\n    LazyWrapper.prototype.takeRightWhile = function(predicate) {\n      return this.reverse().takeWhile(predicate).reverse();\n    };\n\n    LazyWrapper.prototype.toArray = function() {\n      return this.take(MAX_ARRAY_LENGTH);\n    };\n\n    // Add `LazyWrapper` methods to `lodash.prototype`.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),\n          isTaker = /^(?:head|last)$/.test(methodName),\n          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],\n          retUnwrapped = isTaker || /^find/.test(methodName);\n\n      if (!lodashFunc) {\n        return;\n      }\n      lodash.prototype[methodName] = function() {\n        var value = this.__wrapped__,\n            args = isTaker ? [1] : arguments,\n            isLazy = value instanceof LazyWrapper,\n            iteratee = args[0],\n            useLazy = isLazy || isArray(value);\n\n        var interceptor = function(value) {\n          var result = lodashFunc.apply(lodash, arrayPush([value], args));\n          return (isTaker && chainAll) ? result[0] : result;\n        };\n\n        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {\n          // Avoid lazy use if the iteratee has a \"length\" value other than `1`.\n          isLazy = useLazy = false;\n        }\n        var chainAll = this.__chain__,\n            isHybrid = !!this.__actions__.length,\n            isUnwrapped = retUnwrapped && !chainAll,\n            onlyLazy = isLazy && !isHybrid;\n\n        if (!retUnwrapped && useLazy) {\n          value = onlyLazy ? value : new LazyWrapper(this);\n          var result = func.apply(value, args);\n          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });\n          return new LodashWrapper(result, chainAll);\n        }\n        if (isUnwrapped && onlyLazy) {\n          return func.apply(this, args);\n        }\n        result = this.thru(interceptor);\n        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;\n      };\n    });\n\n    // Add `Array` methods to `lodash.prototype`.\n    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {\n      var func = arrayProto[methodName],\n          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',\n          retUnwrapped = /^(?:pop|shift)$/.test(methodName);\n\n      lodash.prototype[methodName] = function() {\n        var args = arguments;\n        if (retUnwrapped && !this.__chain__) {\n          var value = this.value();\n          return func.apply(isArray(value) ? value : [], args);\n        }\n        return this[chainName](function(value) {\n          return func.apply(isArray(value) ? value : [], args);\n        });\n      };\n    });\n\n    // Map minified method names to their real names.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var lodashFunc = lodash[methodName];\n      if (lodashFunc) {\n        var key = lodashFunc.name + '';\n        if (!hasOwnProperty.call(realNames, key)) {\n          realNames[key] = [];\n        }\n        realNames[key].push({ 'name': methodName, 'func': lodashFunc });\n      }\n    });\n\n    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{\n      'name': 'wrapper',\n      'func': undefined\n    }];\n\n    // Add methods to `LazyWrapper`.\n    LazyWrapper.prototype.clone = lazyClone;\n    LazyWrapper.prototype.reverse = lazyReverse;\n    LazyWrapper.prototype.value = lazyValue;\n\n    // Add chain sequence methods to the `lodash` wrapper.\n    lodash.prototype.at = wrapperAt;\n    lodash.prototype.chain = wrapperChain;\n    lodash.prototype.commit = wrapperCommit;\n    lodash.prototype.next = wrapperNext;\n    lodash.prototype.plant = wrapperPlant;\n    lodash.prototype.reverse = wrapperReverse;\n    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;\n\n    // Add lazy aliases.\n    lodash.prototype.first = lodash.prototype.head;\n\n    if (symIterator) {\n      lodash.prototype[symIterator] = wrapperToIterator;\n    }\n    return lodash;\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  // Export lodash.\n  var _ = runInContext();\n\n  // Some AMD build optimizers, like r.js, check for condition patterns like:\n  if (true) {\n    // Expose Lodash on the global object to prevent errors when Lodash is\n    // loaded by a script tag in the presence of an AMD loader.\n    // See http://requirejs.org/docs/errors.html#mismatch for more details.\n    // Use `_.noConflict` to remove Lodash from the global object.\n    root._ = _;\n\n    // Define as an anonymous module so, through path mapping, it can be\n    // referenced as the \"underscore\" module.\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n      return _;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n  // Check for `exports` after `define` in case a build optimizer adds it.\n  else {}\n}.call(this));\n\n\n//# sourceURL=webpack://vim/./node_modules/lodash/lodash.js?")},"./node_modules/os-browserify/browser.js":(__unused_webpack_module,exports)=>{eval("exports.endianness = function () { return 'LE' };\n\nexports.hostname = function () {\n    if (typeof location !== 'undefined') {\n        return location.hostname\n    }\n    else return '';\n};\n\nexports.loadavg = function () { return [] };\n\nexports.uptime = function () { return 0 };\n\nexports.freemem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.totalmem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.cpus = function () { return [] };\n\nexports.type = function () { return 'Browser' };\n\nexports.release = function () {\n    if (typeof navigator !== 'undefined') {\n        return navigator.appVersion;\n    }\n    return '';\n};\n\nexports.networkInterfaces\n= exports.getNetworkInterfaces\n= function () { return {} };\n\nexports.arch = function () { return 'javascript' };\n\nexports.platform = function () { return 'browser' };\n\nexports.tmpdir = exports.tmpDir = function () {\n    return '/tmp';\n};\n\nexports.EOL = '\\n';\n\nexports.homedir = function () {\n\treturn '/'\n};\n\n\n//# sourceURL=webpack://vim/./node_modules/os-browserify/browser.js?")},"./node_modules/parsimmon/build/parsimmon.umd.min.js":function(module){eval('!function(n,t){ true?module.exports=t():0}("undefined"!=typeof self?self:this,function(){return function(n){var t={};function r(e){if(t[e])return t[e].exports;var u=t[e]={i:e,l:!1,exports:{}};return n[e].call(u.exports,u,u.exports,r),u.l=!0,u.exports}return r.m=n,r.c=t,r.d=function(n,t,e){r.o(n,t)||Object.defineProperty(n,t,{configurable:!1,enumerable:!0,get:e})},r.r=function(n){Object.defineProperty(n,"__esModule",{value:!0})},r.n=function(n){var t=n&&n.__esModule?function(){return n.default}:function(){return n};return r.d(t,"a",t),t},r.o=function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},r.p="",r(r.s=0)}([function(n,t,r){"use strict";function e(n){if(!(this instanceof e))return new e(n);this._=n}var u=e.prototype;function o(n,t){for(var r=0;r<n;r++)t(r)}function i(n,t,r){return function(n,t){o(t.length,function(r){n(t[r],r,t)})}(function(r,e,u){t=n(t,r,e,u)},r),t}function a(n,t){return i(function(t,r,e,u){return t.concat([n(r,e,u)])},[],t)}function f(n,t){var r={v:0,buf:t};return o(n,function(){var n;r={v:r.v<<1|(n=r.buf,n[0]>>7),buf:function(n){var t=i(function(n,t,r,e){return n.concat(r===e.length-1?Buffer.from([t,0]).readUInt16BE(0):e.readUInt16BE(r))},[],n);return Buffer.from(a(function(n){return(n<<1&65535)>>8},t))}(r.buf)}}),r}function c(){return"undefined"!=typeof Buffer}function s(){if(!c())throw new Error("Buffer global does not exist; please use webpack if you need to parse Buffers in the browser.")}function l(n){s();var t=i(function(n,t){return n+t},0,n);if(t%8!=0)throw new Error("The bits ["+n.join(", ")+"] add up to "+t+" which is not an even number of bytes; the total should be divisible by 8");var r,u=t/8,o=(r=function(n){return n>48},i(function(n,t){return n||(r(t)?t:n)},null,n));if(o)throw new Error(o+" bit range requested exceeds 48 bit (6 byte) Number max.");return new e(function(t,r){var e=u+r;return e>t.length?x(r,u.toString()+" bytes"):b(e,i(function(n,t){var r=f(t,n.buf);return{coll:n.coll.concat(r.v),buf:r.buf}},{coll:[],buf:t.slice(r,e)},n).coll)})}function h(n,t){return new e(function(r,e){return s(),e+t>r.length?x(e,t+" bytes for "+n):b(e+t,r.slice(e,e+t))})}function p(n,t){if("number"!=typeof(r=t)||Math.floor(r)!==r||t<0||t>6)throw new Error(n+" requires integer length in range [0, 6].");var r}function d(n){return p("uintBE",n),h("uintBE("+n+")",n).map(function(t){return t.readUIntBE(0,n)})}function v(n){return p("uintLE",n),h("uintLE("+n+")",n).map(function(t){return t.readUIntLE(0,n)})}function g(n){return p("intBE",n),h("intBE("+n+")",n).map(function(t){return t.readIntBE(0,n)})}function m(n){return p("intLE",n),h("intLE("+n+")",n).map(function(t){return t.readIntLE(0,n)})}function y(n){return n instanceof e}function E(n){return"[object Array]"==={}.toString.call(n)}function w(n){return c()&&Buffer.isBuffer(n)}function b(n,t){return{status:!0,index:n,value:t,furthest:-1,expected:[]}}function x(n,t){return E(t)||(t=[t]),{status:!1,index:-1,value:null,furthest:n,expected:t}}function B(n,t){if(!t)return n;if(n.furthest>t.furthest)return n;var r=n.furthest===t.furthest?function(n,t){if(function(){if(void 0!==e._supportsSet)return e._supportsSet;var n="undefined"!=typeof Set;return e._supportsSet=n,n}()&&Array.from){for(var r=new Set(n),u=0;u<t.length;u++)r.add(t[u]);var o=Array.from(r);return o.sort(),o}for(var i={},a=0;a<n.length;a++)i[n[a]]=!0;for(var f=0;f<t.length;f++)i[t[f]]=!0;var c=[];for(var s in i)({}).hasOwnProperty.call(i,s)&&c.push(s);return c.sort(),c}(n.expected,t.expected):t.expected;return{status:n.status,index:n.index,value:n.value,furthest:t.furthest,expected:r}}var j={};function S(n,t){if(w(n))return{offset:t,line:-1,column:-1};n in j||(j[n]={});for(var r=j[n],e=0,u=0,o=0,i=t;i>=0;){if(i in r){e=r[i].line,0===o&&(o=r[i].lineStart);break}("\\n"===n.charAt(i)||"\\r"===n.charAt(i)&&"\\n"!==n.charAt(i+1))&&(u++,0===o&&(o=i+1)),i--}var a=e+u,f=t-o;return r[t]={line:a,lineStart:o},{offset:t,line:a+1,column:f+1}}function _(n){if(!y(n))throw new Error("not a parser: "+n)}function L(n,t){return"string"==typeof n?n.charAt(t):n[t]}function O(n){if("number"!=typeof n)throw new Error("not a number: "+n)}function k(n){if("function"!=typeof n)throw new Error("not a function: "+n)}function P(n){if("string"!=typeof n)throw new Error("not a string: "+n)}var q=2,A=3,I=8,F=5*I,M=4*I,z="  ";function R(n,t){return new Array(t+1).join(n)}function U(n,t,r){var e=t-n.length;return e<=0?n:R(r,e)+n}function W(n,t,r,e){return{from:n-t>0?n-t:0,to:n+r>e?e:n+r}}function D(n,t){var r,e,u,o,f,c=t.index,s=c.offset,l=1;if(s===n.length)return"Got the end of the input";if(w(n)){var h=s-s%I,p=s-h,d=W(h,F,M+I,n.length),v=a(function(n){return a(function(n){return U(n.toString(16),2,"0")},n)},function(n,t){var r=n.length,e=[],u=0;if(r<=t)return[n.slice()];for(var o=0;o<r;o++)e[u]||e.push([]),e[u].push(n[o]),(o+1)%t==0&&u++;return e}(n.slice(d.from,d.to).toJSON().data,I));o=function(n){return 0===n.from&&1===n.to?{from:n.from,to:n.to}:{from:n.from/I,to:Math.floor(n.to/I)}}(d),e=h/I,r=3*p,p>=4&&(r+=1),l=2,u=a(function(n){return n.length<=4?n.join(" "):n.slice(0,4).join(" ")+"  "+n.slice(4).join(" ")},v),(f=(8*(o.to>0?o.to-1:o.to)).toString(16).length)<2&&(f=2)}else{var g=n.split(/\\r\\n|[\\n\\r\\u2028\\u2029]/);r=c.column-1,e=c.line-1,o=W(e,q,A,g.length),u=g.slice(o.from,o.to),f=o.to.toString().length}var m=e-o.from;return w(n)&&(f=(8*(o.to>0?o.to-1:o.to)).toString(16).length)<2&&(f=2),i(function(t,e,u){var i,a=u===m,c=a?"> ":z;return i=w(n)?U((8*(o.from+u)).toString(16),f,"0"):U((o.from+u+1).toString(),f," "),[].concat(t,[c+i+" | "+e],a?[z+R(" ",f)+" | "+U("",r," ")+R("^",l)]:[])},[],u).join("\\n")}function N(n,t){return["\\n","-- PARSING FAILED "+R("-",50),"\\n\\n",D(n,t),"\\n\\n",(r=t.expected,1===r.length?"Expected:\\n\\n"+r[0]:"Expected one of the following: \\n\\n"+r.join(", ")),"\\n"].join("");var r}function G(n){return void 0!==n.flags?n.flags:[n.global?"g":"",n.ignoreCase?"i":"",n.multiline?"m":"",n.unicode?"u":"",n.sticky?"y":""].join("")}function C(){for(var n=[].slice.call(arguments),t=n.length,r=0;r<t;r+=1)_(n[r]);return e(function(r,e){for(var u,o=new Array(t),i=0;i<t;i+=1){if(!(u=B(n[i]._(r,e),u)).status)return u;o[i]=u.value,e=u.index}return B(b(e,o),u)})}function J(){var n=[].slice.call(arguments);if(0===n.length)throw new Error("seqMap needs at least one argument");var t=n.pop();return k(t),C.apply(null,n).map(function(n){return t.apply(null,n)})}function T(){var n=[].slice.call(arguments),t=n.length;if(0===t)return Y("zero alternates");for(var r=0;r<t;r+=1)_(n[r]);return e(function(t,r){for(var e,u=0;u<n.length;u+=1)if((e=B(n[u]._(t,r),e)).status)return e;return e})}function V(n,t){return H(n,t).or(X([]))}function H(n,t){return _(n),_(t),J(n,t.then(n).many(),function(n,t){return[n].concat(t)})}function K(n){P(n);var t="\'"+n+"\'";return e(function(r,e){var u=e+n.length,o=r.slice(e,u);return o===n?b(u,o):x(e,t)})}function Q(n,t){!function(n){if(!(n instanceof RegExp))throw new Error("not a regexp: "+n);for(var t=G(n),r=0;r<t.length;r++){var e=t.charAt(r);if("i"!==e&&"m"!==e&&"u"!==e&&"s"!==e)throw new Error(\'unsupported regexp flag "\'+e+\'": \'+n)}}(n),arguments.length>=2?O(t):t=0;var r=function(n){return RegExp("^(?:"+n.source+")",G(n))}(n),u=""+n;return e(function(n,e){var o=r.exec(n.slice(e));if(o){if(0<=t&&t<=o.length){var i=o[0],a=o[t];return b(e+i.length,a)}return x(e,"valid match group (0 to "+o.length+") in "+u)}return x(e,u)})}function X(n){return e(function(t,r){return b(r,n)})}function Y(n){return e(function(t,r){return x(r,n)})}function Z(n){if(y(n))return e(function(t,r){var e=n._(t,r);return e.index=r,e.value="",e});if("string"==typeof n)return Z(K(n));if(n instanceof RegExp)return Z(Q(n));throw new Error("not a string, regexp, or parser: "+n)}function $(n){return _(n),e(function(t,r){var e=n._(t,r),u=t.slice(r,e.index);return e.status?x(r,\'not "\'+u+\'"\'):b(r,null)})}function nn(n){return k(n),e(function(t,r){var e=L(t,r);return r<t.length&&n(e)?b(r+1,e):x(r,"a character/byte matching "+n)})}function tn(n,t){arguments.length<2&&(t=n,n=void 0);var r=e(function(n,e){return r._=t()._,r._(n,e)});return n?r.desc(n):r}function rn(){return Y("fantasy-land/empty")}u.parse=function(n){if("string"!=typeof n&&!w(n))throw new Error(".parse must be called with a string or Buffer as its argument");var t,r=this.skip(an)._(n,0);return t=r.status?{status:!0,value:r.value}:{status:!1,index:S(n,r.furthest),expected:r.expected},delete j[n],t},u.tryParse=function(n){var t=this.parse(n);if(t.status)return t.value;var r=N(n,t),e=new Error(r);throw e.type="ParsimmonError",e.result=t,e},u.assert=function(n,t){return this.chain(function(r){return n(r)?X(r):Y(t)})},u.or=function(n){return T(this,n)},u.trim=function(n){return this.wrap(n,n)},u.wrap=function(n,t){return J(n,this,t,function(n,t){return t})},u.thru=function(n){return n(this)},u.then=function(n){return _(n),C(this,n).map(function(n){return n[1]})},u.many=function(){var n=this;return e(function(t,r){for(var e=[],u=void 0;;){if(!(u=B(n._(t,r),u)).status)return B(b(r,e),u);if(r===u.index)throw new Error("infinite loop detected in .many() parser --- calling .many() on a parser which can accept zero characters is usually the cause");r=u.index,e.push(u.value)}})},u.tieWith=function(n){return P(n),this.map(function(t){if(function(n){if(!E(n))throw new Error("not an array: "+n)}(t),t.length){P(t[0]);for(var r=t[0],e=1;e<t.length;e++)P(t[e]),r+=n+t[e];return r}return""})},u.tie=function(){return this.tieWith("")},u.times=function(n,t){var r=this;return arguments.length<2&&(t=n),O(n),O(t),e(function(e,u){for(var o=[],i=void 0,a=void 0,f=0;f<n;f+=1){if(a=B(i=r._(e,u),a),!i.status)return a;u=i.index,o.push(i.value)}for(;f<t&&(a=B(i=r._(e,u),a),i.status);f+=1)u=i.index,o.push(i.value);return B(b(u,o),a)})},u.result=function(n){return this.map(function(){return n})},u.atMost=function(n){return this.times(0,n)},u.atLeast=function(n){return J(this.times(n),this.many(),function(n,t){return n.concat(t)})},u.map=function(n){k(n);var t=this;return e(function(r,e){var u=t._(r,e);return u.status?B(b(u.index,n(u.value)),u):u})},u.contramap=function(n){k(n);var t=this;return e(function(r,e){var u=t.parse(n(r.slice(e)));return u.status?b(e+r.length,u.value):u})},u.promap=function(n,t){return k(n),k(t),this.contramap(n).map(t)},u.skip=function(n){return C(this,n).map(function(n){return n[0]})},u.mark=function(){return J(en,this,en,function(n,t,r){return{start:n,value:t,end:r}})},u.node=function(n){return J(en,this,en,function(t,r,e){return{name:n,value:r,start:t,end:e}})},u.sepBy=function(n){return V(this,n)},u.sepBy1=function(n){return H(this,n)},u.lookahead=function(n){return this.skip(Z(n))},u.notFollowedBy=function(n){return this.skip($(n))},u.desc=function(n){E(n)||(n=[n]);var t=this;return e(function(r,e){var u=t._(r,e);return u.status||(u.expected=n),u})},u.fallback=function(n){return this.or(X(n))},u.ap=function(n){return J(n,this,function(n,t){return n(t)})},u.chain=function(n){var t=this;return e(function(r,e){var u=t._(r,e);return u.status?B(n(u.value)._(r,u.index),u):u})},u.concat=u.or,u.empty=rn,u.of=X,u["fantasy-land/ap"]=u.ap,u["fantasy-land/chain"]=u.chain,u["fantasy-land/concat"]=u.concat,u["fantasy-land/empty"]=u.empty,u["fantasy-land/of"]=u.of,u["fantasy-land/map"]=u.map;var en=e(function(n,t){return b(t,S(n,t))}),un=e(function(n,t){return t>=n.length?x(t,"any character/byte"):b(t+1,L(n,t))}),on=e(function(n,t){return b(n.length,n.slice(t))}),an=e(function(n,t){return t<n.length?x(t,"EOF"):b(t,null)}),fn=Q(/[0-9]/).desc("a digit"),cn=Q(/[0-9]*/).desc("optional digits"),sn=Q(/[a-z]/i).desc("a letter"),ln=Q(/[a-z]*/i).desc("optional letters"),hn=Q(/\\s*/).desc("optional whitespace"),pn=Q(/\\s+/).desc("whitespace"),dn=K("\\r"),vn=K("\\n"),gn=K("\\r\\n"),mn=T(gn,vn,dn).desc("newline"),yn=T(mn,an);e.all=on,e.alt=T,e.any=un,e.cr=dn,e.createLanguage=function(n){var t={};for(var r in n)({}).hasOwnProperty.call(n,r)&&function(r){t[r]=tn(function(){return n[r](t)})}(r);return t},e.crlf=gn,e.custom=function(n){return e(n(b,x))},e.digit=fn,e.digits=cn,e.empty=rn,e.end=yn,e.eof=an,e.fail=Y,e.formatError=N,e.index=en,e.isParser=y,e.lazy=tn,e.letter=sn,e.letters=ln,e.lf=vn,e.lookahead=Z,e.makeFailure=x,e.makeSuccess=b,e.newline=mn,e.noneOf=function(n){return nn(function(t){return n.indexOf(t)<0}).desc("none of \'"+n+"\'")},e.notFollowedBy=$,e.of=X,e.oneOf=function(n){for(var t=n.split(""),r=0;r<t.length;r++)t[r]="\'"+t[r]+"\'";return nn(function(t){return n.indexOf(t)>=0}).desc(t)},e.optWhitespace=hn,e.Parser=e,e.range=function(n,t){return nn(function(r){return n<=r&&r<=t}).desc(n+"-"+t)},e.regex=Q,e.regexp=Q,e.sepBy=V,e.sepBy1=H,e.seq=C,e.seqMap=J,e.seqObj=function(){for(var n,t={},r=0,u=(n=arguments,Array.prototype.slice.call(n)),o=u.length,i=0;i<o;i+=1){var a=u[i];if(!y(a)){if(E(a)&&2===a.length&&"string"==typeof a[0]&&y(a[1])){var f=a[0];if(Object.prototype.hasOwnProperty.call(t,f))throw new Error("seqObj: duplicate key "+f);t[f]=!0,r++;continue}throw new Error("seqObj arguments must be parsers or [string, parser] array pairs.")}}if(0===r)throw new Error("seqObj expects at least one named parser, found zero");return e(function(n,t){for(var r,e={},i=0;i<o;i+=1){var a,f;if(E(u[i])?(a=u[i][0],f=u[i][1]):(a=null,f=u[i]),!(r=B(f._(n,t),r)).status)return r;a&&(e[a]=r.value),t=r.index}return B(b(t,e),r)})},e.string=K,e.succeed=X,e.takeWhile=function(n){return k(n),e(function(t,r){for(var e=r;e<t.length&&n(L(t,e));)e++;return b(e,t.slice(r,e))})},e.test=nn,e.whitespace=pn,e["fantasy-land/empty"]=rn,e["fantasy-land/of"]=X,e.Binary={bitSeq:l,bitSeqObj:function(n){s();var t={},r=0,e=a(function(n){if(E(n)){var e=n;if(2!==e.length)throw new Error("["+e.join(", ")+"] should be length 2, got length "+e.length);if(P(e[0]),O(e[1]),Object.prototype.hasOwnProperty.call(t,e[0]))throw new Error("duplicate key in bitSeqObj: "+e[0]);return t[e[0]]=!0,r++,e}return O(n),[null,n]},n);if(r<1)throw new Error("bitSeqObj expects at least one named pair, got ["+n.join(", ")+"]");var u=a(function(n){return n[0]},e);return l(a(function(n){return n[1]},e)).map(function(n){return i(function(n,t){return null!==t[0]&&(n[t[0]]=t[1]),n},{},a(function(t,r){return[t,n[r]]},u))})},byte:function(n){if(s(),O(n),n>255)throw new Error("Value specified to byte constructor ("+n+"=0x"+n.toString(16)+") is larger in value than a single byte.");var t=(n>15?"0x":"0x0")+n.toString(16);return e(function(r,e){var u=L(r,e);return u===n?b(e+1,u):x(e,t)})},buffer:function(n){return h("buffer",n).map(function(n){return Buffer.from(n)})},encodedString:function(n,t){return h("string",t).map(function(t){return t.toString(n)})},uintBE:d,uint8BE:d(1),uint16BE:d(2),uint32BE:d(4),uintLE:v,uint8LE:v(1),uint16LE:v(2),uint32LE:v(4),intBE:g,int8BE:g(1),int16BE:g(2),int32BE:g(4),intLE:m,int8LE:m(1),int16LE:m(2),int32LE:m(4),floatBE:h("floatBE",4).map(function(n){return n.readFloatBE(0)}),floatLE:h("floatLE",4).map(function(n){return n.readFloatLE(0)}),doubleBE:h("doubleBE",8).map(function(n){return n.readDoubleBE(0)}),doubleLE:h("doubleLE",8).map(function(n){return n.readDoubleLE(0)})},n.exports=e}])});\n\n//# sourceURL=webpack://vim/./node_modules/parsimmon/build/parsimmon.umd.min.js?')},"./node_modules/path-browserify/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n\n\n//# sourceURL=webpack://vim/./node_modules/path-browserify/index.js?")},"./node_modules/process/browser.js":module=>{eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack://vim/./node_modules/process/browser.js?")},"./node_modules/queue/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")\nvar EventEmitter = (__webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter)\n\nmodule.exports = Queue\nmodule.exports[\"default\"] = Queue\n\nfunction Queue (options) {\n  if (!(this instanceof Queue)) {\n    return new Queue(options)\n  }\n\n  EventEmitter.call(this)\n  options = options || {}\n  this.concurrency = options.concurrency || Infinity\n  this.timeout = options.timeout || 0\n  this.autostart = options.autostart || false\n  this.results = options.results || null\n  this.pending = 0\n  this.session = 0\n  this.running = false\n  this.jobs = []\n  this.timers = {}\n}\ninherits(Queue, EventEmitter)\n\nvar arrayMethods = [\n  'pop',\n  'shift',\n  'indexOf',\n  'lastIndexOf'\n]\n\narrayMethods.forEach(function (method) {\n  Queue.prototype[method] = function () {\n    return Array.prototype[method].apply(this.jobs, arguments)\n  }\n})\n\nQueue.prototype.slice = function (begin, end) {\n  this.jobs = this.jobs.slice(begin, end)\n  return this\n}\n\nQueue.prototype.reverse = function () {\n  this.jobs.reverse()\n  return this\n}\n\nvar arrayAddMethods = [\n  'push',\n  'unshift',\n  'splice'\n]\n\narrayAddMethods.forEach(function (method) {\n  Queue.prototype[method] = function () {\n    var methodResult = Array.prototype[method].apply(this.jobs, arguments)\n    if (this.autostart) {\n      this.start()\n    }\n    return methodResult\n  }\n})\n\nObject.defineProperty(Queue.prototype, 'length', {\n  get: function () {\n    return this.pending + this.jobs.length\n  }\n})\n\nQueue.prototype.start = function (cb) {\n  if (cb) {\n    callOnErrorOrEnd.call(this, cb)\n  }\n\n  this.running = true\n\n  if (this.pending >= this.concurrency) {\n    return\n  }\n\n  if (this.jobs.length === 0) {\n    if (this.pending === 0) {\n      done.call(this)\n    }\n    return\n  }\n\n  var self = this\n  var job = this.jobs.shift()\n  var once = true\n  var session = this.session\n  var timeoutId = null\n  var didTimeout = false\n  var resultIndex = null\n  var timeout = job.hasOwnProperty('timeout') ? job.timeout : this.timeout\n\n  function next (err, result) {\n    if (once && self.session === session) {\n      once = false\n      self.pending--\n      if (timeoutId !== null) {\n        delete self.timers[timeoutId]\n        clearTimeout(timeoutId)\n      }\n\n      if (err) {\n        self.emit('error', err, job)\n      } else if (didTimeout === false) {\n        if (resultIndex !== null) {\n          self.results[resultIndex] = Array.prototype.slice.call(arguments, 1)\n        }\n        self.emit('success', result, job)\n      }\n\n      if (self.session === session) {\n        if (self.pending === 0 && self.jobs.length === 0) {\n          done.call(self)\n        } else if (self.running) {\n          self.start()\n        }\n      }\n    }\n  }\n\n  if (timeout) {\n    timeoutId = setTimeout(function () {\n      didTimeout = true\n      if (self.listeners('timeout').length > 0) {\n        self.emit('timeout', next, job)\n      } else {\n        next()\n      }\n    }, timeout)\n    this.timers[timeoutId] = timeoutId\n  }\n\n  if (this.results) {\n    resultIndex = this.results.length\n    this.results[resultIndex] = null\n  }\n\n  this.pending++\n  self.emit('start', job)\n  var promise = job(next)\n  if (promise && promise.then && typeof promise.then === 'function') {\n    promise.then(function (result) {\n      return next(null, result)\n    }).catch(function (err) {\n      return next(err || true)\n    })\n  }\n\n  if (this.running && this.jobs.length > 0) {\n    this.start()\n  }\n}\n\nQueue.prototype.stop = function () {\n  this.running = false\n}\n\nQueue.prototype.end = function (err) {\n  clearTimers.call(this)\n  this.jobs.length = 0\n  this.pending = 0\n  done.call(this, err)\n}\n\nfunction clearTimers () {\n  for (var key in this.timers) {\n    var timeoutId = this.timers[key]\n    delete this.timers[key]\n    clearTimeout(timeoutId)\n  }\n}\n\nfunction callOnErrorOrEnd (cb) {\n  var self = this\n  this.on('error', onerror)\n  this.on('end', onend)\n\n  function onerror (err) { self.end(err) }\n  function onend (err) {\n    self.removeListener('error', onerror)\n    self.removeListener('end', onend)\n    cb(err, this.results)\n  }\n}\n\nfunction done (err) {\n  this.session++\n  this.running = false\n  this.emit('end', err)\n}\n\n\n//# sourceURL=webpack://vim/./node_modules/queue/index.js?")},"./node_modules/setimmediate/setImmediate.js":function(__unused_webpack_module,__unused_webpack_exports,__webpack_require__){eval('/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/process/browser.js");\n(function (global, undefined) {\n    "use strict";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== "function") {\n        callback = new Function("" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."\n        // So if we\'re currently running a task, we\'ll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // "too much recursion" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can\'t be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage("", "*");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = "setImmediate$" + Math.random() + "$";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === "string" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener("message", onGlobalMessage, false);\n        } else {\n            global.attachEvent("onmessage", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, "*");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it\'s been called.\n            var script = doc.createElement("script");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don\'t get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === "[object process]") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && "onreadystatechange" in doc.createElement("script")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === "undefined" ? typeof __webpack_require__.g === "undefined" ? this : __webpack_require__.g : self));\n\n\n//# sourceURL=webpack://vim/./node_modules/setimmediate/setImmediate.js?')},"./extensionBase.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.registerEventListener = exports.registerCommand = exports.activate = exports.getAndUpdateModeHandler = void 0;\nconst vscode = __importStar(__webpack_require__(/*! vscode */ \"vscode\"));\nconst commandLine_1 = __webpack_require__(/*! ./src/cmd_line/commandLine */ \"./src/cmd_line/commandLine.ts\");\nconst configuration_1 = __webpack_require__(/*! ./src/configuration/configuration */ \"./src/configuration/configuration.ts\");\nconst notation_1 = __webpack_require__(/*! ./src/configuration/notation */ \"./src/configuration/notation.ts\");\nconst globals_1 = __webpack_require__(/*! ./src/globals */ \"./src/globals.ts\");\nconst jump_1 = __webpack_require__(/*! ./src/jumps/jump */ \"./src/jumps/jump.ts\");\nconst mode_1 = __webpack_require__(/*! ./src/mode/mode */ \"./src/mode/mode.ts\");\nconst modeHandlerMap_1 = __webpack_require__(/*! ./src/mode/modeHandlerMap */ \"./src/mode/modeHandlerMap.ts\");\nconst register_1 = __webpack_require__(/*! ./src/register/register */ \"./src/register/register.ts\");\nconst compositionState_1 = __webpack_require__(/*! ./src/state/compositionState */ \"./src/state/compositionState.ts\");\nconst globalState_1 = __webpack_require__(/*! ./src/state/globalState */ \"./src/state/globalState.ts\");\nconst statusBar_1 = __webpack_require__(/*! ./src/statusBar */ \"./src/statusBar.ts\");\nconst taskQueue_1 = __webpack_require__(/*! ./src/taskQueue */ \"./src/taskQueue.ts\");\nconst logger_1 = __webpack_require__(/*! ./src/util/logger */ \"./src/util/logger.ts\");\nconst specialKeys_1 = __webpack_require__(/*! ./src/util/specialKeys */ \"./src/util/specialKeys.ts\");\nconst vscodeContext_1 = __webpack_require__(/*! ./src/util/vscodeContext */ \"./src/util/vscodeContext.ts\");\nconst exCommandParser_1 = __webpack_require__(/*! ./src/vimscript/exCommandParser */ \"./src/vimscript/exCommandParser.ts\");\nlet extensionContext;\nlet previousActiveEditorUri;\nlet lastClosedModeHandler = null;\nasync function getAndUpdateModeHandler(forceSyncAndUpdate = false) {\n    const activeTextEditor = vscode.window.activeTextEditor;\n    if (activeTextEditor === undefined || activeTextEditor.document.isClosed) {\n        return undefined;\n    }\n    const [curHandler, isNew] = await modeHandlerMap_1.ModeHandlerMap.getOrCreate(activeTextEditor);\n    if (isNew) {\n        extensionContext.subscriptions.push(curHandler);\n    }\n    curHandler.vimState.editor = activeTextEditor;\n    if (forceSyncAndUpdate ||\n        !previousActiveEditorUri ||\n        previousActiveEditorUri !== activeTextEditor.document.uri) {\n        // We sync the cursors here because ModeHandler is specific to a document, not an editor, so we\n        // need to update our representation of the cursors when switching between editors for the same document.\n        // This will be unnecessary once #4889 is fixed.\n        curHandler.syncCursors();\n        await curHandler.updateView({ drawSelection: false, revealRange: false });\n    }\n    previousActiveEditorUri = activeTextEditor.document.uri;\n    if (curHandler.focusChanged) {\n        curHandler.focusChanged = false;\n        if (previousActiveEditorUri) {\n            const prevHandler = modeHandlerMap_1.ModeHandlerMap.get(previousActiveEditorUri);\n            prevHandler.focusChanged = true;\n        }\n    }\n    return curHandler;\n}\nexports.getAndUpdateModeHandler = getAndUpdateModeHandler;\n/**\n * Loads and validates the user's configuration\n */\nasync function loadConfiguration() {\n    const validatorResults = await configuration_1.configuration.load();\n    logger_1.Logger.debug(`${validatorResults.numErrors} errors found with vim configuration`);\n    if (validatorResults.numErrors > 0) {\n        for (const validatorResult of validatorResults.get()) {\n            switch (validatorResult.level) {\n                case 'error':\n                    logger_1.Logger.error(validatorResult.message);\n                    break;\n                case 'warning':\n                    logger_1.Logger.warn(validatorResult.message);\n                    break;\n            }\n        }\n    }\n}\n/**\n * The extension's entry point\n */\nasync function activate(context, handleLocal = true) {\n    commandLine_1.ExCommandLine.parser = exCommandParser_1.exCommandParser;\n    logger_1.Logger.init();\n    // before we do anything else, we need to load the configuration\n    await loadConfiguration();\n    logger_1.Logger.debug('Start');\n    extensionContext = context;\n    extensionContext.subscriptions.push(statusBar_1.StatusBar);\n    // Load state\n    register_1.Register.loadFromDisk(handleLocal);\n    await Promise.all([commandLine_1.ExCommandLine.loadHistory(context), commandLine_1.SearchCommandLine.loadHistory(context)]);\n    if (vscode.window.activeTextEditor) {\n        const filepathComponents = vscode.window.activeTextEditor.document.fileName.split(/\\\\|\\//);\n        register_1.Register.setReadonlyRegister('%', filepathComponents[filepathComponents.length - 1]);\n    }\n    // workspace events\n    registerEventListener(context, vscode.workspace.onDidChangeConfiguration, async () => {\n        logger_1.Logger.info('Configuration changed');\n        await loadConfiguration();\n    }, false);\n    registerEventListener(context, vscode.workspace.onDidChangeTextDocument, async (event) => {\n        if (event.document.uri.scheme === 'output') {\n            // Without this, we'll get an infinite logging loop\n            return;\n        }\n        if (event.contentChanges.length === 0) {\n            // This happens when the document is saved\n            return;\n        }\n        logger_1.Logger.debug(`${event.contentChanges.length} change(s) to ${event.document.fileName} because ${event.reason}`);\n        for (const x of event.contentChanges) {\n            logger_1.Logger.trace(`\\t-${x.rangeLength}, +'${x.text}'`);\n        }\n        if (event.contentChanges.length === 1) {\n            const change = event.contentChanges[0];\n            const anyLinesDeleted = change.range.start.line !== change.range.end.line;\n            if (anyLinesDeleted && change.text === '') {\n                globalState_1.globalState.jumpTracker.handleTextDeleted(event.document, change.range);\n            }\n            else if (!anyLinesDeleted && change.text.includes('\\n')) {\n                globalState_1.globalState.jumpTracker.handleTextAdded(event.document, change.range, change.text);\n            }\n            else {\n                // TODO: What to do here?\n            }\n        }\n        else {\n            // TODO: In this case, we should probably loop over the content changes...\n        }\n        // Change from VSCode editor should set document.isDirty to true but they initially don't!\n        // There is a timing issue in VSCode codebase between when the isDirty flag is set and\n        // when registered callbacks are fired. https://github.com/Microsoft/vscode/issues/11339\n        const contentChangeHandler = (modeHandler) => {\n            if (modeHandler.vimState.currentMode === mode_1.Mode.Insert) {\n                if (modeHandler.vimState.historyTracker.currentContentChanges === undefined) {\n                    modeHandler.vimState.historyTracker.currentContentChanges = [];\n                }\n                modeHandler.vimState.historyTracker.currentContentChanges =\n                    modeHandler.vimState.historyTracker.currentContentChanges.concat(event.contentChanges);\n            }\n        };\n        const mh = modeHandlerMap_1.ModeHandlerMap.get(event.document.uri);\n        if (mh) {\n            contentChangeHandler(mh);\n        }\n    });\n    registerEventListener(context, vscode.workspace.onDidCloseTextDocument, async (closedDocument) => {\n        logger_1.Logger.info(`${closedDocument.fileName} closed`);\n        // Delete modehandler once all tabs of this document have been closed\n        for (const [uri, modeHandler] of modeHandlerMap_1.ModeHandlerMap.entries()) {\n            let shouldDelete = false;\n            if (modeHandler == null) {\n                shouldDelete = true;\n            }\n            else {\n                const document = modeHandler.vimState.document;\n                if (!vscode.workspace.textDocuments.includes(document)) {\n                    shouldDelete = true;\n                    if (closedDocument === document) {\n                        lastClosedModeHandler = modeHandler;\n                    }\n                }\n            }\n            if (shouldDelete) {\n                modeHandlerMap_1.ModeHandlerMap.delete(uri);\n            }\n        }\n    }, false);\n    // window events\n    registerEventListener(context, vscode.window.onDidChangeActiveTextEditor, async (activeTextEditor) => {\n        if (activeTextEditor) {\n            logger_1.Logger.info(`Active editor: ${activeTextEditor.document.uri}`);\n        }\n        else {\n            logger_1.Logger.debug(`No active editor`);\n        }\n        const mhPrevious = previousActiveEditorUri\n            ? modeHandlerMap_1.ModeHandlerMap.get(previousActiveEditorUri)\n            : undefined;\n        // Track the closed editor so we can use it the next time an open event occurs.\n        // When vscode changes away from a temporary file, onDidChangeActiveTextEditor first twice.\n        // First it fires when leaving the closed editor. Then onDidCloseTextDocument first, and we delete\n        // the old ModeHandler. Then a new editor opens.\n        //\n        // This also applies to files that are merely closed, which allows you to jump back to that file similarly\n        // once a new file is opened.\n        lastClosedModeHandler = mhPrevious || lastClosedModeHandler;\n        const oldFileRegister = (await register_1.Register.get('%'))?.text;\n        const relativePath = activeTextEditor\n            ? vscode.workspace.asRelativePath(activeTextEditor.document.uri, false)\n            : '';\n        if (relativePath !== oldFileRegister) {\n            if (oldFileRegister && oldFileRegister !== '') {\n                register_1.Register.setReadonlyRegister('#', oldFileRegister);\n            }\n            register_1.Register.setReadonlyRegister('%', relativePath);\n        }\n        if (activeTextEditor === undefined) {\n            return;\n        }\n        taskQueue_1.taskQueue.enqueueTask(async () => {\n            const mh = await getAndUpdateModeHandler(true);\n            if (mh) {\n                globalState_1.globalState.jumpTracker.handleFileJump(lastClosedModeHandler ? jump_1.Jump.fromStateNow(lastClosedModeHandler.vimState) : null, jump_1.Jump.fromStateNow(mh.vimState));\n            }\n        });\n    }, true, true);\n    registerEventListener(context, vscode.window.onDidChangeTextEditorSelection, async (e) => {\n        if (e.textEditor.document.uri.scheme === 'output') {\n            // Without this, we can an infinite logging loop\n            return;\n        }\n        if (vscode.window.activeTextEditor === undefined ||\n            e.textEditor.document !== vscode.window.activeTextEditor.document) {\n            // We don't care if user selection changed in a paneled window (e.g debug console/terminal)\n            return;\n        }\n        const mh = modeHandlerMap_1.ModeHandlerMap.get(vscode.window.activeTextEditor.document.uri);\n        if (mh === undefined) {\n            // We don't care if there is no active editor\n            return;\n        }\n        if (e.kind !== vscode.TextEditorSelectionChangeKind.Mouse) {\n            const selectionsHash = e.selections.reduce((hash, s) => hash +\n                `[${s.anchor.line}, ${s.anchor.character}; ${s.active.line}, ${s.active.character}]`, '');\n            const idx = mh.selectionsChanged.ourSelections.indexOf(selectionsHash);\n            if (idx > -1) {\n                mh.selectionsChanged.ourSelections.splice(idx, 1);\n                logger_1.Logger.trace(`Ignoring selection: ${selectionsHash}. ${mh.selectionsChanged.ourSelections.length} left`);\n                return;\n            }\n            else if (mh.selectionsChanged.ignoreIntermediateSelections) {\n                logger_1.Logger.trace(`Ignoring intermediate selection change: ${selectionsHash}`);\n                return;\n            }\n            else if (mh.selectionsChanged.ourSelections.length > 0) {\n                // Some intermediate selection must have slipped in after setting the\n                // 'ignoreIntermediateSelections' to false. Which means we didn't count\n                // for it yet, but since we have selections to be ignored then we probably\n                // wanted this one to be ignored as well.\n                logger_1.Logger.warn(`Ignoring slipped selection: ${selectionsHash}`);\n                return;\n            }\n        }\n        // We may receive changes from other panels when, having selections in them containing the same file\n        // and changing text before the selection in current panel.\n        if (e.textEditor !== mh.vimState.editor) {\n            return;\n        }\n        if (mh.focusChanged) {\n            mh.focusChanged = false;\n            return;\n        }\n        if (mh.currentMode === mode_1.Mode.EasyMotionMode) {\n            return;\n        }\n        taskQueue_1.taskQueue.enqueueTask(() => mh.handleSelectionChange(e));\n    }, true, false);\n    registerEventListener(context, vscode.window.onDidChangeTextEditorVisibleRanges, async (e) => {\n        if (e.textEditor !== vscode.window.activeTextEditor) {\n            return;\n        }\n        taskQueue_1.taskQueue.enqueueTask(async () => {\n            // Scrolling the viewport clears any status bar message, even errors.\n            const mh = await getAndUpdateModeHandler();\n            if (mh && statusBar_1.StatusBar.lastMessageTime) {\n                // TODO: Using the time elapsed works most of the time, but is a bit of a hack\n                const timeElapsed = Date.now() - Number(statusBar_1.StatusBar.lastMessageTime);\n                if (timeElapsed > 100) {\n                    statusBar_1.StatusBar.clear(mh.vimState, true);\n                }\n            }\n        });\n    });\n    const compositionState = new compositionState_1.CompositionState();\n    // Override VSCode commands\n    overrideCommand(context, 'type', async (args) => {\n        taskQueue_1.taskQueue.enqueueTask(async () => {\n            const mh = await getAndUpdateModeHandler();\n            if (mh) {\n                if (compositionState.isInComposition) {\n                    compositionState.composingText += args.text;\n                    if (mh.vimState.currentMode === mode_1.Mode.Insert) {\n                        compositionState.insertedText = true;\n                        void vscode.commands.executeCommand('default:type', { text: args.text });\n                    }\n                }\n                else {\n                    await mh.handleKeyEvent(args.text);\n                }\n            }\n        });\n    });\n    overrideCommand(context, 'replacePreviousChar', async (args) => {\n        taskQueue_1.taskQueue.enqueueTask(async () => {\n            const mh = await getAndUpdateModeHandler();\n            if (mh) {\n                if (compositionState.isInComposition) {\n                    compositionState.composingText =\n                        compositionState.composingText.substr(0, compositionState.composingText.length - args.replaceCharCnt) + args.text;\n                }\n                if (compositionState.insertedText) {\n                    await vscode.commands.executeCommand('default:replacePreviousChar', {\n                        text: args.text,\n                        replaceCharCnt: args.replaceCharCnt,\n                    });\n                    mh.vimState.cursorStopPosition = mh.vimState.editor.selection.start;\n                    mh.vimState.cursorStartPosition = mh.vimState.editor.selection.start;\n                }\n            }\n            else {\n                await vscode.commands.executeCommand('default:replacePreviousChar', {\n                    text: args.text,\n                    replaceCharCnt: args.replaceCharCnt,\n                });\n            }\n        });\n    });\n    overrideCommand(context, 'compositionStart', async () => {\n        taskQueue_1.taskQueue.enqueueTask(async () => {\n            compositionState.isInComposition = true;\n        });\n    });\n    overrideCommand(context, 'compositionEnd', async () => {\n        taskQueue_1.taskQueue.enqueueTask(async () => {\n            const mh = await getAndUpdateModeHandler();\n            if (mh) {\n                if (compositionState.insertedText) {\n                    mh.selectionsChanged.ignoreIntermediateSelections = true;\n                    await vscode.commands.executeCommand('default:replacePreviousChar', {\n                        text: '',\n                        replaceCharCnt: compositionState.composingText.length,\n                    });\n                    mh.vimState.cursorStopPosition = mh.vimState.editor.selection.active;\n                    mh.vimState.cursorStartPosition = mh.vimState.editor.selection.active;\n                    mh.selectionsChanged.ignoreIntermediateSelections = false;\n                }\n                const text = compositionState.composingText;\n                await mh.handleMultipleKeyEvents(text.split(''));\n            }\n            compositionState.reset();\n        });\n    });\n    // Register extension commands\n    registerCommand(context, 'vim.showQuickpickCmdLine', async () => {\n        const mh = await getAndUpdateModeHandler();\n        if (mh) {\n            const cmd = await vscode.window.showInputBox({\n                prompt: 'Vim command line',\n                value: '',\n                ignoreFocusOut: false,\n                valueSelection: [0, 0],\n            });\n            if (cmd) {\n                await new commandLine_1.ExCommandLine(cmd, mh.vimState.currentMode).run(mh.vimState);\n            }\n            void mh.updateView();\n        }\n    });\n    registerCommand(context, 'vim.remap', async (args) => {\n        taskQueue_1.taskQueue.enqueueTask(async () => {\n            const mh = await getAndUpdateModeHandler();\n            if (mh === undefined) {\n                return;\n            }\n            if (!args) {\n                throw new Error(\"'args' is undefined. For this remap to work it needs to have 'args' with an '\\\"after\\\": string[]' and/or a '\\\"commands\\\": { command: string; args: any[] }[]'\");\n            }\n            if (args.after) {\n                for (const key of args.after) {\n                    await mh.handleKeyEvent(notation_1.Notation.NormalizeKey(key, configuration_1.configuration.leader));\n                }\n            }\n            if (args.commands) {\n                for (const command of args.commands) {\n                    // Check if this is a vim command by looking for :\n                    if (command.command.startsWith(':')) {\n                        await new commandLine_1.ExCommandLine(command.command.slice(1, command.command.length), mh.vimState.currentMode).run(mh.vimState);\n                        void mh.updateView();\n                    }\n                    else {\n                        await vscode.commands.executeCommand(command.command, command.args);\n                    }\n                }\n            }\n        });\n    });\n    registerCommand(context, 'toggleVim', async () => {\n        configuration_1.configuration.disableExtension = !configuration_1.configuration.disableExtension;\n        void toggleExtension(configuration_1.configuration.disableExtension, compositionState);\n    });\n    for (const boundKey of configuration_1.configuration.boundKeyCombinations) {\n        const command = ['<Esc>', '<C-c>'].includes(boundKey.key)\n            ? async () => {\n                const mh = await getAndUpdateModeHandler();\n                if (mh && !(await forceStopRecursiveRemap(mh))) {\n                    await mh.handleKeyEvent(`${boundKey.key}`);\n                }\n            }\n            : async () => {\n                const mh = await getAndUpdateModeHandler();\n                if (mh) {\n                    await mh.handleKeyEvent(`${boundKey.key}`);\n                }\n            };\n        registerCommand(context, boundKey.command, async () => {\n            taskQueue_1.taskQueue.enqueueTask(command);\n        });\n    }\n    {\n        // Initialize mode handler for current active Text Editor at startup.\n        const modeHandler = await getAndUpdateModeHandler();\n        if (modeHandler) {\n            if (!configuration_1.configuration.startInInsertMode) {\n                const vimState = modeHandler.vimState;\n                // Make sure no cursors start on the EOL character (which is invalid in normal mode)\n                // This can happen if we quit last session in insert mode at the end of the line\n                vimState.cursors = vimState.cursors.map((cursor) => {\n                    const eolColumn = vimState.document.lineAt(cursor.stop).text.length;\n                    if (cursor.stop.character >= eolColumn) {\n                        const character = Math.max(eolColumn - 1, 0);\n                        return cursor.withNewStop(cursor.stop.with({ character }));\n                    }\n                    else {\n                        return cursor;\n                    }\n                });\n            }\n            // This is called last because getAndUpdateModeHandler() will change cursor\n            void modeHandler.updateView({ drawSelection: true, revealRange: false });\n        }\n    }\n    // Disable automatic keyboard navigation in lists, so it doesn't interfere\n    // with our list navigation keybindings\n    await vscodeContext_1.VSCodeContext.set('listAutomaticKeyboardNavigation', false);\n    await toggleExtension(configuration_1.configuration.disableExtension, compositionState);\n    logger_1.Logger.debug('Finish.');\n}\nexports.activate = activate;\n/**\n * Toggles the VSCodeVim extension between Enabled mode and Disabled mode. This\n * function is activated by calling the 'toggleVim' command from the Command Palette.\n *\n * @param isDisabled if true, sets VSCodeVim to Disabled mode; else sets to enabled mode\n */\nasync function toggleExtension(isDisabled, compositionState) {\n    await vscodeContext_1.VSCodeContext.set('vim.active', !isDisabled);\n    const mh = await getAndUpdateModeHandler();\n    if (mh) {\n        if (isDisabled) {\n            await mh.handleKeyEvent(specialKeys_1.SpecialKeys.ExtensionDisable);\n            compositionState.reset();\n            modeHandlerMap_1.ModeHandlerMap.clear();\n        }\n        else {\n            await mh.handleKeyEvent(specialKeys_1.SpecialKeys.ExtensionEnable);\n        }\n    }\n}\nfunction overrideCommand(context, command, callback) {\n    const disposable = vscode.commands.registerCommand(command, async (args) => {\n        if (configuration_1.configuration.disableExtension) {\n            return vscode.commands.executeCommand('default:' + command, args);\n        }\n        if (!vscode.window.activeTextEditor) {\n            return;\n        }\n        if (vscode.window.activeTextEditor.document &&\n            vscode.window.activeTextEditor.document.uri.toString() === 'debug:input') {\n            return vscode.commands.executeCommand('default:' + command, args);\n        }\n        return callback(args);\n    });\n    context.subscriptions.push(disposable);\n}\nfunction registerCommand(context, command, callback, requiresActiveEditor = true) {\n    const disposable = vscode.commands.registerCommand(command, async (args) => {\n        if (requiresActiveEditor && !vscode.window.activeTextEditor) {\n            return;\n        }\n        callback(args);\n    });\n    context.subscriptions.push(disposable);\n}\nexports.registerCommand = registerCommand;\nfunction registerEventListener(context, event, listener, exitOnExtensionDisable = true, exitOnTests = false) {\n    const disposable = event(async (e) => {\n        if (exitOnExtensionDisable && configuration_1.configuration.disableExtension) {\n            return;\n        }\n        if (exitOnTests && globals_1.Globals.isTesting) {\n            return;\n        }\n        listener(e);\n    });\n    context.subscriptions.push(disposable);\n}\nexports.registerEventListener = registerEventListener;\n/**\n * @returns true if there was a remap being executed to stop\n */\nasync function forceStopRecursiveRemap(mh) {\n    if (mh.remapState.isCurrentlyPerformingRecursiveRemapping) {\n        mh.remapState.forceStopRecursiveRemapping = true;\n        return true;\n    }\n    return false;\n}\n\n\n//# sourceURL=webpack://vim/./extensionBase.ts?")},"./extensionWeb.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.activate = void 0;\n/**\n * Extension.ts is a lightweight wrapper around ModeHandler. It converts key\n * events to their string names and passes them on to ModeHandler via\n * handleKeyEvent().\n */\n__webpack_require__(/*! ./src/actions/include-main */ "./src/actions/include-main.ts");\n/**\n * Load configuration validator\n */\n__webpack_require__(/*! ./src/configuration/validators/inputMethodSwitcherValidator */ "./src/configuration/validators/inputMethodSwitcherValidator.ts");\n__webpack_require__(/*! ./src/configuration/validators/remappingValidator */ "./src/configuration/validators/remappingValidator.ts");\nconst extensionBase_1 = __webpack_require__(/*! ./extensionBase */ "./extensionBase.ts");\n__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");\nasync function activate(context) {\n    void (0, extensionBase_1.activate)(context, false);\n}\nexports.activate = activate;\n\n\n//# sourceURL=webpack://vim/./extensionWeb.ts?')},"./src/actions/base.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.RegisterAction = exports.getRelevantAction = exports.KeypressState = exports.BaseCommand = exports.BaseAction = void 0;\nconst cursor_1 = __webpack_require__(/*! ../common/motion/cursor */ "./src/common/motion/cursor.ts");\nconst notation_1 = __webpack_require__(/*! ../configuration/notation */ "./src/configuration/notation.ts");\nconst transformations_1 = __webpack_require__(/*! ../transformations/transformations */ "./src/transformations/transformations.ts");\nconst configuration_1 = __webpack_require__(/*! ./../configuration/configuration */ "./src/configuration/configuration.ts");\nconst mode_1 = __webpack_require__(/*! ./../mode/mode */ "./src/mode/mode.ts");\nclass BaseAction {\n    constructor() {\n        this.name = \'\';\n        /**\n         * If true, the cursor position will be added to the jump list on completion.\n         */\n        this.isJump = false;\n        /**\n         * If true, the action will create an undo point.\n         */\n        this.createsUndoPoint = false;\n        /**\n         * Whether we should change `vimState.desiredColumn`\n         */\n        this.preservesDesiredColumn = false;\n        /**\n         * The keys pressed at the time that this action was triggered.\n         */\n        // TODO: make readonly\n        this.keysPressed = [];\n    }\n    /**\n     * Is this action valid in the current Vim state?\n     */\n    doesActionApply(vimState, keysPressed) {\n        if (vimState.currentModeIncludingPseudoModes === mode_1.Mode.OperatorPendingMode &&\n            this.actionType === \'command\') {\n            return false;\n        }\n        return (this.modes.includes(vimState.currentMode) &&\n            BaseAction.CompareKeypressSequence(this.keys, keysPressed));\n    }\n    /**\n     * Could the user be in the process of doing this action.\n     */\n    couldActionApply(vimState, keysPressed) {\n        if (vimState.currentModeIncludingPseudoModes === mode_1.Mode.OperatorPendingMode &&\n            this.actionType === \'command\') {\n            return false;\n        }\n        if (!this.modes.includes(vimState.currentMode)) {\n            return false;\n        }\n        const keys2D = BaseAction.is2DArray(this.keys) ? this.keys : [this.keys];\n        const keysSlice = keys2D.map((x) => x.slice(0, keysPressed.length));\n        if (!BaseAction.CompareKeypressSequence(keysSlice, keysPressed)) {\n            return false;\n        }\n        return true;\n    }\n    static CompareKeypressSequence(one, two) {\n        if (BaseAction.is2DArray(one)) {\n            for (const sequence of one) {\n                if (BaseAction.CompareKeypressSequence(sequence, two)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        if (one.length !== two.length) {\n            return false;\n        }\n        for (let i = 0, j = 0; i < one.length; i++, j++) {\n            const left = one[i];\n            const right = two[j];\n            if (left === right && right !== configuration_1.configuration.leader) {\n                continue;\n            }\n            else if (left === \'<any>\') {\n                continue;\n            }\n            else if (left === \'<leader>\' && right === configuration_1.configuration.leader) {\n                continue;\n            }\n            else if (left === \'<number>\' && this.isSingleNumber.test(right)) {\n                continue;\n            }\n            else if (left === \'<alpha>\' && this.isSingleAlpha.test(right)) {\n                continue;\n            }\n            else if (left === \'<character>\' && !notation_1.Notation.IsControlKey(right)) {\n                continue;\n            }\n            else {\n                return false;\n            }\n        }\n        return true;\n    }\n    toString() {\n        return this.keys.join(\'\');\n    }\n    static is2DArray(x) {\n        return Array.isArray(x[0]);\n    }\n}\nexports.BaseAction = BaseAction;\nBaseAction.isSingleNumber = /^[0-9]$/;\nBaseAction.isSingleAlpha = /^[a-zA-Z]$/;\n/**\n * A command is something like <Esc>, :, v, i, etc.\n */\nclass BaseCommand extends BaseAction {\n    constructor() {\n        super(...arguments);\n        this.actionType = \'command\';\n        /**\n         * If isCompleteAction is true, then triggering this command is a complete action -\n         * that means that we\'ll go and try to run it.\n         */\n        this.isCompleteAction = true;\n        /**\n         * If true, exec() will get called N times where N is the count.\n         *\n         * If false, exec() will only be called once, and you are expected to\n         * handle count prefixes (e.g. the 3 in 3w) yourself.\n         */\n        this.runsOnceForEachCountPrefix = false;\n    }\n    /**\n     * In multi-cursor mode, do we run this command for every cursor, or just once?\n     */\n    runsOnceForEveryCursor() {\n        return true;\n    }\n    /**\n     * Run the command a single time.\n     */\n    async exec(position, vimState) {\n        throw new Error(\'Not implemented!\');\n    }\n    /**\n     * Run the command the number of times VimState wants us to.\n     */\n    async execCount(position, vimState) {\n        const timesToRepeat = this.runsOnceForEachCountPrefix ? vimState.recordedState.count || 1 : 1;\n        if (!this.runsOnceForEveryCursor()) {\n            for (let i = 0; i < timesToRepeat; i++) {\n                await this.exec(position, vimState);\n            }\n            for (const transformation of vimState.recordedState.transformer.transformations) {\n                if ((0, transformations_1.isTextTransformation)(transformation) && transformation.cursorIndex === undefined) {\n                    transformation.cursorIndex = 0;\n                }\n            }\n            return;\n        }\n        const resultingCursors = [];\n        const cursorsToIterateOver = vimState.cursors\n            .map((x) => new cursor_1.Cursor(x.start, x.stop))\n            .sort((a, b) => a.start.line > b.start.line ||\n            (a.start.line === b.start.line && a.start.character > b.start.character)\n            ? 1\n            : -1);\n        let cursorIndex = 0;\n        for (const { start, stop } of cursorsToIterateOver) {\n            this.multicursorIndex = cursorIndex++;\n            vimState.cursorStopPosition = stop;\n            vimState.cursorStartPosition = start;\n            for (let j = 0; j < timesToRepeat; j++) {\n                await this.exec(stop, vimState);\n            }\n            resultingCursors.push(new cursor_1.Cursor(vimState.cursorStartPosition, vimState.cursorStopPosition));\n            for (const transformation of vimState.recordedState.transformer.transformations) {\n                if ((0, transformations_1.isTextTransformation)(transformation) && transformation.cursorIndex === undefined) {\n                    transformation.cursorIndex = this.multicursorIndex;\n                }\n            }\n        }\n        vimState.cursors = resultingCursors;\n    }\n}\nexports.BaseCommand = BaseCommand;\nvar KeypressState;\n(function (KeypressState) {\n    KeypressState[KeypressState["WaitingOnKeys"] = 0] = "WaitingOnKeys";\n    KeypressState[KeypressState["NoPossibleMatch"] = 1] = "NoPossibleMatch";\n})(KeypressState || (exports.KeypressState = KeypressState = {}));\n/**\n * Every Vim action will be added here with the @RegisterAction decorator.\n */\nconst actionMap = new Map();\n/**\n * Gets the action that should be triggered given a key sequence.\n *\n * If there is a definitive action that matched, returns that action.\n *\n * If an action could potentially match if more keys were to be pressed, returns `KeyPressState.WaitingOnKeys`\n * (e.g. you pressed "g" and are about to press "g" action to make the full action "gg")\n *\n * If no action could ever match, returns `KeypressState.NoPossibleMatch`.\n */\nfunction getRelevantAction(keysPressed, vimState) {\n    const possibleActionsForMode = actionMap.get(vimState.currentMode) ?? [];\n    let hasPotentialMatch = false;\n    for (const actionType of possibleActionsForMode) {\n        // TODO: Constructing up to several hundred Actions every time we hit a key is moronic.\n        //       I think we can make `doesActionApply` and `couldActionApply` static...\n        const action = new actionType();\n        if (action.doesActionApply(vimState, keysPressed)) {\n            action.keysPressed = vimState.recordedState.actionKeys.slice(0);\n            return action;\n        }\n        hasPotentialMatch ||= action.couldActionApply(vimState, keysPressed);\n    }\n    return hasPotentialMatch ? KeypressState.WaitingOnKeys : KeypressState.NoPossibleMatch;\n}\nexports.getRelevantAction = getRelevantAction;\nfunction RegisterAction(action) {\n    const actionInstance = new action();\n    for (const modeName of actionInstance.modes) {\n        let actions = actionMap.get(modeName);\n        if (!actions) {\n            actions = [];\n            actionMap.set(modeName, actions);\n        }\n        if (actionInstance.keys === undefined) {\n            // action that can\'t be called directly\n            continue;\n        }\n        actions.push(action);\n    }\n}\nexports.RegisterAction = RegisterAction;\n\n\n//# sourceURL=webpack://vim/./src/actions/base.ts?')},"./src/actions/baseMotion.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.BaseMovement = exports.failedMovement = exports.SelectionType = exports.isIMovement = void 0;\nconst base_1 = __webpack_require__(/*! ./base */ "./src/actions/base.ts");\nconst mode_1 = __webpack_require__(/*! ../mode/mode */ "./src/mode/mode.ts");\nconst util_1 = __webpack_require__(/*! ../util/util */ "./src/util/util.ts");\nconst vscode_1 = __webpack_require__(/*! vscode */ "vscode");\nfunction isIMovement(o) {\n    return o.start !== undefined && o.stop !== undefined;\n}\nexports.isIMovement = isIMovement;\nvar SelectionType;\n(function (SelectionType) {\n    SelectionType[SelectionType["Concatenating"] = 0] = "Concatenating";\n    SelectionType[SelectionType["Expanding"] = 1] = "Expanding";\n})(SelectionType || (exports.SelectionType = SelectionType = {}));\nfunction failedMovement(vimState) {\n    return {\n        start: vimState.cursorStartPosition,\n        stop: vimState.cursorStopPosition,\n        failed: true,\n    };\n}\nexports.failedMovement = failedMovement;\nclass BaseMovement extends base_1.BaseAction {\n    constructor(keysPressed, isRepeat) {\n        super();\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n        this.actionType = \'motion\';\n        /**\n         * If movement can be repeated with semicolon or comma this will be true when\n         * running the repetition.\n         */\n        this.isRepeat = false;\n        /**\n         * This is for commands like $ which force the desired column to be at\n         * the end of even the longest line.\n         */\n        this.setsDesiredColumnToEOL = false;\n        this.selectionType = SelectionType.Concatenating;\n        if (keysPressed) {\n            this.keysPressed = keysPressed;\n        }\n        if (isRepeat) {\n            this.isRepeat = isRepeat;\n        }\n    }\n    /**\n     * Run the movement a single time.\n     *\n     * Generally returns a new Position. If necessary, it can return an IMovement instead.\n     * Note: If returning an IMovement, make sure that repeated actions on a\n     * visual selection work. For example, V}}\n     */\n    async execAction(position, vimState, firstIteration, lastIteration) {\n        throw new Error(\'Not implemented!\');\n    }\n    /**\n     * Run the movement in an operator context a single time.\n     *\n     * Some movements operate over different ranges when used for operators.\n     */\n    async execActionForOperator(position, vimState, firstIteration, lastIteration) {\n        return this.execAction(position, vimState, firstIteration, lastIteration);\n    }\n    /**\n     * Run a movement count times.\n     *\n     * count: the number prefix the user entered, or 0 if they didn\'t enter one.\n     */\n    async execActionWithCount(position, vimState, count) {\n        let result;\n        let prevResult = failedMovement(vimState);\n        let firstMovementStart = position;\n        count = (0, util_1.clamp)(count, 1, 99999);\n        for (let i = 0; i < count; i++) {\n            const firstIteration = i === 0;\n            const lastIteration = i === count - 1;\n            result =\n                vimState.recordedState.operator && lastIteration\n                    ? await this.execActionForOperator(position, vimState, firstIteration, lastIteration)\n                    : await this.execAction(position, vimState, firstIteration, lastIteration);\n            if (result instanceof vscode_1.Position) {\n                /**\n                 * This position will be passed to the `motion` on the next iteration,\n                 * it may cause some issues when count > 1.\n                 */\n                position = result;\n            }\n            else {\n                if (result.failed) {\n                    return prevResult;\n                }\n                if (firstIteration) {\n                    firstMovementStart = result.start;\n                }\n                position = this.adjustPosition(position, result, lastIteration);\n                prevResult = result;\n            }\n        }\n        if (this.selectionType === SelectionType.Concatenating && isIMovement(result)) {\n            result.start = firstMovementStart;\n        }\n        return result;\n    }\n    adjustPosition(position, result, lastIteration) {\n        if (!lastIteration) {\n            position = result.stop.getRightThroughLineBreaks();\n        }\n        return position;\n    }\n}\nexports.BaseMovement = BaseMovement;\n\n\n//# sourceURL=webpack://vim/./src/actions/baseMotion.ts?')},"./src/actions/commands/actions.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar CommandNumber_1;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ActionOverrideCmdD = exports.CommandUnicodeName = exports.ActionDeleteCharVisualLineMode = exports.ActionDeleteLastChar = exports.ActionDeleteCharWithDeleteKey = exports.ActionDeleteChar = exports.CommandInsertNewLineBefore = exports.CommandInsertNewLineAbove = exports.CommandInsertAtLineEnd = exports.CommandInsertAfterCursor = exports.CommandInsertAtLineBegin = exports.CommandInsertAtFirstCharacter = exports.CommandInsertAtLastChange = exports.CommandYankFullLine = exports.CommandRedo = exports.CommandUndo = exports.CommandShowSearchHistory = exports.CommandShowCommandHistory = exports.CommandReplaceAtCursorFromNormalMode = exports.CommandInsertAtCursor = exports.CommandQuitRecordMacro = exports.CommandRegister = exports.CommandNumber = exports.DocumentContentChangeAction = void 0;\nconst vscode = __importStar(__webpack_require__(/*! vscode */ \"vscode\"));\nconst path_1 = __importDefault(__webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\"));\nconst fs_1 = __webpack_require__(/*! platform/fs */ \"./src/platform/browser/fs.ts\");\nconst vscode_1 = __webpack_require__(/*! vscode */ \"vscode\");\nconst writequit_1 = __webpack_require__(/*! ../../cmd_line/commands/writequit */ \"./src/cmd_line/commands/writequit.ts\");\nconst cursor_1 = __webpack_require__(/*! ../../common/motion/cursor */ \"./src/common/motion/cursor.ts\");\nconst error_1 = __webpack_require__(/*! ../../error */ \"./src/error.ts\");\nconst globalState_1 = __webpack_require__(/*! ../../state/globalState */ \"./src/state/globalState.ts\");\nconst recordedState_1 = __webpack_require__(/*! ../../state/recordedState */ \"./src/state/recordedState.ts\");\nconst statusBar_1 = __webpack_require__(/*! ../../statusBar */ \"./src/statusBar.ts\");\nconst word_1 = __webpack_require__(/*! ../../textobject/word */ \"./src/textobject/word.ts\");\nconst clipboard_1 = __webpack_require__(/*! ../../util/clipboard */ \"./src/util/clipboard.ts\");\nconst specialKeys_1 = __webpack_require__(/*! ../../util/specialKeys */ \"./src/util/specialKeys.ts\");\nconst statusBarTextUtils_1 = __webpack_require__(/*! ../../util/statusBarTextUtils */ \"./src/util/statusBarTextUtils.ts\");\nconst util_1 = __webpack_require__(/*! ../../util/util */ \"./src/util/util.ts\");\nconst pattern_1 = __webpack_require__(/*! ../../vimscript/pattern */ \"./src/vimscript/pattern.ts\");\nconst wrapping_1 = __webpack_require__(/*! ../wrapping */ \"./src/actions/wrapping.ts\");\nconst commandLine_1 = __webpack_require__(/*! ./../../cmd_line/commandLine */ \"./src/cmd_line/commandLine.ts\");\nconst file_1 = __webpack_require__(/*! ./../../cmd_line/commands/file */ \"./src/cmd_line/commands/file.ts\");\nconst quit_1 = __webpack_require__(/*! ./../../cmd_line/commands/quit */ \"./src/cmd_line/commands/quit.ts\");\nconst tab_1 = __webpack_require__(/*! ./../../cmd_line/commands/tab */ \"./src/cmd_line/commands/tab.ts\");\nconst position_1 = __webpack_require__(/*! ./../../common/motion/position */ \"./src/common/motion/position.ts\");\nconst numericString_1 = __webpack_require__(/*! ./../../common/number/numericString */ \"./src/common/number/numericString.ts\");\nconst configuration_1 = __webpack_require__(/*! ./../../configuration/configuration */ \"./src/configuration/configuration.ts\");\nconst mode_1 = __webpack_require__(/*! ./../../mode/mode */ \"./src/mode/mode.ts\");\nconst register_1 = __webpack_require__(/*! ./../../register/register */ \"./src/register/register.ts\");\nconst textEditor_1 = __webpack_require__(/*! ./../../textEditor */ \"./src/textEditor.ts\");\nconst transformations_1 = __webpack_require__(/*! ./../../transformations/transformations */ \"./src/transformations/transformations.ts\");\nconst base_1 = __webpack_require__(/*! ./../base */ \"./src/actions/base.ts\");\nconst operator = __importStar(__webpack_require__(/*! ./../operator */ \"./src/actions/operator.ts\"));\n/**\n * A very special snowflake.\n *\n * Each keystroke when typing in Insert mode is its own Action, which means naively replaying a\n * realistic insertion (via `.` or a macro) does many small insertions, which is very slow.\n * So instead, we fold all those actions after the fact into a single DocumentContentChangeAction,\n * which compresses the changes, generally into a single document edit per cursor.\n */\nclass DocumentContentChangeAction extends base_1.BaseCommand {\n    constructor(cursorStart) {\n        super();\n        this.modes = [];\n        this.keys = [];\n        this.contentChanges = [];\n        this.cursorStart = cursorStart;\n        this.cursorEnd = cursorStart;\n    }\n    addChanges(changes, cursorPosition) {\n        this.contentChanges = [...this.contentChanges, ...changes];\n        this.compressChanges();\n        this.cursorEnd = cursorPosition;\n    }\n    getTransformation(positionDiff) {\n        return {\n            type: 'contentChange',\n            changes: this.contentChanges,\n            diff: positionDiff,\n        };\n    }\n    async exec(position, vimState) {\n        if (this.contentChanges.length === 0) {\n            return;\n        }\n        let originalLeftBoundary = this.cursorStart;\n        let rightBoundary = position;\n        for (const change of this.contentChanges) {\n            if (change.range.start.line < originalLeftBoundary.line) {\n                // This change should be ignored\n                const linesAffected = change.range.end.line - change.range.start.line + 1;\n                const resultLines = change.text.split('\\n').length;\n                originalLeftBoundary = originalLeftBoundary.with(Math.max(0, originalLeftBoundary.line + resultLines - linesAffected));\n                continue;\n            }\n            // Translates diffPos from a position relative to originalLeftBoundary to one relative to position\n            const translate = (diffPos) => {\n                const lineOffset = diffPos.line - originalLeftBoundary.line;\n                const char = lineOffset === 0\n                    ? position.character + diffPos.character - originalLeftBoundary.character\n                    : diffPos.character;\n                // TODO: Should we document.validate() this position?\n                return new vscode_1.Position(Math.max(position.line + lineOffset, 0), Math.max(char, 0));\n            };\n            const replaceRange = new vscode.Range(translate(change.range.start), translate(change.range.end));\n            if (replaceRange.start.isAfter(rightBoundary)) {\n                // This change should be ignored as it's out of boundary\n                continue;\n            }\n            // Calculate new right boundary\n            const textDiffLines = change.text.split('\\n');\n            const numLinesAdded = textDiffLines.length - 1;\n            const newRightBoundary = numLinesAdded === 0\n                ? new vscode_1.Position(replaceRange.start.line, replaceRange.start.character + change.text.length)\n                : new vscode_1.Position(replaceRange.start.line + numLinesAdded, textDiffLines.pop().length);\n            rightBoundary = (0, position_1.laterOf)(rightBoundary, newRightBoundary);\n            if (replaceRange.start.isEqual(replaceRange.end)) {\n                vimState.recordedState.transformer.insert(replaceRange.start, change.text, position_1.PositionDiff.exactPosition(translate(this.cursorEnd)));\n            }\n            else {\n                vimState.recordedState.transformer.replace(replaceRange, change.text, position_1.PositionDiff.exactPosition(translate(this.cursorEnd)));\n            }\n        }\n    }\n    compressChanges() {\n        const merge = (first, second) => {\n            if (first.rangeOffset + first.text.length === second.rangeOffset) {\n                // Simple concatenation\n                return {\n                    text: first.text + second.text,\n                    range: first.range,\n                    rangeOffset: first.rangeOffset,\n                    rangeLength: first.rangeLength,\n                };\n            }\n            else if (first.rangeOffset <= second.rangeOffset &&\n                first.text.length >= second.rangeLength) {\n                const start = second.rangeOffset - first.rangeOffset;\n                const end = start + second.rangeLength;\n                const text = first.text.slice(0, start) + second.text + first.text.slice(end);\n                // `second` replaces part of `first`\n                // Most often, this is the result of confirming an auto-completion\n                return {\n                    text,\n                    range: first.range,\n                    rangeOffset: first.rangeOffset,\n                    rangeLength: first.rangeLength,\n                };\n            }\n            else {\n                // TODO: Do any of the cases falling into this `else` matter?\n                // TODO: YES - make an insertion and then autocomplete to something totally different (replace subsumes insert)\n                return undefined;\n            }\n        };\n        const compressed = [];\n        let prev;\n        for (const change of this.contentChanges) {\n            if (prev === undefined) {\n                prev = change;\n            }\n            else {\n                const merged = merge(prev, change);\n                if (merged) {\n                    prev = merged;\n                }\n                else {\n                    compressed.push(prev);\n                    prev = change;\n                }\n            }\n        }\n        if (prev !== undefined) {\n            compressed.push(prev);\n        }\n        this.contentChanges = compressed;\n    }\n}\nexports.DocumentContentChangeAction = DocumentContentChangeAction;\nlet DisableExtension = class DisableExtension extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [\n            mode_1.Mode.Normal,\n            mode_1.Mode.Insert,\n            mode_1.Mode.Visual,\n            mode_1.Mode.VisualBlock,\n            mode_1.Mode.VisualLine,\n            mode_1.Mode.SearchInProgressMode,\n            mode_1.Mode.CommandlineInProgress,\n            mode_1.Mode.Replace,\n            mode_1.Mode.EasyMotionMode,\n            mode_1.Mode.EasyMotionInputMode,\n            mode_1.Mode.SurroundInputMode,\n        ];\n        this.keys = [specialKeys_1.SpecialKeys.ExtensionDisable];\n    }\n    async exec(position, vimState) {\n        await vimState.setCurrentMode(mode_1.Mode.Disabled);\n    }\n};\nDisableExtension = __decorate([\n    base_1.RegisterAction\n], DisableExtension);\nlet EnableExtension = class EnableExtension extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Disabled];\n        this.keys = [specialKeys_1.SpecialKeys.ExtensionEnable];\n    }\n    async exec(position, vimState) {\n        await vimState.setCurrentMode(mode_1.Mode.Normal);\n    }\n};\nEnableExtension = __decorate([\n    base_1.RegisterAction\n], EnableExtension);\nlet CommandNumber = CommandNumber_1 = class CommandNumber extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n        this.keys = ['<number>'];\n        this.name = 'cmd_num';\n        this.isCompleteAction = false;\n        this.actionType = 'number';\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        const num = parseInt(this.keysPressed[0], 10);\n        const operatorCount = vimState.recordedState.operatorCount;\n        if (operatorCount > 0) {\n            const lastAction = vimState.recordedState.actionsRun[vimState.recordedState.actionsRun.length - 2];\n            if (!(lastAction instanceof CommandNumber_1)) {\n                // We have set an operatorCount !== 0 after an operator, but now we got another count\n                // number so we need to multiply them.\n                vimState.recordedState.count = operatorCount * num;\n            }\n            else {\n                // We are now getting another digit which means we need to multiply by 10 and add\n                // the new digit multiplied by operatorCount.\n                //\n                // Example: user presses '2d31w':\n                // - After '2' the number 2 is stored in 'count'\n                // - After 'd' the count (2) is stored in 'operatorCount'\n                // - After '3' the number 3 multiplied by 'operatorCount' (3 x 2 = 6) is stored in 'count'\n                // - After '1' the count is multiplied by 10 and added by number 1 multiplied by 'operatorCount'\n                //   (6 * 10 + 1 * 2 = 62)\n                // The final result will be the deletion of 62 words.\n                vimState.recordedState.count = vimState.recordedState.count * 10 + num * operatorCount;\n            }\n        }\n        else {\n            vimState.recordedState.count = vimState.recordedState.count * 10 + num;\n        }\n    }\n    doesActionApply(vimState, keysPressed) {\n        const isZero = keysPressed[0] === '0';\n        return (super.doesActionApply(vimState, keysPressed) &&\n            ((isZero && vimState.recordedState.count > 0) || !isZero));\n    }\n    couldActionApply(vimState, keysPressed) {\n        const isZero = keysPressed[0] === '0';\n        return (super.couldActionApply(vimState, keysPressed) &&\n            ((isZero && vimState.recordedState.count > 0) || !isZero));\n    }\n};\nexports.CommandNumber = CommandNumber;\nexports.CommandNumber = CommandNumber = CommandNumber_1 = __decorate([\n    base_1.RegisterAction\n], CommandNumber);\nlet CommandRegister = class CommandRegister extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n        this.keys = ['\"', '<character>'];\n        this.name = 'cmd_register';\n        this.isCompleteAction = false;\n    }\n    async exec(position, vimState) {\n        const register = this.keysPressed[1];\n        if (register_1.Register.isValidRegister(register)) {\n            vimState.recordedState.registerName = register;\n        }\n        else {\n            // TODO: Changing isCompleteAction here is maybe a bit janky - should it be a function?\n            this.isCompleteAction = true;\n        }\n    }\n};\nexports.CommandRegister = CommandRegister;\nexports.CommandRegister = CommandRegister = __decorate([\n    base_1.RegisterAction\n], CommandRegister);\nlet CommandRecordMacro = class CommandRecordMacro extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n        this.keys = [\n            ['q', '<alpha>'],\n            ['q', '<number>'],\n            ['q', '\"'],\n        ];\n    }\n    async exec(position, vimState) {\n        const registerKey = this.keysPressed[1];\n        const register = registerKey.toLocaleLowerCase();\n        vimState.macro = new recordedState_1.RecordedState();\n        vimState.macro.registerKey = registerKey;\n        vimState.macro.registerName = register;\n        if (!register_1.Register.isValidUppercaseRegister(registerKey) || !register_1.Register.has(register)) {\n            // TODO: this seems suspect - why are we not putting `vimState.macro` in the register? Why are we setting `registerName`?\n            const newRegister = new recordedState_1.RecordedState();\n            newRegister.registerName = register;\n            vimState.recordedState.registerName = register;\n            register_1.Register.put(vimState, newRegister);\n        }\n    }\n};\nCommandRecordMacro = __decorate([\n    base_1.RegisterAction\n], CommandRecordMacro);\nlet CommandQuitRecordMacro = class CommandQuitRecordMacro extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n        this.keys = ['q'];\n    }\n    async exec(position, vimState) {\n        const macro = vimState.macro;\n        if (macro === undefined) {\n            return;\n        }\n        const existingMacro = (await register_1.Register.get(macro.registerName))?.text;\n        if (existingMacro instanceof recordedState_1.RecordedState) {\n            if (register_1.Register.isValidUppercaseRegister(macro.registerKey)) {\n                existingMacro.actionsRun = existingMacro.actionsRun.concat(macro.actionsRun);\n            }\n            else {\n                existingMacro.actionsRun = macro.actionsRun;\n            }\n        }\n        vimState.macro = undefined;\n    }\n    doesActionApply(vimState, keysPressed) {\n        return super.doesActionApply(vimState, keysPressed) && vimState.macro !== undefined;\n    }\n    couldActionApply(vimState, keysPressed) {\n        return super.couldActionApply(vimState, keysPressed) && vimState.macro !== undefined;\n    }\n};\nexports.CommandQuitRecordMacro = CommandQuitRecordMacro;\nexports.CommandQuitRecordMacro = CommandQuitRecordMacro = __decorate([\n    base_1.RegisterAction\n], CommandQuitRecordMacro);\nlet CommandExecuteLastMacro = class CommandExecuteLastMacro extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n        this.keys = ['@', '@'];\n        this.runsOnceForEachCountPrefix = true;\n        this.createsUndoPoint = true;\n        this.isJump = true;\n    }\n    async exec(position, vimState) {\n        const { lastInvokedMacro } = globalState_1.globalState;\n        if (lastInvokedMacro) {\n            vimState.recordedState.transformer.addTransformation({\n                type: 'macro',\n                register: lastInvokedMacro.registerName,\n                replay: 'contentChange',\n            });\n        }\n        else {\n            statusBar_1.StatusBar.displayError(vimState, error_1.VimError.fromCode(error_1.ErrorCode.NoPreviouslyUsedRegister));\n        }\n    }\n};\nCommandExecuteLastMacro = __decorate([\n    base_1.RegisterAction\n], CommandExecuteLastMacro);\nlet CommandExecuteMacro = class CommandExecuteMacro extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n        this.keys = ['@', '<character>'];\n        this.runsOnceForEachCountPrefix = true;\n        this.createsUndoPoint = true;\n    }\n    async exec(position, vimState) {\n        const register = this.keysPressed[1].toLocaleLowerCase();\n        const isFilenameRegister = register === '%' || register === '#';\n        if (!register_1.Register.isValidRegister(register) || isFilenameRegister) {\n            statusBar_1.StatusBar.displayError(vimState, error_1.VimError.fromCode(error_1.ErrorCode.InvalidRegisterName, `'${register}'`));\n        }\n        if (register_1.Register.has(register)) {\n            vimState.recordedState.transformer.addTransformation({\n                type: 'macro',\n                register,\n                replay: 'contentChange',\n            });\n        }\n    }\n};\nCommandExecuteMacro = __decorate([\n    base_1.RegisterAction\n], CommandExecuteMacro);\nlet CommandEsc = class CommandEsc extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [\n            mode_1.Mode.Visual,\n            mode_1.Mode.VisualLine,\n            mode_1.Mode.VisualBlock,\n            mode_1.Mode.Normal,\n            mode_1.Mode.SurroundInputMode,\n            mode_1.Mode.EasyMotionMode,\n            mode_1.Mode.EasyMotionInputMode,\n        ];\n        this.keys = [['<Esc>'], ['<C-c>'], ['<C-[>']];\n        this.preservesDesiredColumn = true;\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        if (vimState.currentMode === mode_1.Mode.Normal) {\n            vimState.surround = undefined;\n            if (vimState.isMultiCursor) {\n                vimState.cursors = [vimState.cursors[0]];\n            }\n            else {\n                // If there's nothing to do on the vim side, we might as well call some\n                // of vscode's default \"close notification\" actions. I think we should\n                // just add to this list as needed.\n                await Promise.allSettled([\n                    vscode.commands.executeCommand('closeReferenceSearchEditor'),\n                    vscode.commands.executeCommand('closeMarkersNavigation'),\n                    vscode.commands.executeCommand('closeDirtyDiff'),\n                ]);\n            }\n        }\n        else {\n            if (vimState.currentMode === mode_1.Mode.EasyMotionMode) {\n                vimState.easyMotion.clearDecorations(vimState.editor);\n            }\n            else if (vimState.currentMode === mode_1.Mode.SurroundInputMode) {\n                vimState.surround = undefined;\n            }\n            await vimState.setCurrentMode(mode_1.Mode.Normal);\n        }\n    }\n};\nCommandEsc = __decorate([\n    base_1.RegisterAction\n], CommandEsc);\nlet CommandInsertAtCursor = class CommandInsertAtCursor extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = [['i'], ['<Insert>']];\n    }\n    async exec(position, vimState) {\n        await vimState.setCurrentMode(mode_1.Mode.Insert);\n    }\n    doesActionApply(vimState, keysPressed) {\n        // Only allow this command to be prefixed with a count or nothing, no other\n        // actions or operators before\n        let previousActionsNumbers = true;\n        for (const prevAction of vimState.recordedState.actionsRun) {\n            if (!(prevAction instanceof CommandNumber)) {\n                previousActionsNumbers = false;\n                break;\n            }\n        }\n        if (vimState.recordedState.actionsRun.length === 0 || previousActionsNumbers) {\n            return super.couldActionApply(vimState, keysPressed);\n        }\n        return false;\n    }\n};\nexports.CommandInsertAtCursor = CommandInsertAtCursor;\nexports.CommandInsertAtCursor = CommandInsertAtCursor = __decorate([\n    base_1.RegisterAction\n], CommandInsertAtCursor);\nlet CommandReplaceAtCursorFromNormalMode = class CommandReplaceAtCursorFromNormalMode extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['R'];\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        await vimState.setCurrentMode(mode_1.Mode.Replace);\n    }\n};\nexports.CommandReplaceAtCursorFromNormalMode = CommandReplaceAtCursorFromNormalMode;\nexports.CommandReplaceAtCursorFromNormalMode = CommandReplaceAtCursorFromNormalMode = __decorate([\n    base_1.RegisterAction\n], CommandReplaceAtCursorFromNormalMode);\n/**\n * Our Vim implementation selects up to but not including the final character\n * of a visual selection, instead opting to render a block cursor on the final\n * character. This works for everything except VSCode's native copy command,\n * which loses the final character because it's not selected. We override that\n * copy command here by default to include the final character.\n */\nlet CommandOverrideCopy = class CommandOverrideCopy extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock, mode_1.Mode.Insert, mode_1.Mode.Normal];\n        this.keys = ['<copy>']; // A special key - see ModeHandler\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        let text = '';\n        if (vimState.currentMode === mode_1.Mode.Visual) {\n            text = vimState.cursors\n                .map((range) => {\n                const [start, stop] = (0, position_1.sorted)(range.start, range.stop);\n                return vimState.document.getText(new vscode.Range(start, stop.getRight()));\n            })\n                .join('\\n');\n        }\n        else if (vimState.currentMode === mode_1.Mode.VisualLine) {\n            text = vimState.cursors\n                .map((range) => {\n                return vimState.document.getText(new vscode.Range((0, position_1.earlierOf)(range.start.getLineBegin(), range.stop.getLineBegin()), (0, position_1.laterOf)(range.start.getLineEnd(), range.stop.getLineEnd())));\n            })\n                .join('\\n');\n        }\n        else if (vimState.currentMode === mode_1.Mode.VisualBlock) {\n            for (const { line } of textEditor_1.TextEditor.iterateLinesInBlock(vimState)) {\n                text += line + '\\n';\n            }\n        }\n        else if (vimState.currentMode === mode_1.Mode.Insert || vimState.currentMode === mode_1.Mode.Normal) {\n            text = vimState.editor.selections\n                .map((selection) => {\n                return vimState.document.getText(new vscode.Range(selection.start, selection.end));\n            })\n                .join('\\n');\n        }\n        const editorSelection = vimState.editor.selection;\n        const hasSelectedText = !editorSelection.active.isEqual(editorSelection.anchor);\n        if (hasSelectedText) {\n            await clipboard_1.Clipboard.Copy(text);\n        }\n        // all vim yank operations return to normal mode.\n        await vimState.setCurrentMode(mode_1.Mode.Normal);\n    }\n};\nCommandOverrideCopy = __decorate([\n    base_1.RegisterAction\n], CommandOverrideCopy);\nlet CommandCmdA = class CommandCmdA extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n        this.keys = ['<D-a>'];\n    }\n    async exec(position, vimState) {\n        vimState.cursorStartPosition = new vscode_1.Position(0, vimState.desiredColumn);\n        vimState.cursorStopPosition = new vscode_1.Position(vimState.document.lineCount - 1, vimState.desiredColumn);\n        await vimState.setCurrentMode(mode_1.Mode.VisualLine);\n    }\n};\nCommandCmdA = __decorate([\n    base_1.RegisterAction\n], CommandCmdA);\nlet MarkCommand = class MarkCommand extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.keys = ['m', '<character>'];\n        this.modes = [mode_1.Mode.Normal];\n    }\n    async exec(position, vimState) {\n        const markName = this.keysPressed[1];\n        vimState.historyTracker.addMark(vimState.document, position, markName);\n    }\n};\nMarkCommand = __decorate([\n    base_1.RegisterAction\n], MarkCommand);\nlet CommandShowCommandLine = class CommandShowCommandLine extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n        this.keys = [':'];\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        let commandLineText;\n        if (vimState.currentMode === mode_1.Mode.Normal) {\n            if (vimState.recordedState.count) {\n                commandLineText = `.,.+${vimState.recordedState.count - 1}`;\n            }\n            else {\n                commandLineText = '';\n            }\n        }\n        else {\n            commandLineText = \"'<,'>\";\n        }\n        const previousMode = vimState.currentMode;\n        await vimState.setCurrentMode(mode_1.Mode.CommandlineInProgress);\n        // TODO: Change or supplement `setCurrentMode` API so this isn't necessary\n        if (vimState.modeData.mode === mode_1.Mode.CommandlineInProgress) {\n            vimState.modeData.commandLine = new commandLine_1.ExCommandLine(commandLineText, previousMode);\n        }\n    }\n};\nCommandShowCommandLine = __decorate([\n    base_1.RegisterAction\n], CommandShowCommandLine);\nlet CommandShowCommandHistory = class CommandShowCommandHistory extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n        this.keys = ['q', ':'];\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        const cmd = await vscode.window.showQuickPick(commandLine_1.ExCommandLine.history.get().slice().reverse(), {\n            placeHolder: 'Vim command history',\n            ignoreFocusOut: false,\n        });\n        if (cmd && cmd.length !== 0) {\n            await new commandLine_1.ExCommandLine(cmd, vimState.currentMode).run(vimState);\n        }\n        await vimState.setCurrentMode(mode_1.Mode.Normal);\n    }\n};\nexports.CommandShowCommandHistory = CommandShowCommandHistory;\nexports.CommandShowCommandHistory = CommandShowCommandHistory = __decorate([\n    base_1.RegisterAction\n], CommandShowCommandHistory);\ncommandLine_1.ExCommandLine.onSearch = async (vimState) => {\n    void new CommandShowCommandHistory().exec(vimState.cursorStopPosition, vimState);\n};\nlet CommandShowSearchHistory = class CommandShowSearchHistory extends base_1.BaseCommand {\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    constructor(direction = pattern_1.SearchDirection.Forward) {\n        super();\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n        this.keys = [\n            ['q', '/'],\n            ['q', '?'],\n        ];\n        this.direction = pattern_1.SearchDirection.Forward;\n        this.direction = direction;\n    }\n    async exec(position, vimState) {\n        if (this.keysPressed.includes('?')) {\n            this.direction = pattern_1.SearchDirection.Backward;\n        }\n        const searchState = await commandLine_1.SearchCommandLine.showSearchHistory();\n        if (searchState) {\n            globalState_1.globalState.searchState = searchState;\n            globalState_1.globalState.hl = true;\n            const nextMatch = searchState.getNextSearchMatchPosition(vimState, vimState.cursorStartPosition, this.direction);\n            if (!nextMatch) {\n                throw error_1.VimError.fromCode(this.direction > 0 ? error_1.ErrorCode.SearchHitBottom : error_1.ErrorCode.SearchHitTop, searchState.searchString);\n            }\n            vimState.cursorStopPosition = nextMatch.pos;\n            (0, statusBarTextUtils_1.reportSearch)(nextMatch.index, searchState.getMatchRanges(vimState).length, vimState);\n        }\n        await vimState.setCurrentMode(mode_1.Mode.Normal);\n    }\n};\nexports.CommandShowSearchHistory = CommandShowSearchHistory;\nexports.CommandShowSearchHistory = CommandShowSearchHistory = __decorate([\n    base_1.RegisterAction\n], CommandShowSearchHistory);\n// Register the command to execute on CtrlF.\ncommandLine_1.SearchCommandLine.onSearch = async (vimState, direction) => {\n    return new CommandShowSearchHistory(direction).exec(vimState.cursorStopPosition, vimState);\n};\nlet CommandDot = class CommandDot extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['.'];\n    }\n    async execCount(position, vimState) {\n        if (globalState_1.globalState.previousFullAction) {\n            const count = vimState.recordedState.count || 1;\n            for (let i = 0; i < count; i++) {\n                vimState.recordedState.transformer.addTransformation({\n                    type: 'replayRecordedState',\n                    recordedState: globalState_1.globalState.previousFullAction,\n                });\n            }\n        }\n    }\n};\nCommandDot = __decorate([\n    base_1.RegisterAction\n], CommandDot);\nlet CommandRepeatSubstitution = class CommandRepeatSubstitution extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['&'];\n        this.createsUndoPoint = true;\n    }\n    async exec(position, vimState) {\n        // Parsing the command from a string, while not ideal, is currently\n        // necessary to make this work with and without neovim integration\n        await commandLine_1.ExCommandLine.parser.tryParse('s').command.execute(vimState);\n    }\n};\nCommandRepeatSubstitution = __decorate([\n    base_1.RegisterAction\n], CommandRepeatSubstitution);\nlet CommandGoToOtherEndOfHighlightedText = class CommandGoToOtherEndOfHighlightedText extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n        this.keys = ['o'];\n        this.isJump = true;\n    }\n    async exec(position, vimState) {\n        [vimState.cursorStartPosition, vimState.cursorStopPosition] = [\n            vimState.cursorStopPosition,\n            vimState.cursorStartPosition,\n        ];\n    }\n};\nCommandGoToOtherEndOfHighlightedText = __decorate([\n    base_1.RegisterAction\n], CommandGoToOtherEndOfHighlightedText);\nlet CommandGoToOtherSideOfHighlightedText = class CommandGoToOtherSideOfHighlightedText extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n        this.keys = ['O'];\n        this.isJump = true;\n    }\n    async exec(position, vimState) {\n        if (vimState.currentMode === mode_1.Mode.VisualBlock) {\n            [vimState.cursorStartPosition, vimState.cursorStopPosition] = [\n                new vscode.Position(vimState.cursorStartPosition.line, vimState.cursorStopPosition.character),\n                new vscode.Position(vimState.cursorStopPosition.line, vimState.cursorStartPosition.character),\n            ];\n        }\n        else {\n            return new CommandGoToOtherEndOfHighlightedText().exec(position, vimState);\n        }\n    }\n};\nCommandGoToOtherSideOfHighlightedText = __decorate([\n    base_1.RegisterAction\n], CommandGoToOtherSideOfHighlightedText);\nlet CommandUndo = class CommandUndo extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['u'];\n        // we support a count to undo by this setting\n        this.runsOnceForEachCountPrefix = true;\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        const newPosition = await vimState.historyTracker.goBackHistoryStep();\n        if (newPosition === undefined) {\n            statusBar_1.StatusBar.setText(vimState, 'Already at oldest change');\n        }\n        else {\n            vimState.cursors = [new cursor_1.Cursor(newPosition, newPosition)];\n        }\n    }\n};\nexports.CommandUndo = CommandUndo;\nexports.CommandUndo = CommandUndo = __decorate([\n    base_1.RegisterAction\n], CommandUndo);\nlet CommandUndoOnLine = class CommandUndoOnLine extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['U'];\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        const newPosition = await vimState.historyTracker.goBackHistoryStepsOnLine();\n        if (newPosition !== undefined) {\n            vimState.cursors = [new cursor_1.Cursor(newPosition, newPosition)];\n        }\n    }\n};\nCommandUndoOnLine = __decorate([\n    base_1.RegisterAction\n], CommandUndoOnLine);\nlet CommandRedo = class CommandRedo extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['<C-r>'];\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        const newPosition = await vimState.historyTracker.goForwardHistoryStep();\n        if (newPosition === undefined) {\n            statusBar_1.StatusBar.setText(vimState, 'Already at newest change');\n        }\n        else {\n            vimState.cursors = [new cursor_1.Cursor(newPosition, newPosition)];\n        }\n    }\n};\nexports.CommandRedo = CommandRedo;\nexports.CommandRedo = CommandRedo = __decorate([\n    base_1.RegisterAction\n], CommandRedo);\nlet CommandDeleteToLineEnd = class CommandDeleteToLineEnd extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['D'];\n        this.createsUndoPoint = true;\n    }\n    runsOnceForEveryCursor() {\n        return true;\n    }\n    async exec(position, vimState) {\n        if (position.isLineEnd()) {\n            return;\n        }\n        const linesDown = (vimState.recordedState.count || 1) - 1;\n        const start = position;\n        const end = position.getDown(linesDown).getLineEnd().getLeftThroughLineBreaks();\n        await new operator.DeleteOperator(this.multicursorIndex).run(vimState, start, end);\n    }\n};\nCommandDeleteToLineEnd = __decorate([\n    base_1.RegisterAction\n], CommandDeleteToLineEnd);\nlet CommandYankFullLine = class CommandYankFullLine extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['Y'];\n        this.name = 'yank_full_line';\n    }\n    async exec(position, vimState) {\n        const linesDown = (vimState.recordedState.count || 1) - 1;\n        const start = position.getLineBegin();\n        const end = position.getDown(linesDown).getLeft();\n        vimState.currentRegisterMode = register_1.RegisterMode.LineWise;\n        await new operator.YankOperator(this.multicursorIndex).run(vimState, start, end);\n    }\n};\nexports.CommandYankFullLine = CommandYankFullLine;\nexports.CommandYankFullLine = CommandYankFullLine = __decorate([\n    base_1.RegisterAction\n], CommandYankFullLine);\nlet CommandChangeToLineEnd = class CommandChangeToLineEnd extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['C'];\n        this.runsOnceForEachCountPrefix = false;\n    }\n    async exec(position, vimState) {\n        const count = vimState.recordedState.count || 1;\n        await new operator.ChangeOperator(this.multicursorIndex).run(vimState, position, position\n            .getDown(Math.max(0, count - 1))\n            .getLineEnd()\n            .getLeft());\n    }\n};\nCommandChangeToLineEnd = __decorate([\n    base_1.RegisterAction\n], CommandChangeToLineEnd);\nlet CommandClearLine = class CommandClearLine extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['S'];\n        this.runsOnceForEachCountPrefix = false;\n    }\n    async exec(position, vimState) {\n        await new operator.ChangeOperator(this.multicursorIndex).runRepeat(vimState, position, vimState.recordedState.count || 1);\n    }\n    // Don't clash with sneak\n    doesActionApply(vimState, keysPressed) {\n        return super.doesActionApply(vimState, keysPressed) && !configuration_1.configuration.sneak;\n    }\n    couldActionApply(vimState, keysPressed) {\n        return super.couldActionApply(vimState, keysPressed) && !configuration_1.configuration.sneak;\n    }\n};\nCommandClearLine = __decorate([\n    base_1.RegisterAction\n], CommandClearLine);\nlet CommandExitVisualMode = class CommandExitVisualMode extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Visual];\n        this.keys = ['v'];\n    }\n    async exec(position, vimState) {\n        await vimState.setCurrentMode(mode_1.Mode.Normal);\n    }\n};\nCommandExitVisualMode = __decorate([\n    base_1.RegisterAction\n], CommandExitVisualMode);\nlet CommandVisualMode = class CommandVisualMode extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n        this.keys = ['v'];\n        this.isCompleteAction = false;\n    }\n    async exec(position, vimState) {\n        if (vimState.currentMode === mode_1.Mode.Normal && vimState.recordedState.count > 1) {\n            vimState.cursorStopPosition = position.getRight(vimState.recordedState.count - 1);\n        }\n        await vimState.setCurrentMode(mode_1.Mode.Visual);\n    }\n};\nCommandVisualMode = __decorate([\n    base_1.RegisterAction\n], CommandVisualMode);\nlet CommandReselectVisual = class CommandReselectVisual extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['g', 'v'];\n    }\n    async exec(position, vimState) {\n        // Try to restore selection only if valid\n        if (vimState.lastVisualSelection !== undefined) {\n            let { start, end, mode } = vimState.lastVisualSelection;\n            if (end.line <= vimState.document.lineCount - 1) {\n                if (mode === mode_1.Mode.Visual && start.isBeforeOrEqual(end)) {\n                    end = end.getLeftThroughLineBreaks(true);\n                }\n                await vimState.setCurrentMode(mode);\n                vimState.cursorStartPosition = start;\n                vimState.cursorStopPosition = end;\n            }\n        }\n    }\n};\nCommandReselectVisual = __decorate([\n    base_1.RegisterAction\n], CommandReselectVisual);\nlet CommandVisualBlockMode = class CommandVisualBlockMode extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n        this.keys = [['<C-v>'], ['<C-q>']];\n    }\n    async exec(position, vimState) {\n        if (vimState.currentMode === mode_1.Mode.Normal && vimState.recordedState.count > 1) {\n            vimState.cursorStopPosition = position.getRight(vimState.recordedState.count - 1);\n        }\n        await vimState.setCurrentMode(mode_1.Mode.VisualBlock);\n    }\n};\nCommandVisualBlockMode = __decorate([\n    base_1.RegisterAction\n], CommandVisualBlockMode);\nlet CommandExitVisualBlockMode = class CommandExitVisualBlockMode extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.VisualBlock];\n        this.keys = [['<C-v>'], ['<C-q>']];\n    }\n    async exec(position, vimState) {\n        await vimState.setCurrentMode(mode_1.Mode.Normal);\n    }\n};\nCommandExitVisualBlockMode = __decorate([\n    base_1.RegisterAction\n], CommandExitVisualBlockMode);\nlet CommandVisualLineMode = class CommandVisualLineMode extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualBlock];\n        this.keys = ['V'];\n    }\n    async exec(position, vimState) {\n        if (vimState.currentMode === mode_1.Mode.Normal && vimState.recordedState.count > 1) {\n            vimState.cursorStopPosition = position.getDown(vimState.recordedState.count - 1);\n        }\n        await vimState.setCurrentMode(mode_1.Mode.VisualLine);\n    }\n};\nCommandVisualLineMode = __decorate([\n    base_1.RegisterAction\n], CommandVisualLineMode);\nlet CommandExitVisualLineMode = class CommandExitVisualLineMode extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.VisualLine];\n        this.keys = ['V'];\n    }\n    async exec(position, vimState) {\n        await vimState.setCurrentMode(mode_1.Mode.Normal);\n    }\n};\nCommandExitVisualLineMode = __decorate([\n    base_1.RegisterAction\n], CommandExitVisualLineMode);\nlet CommandOpenFile = class CommandOpenFile extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual];\n        this.keys = ['g', 'f'];\n        this.isJump = true;\n    }\n    async exec(position, vimState) {\n        let fullFilePath;\n        if (vimState.currentMode === mode_1.Mode.Visual) {\n            fullFilePath = vimState.document.getText(vimState.editor.selection);\n        }\n        else {\n            const range = new vscode.Range(position.prevWordStart(vimState.document, { wordType: word_1.WordType.FileName, inclusive: true }), position.nextWordStart(vimState.document, { wordType: word_1.WordType.FileName }));\n            fullFilePath = vimState.document.getText(range).trim();\n        }\n        const fileInfo = fullFilePath.match(/(.*?(?=:[0-9]+)|.*):?([0-9]*)$/);\n        if (fileInfo) {\n            const workspaceRootPath = vscode.workspace.getWorkspaceFolder(vimState.document.uri)?.uri\n                .fsPath;\n            const filePath = path_1.default.isAbsolute(fileInfo[1]) || !workspaceRootPath\n                ? fileInfo[1]\n                : path_1.default.join(workspaceRootPath, fileInfo[1]);\n            const line = parseInt(fileInfo[2], 10);\n            const fileCommand = new file_1.FileCommand({\n                name: 'edit',\n                bang: false,\n                opt: [],\n                file: filePath,\n                cmd: isNaN(line) ? undefined : { type: 'line_number', line: line - 1 },\n                createFileIfNotExists: false,\n            });\n            void fileCommand.execute(vimState);\n        }\n    }\n};\nCommandOpenFile = __decorate([\n    base_1.RegisterAction\n], CommandOpenFile);\nlet GoToDeclaration = class GoToDeclaration extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = [\n            ['g', 'd'],\n            ['g', 'D'],\n        ];\n        this.isJump = true;\n    }\n    async exec(position, vimState) {\n        await vscode.commands.executeCommand('editor.action.goToDeclaration');\n        if (vimState.editor === vscode.window.activeTextEditor) {\n            // We didn't switch to a different editor\n            vimState.cursorStartPosition = vimState.editor.selection.start;\n            vimState.cursorStopPosition = vimState.editor.selection.end;\n        }\n    }\n};\nGoToDeclaration = __decorate([\n    base_1.RegisterAction\n], GoToDeclaration);\nlet GoToDefinition = class GoToDefinition extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['<C-]>'];\n        this.isJump = true;\n    }\n    async exec(position, vimState) {\n        await vscode.commands.executeCommand('editor.action.revealDefinition');\n        if (vimState.editor === vscode.window.activeTextEditor) {\n            // We didn't switch to a different editor\n            vimState.cursorStopPosition = vimState.editor.selection.start;\n        }\n    }\n};\nGoToDefinition = __decorate([\n    base_1.RegisterAction\n], GoToDefinition);\nlet CommandOpenLink = class CommandOpenLink extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n        this.keys = ['g', 'x'];\n    }\n    async exec(position, vimState) {\n        void vscode.commands.executeCommand('editor.action.openLink');\n    }\n};\nCommandOpenLink = __decorate([\n    base_1.RegisterAction\n], CommandOpenLink);\nlet CommandGoBackInChangelist = class CommandGoBackInChangelist extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['g', ';'];\n        this.isJump = true;\n    }\n    async exec(position, vimState) {\n        const prevPos = vimState.historyTracker.prevChangeInChangeList();\n        if (prevPos instanceof error_1.VimError) {\n            statusBar_1.StatusBar.displayError(vimState, prevPos);\n        }\n        else {\n            vimState.cursorStopPosition = prevPos;\n        }\n    }\n};\nCommandGoBackInChangelist = __decorate([\n    base_1.RegisterAction\n], CommandGoBackInChangelist);\nlet CommandGoForwardInChangelist = class CommandGoForwardInChangelist extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['g', ','];\n        this.isJump = true;\n    }\n    async exec(position, vimState) {\n        const nextPos = vimState.historyTracker.nextChangeInChangeList();\n        if (nextPos instanceof error_1.VimError) {\n            statusBar_1.StatusBar.displayError(vimState, nextPos);\n        }\n        else {\n            vimState.cursorStopPosition = nextPos;\n        }\n    }\n};\nCommandGoForwardInChangelist = __decorate([\n    base_1.RegisterAction\n], CommandGoForwardInChangelist);\nlet CommandInsertAtLastChange = class CommandInsertAtLastChange extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['g', 'i'];\n    }\n    async exec(position, vimState) {\n        vimState.cursorStopPosition = vimState.cursorStartPosition =\n            vimState.historyTracker.getLastChangeEndPosition() ?? new vscode_1.Position(0, 0);\n        await vimState.setCurrentMode(mode_1.Mode.Insert);\n    }\n};\nexports.CommandInsertAtLastChange = CommandInsertAtLastChange;\nexports.CommandInsertAtLastChange = CommandInsertAtLastChange = __decorate([\n    base_1.RegisterAction\n], CommandInsertAtLastChange);\nlet CommandInsertAtFirstCharacter = class CommandInsertAtFirstCharacter extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['I'];\n    }\n    async exec(position, vimState) {\n        await vimState.setCurrentMode(mode_1.Mode.Insert);\n        vimState.cursorStopPosition = vimState.cursorStartPosition =\n            textEditor_1.TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, position.line);\n    }\n};\nexports.CommandInsertAtFirstCharacter = CommandInsertAtFirstCharacter;\nexports.CommandInsertAtFirstCharacter = CommandInsertAtFirstCharacter = __decorate([\n    base_1.RegisterAction\n], CommandInsertAtFirstCharacter);\nlet CommandInsertAtLineBegin = class CommandInsertAtLineBegin extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['g', 'I'];\n    }\n    async exec(position, vimState) {\n        await vimState.setCurrentMode(mode_1.Mode.Insert);\n        vimState.cursorStopPosition = vimState.cursorStartPosition = position.getLineBegin();\n    }\n};\nexports.CommandInsertAtLineBegin = CommandInsertAtLineBegin;\nexports.CommandInsertAtLineBegin = CommandInsertAtLineBegin = __decorate([\n    base_1.RegisterAction\n], CommandInsertAtLineBegin);\nlet CommandInsertAfterCursor = class CommandInsertAfterCursor extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['a'];\n    }\n    async exec(position, vimState) {\n        await vimState.setCurrentMode(mode_1.Mode.Insert);\n        vimState.cursorStopPosition = vimState.cursorStartPosition = position.getRight();\n    }\n    doesActionApply(vimState, keysPressed) {\n        // Only allow this command to be prefixed with a count or nothing, no other actions or operators before\n        if (!vimState.recordedState.actionsRun.every((action) => action instanceof CommandNumber)) {\n            return false;\n        }\n        return super.couldActionApply(vimState, keysPressed);\n    }\n};\nexports.CommandInsertAfterCursor = CommandInsertAfterCursor;\nexports.CommandInsertAfterCursor = CommandInsertAfterCursor = __decorate([\n    base_1.RegisterAction\n], CommandInsertAfterCursor);\nlet CommandInsertAtLineEnd = class CommandInsertAtLineEnd extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['A'];\n    }\n    async exec(position, vimState) {\n        await vimState.setCurrentMode(mode_1.Mode.Insert);\n        vimState.cursorStopPosition = vimState.cursorStartPosition = position.getLineEnd();\n    }\n};\nexports.CommandInsertAtLineEnd = CommandInsertAtLineEnd;\nexports.CommandInsertAtLineEnd = CommandInsertAtLineEnd = __decorate([\n    base_1.RegisterAction\n], CommandInsertAtLineEnd);\nlet CommandInsertNewLineAbove = class CommandInsertNewLineAbove extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['O'];\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async execCount(position, vimState) {\n        await vimState.setCurrentMode(mode_1.Mode.Insert);\n        const count = vimState.recordedState.count || 1;\n        const charPos = position.getLineBeginRespectingIndent(vimState.document).character;\n        for (let i = 0; i < count; i++) {\n            await vscode.commands.executeCommand('editor.action.insertLineBefore');\n        }\n        vimState.cursors = (0, util_1.getCursorsAfterSync)(vimState.editor);\n        const endPos = vimState.cursors[0].start.character;\n        const indentAmt = charPos - endPos;\n        for (let i = 0; i < count; i++) {\n            const newPos = new vscode_1.Position(vimState.cursors[0].start.line + i, charPos);\n            if (i === 0) {\n                vimState.cursors[0] = new cursor_1.Cursor(newPos, newPos);\n            }\n            else {\n                vimState.cursors.push(new cursor_1.Cursor(newPos, newPos));\n            }\n            if (indentAmt >= 0) {\n                vimState.recordedState.transformer.addTransformation({\n                    type: 'insertText',\n                    // TODO: Use `editor.options.insertSpaces`, I think\n                    text: textEditor_1.TextEditor.setIndentationLevel('', indentAmt, configuration_1.configuration.expandtab),\n                    position: newPos,\n                    cursorIndex: i,\n                    manuallySetCursorPositions: true,\n                });\n            }\n            else {\n                vimState.recordedState.transformer.addTransformation({\n                    type: 'deleteRange',\n                    cursorIndex: i,\n                    range: new vscode.Range(newPos, new vscode_1.Position(newPos.line, endPos)),\n                    manuallySetCursorPositions: true,\n                });\n            }\n        }\n        vimState.cursors = vimState.cursors.reverse();\n        vimState.isFakeMultiCursor = true;\n    }\n};\nexports.CommandInsertNewLineAbove = CommandInsertNewLineAbove;\nexports.CommandInsertNewLineAbove = CommandInsertNewLineAbove = __decorate([\n    base_1.RegisterAction\n], CommandInsertNewLineAbove);\nlet CommandInsertNewLineBefore = class CommandInsertNewLineBefore extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['o'];\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async execCount(position, vimState) {\n        await vimState.setCurrentMode(mode_1.Mode.Insert);\n        const count = vimState.recordedState.count || 1;\n        for (let i = 0; i < count; i++) {\n            await vscode.commands.executeCommand('editor.action.insertLineAfter');\n        }\n        vimState.cursors = (0, util_1.getCursorsAfterSync)(vimState.editor);\n        for (let i = 1; i < count; i++) {\n            const newPos = new vscode_1.Position(vimState.cursorStartPosition.line - i, vimState.cursorStartPosition.character);\n            vimState.cursors.push(new cursor_1.Cursor(newPos, newPos));\n            // Ahhhhhh. We have to manually set cursor position here as we need text\n            // transformations AND to set multiple cursors.\n            vimState.recordedState.transformer.addTransformation({\n                type: 'insertText',\n                // TODO: Use `editor.options.insertSpaces`, I think\n                text: textEditor_1.TextEditor.setIndentationLevel('', newPos.character, configuration_1.configuration.expandtab),\n                position: newPos,\n                cursorIndex: i,\n                manuallySetCursorPositions: true,\n            });\n        }\n        vimState.cursors = vimState.cursors.reverse();\n        vimState.isFakeMultiCursor = true;\n    }\n};\nexports.CommandInsertNewLineBefore = CommandInsertNewLineBefore;\nexports.CommandInsertNewLineBefore = CommandInsertNewLineBefore = __decorate([\n    base_1.RegisterAction\n], CommandInsertNewLineBefore);\nlet CommandNavigateBack = class CommandNavigateBack extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = [['<C-o>'], ['<C-t>']];\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        await globalState_1.globalState.jumpTracker.jumpBack(position, vimState);\n    }\n};\nCommandNavigateBack = __decorate([\n    base_1.RegisterAction\n], CommandNavigateBack);\nlet CommandNavigateForward = class CommandNavigateForward extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['<C-i>'];\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        await globalState_1.globalState.jumpTracker.jumpForward(position, vimState);\n    }\n};\nCommandNavigateForward = __decorate([\n    base_1.RegisterAction\n], CommandNavigateForward);\nlet CommandTabNext = class CommandTabNext extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n        this.keys = [['g', 't'], ['<C-pagedown>']];\n        this.runsOnceForEachCountPrefix = false;\n    }\n    async exec(position, vimState) {\n        // gt behaves differently than gT and goes to an absolute index tab\n        // (1-based), it does NOT iterate over next tabs\n        if (vimState.recordedState.count > 0) {\n            void new tab_1.TabCommand({\n                type: tab_1.TabCommandType.Absolute,\n                count: vimState.recordedState.count,\n            }).execute(vimState);\n        }\n        else {\n            void new tab_1.TabCommand({\n                type: tab_1.TabCommandType.Next,\n                bang: false,\n            }).execute(vimState);\n        }\n    }\n};\nCommandTabNext = __decorate([\n    base_1.RegisterAction\n], CommandTabNext);\nlet CommandTabPrevious = class CommandTabPrevious extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n        this.keys = [['g', 'T'], ['<C-pageup>']];\n        this.runsOnceForEachCountPrefix = true;\n    }\n    async exec(position, vimState) {\n        void new tab_1.TabCommand({\n            type: tab_1.TabCommandType.Previous,\n            bang: false,\n        }).execute(vimState);\n    }\n};\nCommandTabPrevious = __decorate([\n    base_1.RegisterAction\n], CommandTabPrevious);\nlet ActionDeleteChar = class ActionDeleteChar extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['x'];\n        this.name = 'delete_char';\n        this.createsUndoPoint = true;\n    }\n    async exec(position, vimState) {\n        // If line is empty, do nothing\n        if (vimState.document.lineAt(position).text.length === 0) {\n            return;\n        }\n        const timesToRepeat = vimState.recordedState.count || 1;\n        await new operator.DeleteOperator(this.multicursorIndex).run(vimState, position, position.getRight(timesToRepeat - 1).getLeftIfEOL());\n        await vimState.setCurrentMode(mode_1.Mode.Normal);\n    }\n};\nexports.ActionDeleteChar = ActionDeleteChar;\nexports.ActionDeleteChar = ActionDeleteChar = __decorate([\n    base_1.RegisterAction\n], ActionDeleteChar);\nlet ActionDeleteCharWithDeleteKey = class ActionDeleteCharWithDeleteKey extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['<Del>'];\n        this.name = 'delete_char_with_del';\n        this.runsOnceForEachCountPrefix = true;\n        this.createsUndoPoint = true;\n    }\n    async execCount(position, vimState) {\n        // If <del> has a count in front of it, then <del> deletes a character\n        // off the count. Therefore, 100<del>x, would apply 'x' 10 times.\n        // http://vimdoc.sourceforge.net/htmldoc/change.html#<Del>\n        if (vimState.recordedState.count !== 0) {\n            vimState.recordedState.count = Math.floor(vimState.recordedState.count / 10);\n            // Change actionsRunPressedKeys so that showCmd updates correctly\n            vimState.recordedState.actionsRunPressedKeys =\n                vimState.recordedState.count > 0 ? vimState.recordedState.count.toString().split('') : [];\n            this.isCompleteAction = false;\n        }\n        else {\n            await new ActionDeleteChar().execCount(position, vimState);\n        }\n    }\n};\nexports.ActionDeleteCharWithDeleteKey = ActionDeleteCharWithDeleteKey;\nexports.ActionDeleteCharWithDeleteKey = ActionDeleteCharWithDeleteKey = __decorate([\n    base_1.RegisterAction\n], ActionDeleteCharWithDeleteKey);\nlet ActionDeleteLastChar = class ActionDeleteLastChar extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['X'];\n        this.name = 'delete_last_char';\n        this.createsUndoPoint = true;\n    }\n    async exec(position, vimState) {\n        if (position.character === 0) {\n            return;\n        }\n        const timesToRepeat = vimState.recordedState.count || 1;\n        await new operator.DeleteOperator(this.multicursorIndex).run(vimState, position.getLeft(timesToRepeat), position.getLeft());\n    }\n};\nexports.ActionDeleteLastChar = ActionDeleteLastChar;\nexports.ActionDeleteLastChar = ActionDeleteLastChar = __decorate([\n    base_1.RegisterAction\n], ActionDeleteLastChar);\nlet ActionJoin = class ActionJoin extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['J'];\n        this.createsUndoPoint = true;\n        this.runsOnceForEachCountPrefix = false;\n    }\n    firstNonWhitespaceIndex(str) {\n        for (let i = 0, len = str.length; i < len; i++) {\n            const chCode = str.charCodeAt(i);\n            if (chCode !== 32 /** space */ && chCode !== 9 /** tab */) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    async execJoinLines(startPosition, position, vimState, count) {\n        count = count - 1 || 1;\n        const joinspaces = configuration_1.configuration.joinspaces;\n        let startLineNumber;\n        let startColumn;\n        let endLineNumber;\n        let endColumn;\n        let columnDeltaOffset = 0;\n        if (startPosition.isEqual(position) || startPosition.line === position.line) {\n            if (position.line + 1 < vimState.document.lineCount) {\n                startLineNumber = position.line;\n                startColumn = 0;\n                endLineNumber = position.getDown(count).line;\n                endColumn = textEditor_1.TextEditor.getLineLength(endLineNumber);\n            }\n            else {\n                startLineNumber = position.line;\n                startColumn = 0;\n                endLineNumber = position.line;\n                endColumn = textEditor_1.TextEditor.getLineLength(endLineNumber);\n            }\n        }\n        else {\n            startLineNumber = startPosition.line;\n            startColumn = 0;\n            endLineNumber = position.line;\n            endColumn = textEditor_1.TextEditor.getLineLength(endLineNumber);\n        }\n        let trimmedLinesContent = vimState.document.lineAt(startPosition).text;\n        for (let i = startLineNumber + 1; i <= endLineNumber; i++) {\n            const lineText = vimState.document.lineAt(i).text;\n            const firstNonWhitespaceIdx = this.firstNonWhitespaceIndex(lineText);\n            if (firstNonWhitespaceIdx >= 0) {\n                // Compute number of spaces to separate the lines\n                let insertSpace = ' ';\n                if (trimmedLinesContent === '' || trimmedLinesContent.endsWith('\\t')) {\n                    insertSpace = '';\n                }\n                else if (joinspaces &&\n                    (trimmedLinesContent.endsWith('.') ||\n                        trimmedLinesContent.endsWith('!') ||\n                        trimmedLinesContent.endsWith('?'))) {\n                    insertSpace = '  ';\n                }\n                else if (joinspaces &&\n                    (trimmedLinesContent.endsWith('. ') ||\n                        trimmedLinesContent.endsWith('! ') ||\n                        trimmedLinesContent.endsWith('? '))) {\n                    insertSpace = ' ';\n                }\n                else if (trimmedLinesContent.endsWith(' ')) {\n                    insertSpace = '';\n                }\n                const lineTextWithoutIndent = lineText.substr(firstNonWhitespaceIdx);\n                if (lineTextWithoutIndent.charAt(0) === ')') {\n                    insertSpace = '';\n                }\n                trimmedLinesContent += insertSpace + lineTextWithoutIndent;\n                columnDeltaOffset = lineTextWithoutIndent.length + insertSpace.length;\n            }\n        }\n        const deleteStartPosition = new vscode_1.Position(startLineNumber, startColumn);\n        const deleteEndPosition = new vscode_1.Position(endLineNumber, endColumn);\n        if (!deleteStartPosition.isEqual(deleteEndPosition)) {\n            if (startPosition.isEqual(position)) {\n                vimState.recordedState.transformer.addTransformation({\n                    type: 'replaceText',\n                    text: trimmedLinesContent,\n                    range: new vscode.Range(deleteStartPosition, deleteEndPosition),\n                    diff: position_1.PositionDiff.offset({\n                        character: trimmedLinesContent.length - columnDeltaOffset - position.character,\n                    }),\n                });\n            }\n            else {\n                vimState.recordedState.transformer.addTransformation({\n                    type: 'replaceText',\n                    text: trimmedLinesContent,\n                    range: new vscode.Range(deleteStartPosition, deleteEndPosition),\n                    manuallySetCursorPositions: true,\n                });\n                vimState.cursorStartPosition = vimState.cursorStopPosition = new vscode_1.Position(startPosition.line, trimmedLinesContent.length - columnDeltaOffset);\n                await vimState.setCurrentMode(mode_1.Mode.Normal);\n            }\n        }\n    }\n    async execCount(position, vimState) {\n        const cursorsToIterateOver = vimState.cursors\n            .map((x) => new cursor_1.Cursor(x.start, x.stop))\n            .sort((a, b) => a.start.line > b.start.line ||\n            (a.start.line === b.start.line && a.start.character > b.start.character)\n            ? 1\n            : -1);\n        const resultingCursors = [];\n        for (const [idx, { start, stop }] of cursorsToIterateOver.entries()) {\n            this.multicursorIndex = idx;\n            vimState.cursorStopPosition = stop;\n            vimState.cursorStartPosition = start;\n            await this.execJoinLines(start, stop, vimState, vimState.recordedState.count || 1);\n            resultingCursors.push(new cursor_1.Cursor(vimState.cursorStartPosition, vimState.cursorStopPosition));\n            for (const transformation of vimState.recordedState.transformer.transformations) {\n                if ((0, transformations_1.isTextTransformation)(transformation) && transformation.cursorIndex === undefined) {\n                    transformation.cursorIndex = this.multicursorIndex;\n                }\n            }\n        }\n        vimState.cursors = resultingCursors;\n    }\n};\nActionJoin = __decorate([\n    base_1.RegisterAction\n], ActionJoin);\nlet ActionJoinVisualMode = class ActionJoinVisualMode extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n        this.keys = ['J'];\n    }\n    async exec(position, vimState) {\n        const [start, end] = (0, position_1.sorted)(vimState.editor.selection.start, vimState.editor.selection.end);\n        /**\n         * For joining lines, Visual Line behaves the same as Visual so we align the register mode here.\n         */\n        vimState.currentRegisterMode = register_1.RegisterMode.CharacterWise;\n        await new ActionJoin().execJoinLines(start, end, vimState, 1);\n    }\n};\nActionJoinVisualMode = __decorate([\n    base_1.RegisterAction\n], ActionJoinVisualMode);\nlet ActionJoinVisualBlockMode = class ActionJoinVisualBlockMode extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.VisualBlock];\n        this.keys = ['J'];\n    }\n    async exec(position, vimState) {\n        const [start, end] = (0, position_1.sorted)(vimState.cursorStartPosition, vimState.cursorStopPosition);\n        vimState.currentRegisterMode = register_1.RegisterMode.CharacterWise;\n        await new ActionJoin().execJoinLines(start, end, vimState, 1);\n    }\n};\nActionJoinVisualBlockMode = __decorate([\n    base_1.RegisterAction\n], ActionJoinVisualBlockMode);\nlet ActionJoinNoWhitespace = class ActionJoinNoWhitespace extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['g', 'J'];\n        this.createsUndoPoint = true;\n    }\n    // gJ is essentially J without the edge cases. ;-)\n    async exec(position, vimState) {\n        if (position.line === vimState.document.lineCount - 1) {\n            return; // TODO: bell\n        }\n        const count = vimState.recordedState.count > 2 ? vimState.recordedState.count - 1 : 1;\n        await this.execJoin(count, position, vimState);\n    }\n    async execJoin(count, position, vimState) {\n        const replaceRange = new vscode.Range(new vscode_1.Position(position.line, 0), new vscode_1.Position(Math.min(position.line + count, vimState.document.lineCount - 1), 0).getLineEnd());\n        const joinedText = vimState.document.getText(replaceRange).replace(/\\r?\\n/g, '');\n        // Put the cursor at the start of the last joined line's text\n        const newCursorColumn = joinedText.length - vimState.document.lineAt(replaceRange.end).text.length;\n        vimState.recordedState.transformer.addTransformation({\n            type: 'replaceText',\n            range: replaceRange,\n            text: joinedText,\n            diff: position_1.PositionDiff.exactCharacter({\n                character: newCursorColumn,\n            }),\n        });\n    }\n};\nActionJoinNoWhitespace = __decorate([\n    base_1.RegisterAction\n], ActionJoinNoWhitespace);\nlet ActionJoinNoWhitespaceVisualMode = class ActionJoinNoWhitespaceVisualMode extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n        this.keys = ['g', 'J'];\n    }\n    async exec(position, vimState) {\n        const [start, end] = (0, position_1.sorted)(vimState.cursorStartPosition, vimState.cursorStopPosition);\n        const count = start.line === end.line ? 1 : end.line - start.line;\n        await new ActionJoinNoWhitespace().execJoin(count, start, vimState);\n        await vimState.setCurrentMode(mode_1.Mode.Normal);\n    }\n};\nActionJoinNoWhitespaceVisualMode = __decorate([\n    base_1.RegisterAction\n], ActionJoinNoWhitespaceVisualMode);\nlet ActionReplaceCharacter = class ActionReplaceCharacter extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['r', '<character>'];\n        this.createsUndoPoint = true;\n        this.runsOnceForEachCountPrefix = false;\n    }\n    async exec(position, vimState) {\n        const timesToRepeat = vimState.recordedState.count || 1;\n        const toReplace = this.keysPressed[1];\n        /**\n         * <character> includes <BS>, <S-BS> and <TAB> but not any control keys,\n         * so we ignore the former two keys and have a special handle for <tab>.\n         */\n        if (['<BS>', '<S-BS>'].includes(toReplace.toUpperCase())) {\n            return;\n        }\n        if (position.character + timesToRepeat > position.getLineEnd().character) {\n            return;\n        }\n        let endPos = new vscode_1.Position(position.line, position.character + timesToRepeat);\n        // Return if tried to repeat longer than linelength\n        if (endPos.character > vimState.document.lineAt(endPos).text.length) {\n            return;\n        }\n        // If last char (not EOL char), add 1 so that replace selection is complete\n        if (endPos.character > vimState.document.lineAt(endPos).text.length) {\n            endPos = new vscode_1.Position(endPos.line, endPos.character + 1);\n        }\n        if (toReplace === '<tab>') {\n            vimState.recordedState.transformer.delete(new vscode.Range(position, endPos));\n            vimState.recordedState.transformer.vscodeCommand('tab');\n            vimState.recordedState.transformer.moveCursor(position_1.PositionDiff.offset({ character: -1 }), this.multicursorIndex);\n        }\n        else if (toReplace === '\\n') {\n            // A newline replacement always inserts exactly one newline (regardless\n            // of count prefix) and puts the cursor on the next line.\n            // We use `insertTextVSCode` so we get the right indentation\n            vimState.recordedState.transformer.delete(new vscode.Range(position, endPos));\n            vimState.recordedState.transformer.addTransformation({\n                type: 'insertTextVSCode',\n                text: '\\n',\n            });\n        }\n        else {\n            vimState.recordedState.transformer.addTransformation({\n                type: 'replaceText',\n                text: toReplace.repeat(timesToRepeat),\n                range: new vscode.Range(position, endPos),\n                diff: position_1.PositionDiff.offset({ character: timesToRepeat - 1 }),\n            });\n        }\n    }\n};\nActionReplaceCharacter = __decorate([\n    base_1.RegisterAction\n], ActionReplaceCharacter);\nlet ActionReplaceCharacterVisual = class ActionReplaceCharacterVisual extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n        this.keys = ['r', '<character>'];\n        this.createsUndoPoint = true;\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        let toInsert = this.keysPressed[1];\n        if (toInsert === '<tab>') {\n            toInsert = textEditor_1.TextEditor.getTabCharacter(vimState.editor);\n        }\n        let visualSelectionOffset = 1;\n        // If selection is reversed, reorganize it so that the text replace logic always works\n        let [start, end] = (0, position_1.sorted)(vimState.cursorStartPosition, vimState.cursorStopPosition);\n        if (vimState.currentMode === mode_1.Mode.VisualLine) {\n            [start, end] = [start.getLineBegin(), end.getLineEnd()];\n        }\n        // Limit to not replace EOL\n        const textLength = vimState.document.lineAt(end).text.length;\n        if (textLength <= 0) {\n            visualSelectionOffset = 0;\n        }\n        end = new vscode_1.Position(end.line, Math.min(end.character, textLength > 0 ? textLength - 1 : 0));\n        // Iterate over every line in the current selection\n        for (let lineNum = start.line; lineNum <= end.line; lineNum++) {\n            // Get line of text\n            const lineText = vimState.document.lineAt(lineNum).text;\n            if (start.line === end.line) {\n                // This is a visual section all on one line, only replace the part within the selection\n                vimState.recordedState.transformer.addTransformation({\n                    type: 'replaceText',\n                    text: Array(end.character - start.character + 2).join(toInsert),\n                    range: new vscode.Range(start, new vscode_1.Position(end.line, end.character + 1)),\n                    manuallySetCursorPositions: true,\n                });\n            }\n            else if (lineNum === start.line) {\n                // This is the first line of the selection so only replace after the cursor\n                vimState.recordedState.transformer.addTransformation({\n                    type: 'replaceText',\n                    text: Array(lineText.length - start.character + 1).join(toInsert),\n                    range: new vscode.Range(start, new vscode_1.Position(start.line, lineText.length)),\n                    manuallySetCursorPositions: true,\n                });\n            }\n            else if (lineNum === end.line) {\n                // This is the last line of the selection so only replace before the cursor\n                vimState.recordedState.transformer.addTransformation({\n                    type: 'replaceText',\n                    text: Array(end.character + 1 + visualSelectionOffset).join(toInsert),\n                    range: new vscode.Range(new vscode_1.Position(end.line, 0), new vscode_1.Position(end.line, end.character + visualSelectionOffset)),\n                    manuallySetCursorPositions: true,\n                });\n            }\n            else {\n                // Replace the entire line length since it is in the middle of the selection\n                vimState.recordedState.transformer.addTransformation({\n                    type: 'replaceText',\n                    text: Array(lineText.length + 1).join(toInsert),\n                    range: new vscode.Range(new vscode_1.Position(lineNum, 0), new vscode_1.Position(lineNum, lineText.length)),\n                    manuallySetCursorPositions: true,\n                });\n            }\n        }\n        vimState.cursorStopPosition = start;\n        vimState.cursorStartPosition = start;\n        await vimState.setCurrentMode(mode_1.Mode.Normal);\n    }\n};\nActionReplaceCharacterVisual = __decorate([\n    base_1.RegisterAction\n], ActionReplaceCharacterVisual);\nlet ActionReplaceCharacterVisualBlock = class ActionReplaceCharacterVisualBlock extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.VisualBlock];\n        this.keys = ['r', '<character>'];\n        this.createsUndoPoint = true;\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        let toInsert = this.keysPressed[1];\n        if (toInsert === '<tab>') {\n            toInsert = textEditor_1.TextEditor.getTabCharacter(vimState.editor);\n        }\n        for (const { start, end } of textEditor_1.TextEditor.iterateLinesInBlock(vimState)) {\n            if (end.isBeforeOrEqual(start)) {\n                continue;\n            }\n            vimState.recordedState.transformer.addTransformation({\n                type: 'replaceText',\n                text: Array(end.character - start.character + 1).join(toInsert),\n                range: new vscode.Range(start, end),\n                manuallySetCursorPositions: true,\n            });\n        }\n        const topLeft = (0, mode_1.visualBlockGetTopLeftPosition)(vimState.cursorStopPosition, vimState.cursorStartPosition);\n        vimState.cursors = [new cursor_1.Cursor(topLeft, topLeft)];\n        await vimState.setCurrentMode(mode_1.Mode.Normal);\n    }\n};\nActionReplaceCharacterVisualBlock = __decorate([\n    base_1.RegisterAction\n], ActionReplaceCharacterVisualBlock);\nlet ActionDeleteVisualBlock = class ActionDeleteVisualBlock extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.VisualBlock];\n        this.keys = [['d'], ['x'], ['X']];\n        this.createsUndoPoint = true;\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        const lines = [];\n        for (const { line, start, end } of textEditor_1.TextEditor.iterateLinesInBlock(vimState)) {\n            lines.push(line);\n            vimState.recordedState.transformer.addTransformation({\n                type: 'deleteRange',\n                range: new vscode.Range(start, end),\n                manuallySetCursorPositions: true,\n            });\n        }\n        const text = lines.length === 1 ? lines[0] : lines.join('\\n');\n        vimState.currentRegisterMode = register_1.RegisterMode.BlockWise;\n        register_1.Register.put(vimState, text, this.multicursorIndex, true);\n        const topLeft = (0, mode_1.visualBlockGetTopLeftPosition)(vimState.cursorStopPosition, vimState.cursorStartPosition);\n        vimState.cursors = [new cursor_1.Cursor(topLeft, topLeft)];\n        await vimState.setCurrentMode(mode_1.Mode.Normal);\n    }\n};\nActionDeleteVisualBlock = __decorate([\n    base_1.RegisterAction\n], ActionDeleteVisualBlock);\nlet ActionShiftDVisualBlock = class ActionShiftDVisualBlock extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.VisualBlock];\n        this.keys = ['D'];\n        this.createsUndoPoint = true;\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        const lines = [];\n        for (const { start } of textEditor_1.TextEditor.iterateLinesInBlock(vimState)) {\n            const range = new vscode.Range(start, start.getLineEnd());\n            lines.push(vimState.editor.document.getText(range));\n            vimState.recordedState.transformer.addTransformation({\n                type: 'deleteRange',\n                range,\n                manuallySetCursorPositions: true,\n            });\n        }\n        const topLeft = (0, mode_1.visualBlockGetTopLeftPosition)(vimState.cursorStopPosition, vimState.cursorStartPosition);\n        const text = lines.length === 1 ? lines[0] : lines.join('\\n');\n        register_1.Register.put(vimState, text, this.multicursorIndex, true);\n        vimState.cursors = [new cursor_1.Cursor(topLeft, topLeft)];\n        await vimState.setCurrentMode(mode_1.Mode.Normal);\n    }\n};\nActionShiftDVisualBlock = __decorate([\n    base_1.RegisterAction\n], ActionShiftDVisualBlock);\nlet ActionGoToInsertVisualBlockMode = class ActionGoToInsertVisualBlockMode extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.VisualBlock];\n        this.keys = ['I'];\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        const cursors = [];\n        for (const cursor of vimState.cursors) {\n            for (const { line, start } of textEditor_1.TextEditor.iterateLinesInBlock(vimState, cursor)) {\n                if (line === '' && start.character !== 0) {\n                    continue;\n                }\n                cursors.push(new cursor_1.Cursor(start, start));\n            }\n        }\n        vimState.cursors = cursors;\n        await vimState.setCurrentMode(mode_1.Mode.Insert);\n        vimState.isFakeMultiCursor = true;\n    }\n};\nActionGoToInsertVisualBlockMode = __decorate([\n    base_1.RegisterAction\n], ActionGoToInsertVisualBlockMode);\nlet ActionChangeInVisualBlockMode = class ActionChangeInVisualBlockMode extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.VisualBlock];\n        this.keys = [['c'], ['s']];\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        const cursors = [];\n        const lines = [];\n        for (const cursor of vimState.cursors) {\n            const width = 1 +\n                (0, mode_1.visualBlockGetBottomRightPosition)(cursor.start, cursor.stop).character -\n                (0, mode_1.visualBlockGetTopLeftPosition)(cursor.start, cursor.stop).character;\n            for (const { line, start, end } of textEditor_1.TextEditor.iterateLinesInBlock(vimState, cursor)) {\n                // TODO: is this behavior consistent with similar actions like VisualBlock `d`?\n                lines.push(line.padEnd(width, ' '));\n                if (line) {\n                    vimState.recordedState.transformer.addTransformation({\n                        type: 'deleteRange',\n                        range: new vscode.Range(start, end),\n                        manuallySetCursorPositions: true,\n                    });\n                    cursors.push(new cursor_1.Cursor(start, start));\n                }\n            }\n        }\n        vimState.cursors = cursors;\n        const text = lines.length === 1 ? lines[0] : lines.join('\\n');\n        register_1.Register.put(vimState, text, this.multicursorIndex, true);\n        await vimState.setCurrentMode(mode_1.Mode.Insert);\n        vimState.isFakeMultiCursor = true;\n    }\n};\nActionChangeInVisualBlockMode = __decorate([\n    base_1.RegisterAction\n], ActionChangeInVisualBlockMode);\nlet ActionChangeToEOLInVisualBlockMode = class ActionChangeToEOLInVisualBlockMode extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.VisualBlock];\n        this.keys = ['C'];\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        const cursors = [];\n        for (const cursor of vimState.cursors) {\n            for (const { start, end } of textEditor_1.TextEditor.iterateLinesInBlock(vimState, cursor)) {\n                vimState.recordedState.transformer.delete(new vscode.Range(start, start.getLineEnd()));\n                cursors.push(new cursor_1.Cursor(end, end));\n            }\n        }\n        vimState.cursors = cursors;\n        await vimState.setCurrentMode(mode_1.Mode.Insert);\n        vimState.isFakeMultiCursor = true;\n    }\n};\nActionChangeToEOLInVisualBlockMode = __decorate([\n    base_1.RegisterAction\n], ActionChangeToEOLInVisualBlockMode);\nclass ActionGoToInsertVisualLineModeCommand extends base_1.BaseCommand {\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        await vimState.setCurrentMode(mode_1.Mode.Insert);\n        vimState.isFakeMultiCursor = true;\n        const resultingCursors = [];\n        const cursorsOnBlankLines = [];\n        for (const selection of vimState.editor.selections) {\n            const { start, end } = selection;\n            for (let i = start.line; i <= end.line; i++) {\n                const line = vimState.document.lineAt(i);\n                const cursorRange = this.getCursorRangeForLine(line, start, end);\n                if (!line.isEmptyOrWhitespace) {\n                    resultingCursors.push(cursorRange);\n                }\n                else {\n                    cursorsOnBlankLines.push(cursorRange);\n                }\n            }\n        }\n        if (resultingCursors.length > 0) {\n            vimState.cursors = resultingCursors;\n        }\n        else {\n            vimState.cursors = cursorsOnBlankLines;\n        }\n    }\n}\nlet ActionGoToInsertVisualLineMode = class ActionGoToInsertVisualLineMode extends ActionGoToInsertVisualLineModeCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.VisualLine];\n        this.keys = ['I'];\n    }\n    getCursorRangeForLine(line) {\n        const startCharacterPosition = new vscode_1.Position(line.lineNumber, line.firstNonWhitespaceCharacterIndex);\n        return new cursor_1.Cursor(startCharacterPosition, startCharacterPosition);\n    }\n};\nActionGoToInsertVisualLineMode = __decorate([\n    base_1.RegisterAction\n], ActionGoToInsertVisualLineMode);\nlet ActionGoToInsertVisualLineModeAppend = class ActionGoToInsertVisualLineModeAppend extends ActionGoToInsertVisualLineModeCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.VisualLine];\n        this.keys = ['A'];\n    }\n    getCursorRangeForLine(line) {\n        const endCharacterPosition = new vscode_1.Position(line.lineNumber, line.range.end.character);\n        return new cursor_1.Cursor(endCharacterPosition, endCharacterPosition);\n    }\n};\nActionGoToInsertVisualLineModeAppend = __decorate([\n    base_1.RegisterAction\n], ActionGoToInsertVisualLineModeAppend);\nlet ActionGoToInsertVisualMode = class ActionGoToInsertVisualMode extends ActionGoToInsertVisualLineModeCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Visual];\n        this.keys = ['I'];\n    }\n    getCursorRangeForLine(line, selectionStart, selectionEnd) {\n        const startCharacterPosition = line.lineNumber === selectionStart.line\n            ? selectionStart\n            : new vscode_1.Position(line.lineNumber, line.firstNonWhitespaceCharacterIndex);\n        return new cursor_1.Cursor(startCharacterPosition, startCharacterPosition);\n    }\n};\nActionGoToInsertVisualMode = __decorate([\n    base_1.RegisterAction\n], ActionGoToInsertVisualMode);\nlet ActionGoToInsertVisualModeAppend = class ActionGoToInsertVisualModeAppend extends ActionGoToInsertVisualLineModeCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Visual];\n        this.keys = ['A'];\n    }\n    getCursorRangeForLine(line, selectionStart, selectionEnd) {\n        const endCharacterPosition = line.lineNumber === selectionEnd.line\n            ? selectionEnd\n            : new vscode_1.Position(line.lineNumber, line.range.end.character);\n        return new cursor_1.Cursor(endCharacterPosition, endCharacterPosition);\n    }\n};\nActionGoToInsertVisualModeAppend = __decorate([\n    base_1.RegisterAction\n], ActionGoToInsertVisualModeAppend);\nlet ActionGoToInsertVisualBlockModeAppend = class ActionGoToInsertVisualBlockModeAppend extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.VisualBlock];\n        this.keys = ['A'];\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        const newCursors = [];\n        for (const cursor of vimState.cursors) {\n            const [start, end] = (0, position_1.sorted)(cursor.start, cursor.stop);\n            for (let lineNum = start.line; lineNum <= end.line; lineNum++) {\n                const line = vimState.document.lineAt(lineNum);\n                const insertionColumn = vimState.desiredColumn === Number.POSITIVE_INFINITY\n                    ? line.text.length\n                    : Math.max(cursor.start.character, cursor.stop.character) + 1;\n                if (line.text.length < insertionColumn) {\n                    await textEditor_1.TextEditor.insert(vimState.editor, ' '.repeat(insertionColumn - line.text.length), line.range.end, false);\n                }\n                const newCursor = new vscode_1.Position(lineNum, insertionColumn);\n                newCursors.push(new cursor_1.Cursor(newCursor, newCursor));\n            }\n        }\n        vimState.cursors = newCursors;\n        await vimState.setCurrentMode(mode_1.Mode.Insert);\n        vimState.isFakeMultiCursor = true;\n    }\n};\nActionGoToInsertVisualBlockModeAppend = __decorate([\n    base_1.RegisterAction\n], ActionGoToInsertVisualBlockModeAppend);\nlet ActionDeleteCharVisualLineMode = class ActionDeleteCharVisualLineMode extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.VisualLine];\n        this.keys = ['x'];\n        this.name = 'delete_char_visual_line_mode';\n    }\n    async exec(position, vimState) {\n        const [start, end] = (0, position_1.sorted)(vimState.cursorStartPosition, vimState.cursorStopPosition);\n        await new operator.DeleteOperator(this.multicursorIndex).run(vimState, start.getLineBegin(), end.getLineEnd());\n    }\n};\nexports.ActionDeleteCharVisualLineMode = ActionDeleteCharVisualLineMode;\nexports.ActionDeleteCharVisualLineMode = ActionDeleteCharVisualLineMode = __decorate([\n    base_1.RegisterAction\n], ActionDeleteCharVisualLineMode);\nlet ActionDeleteLineVisualMode = class ActionDeleteLineVisualMode extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n        this.keys = ['X'];\n    }\n    async exec(position, vimState) {\n        const [start, end] = (0, position_1.sorted)(vimState.cursorStartPosition, vimState.cursorStopPosition);\n        await new operator.DeleteOperator(this.multicursorIndex).run(vimState, start.getLineBegin(), end.getLineEnd());\n    }\n};\nActionDeleteLineVisualMode = __decorate([\n    base_1.RegisterAction\n], ActionDeleteLineVisualMode);\nlet ActionChangeLineVisualModeS = class ActionChangeLineVisualModeS extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n        this.keys = ['S'];\n    }\n    doesActionApply(vimState, keysPressed) {\n        return !configuration_1.configuration.surround && super.doesActionApply(vimState, keysPressed);\n    }\n    async exec(position, vimState) {\n        return new ActionChangeLineVisualMode().exec(position, vimState);\n    }\n};\nActionChangeLineVisualModeS = __decorate([\n    base_1.RegisterAction\n], ActionChangeLineVisualModeS);\nlet ActionChangeLineVisualMode = class ActionChangeLineVisualMode extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n        this.keys = [['C'], ['R']];\n    }\n    async exec(position, vimState) {\n        const [start, end] = (0, position_1.sorted)(vimState.cursorStartPosition, vimState.cursorStopPosition);\n        await new operator.ChangeOperator(this.multicursorIndex).run(vimState, start.getLineBegin(), end.getLineEnd().getLeftIfEOL());\n    }\n};\nActionChangeLineVisualMode = __decorate([\n    base_1.RegisterAction\n], ActionChangeLineVisualMode);\nlet ActionChangeLineVisualBlockMode = class ActionChangeLineVisualBlockMode extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.VisualBlock];\n        this.keys = [['R'], ['S']];\n    }\n    async exec(position, vimState) {\n        return new ActionChangeLineVisualMode().exec(position, vimState);\n    }\n};\nActionChangeLineVisualBlockMode = __decorate([\n    base_1.RegisterAction\n], ActionChangeLineVisualBlockMode);\nlet ActionChangeChar = class ActionChangeChar extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['s'];\n    }\n    async exec(position, vimState) {\n        await new operator.ChangeOperator(this.multicursorIndex).run(vimState, position, position.getRight((vimState.recordedState.count || 1) - 1));\n    }\n    // Don't clash with surround or sneak modes!\n    doesActionApply(vimState, keysPressed) {\n        return (super.doesActionApply(vimState, keysPressed) &&\n            !configuration_1.configuration.sneak &&\n            !vimState.recordedState.operator);\n    }\n    couldActionApply(vimState, keysPressed) {\n        return (super.couldActionApply(vimState, keysPressed) &&\n            !configuration_1.configuration.sneak &&\n            !vimState.recordedState.operator);\n    }\n};\nActionChangeChar = __decorate([\n    base_1.RegisterAction\n], ActionChangeChar);\nlet ToggleCaseAndMoveForward = class ToggleCaseAndMoveForward extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['~'];\n        this.createsUndoPoint = true;\n    }\n    toggleCase(text) {\n        let newText = '';\n        for (const char of text) {\n            let toggled = char.toLocaleLowerCase();\n            if (toggled === char) {\n                toggled = char.toLocaleUpperCase();\n            }\n            newText += toggled;\n        }\n        return newText;\n    }\n    async exec(position, vimState) {\n        const count = vimState.recordedState.count || 1;\n        const range = new vscode.Range(position, (0, wrapping_1.shouldWrapKey)(vimState.currentMode, '~')\n            ? position.getOffsetThroughLineBreaks(count)\n            : position.getRight(count));\n        vimState.recordedState.transformer.addTransformation({\n            type: 'replaceText',\n            range,\n            text: this.toggleCase(vimState.document.getText(range)),\n            diff: position_1.PositionDiff.exactPosition(range.end),\n        });\n    }\n};\nToggleCaseAndMoveForward = __decorate([\n    base_1.RegisterAction\n], ToggleCaseAndMoveForward);\nclass IncrementDecrementNumberAction extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n        this.createsUndoPoint = true;\n    }\n    async exec(position, vimState) {\n        const ranges = this.getSearchRanges(vimState);\n        let stepNum = 1;\n        for (const [idx, range] of ranges.entries()) {\n            position = range.start;\n            const text = vimState.document.lineAt(position).text;\n            // Make sure position within the text is possible and return if not\n            if (text.length <= position.character) {\n                continue;\n            }\n            // Start looking to the right for the next word to increment, unless we're\n            // already on a word to increment, in which case start at the beginning of\n            // that word.\n            const whereToStart = text[position.character].match(/\\s/)\n                ? position\n                : position.prevWordStart(vimState.document, { inclusive: true });\n            wordLoop: for (let { start, end, word } of textEditor_1.TextEditor.iterateWords(vimState.document, whereToStart)) {\n                if (start.isAfter(range.stop)) {\n                    break;\n                }\n                // '-' doesn't count as a word, but is important to include in parsing\n                // the number, as long as it is not just part of the word (-foo2 for example)\n                if (text[start.character - 1] === '-' && /\\d/.test(text[start.character])) {\n                    start = start.getLeft();\n                    word = text[start.character] + word;\n                }\n                // Strict number parsing so \"1a\" doesn't silently get converted to \"1\"\n                do {\n                    const result = numericString_1.NumericString.parse(word);\n                    if (result === undefined) {\n                        break;\n                    }\n                    const { num, suffixOffset } = result;\n                    // Use suffix offset to check if current cursor is in or before detected number.\n                    if (position.character < start.character + suffixOffset) {\n                        const pos = await this.replaceNum(vimState, num, this.offset * stepNum * (vimState.recordedState.count || 1), start, end);\n                        if (this.staircase) {\n                            stepNum++;\n                        }\n                        if (vimState.currentMode === mode_1.Mode.Normal) {\n                            vimState.recordedState.transformer.moveCursor(position_1.PositionDiff.exactPosition(pos.getLeft(num.suffix.length)));\n                        }\n                        break wordLoop;\n                    }\n                    else {\n                        // For situation like this: xyz1999em199[cursor]9m\n                        word = word.slice(suffixOffset);\n                        start = new vscode_1.Position(start.line, start.character + suffixOffset);\n                    }\n                } while (true);\n            }\n        }\n        if ((0, mode_1.isVisualMode)(vimState.currentMode)) {\n            vimState.recordedState.transformer.moveCursor(position_1.PositionDiff.exactPosition(ranges[0].start));\n        }\n        await vimState.setCurrentMode(mode_1.Mode.Normal);\n    }\n    async replaceNum(vimState, start, offset, startPos, endPos) {\n        const oldLength = endPos.character + 1 - startPos.character;\n        start.value += offset;\n        const newNum = start.toString();\n        const range = new vscode.Range(startPos, endPos.getRight());\n        vimState.recordedState.transformer.replace(range, newNum);\n        if (oldLength !== newNum.length) {\n            // Adjust end position according to difference in width of number-string\n            endPos = new vscode_1.Position(endPos.line, startPos.character + newNum.length - 1);\n        }\n        return endPos;\n    }\n    /**\n     * @returns a list of Ranges in which to search for numbers\n     */\n    getSearchRanges(vimState) {\n        const ranges = [];\n        const [start, stop] = (0, position_1.sorted)(vimState.cursorStartPosition, vimState.cursorStopPosition);\n        switch (vimState.currentMode) {\n            case mode_1.Mode.Normal: {\n                ranges.push(new cursor_1.Cursor(vimState.cursorStopPosition, vimState.cursorStopPosition.getLineEnd()));\n                break;\n            }\n            case mode_1.Mode.Visual: {\n                ranges.push(new cursor_1.Cursor(start, start.getLineEnd()));\n                for (let line = start.line + 1; line < stop.line; line++) {\n                    const lineStart = new vscode_1.Position(line, 0);\n                    ranges.push(new cursor_1.Cursor(lineStart, lineStart.getLineEnd()));\n                }\n                ranges.push(new cursor_1.Cursor(stop.getLineBegin(), stop));\n                break;\n            }\n            case mode_1.Mode.VisualLine: {\n                for (let line = start.line; line <= stop.line; line++) {\n                    const lineStart = new vscode_1.Position(line, 0);\n                    ranges.push(new cursor_1.Cursor(lineStart, lineStart.getLineEnd()));\n                }\n                break;\n            }\n            case mode_1.Mode.VisualBlock: {\n                const topLeft = (0, mode_1.visualBlockGetTopLeftPosition)(start, stop);\n                const bottomRight = (0, mode_1.visualBlockGetBottomRightPosition)(start, stop);\n                for (let line = topLeft.line; line <= bottomRight.line; line++) {\n                    ranges.push(new cursor_1.Cursor(new vscode_1.Position(line, topLeft.character), new vscode_1.Position(line, bottomRight.character)));\n                }\n                break;\n            }\n            default:\n                throw new Error(`Unexpected mode ${vimState.currentMode} in IncrementDecrementNumberAction.getPositions()`);\n        }\n        return ranges;\n    }\n}\nlet IncrementNumberAction = class IncrementNumberAction extends IncrementDecrementNumberAction {\n    constructor() {\n        super(...arguments);\n        this.keys = ['<C-a>'];\n        this.offset = +1;\n        this.staircase = false;\n    }\n};\nIncrementNumberAction = __decorate([\n    base_1.RegisterAction\n], IncrementNumberAction);\nlet DecrementNumberAction = class DecrementNumberAction extends IncrementDecrementNumberAction {\n    constructor() {\n        super(...arguments);\n        this.keys = ['<C-x>'];\n        this.offset = -1;\n        this.staircase = false;\n    }\n};\nDecrementNumberAction = __decorate([\n    base_1.RegisterAction\n], DecrementNumberAction);\nlet IncrementNumberStaircaseAction = class IncrementNumberStaircaseAction extends IncrementDecrementNumberAction {\n    constructor() {\n        super(...arguments);\n        this.keys = ['g', '<C-a>'];\n        this.offset = +1;\n        this.staircase = true;\n    }\n};\nIncrementNumberStaircaseAction = __decorate([\n    base_1.RegisterAction\n], IncrementNumberStaircaseAction);\nlet DecrementNumberStaircaseAction = class DecrementNumberStaircaseAction extends IncrementDecrementNumberAction {\n    constructor() {\n        super(...arguments);\n        this.keys = ['g', '<C-x>'];\n        this.offset = -1;\n        this.staircase = true;\n    }\n};\nDecrementNumberStaircaseAction = __decorate([\n    base_1.RegisterAction\n], DecrementNumberStaircaseAction);\nlet CommandUnicodeName = class CommandUnicodeName extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['g', 'a'];\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        const char = vimState.document.getText(new vscode.Range(position, position.getRight()));\n        const charCode = char.charCodeAt(0);\n        // TODO: Handle charCode > 127 by also including <M-x>\n        statusBar_1.StatusBar.setText(vimState, `<${char}>  ${charCode},  Hex ${charCode.toString(16)},  Octal ${charCode.toString(8)}`);\n    }\n};\nexports.CommandUnicodeName = CommandUnicodeName;\nexports.CommandUnicodeName = CommandUnicodeName = __decorate([\n    base_1.RegisterAction\n], CommandUnicodeName);\nlet ActionTriggerHover = class ActionTriggerHover extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['g', 'h'];\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        await vscode.commands.executeCommand('editor.action.showHover');\n    }\n};\nActionTriggerHover = __decorate([\n    base_1.RegisterAction\n], ActionTriggerHover);\n/**\n * Multi-Cursor Command Overrides\n *\n * We currently have to override the VSCode key commands that get us into multi-cursor mode.\n *\n * Normally, we'd just listen for another cursor to be added in order to go into multi-cursor\n * mode rather than rewriting each keybinding one-by-one. We can't currently do that because\n * Visual Block Mode also creates additional cursors, but will get confused if you're in\n * multi-cursor mode.\n */\nlet ActionOverrideCmdD = class ActionOverrideCmdD extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual];\n        this.keys = [['<D-d>'], ['g', 'b']];\n        this.runsOnceForEachCountPrefix = true;\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        await vscode.commands.executeCommand('editor.action.addSelectionToNextFindMatch');\n        vimState.cursors = (0, util_1.getCursorsAfterSync)(vimState.editor);\n        // If this is the first cursor, select 1 character less\n        // so that only the word is selected, no extra character\n        vimState.cursors = vimState.cursors.map((x) => x.withNewStop(x.stop.getLeft()));\n        await vimState.setCurrentMode(mode_1.Mode.Visual);\n    }\n};\nexports.ActionOverrideCmdD = ActionOverrideCmdD;\nexports.ActionOverrideCmdD = ActionOverrideCmdD = __decorate([\n    base_1.RegisterAction\n], ActionOverrideCmdD);\nlet ActionOverrideCmdDInsert = class ActionOverrideCmdDInsert extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Insert];\n        this.keys = ['<D-d>'];\n        this.runsOnceForEachCountPrefix = true;\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        // Since editor.action.addSelectionToNextFindMatch uses the selection to\n        // determine where to add a word, we need to do a hack and manually set the\n        // selections to the word boundaries before we make the api call.\n        vimState.editor.selections = vimState.editor.selections.map((x, idx) => {\n            const curPos = x.active;\n            if (idx === 0) {\n                return new vscode.Selection(curPos.prevWordStart(vimState.document), curPos.getLeft().nextWordEnd(vimState.document, { inclusive: true }).getRight());\n            }\n            else {\n                // Since we're adding the selections ourselves, we need to make sure\n                // that our selection is actually over what our original word is\n                const matchWordPos = vimState.editor.selections[0].active;\n                const matchWordLength = matchWordPos.getLeft().nextWordEnd(vimState.document, { inclusive: true }).getRight()\n                    .character - matchWordPos.prevWordStart(vimState.document).character;\n                const wordBegin = curPos.getLeft(matchWordLength);\n                return new vscode.Selection(wordBegin, curPos);\n            }\n        });\n        vimState.recordedState.transformer.vscodeCommand('editor.action.addSelectionToNextFindMatch');\n    }\n};\nActionOverrideCmdDInsert = __decorate([\n    base_1.RegisterAction\n], ActionOverrideCmdDInsert);\nlet ActionOverrideCmdAltDown = class ActionOverrideCmdAltDown extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual];\n        this.keys = [\n            ['<D-alt+down>'], // OSX\n            ['<C-alt+down>'], // Windows\n        ];\n        this.runsOnceForEachCountPrefix = true;\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        vimState.recordedState.transformer.vscodeCommand('editor.action.insertCursorBelow');\n    }\n};\nActionOverrideCmdAltDown = __decorate([\n    base_1.RegisterAction\n], ActionOverrideCmdAltDown);\nlet ActionOverrideCmdAltUp = class ActionOverrideCmdAltUp extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual];\n        this.keys = [\n            ['<D-alt+up>'], // OSX\n            ['<C-alt+up>'], // Windows\n        ];\n        this.runsOnceForEachCountPrefix = true;\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        vimState.recordedState.transformer.vscodeCommand('editor.action.insertCursorAbove');\n    }\n};\nActionOverrideCmdAltUp = __decorate([\n    base_1.RegisterAction\n], ActionOverrideCmdAltUp);\nlet ActionShowFileInfo = class ActionShowFileInfo extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['<C-g>'];\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        (0, statusBarTextUtils_1.reportFileInfo)(position, vimState);\n    }\n};\nActionShowFileInfo = __decorate([\n    base_1.RegisterAction\n], ActionShowFileInfo);\nlet WriteQuit = class WriteQuit extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = [['Z', 'Z']];\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        await new writequit_1.WriteQuitCommand({ bang: false, opt: [] }).execute(vimState);\n    }\n};\nWriteQuit = __decorate([\n    base_1.RegisterAction\n], WriteQuit);\nlet Quit = class Quit extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = [['Z', 'Q']];\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        await new quit_1.QuitCommand({ bang: true }).execute(vimState);\n    }\n};\nQuit = __decorate([\n    base_1.RegisterAction\n], Quit);\nlet ActionGoToAlternateFile = class ActionGoToAlternateFile extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = [['<C-6>'], ['<C-^>']];\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        const altFile = await register_1.Register.get('#');\n        if (altFile?.text instanceof recordedState_1.RecordedState) {\n            throw new Error(`# register unexpectedly contained a RecordedState`);\n        }\n        else if (altFile === undefined || altFile.text === '') {\n            statusBar_1.StatusBar.displayError(vimState, error_1.VimError.fromCode(error_1.ErrorCode.NoAlternateFile));\n        }\n        else {\n            let files;\n            if (await (0, fs_1.doesFileExist)(vscode.Uri.file(altFile.text))) {\n                files = [vscode.Uri.file(altFile.text)];\n            }\n            else {\n                files = await vscode.workspace.findFiles(altFile.text);\n            }\n            // TODO: if the path matches a file from multiple workspace roots, we may not choose the right one\n            if (files.length > 0) {\n                const document = await vscode.workspace.openTextDocument(files[0]);\n                await vscode.window.showTextDocument(document);\n            }\n        }\n    }\n};\nActionGoToAlternateFile = __decorate([\n    base_1.RegisterAction\n], ActionGoToAlternateFile);\nlet ShowFileOutline = class ShowFileOutline extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['g', 'O'];\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        await vscode.commands.executeCommand('outline.focus');\n    }\n};\nShowFileOutline = __decorate([\n    base_1.RegisterAction\n], ShowFileOutline);\n\n\n//# sourceURL=webpack://vim/./src/actions/commands/actions.ts?")},"./src/actions/commands/commandLine.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar CommandLineTab_1;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst vscode = __importStar(__webpack_require__(/*! vscode */ \"vscode\"));\nconst commandLine_1 = __webpack_require__(/*! ../../cmd_line/commandLine */ \"./src/cmd_line/commandLine.ts\");\nconst error_1 = __webpack_require__(/*! ../../error */ \"./src/error.ts\");\nconst mode_1 = __webpack_require__(/*! ../../mode/mode */ \"./src/mode/mode.ts\");\nconst register_1 = __webpack_require__(/*! ../../register/register */ \"./src/register/register.ts\");\nconst recordedState_1 = __webpack_require__(/*! ../../state/recordedState */ \"./src/state/recordedState.ts\");\nconst statusBar_1 = __webpack_require__(/*! ../../statusBar */ \"./src/statusBar.ts\");\nconst textEditor_1 = __webpack_require__(/*! ../../textEditor */ \"./src/textEditor.ts\");\nconst clipboard_1 = __webpack_require__(/*! ../../util/clipboard */ \"./src/util/clipboard.ts\");\nconst path_1 = __webpack_require__(/*! ../../util/path */ \"./src/util/path.ts\");\nconst exCommandParser_1 = __webpack_require__(/*! ../../vimscript/exCommandParser */ \"./src/vimscript/exCommandParser.ts\");\nconst pattern_1 = __webpack_require__(/*! ../../vimscript/pattern */ \"./src/vimscript/pattern.ts\");\nconst base_1 = __webpack_require__(/*! ../base */ \"./src/actions/base.ts\");\nclass CommandLineAction extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.CommandlineInProgress, mode_1.Mode.SearchInProgressMode];\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        if (!(vimState.modeData.mode === mode_1.Mode.CommandlineInProgress ||\n            vimState.modeData.mode === mode_1.Mode.SearchInProgressMode)) {\n            throw new Error(`Unexpected mode ${vimState.modeData.mode} in CommandLineAction`);\n        }\n        await this.run(vimState, vimState.modeData.commandLine);\n    }\n}\nlet CommandLineTab = CommandLineTab_1 = class CommandLineTab extends CommandLineAction {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.CommandlineInProgress];\n        this.keys = [['<tab>'], ['<S-tab>']];\n    }\n    cycleCompletion(isTabForward, commandLine) {\n        const autoCompleteItems = commandLine.autoCompleteItems;\n        if (autoCompleteItems.length === 0) {\n            return;\n        }\n        commandLine.autoCompleteIndex = isTabForward\n            ? (commandLine.autoCompleteIndex + 1) % autoCompleteItems.length\n            : (commandLine.autoCompleteIndex - 1 + autoCompleteItems.length) % autoCompleteItems.length;\n        const lastPos = commandLine.preCompleteCharacterPos;\n        const lastCmd = commandLine.preCompleteCommand;\n        const evalCmd = lastCmd.slice(0, lastPos);\n        const restCmd = lastCmd.slice(lastPos);\n        commandLine.text = evalCmd + autoCompleteItems[commandLine.autoCompleteIndex] + restCmd;\n        commandLine.cursorIndex = commandLine.text.length - restCmd.length;\n    }\n    async run(vimState, commandLine) {\n        if (!(commandLine instanceof commandLine_1.ExCommandLine)) {\n            throw new Error('Expected ExCommandLine in CommandLineTab::run()');\n        }\n        const key = this.keysPressed[0];\n        const isTabForward = key === '<tab>';\n        // If we hit <Tab> twice in a row, definitely cycle\n        if (commandLine.autoCompleteItems.length !== 0 &&\n            vimState.recordedState.actionsRun[vimState.recordedState.actionsRun.length - 2] instanceof\n                CommandLineTab_1) {\n            this.cycleCompletion(isTabForward, commandLine);\n            return;\n        }\n        let newCompletionItems = [];\n        // Sub string since vim does completion before the cursor\n        let evalCmd = commandLine.text.slice(0, commandLine.cursorIndex);\n        const restCmd = commandLine.text.slice(commandLine.cursorIndex);\n        // \\s* is the match the extra space before any character like ':  edit'\n        const cmdRegex = /^\\s*\\w+$/;\n        const fileRegex = /^\\s*\\w+\\s+/g;\n        if (cmdRegex.test(evalCmd)) {\n            // Command completion\n            newCompletionItems = exCommandParser_1.builtinExCommands\n                .map((pair) => pair[0][0] + pair[0][1])\n                .filter((cmd) => cmd.startsWith(evalCmd))\n                // Remove the already typed portion in the array\n                .map((cmd) => cmd.slice(cmd.search(evalCmd) + evalCmd.length))\n                .sort();\n        }\n        else if (fileRegex.exec(evalCmd)) {\n            // File completion by searching if there is a space after the first word/command\n            // ideally it should be a process of white-listing to selected commands like :e and :vsp\n            const filePathInCmd = evalCmd.substring(fileRegex.lastIndex);\n            const currentUri = vimState.document.uri;\n            const isRemote = !!vscode.env.remoteName;\n            const { fullDirPath, baseName, partialPath, path: p, } = (0, path_1.getPathDetails)(filePathInCmd, currentUri, isRemote);\n            // Update the evalCmd in case of windows, where we change / to \\\n            evalCmd = evalCmd.slice(0, fileRegex.lastIndex) + partialPath;\n            // test if the baseName is . or ..\n            const shouldAddDotItems = /^\\.\\.?$/g.test(baseName);\n            const dirItems = await (0, path_1.readDirectory)(fullDirPath, p.sep, currentUri, isRemote, shouldAddDotItems);\n            const startWithBaseNameRegex = new RegExp(`^${baseName}`, process.platform === 'win32' ? 'i' : '');\n            newCompletionItems = dirItems\n                .map((name) => [startWithBaseNameRegex.exec(name), name])\n                .filter(([isMatch]) => isMatch !== null)\n                .map(([match, name]) => name.slice(match[0].length))\n                .sort();\n        }\n        const newIndex = isTabForward ? 0 : newCompletionItems.length - 1;\n        commandLine.autoCompleteIndex = newIndex;\n        // If here only one items we fill cmd direct, so the next tab will not cycle the one item array\n        commandLine.autoCompleteItems = newCompletionItems.length <= 1 ? [] : newCompletionItems;\n        commandLine.preCompleteCharacterPos = commandLine.cursorIndex;\n        commandLine.preCompleteCommand = evalCmd + restCmd;\n        const completion = newCompletionItems.length === 0 ? '' : newCompletionItems[newIndex];\n        commandLine.text = evalCmd + completion + restCmd;\n        commandLine.cursorIndex = commandLine.text.length - restCmd.length;\n    }\n};\nCommandLineTab = CommandLineTab_1 = __decorate([\n    base_1.RegisterAction\n], CommandLineTab);\nlet ExCommandLineEnter = class ExCommandLineEnter extends CommandLineAction {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.CommandlineInProgress];\n        this.keys = [['\\n'], ['<C-m>']];\n    }\n    async run(vimState, commandLine) {\n        await commandLine.run(vimState);\n        await vimState.setCurrentMode(mode_1.Mode.Normal);\n    }\n};\nExCommandLineEnter = __decorate([\n    base_1.RegisterAction\n], ExCommandLineEnter);\nlet SearchCommandLineEnter = class SearchCommandLineEnter extends CommandLineAction {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.SearchInProgressMode];\n        this.keys = [['\\n'], ['<C-m>']];\n        this.isJump = true;\n    }\n    runsOnceForEveryCursor() {\n        return true;\n    }\n    async run(vimState, commandLine) {\n        await commandLine.run(vimState);\n        if (this.multicursorIndex === vimState.cursors.length - 1) {\n            // TODO: gah, this is stupid\n            await vimState.setCurrentMode(commandLine.previousMode);\n        }\n    }\n};\nSearchCommandLineEnter = __decorate([\n    base_1.RegisterAction\n], SearchCommandLineEnter);\nlet CommandLineEscape = class CommandLineEscape extends CommandLineAction {\n    constructor() {\n        super(...arguments);\n        this.keys = [['<Esc>'], ['<C-c>'], ['<C-[>']];\n    }\n    async run(vimState, commandLine) {\n        await commandLine.escape(vimState);\n    }\n};\nCommandLineEscape = __decorate([\n    base_1.RegisterAction\n], CommandLineEscape);\nlet CommandLineCtrlF = class CommandLineCtrlF extends CommandLineAction {\n    constructor() {\n        super(...arguments);\n        this.keys = ['<C-f>'];\n    }\n    async run(vimState, commandLine) {\n        await commandLine.ctrlF(vimState);\n    }\n};\nCommandLineCtrlF = __decorate([\n    base_1.RegisterAction\n], CommandLineCtrlF);\nlet CommandLineBackspace = class CommandLineBackspace extends CommandLineAction {\n    constructor() {\n        super(...arguments);\n        this.keys = [['<BS>'], ['<S-BS>'], ['<C-h>']];\n    }\n    async run(vimState, commandLine) {\n        await commandLine.backspace(vimState);\n    }\n};\nCommandLineBackspace = __decorate([\n    base_1.RegisterAction\n], CommandLineBackspace);\nlet CommandLineDelete = class CommandLineDelete extends CommandLineAction {\n    constructor() {\n        super(...arguments);\n        this.keys = ['<Del>'];\n    }\n    async run(vimState, commandLine) {\n        await commandLine.delete(vimState);\n    }\n};\nCommandLineDelete = __decorate([\n    base_1.RegisterAction\n], CommandLineDelete);\nlet CommandlineHome = class CommandlineHome extends CommandLineAction {\n    constructor() {\n        super(...arguments);\n        this.keys = [['<Home>'], ['<C-b>']];\n    }\n    async run(vimState, commandLine) {\n        await commandLine.home();\n    }\n};\nCommandlineHome = __decorate([\n    base_1.RegisterAction\n], CommandlineHome);\nlet CommandLineEnd = class CommandLineEnd extends CommandLineAction {\n    constructor() {\n        super(...arguments);\n        this.keys = [['<End>'], ['<C-e>']];\n    }\n    async run(vimState, commandLine) {\n        await commandLine.end();\n    }\n};\nCommandLineEnd = __decorate([\n    base_1.RegisterAction\n], CommandLineEnd);\nlet CommandLineDeleteWord = class CommandLineDeleteWord extends CommandLineAction {\n    constructor() {\n        super(...arguments);\n        this.keys = [['<C-w>'], ['<C-BS>']];\n    }\n    async run(vimState, commandLine) {\n        await commandLine.deleteWord();\n    }\n};\nCommandLineDeleteWord = __decorate([\n    base_1.RegisterAction\n], CommandLineDeleteWord);\nlet CommandLineDeleteToBeginning = class CommandLineDeleteToBeginning extends CommandLineAction {\n    constructor() {\n        super(...arguments);\n        this.keys = ['<C-u>'];\n    }\n    async run(vimState, commandLine) {\n        await commandLine.deleteToBeginning();\n    }\n};\nCommandLineDeleteToBeginning = __decorate([\n    base_1.RegisterAction\n], CommandLineDeleteToBeginning);\nlet CommandLineWordLeft = class CommandLineWordLeft extends CommandLineAction {\n    constructor() {\n        super(...arguments);\n        this.keys = ['<C-left>'];\n    }\n    async run(vimState, commandLine) {\n        await commandLine.wordLeft();\n    }\n};\nCommandLineWordLeft = __decorate([\n    base_1.RegisterAction\n], CommandLineWordLeft);\nlet CommandLineWordRight = class CommandLineWordRight extends CommandLineAction {\n    constructor() {\n        super(...arguments);\n        this.keys = ['<C-right>'];\n    }\n    async run(vimState, commandLine) {\n        await commandLine.wordRight();\n    }\n};\nCommandLineWordRight = __decorate([\n    base_1.RegisterAction\n], CommandLineWordRight);\nlet CommandLineHistoryBack = class CommandLineHistoryBack extends CommandLineAction {\n    constructor() {\n        super(...arguments);\n        this.keys = [['<up>'], ['<C-p>']];\n    }\n    async run(vimState, commandLine) {\n        await commandLine.historyBack();\n    }\n};\nCommandLineHistoryBack = __decorate([\n    base_1.RegisterAction\n], CommandLineHistoryBack);\nlet CommandLineHistoryForward = class CommandLineHistoryForward extends CommandLineAction {\n    constructor() {\n        super(...arguments);\n        this.keys = [['<down>'], ['<C-n>']];\n    }\n    async run(vimState, commandLine) {\n        await commandLine.historyForward();\n    }\n};\nCommandLineHistoryForward = __decorate([\n    base_1.RegisterAction\n], CommandLineHistoryForward);\nlet CommandInsertRegisterContentInCommandLine = class CommandInsertRegisterContentInCommandLine extends CommandLineAction {\n    constructor() {\n        super(...arguments);\n        this.keys = ['<C-r>', '<character>'];\n        this.isCompleteAction = false;\n    }\n    async run(vimState, commandLine) {\n        if (!register_1.Register.isValidRegister(this.keysPressed[1])) {\n            return;\n        }\n        vimState.recordedState.registerName = this.keysPressed[1];\n        const register = await register_1.Register.get(vimState.recordedState.registerName, this.multicursorIndex);\n        if (register === undefined) {\n            statusBar_1.StatusBar.displayError(vimState, error_1.VimError.fromCode(error_1.ErrorCode.NothingInRegister, vimState.recordedState.registerName));\n            return;\n        }\n        let text;\n        if (register.text instanceof Array) {\n            text = register.text.join('\\n');\n        }\n        else if (register.text instanceof recordedState_1.RecordedState) {\n            let keyStrokes = [];\n            for (const action of register.text.actionsRun) {\n                keyStrokes = keyStrokes.concat(action.keysPressed);\n            }\n            text = keyStrokes.join('\\n');\n        }\n        else {\n            text = register.text;\n        }\n        if (register.registerMode === register_1.RegisterMode.LineWise) {\n            text += '\\n';\n        }\n        commandLine.text += text;\n        commandLine.cursorIndex += text.length;\n    }\n};\nCommandInsertRegisterContentInCommandLine = __decorate([\n    base_1.RegisterAction\n], CommandInsertRegisterContentInCommandLine);\nlet CommandInsertWord = class CommandInsertWord extends CommandLineAction {\n    constructor() {\n        super(...arguments);\n        this.keys = ['<C-r>', '<C-w>'];\n    }\n    async run(vimState, commandLine) {\n        const word = textEditor_1.TextEditor.getWord(vimState.document, vimState.cursorStopPosition.getLeftIfEOL());\n        if (word !== undefined) {\n            commandLine.text += word;\n            commandLine.cursorIndex += word.length;\n        }\n    }\n};\nCommandInsertWord = __decorate([\n    base_1.RegisterAction\n], CommandInsertWord);\nlet CommandLineLeftRight = class CommandLineLeftRight extends CommandLineAction {\n    constructor() {\n        super(...arguments);\n        this.keys = [['<left>'], ['<right>']];\n    }\n    getTrimmedStatusBarText() {\n        // first regex removes the : / and | from the string\n        // second regex removes a single space from the end of the string\n        const trimmedStatusBarText = statusBar_1.StatusBar.getText()\n            .replace(/^(?:\\/|\\:)(.*)(?:\\|)(.*)/, '$1$2')\n            .replace(/(.*) $/, '$1');\n        return trimmedStatusBarText;\n    }\n    async run(vimState, commandLine) {\n        const key = this.keysPressed[0];\n        const statusBarText = this.getTrimmedStatusBarText();\n        if (key === '<right>') {\n            commandLine.cursorIndex = Math.min(commandLine.cursorIndex + 1, statusBarText.length);\n        }\n        else if (key === '<left>') {\n            commandLine.cursorIndex = Math.max(commandLine.cursorIndex - 1, 0);\n        }\n    }\n};\nCommandLineLeftRight = __decorate([\n    base_1.RegisterAction\n], CommandLineLeftRight);\nlet CommandLinePaste = class CommandLinePaste extends CommandLineAction {\n    constructor() {\n        super(...arguments);\n        this.keys = [['<C-v>'], ['<D-v>']];\n    }\n    async run(vimState, commandLine) {\n        const textFromClipboard = await clipboard_1.Clipboard.Paste();\n        commandLine.text = commandLine.text\n            .substring(0, commandLine.cursorIndex)\n            .concat(textFromClipboard)\n            .concat(commandLine.text.slice(commandLine.cursorIndex));\n        commandLine.cursorIndex += textFromClipboard.length;\n    }\n};\nCommandLinePaste = __decorate([\n    base_1.RegisterAction\n], CommandLinePaste);\nlet CommandCtrlLInSearchMode = class CommandCtrlLInSearchMode extends CommandLineAction {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.SearchInProgressMode];\n        this.keys = ['<C-l>'];\n    }\n    async run(vimState, commandLine) {\n        if (commandLine instanceof commandLine_1.SearchCommandLine) {\n            const currentMatch = commandLine.getCurrentMatchRange(vimState);\n            if (currentMatch) {\n                const line = vimState.document.lineAt(currentMatch.range.end).text;\n                if (currentMatch.range.end.character < line.length) {\n                    commandLine.getSearchState().searchString += line[currentMatch.range.end.character];\n                    commandLine.cursorIndex++;\n                }\n            }\n        }\n    }\n};\nCommandCtrlLInSearchMode = __decorate([\n    base_1.RegisterAction\n], CommandCtrlLInSearchMode);\nlet CommandAdvanceCurrentMatch = class CommandAdvanceCurrentMatch extends CommandLineAction {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.SearchInProgressMode];\n        this.keys = [['<C-g>'], ['<C-t>']];\n    }\n    async run(vimState, commandLine) {\n        const key = this.keysPressed[0];\n        const direction = key === '<C-g>'\n            ? pattern_1.SearchDirection.Forward\n            : key === '<C-t>'\n                ? pattern_1.SearchDirection.Backward\n                : undefined;\n        if (commandLine instanceof commandLine_1.SearchCommandLine && direction !== undefined) {\n            void commandLine.advanceCurrentMatch(vimState, direction);\n        }\n    }\n};\nCommandAdvanceCurrentMatch = __decorate([\n    base_1.RegisterAction\n], CommandAdvanceCurrentMatch);\nlet CommandLineType = class CommandLineType extends CommandLineAction {\n    constructor() {\n        super(...arguments);\n        this.keys = [['<character>']];\n    }\n    async run(vimState, commandLine) {\n        void commandLine.typeCharacter(this.keysPressed[0]);\n    }\n};\nCommandLineType = __decorate([\n    base_1.RegisterAction\n], CommandLineType);\n\n\n//# sourceURL=webpack://vim/./src/actions/commands/commandLine.ts?")},"./src/actions/commands/digraphs.ts":(__unused_webpack_module,exports)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.DefaultDigraphs = void 0;\n// prettier-ignore\nexports.DefaultDigraphs = new Map([\n    ["SH", ["^A", 1]],\n    ["SX", ["^B", 2]],\n    ["EX", ["^C", 3]],\n    ["ET", ["^D", 4]],\n    ["EQ", ["^E", 5]],\n    ["AK", ["^F", 6]],\n    ["BL", ["^G", 7]],\n    ["BS", ["^H", 8]],\n    ["HT", ["^I", 9]],\n    ["LF", ["^@", 10]],\n    ["NU", ["^@", 10]],\n    ["VT", ["^K", 11]],\n    ["FF", ["^L", 12]],\n    ["CR", ["^M", 13]],\n    ["SO", ["^N", 14]],\n    ["SI", ["^O", 15]],\n    ["DL", ["^P", 16]],\n    ["D1", ["^Q", 17]],\n    ["D2", ["^R", 18]],\n    ["D3", ["^S", 19]],\n    ["D4", ["^T", 20]],\n    ["NK", ["^U", 21]],\n    ["SY", ["^V", 22]],\n    ["EB", ["^W", 23]],\n    ["CN", ["^X", 24]],\n    ["EM", ["^Y", 25]],\n    ["SB", ["^Z", 26]],\n    ["EC", ["^[", 27]],\n    ["FS", ["^\\\\", 28]],\n    ["GS", ["^]", 29]],\n    ["RS", ["^^", 30]],\n    ["US", ["^_", 31]],\n    ["SP", [" ", 32]],\n    ["Nb", ["#", 35]],\n    ["DO", ["$", 36]],\n    ["At", ["@", 64]],\n    ["<(", ["[", 91]],\n    ["//", ["\\\\", 92]],\n    [")>", ["]", 93]],\n    ["\'>", ["^", 94]],\n    ["\'!", ["`", 96]],\n    ["(!", ["{", 123]],\n    ["!!", ["|", 124]],\n    ["!)", ["}", 125]],\n    ["\'?", ["~", 126]],\n    ["DT", ["^?", 127]],\n    ["PA", ["<80>", 128]],\n    ["HO", ["<81>", 129]],\n    ["BH", ["<82>", 130]],\n    ["NH", ["<83>", 131]],\n    ["IN", ["<84>", 132]],\n    ["NL", ["<85>", 133]],\n    ["SA", ["<86>", 134]],\n    ["ES", ["<87>", 135]],\n    ["HS", ["<88>", 136]],\n    ["HJ", ["<89>", 137]],\n    ["VS", ["<8a>", 138]],\n    ["PD", ["<8b>", 139]],\n    ["PU", ["<8c>", 140]],\n    ["RI", ["<8d>", 141]],\n    ["S2", ["<8e>", 142]],\n    ["S3", ["<8f>", 143]],\n    ["DC", ["<90>", 144]],\n    ["P1", ["<91>", 145]],\n    ["P2", ["<92>", 146]],\n    ["TS", ["<93>", 147]],\n    ["CC", ["<94>", 148]],\n    ["MW", ["<95>", 149]],\n    ["SG", ["<96>", 150]],\n    ["EG", ["<97>", 151]],\n    ["SS", ["<98>", 152]],\n    ["GC", ["<99>", 153]],\n    ["SC", ["<9a>", 154]],\n    ["CI", ["<9b>", 155]],\n    ["ST", ["<9c>", 156]],\n    ["OC", ["<9d>", 157]],\n    ["PM", ["<9e>", 158]],\n    ["AC", ["<9f>", 159]],\n    ["NS", ["", 160]],\n    ["~!", ["", 161]],\n    ["!I", ["", 161]],\n    ["Ct", ["", 162]],\n    ["c|", ["", 162]],\n    ["Pd", ["", 163]],\n    ["$$", ["", 163]],\n    ["Cu", ["", 164]],\n    ["ox", ["", 164]],\n    ["Ye", ["", 165]],\n    ["Y-", ["", 165]],\n    ["BB", ["", 166]],\n    ["||", ["", 166]],\n    ["SE", ["", 167]],\n    ["\',", ["", 168]],\n    ["Co", ["", 169]],\n    ["cO", ["", 169]],\n    ["-a", ["", 170]],\n    ["<<", ["", 171]],\n    ["NO", ["", 172]],\n    ["-,", ["", 172]],\n    ["--", ["", 173]],\n    ["Rg", ["", 174]],\n    ["\'m", ["", 175]],\n    ["-=", ["", 175]],\n    ["DG", ["", 176]],\n    ["~o", ["", 176]],\n    ["+-", ["", 177]],\n    ["2S", ["", 178]],\n    ["22", ["", 178]],\n    ["3S", ["", 179]],\n    ["33", ["", 179]],\n    ["\'\'", ["", 180]],\n    ["My", ["", 181]],\n    ["PI", ["", 182]],\n    ["pp", ["", 182]],\n    [".M", ["", 183]],\n    ["~.", ["", 183]],\n    ["\',", ["", 184]],\n    ["1S", ["", 185]],\n    ["11", ["", 185]],\n    ["-o", ["", 186]],\n    [">>", ["", 187]],\n    ["14", ["", 188]],\n    ["12", ["", 189]],\n    ["34", ["", 190]],\n    ["?I", ["", 191]],\n    ["~?", ["", 191]],\n    ["A!", ["", 192]],\n    ["A`", ["", 192]],\n    ["A\'", ["", 193]],\n    ["A>", ["", 194]],\n    ["A^", ["", 194]],\n    ["A?", ["", 195]],\n    ["A~", ["", 195]],\n    ["A,", ["", 196]],\n    ["A\\"", ["", 196]],\n    ["AA", ["", 197]],\n    ["A@", ["", 197]],\n    ["AE", ["", 198]],\n    ["C,", ["", 199]],\n    ["E!", ["", 200]],\n    ["E`", ["", 200]],\n    ["E\'", ["", 201]],\n    ["E>", ["", 202]],\n    ["E^", ["", 202]],\n    ["E,", ["", 203]],\n    ["E\\"", ["", 203]],\n    ["I!", ["", 204]],\n    ["I`", ["", 204]],\n    ["I\'", ["", 205]],\n    ["I>", ["", 206]],\n    ["I^", ["", 206]],\n    ["I,", ["", 207]],\n    ["I\\"", ["", 207]],\n    ["D-", ["", 208]],\n    ["N?", ["", 209]],\n    ["N~", ["", 209]],\n    ["O!", ["", 210]],\n    ["O`", ["", 210]],\n    ["O\'", ["", 211]],\n    ["O>", ["", 212]],\n    ["O^", ["", 212]],\n    ["O?", ["", 213]],\n    ["O~", ["", 213]],\n    ["O,", ["", 214]],\n    ["*X", ["", 215]],\n    ["/\\\\", ["", 215]],\n    ["O/", ["", 216]],\n    ["U!", ["", 217]],\n    ["U`", ["", 217]],\n    ["U\'", ["", 218]],\n    ["U>", ["", 219]],\n    ["U^", ["", 219]],\n    ["U,", ["", 220]],\n    ["Y\'", ["", 221]],\n    ["TH", ["", 222]],\n    ["Ip", ["", 222]],\n    ["ss", ["", 223]],\n    ["a!", ["", 224]],\n    ["a`", ["", 224]],\n    ["a\'", ["", 225]],\n    ["a>", ["", 226]],\n    ["a^", ["", 226]],\n    ["a?", ["", 227]],\n    ["a~", ["", 227]],\n    ["a,", ["", 228]],\n    ["a\\"", ["", 228]],\n    ["aa", ["", 229]],\n    ["a@", ["", 229]],\n    ["ae", ["", 230]],\n    ["c,", ["", 231]],\n    ["e!", ["", 232]],\n    ["e`", ["", 232]],\n    ["e\'", ["", 233]],\n    ["e>", ["", 234]],\n    ["e^", ["", 234]],\n    ["e,", ["", 235]],\n    ["e\\"", ["", 235]],\n    ["i!", ["", 236]],\n    ["i`", ["", 236]],\n    ["i\'", ["", 237]],\n    ["i>", ["", 238]],\n    ["i^", ["", 238]],\n    ["i,", ["", 239]],\n    ["d-", ["", 240]],\n    ["n?", ["", 241]],\n    ["n~", ["", 241]],\n    ["o!", ["", 242]],\n    ["o`", ["", 242]],\n    ["o\'", ["", 243]],\n    ["o>", ["", 244]],\n    ["o^", ["", 244]],\n    ["o?", ["", 245]],\n    ["o~", ["", 245]],\n    ["o,", ["", 246]],\n    ["-,", ["", 247]],\n    ["o/", ["", 248]],\n    ["u!", ["", 249]],\n    ["u`", ["", 249]],\n    ["u\'", ["", 250]],\n    ["u>", ["", 251]],\n    ["u^", ["", 251]],\n    ["u,", ["", 252]],\n    ["y\'", ["", 253]],\n    ["th", ["", 254]],\n    ["y,", ["", 255]],\n    ["y\\"", ["", 255]],\n    ["A-", ["", 256]],\n    ["a-", ["", 257]],\n    ["A(", ["", 258]],\n    ["a(", ["", 259]],\n    ["A;", ["", 260]],\n    ["a;", ["", 261]],\n    ["C\'", ["", 262]],\n    ["c\'", ["", 263]],\n    ["C>", ["", 264]],\n    ["c>", ["", 265]],\n    ["C.", ["", 266]],\n    ["c.", ["", 267]],\n    ["C<", ["", 268]],\n    ["c<", ["", 269]],\n    ["D<", ["", 270]],\n    ["d<", ["", 271]],\n    ["D/", ["", 272]],\n    ["d/", ["", 273]],\n    ["E-", ["", 274]],\n    ["e-", ["", 275]],\n    ["E(", ["", 276]],\n    ["e(", ["", 277]],\n    ["E.", ["", 278]],\n    ["e.", ["", 279]],\n    ["E;", ["", 280]],\n    ["e;", ["", 281]],\n    ["E<", ["", 282]],\n    ["e<", ["", 283]],\n    ["G>", ["", 284]],\n    ["g>", ["", 285]],\n    ["G(", ["", 286]],\n    ["g(", ["", 287]],\n    ["G.", ["", 288]],\n    ["g.", ["", 289]],\n    ["G,", ["", 290]],\n    ["g,", ["", 291]],\n    ["H>", ["", 292]],\n    ["h>", ["", 293]],\n    ["H/", ["", 294]],\n    ["h/", ["", 295]],\n    ["I?", ["", 296]],\n    ["i?", ["", 297]],\n    ["I-", ["", 298]],\n    ["i-", ["", 299]],\n    ["I(", ["", 300]],\n    ["i(", ["", 301]],\n    ["I;", ["", 302]],\n    ["i;", ["", 303]],\n    ["I.", ["", 304]],\n    ["i.", ["", 305]],\n    ["IJ", ["", 306]],\n    ["ij", ["", 307]],\n    ["J>", ["", 308]],\n    ["j>", ["", 309]],\n    ["K,", ["", 310]],\n    ["k,", ["", 311]],\n    ["kk", ["", 312]],\n    ["L\'", ["", 313]],\n    ["l\'", ["", 314]],\n    ["L,", ["", 315]],\n    ["l,", ["", 316]],\n    ["L<", ["", 317]],\n    ["l<", ["", 318]],\n    ["L.", ["", 319]],\n    ["l.", ["", 320]],\n    ["L/", ["", 321]],\n    ["l/", ["", 322]],\n    ["N\'", ["", 323]],\n    ["n\'", ["", 324]],\n    ["N,", ["", 325]],\n    ["n,", ["", 326]],\n    ["N<", ["", 327]],\n    ["n<", ["", 328]],\n    ["\'n", ["", 329]],\n    ["NG", ["", 330]],\n    ["ng", ["", 331]],\n    ["O-", ["", 332]],\n    ["o-", ["", 333]],\n    ["O(", ["", 334]],\n    ["o(", ["", 335]],\n    ["O\\"", ["", 336]],\n    ["o\\"", ["", 337]],\n    ["OE", ["", 338]],\n    ["oe", ["", 339]],\n    ["R\'", ["", 340]],\n    ["r\'", ["", 341]],\n    ["R,", ["", 342]],\n    ["r,", ["", 343]],\n    ["R<", ["", 344]],\n    ["r<", ["", 345]],\n    ["S\'", ["", 346]],\n    ["s\'", ["", 347]],\n    ["S>", ["", 348]],\n    ["s>", ["", 349]],\n    ["S,", ["", 350]],\n    ["s,", ["", 351]],\n    ["S<", ["", 352]],\n    ["s<", ["", 353]],\n    ["T,", ["", 354]],\n    ["t,", ["", 355]],\n    ["T<", ["", 356]],\n    ["t<", ["", 357]],\n    ["T/", ["", 358]],\n    ["t/", ["", 359]],\n    ["U?", ["", 360]],\n    ["u?", ["", 361]],\n    ["U-", ["", 362]],\n    ["u-", ["", 363]],\n    ["U(", ["", 364]],\n    ["u(", ["", 365]],\n    ["U0", ["", 366]],\n    ["u0", ["", 367]],\n    ["U\\"", ["", 368]],\n    ["u\\"", ["", 369]],\n    ["U;", ["", 370]],\n    ["u;", ["", 371]],\n    ["W>", ["", 372]],\n    ["w>", ["", 373]],\n    ["Y>", ["", 374]],\n    ["y>", ["", 375]],\n    ["Y,", ["", 376]],\n    ["Z\'", ["", 377]],\n    ["z\'", ["", 378]],\n    ["Z.", ["", 379]],\n    ["z.", ["", 380]],\n    ["Z<", ["", 381]],\n    ["z<", ["", 382]],\n    ["fs", ["", 383]],\n    ["O9", ["", 416]],\n    ["o9", ["", 417]],\n    ["OI", ["", 418]],\n    ["oi", ["", 419]],\n    ["yr", ["", 422]],\n    ["U9", ["", 431]],\n    ["u9", ["", 432]],\n    ["Z/", ["", 437]],\n    ["z/", ["", 438]],\n    ["ED", ["", 439]],\n    ["A<", ["", 461]],\n    ["a<", ["", 462]],\n    ["I<", ["", 463]],\n    ["i<", ["", 464]],\n    ["O<", ["", 465]],\n    ["o<", ["", 466]],\n    ["U<", ["", 467]],\n    ["u<", ["", 468]],\n    ["A1", ["", 478]],\n    ["a1", ["", 479]],\n    ["A7", ["", 480]],\n    ["a7", ["", 481]],\n    ["A3", ["", 482]],\n    ["a3", ["", 483]],\n    ["G/", ["", 484]],\n    ["g/", ["", 485]],\n    ["G<", ["", 486]],\n    ["g<", ["", 487]],\n    ["K<", ["", 488]],\n    ["k<", ["", 489]],\n    ["O;", ["", 490]],\n    ["o;", ["", 491]],\n    ["O1", ["", 492]],\n    ["o1", ["", 493]],\n    ["EZ", ["", 494]],\n    ["ez", ["", 495]],\n    ["j<", ["", 496]],\n    ["G\'", ["", 500]],\n    ["g\'", ["", 501]],\n    [";S", ["", 703]],\n    ["\'<", ["", 711]],\n    ["\'(", ["", 728]],\n    ["\'.", ["", 729]],\n    ["\'0", ["", 730]],\n    ["\';", ["", 731]],\n    ["\'\\"", ["", 733]],\n    ["A%", ["", 902]],\n    ["E%", ["", 904]],\n    ["Y%", ["", 905]],\n    ["I%", ["", 906]],\n    ["O%", ["", 908]],\n    ["U%", ["", 910]],\n    ["W%", ["", 911]],\n    ["i3", ["", 912]],\n    ["A*", ["", 913]],\n    ["B*", ["", 914]],\n    ["G*", ["", 915]],\n    ["D*", ["", 916]],\n    ["E*", ["", 917]],\n    ["Z*", ["", 918]],\n    ["Y*", ["", 919]],\n    ["H*", ["", 920]],\n    ["I*", ["", 921]],\n    ["K*", ["", 922]],\n    ["L*", ["", 923]],\n    ["M*", ["", 924]],\n    ["N*", ["", 925]],\n    ["C*", ["", 926]],\n    ["O*", ["", 927]],\n    ["P*", ["", 928]],\n    ["R*", ["", 929]],\n    ["S*", ["", 931]],\n    ["T*", ["", 932]],\n    ["U*", ["", 933]],\n    ["F*", ["", 934]],\n    ["X*", ["", 935]],\n    ["Q*", ["", 936]],\n    ["W*", ["", 937]],\n    ["J*", ["", 938]],\n    ["V*", ["", 939]],\n    ["a%", ["", 940]],\n    ["e%", ["", 941]],\n    ["y%", ["", 942]],\n    ["i%", ["", 943]],\n    ["u3", ["", 944]],\n    ["a*", ["", 945]],\n    ["b*", ["", 946]],\n    ["g*", ["", 947]],\n    ["d*", ["", 948]],\n    ["e*", ["", 949]],\n    ["z*", ["", 950]],\n    ["y*", ["", 951]],\n    ["h*", ["", 952]],\n    ["i*", ["", 953]],\n    ["k*", ["", 954]],\n    ["l*", ["", 955]],\n    ["m*", ["", 956]],\n    ["n*", ["", 957]],\n    ["c*", ["", 958]],\n    ["o*", ["", 959]],\n    ["p*", ["", 960]],\n    ["r*", ["", 961]],\n    ["*s", ["", 962]],\n    ["s*", ["", 963]],\n    ["t*", ["", 964]],\n    ["u*", ["", 965]],\n    ["f*", ["", 966]],\n    ["x*", ["", 967]],\n    ["q*", ["", 968]],\n    ["w*", ["", 969]],\n    ["j*", ["", 970]],\n    ["v*", ["", 971]],\n    ["o%", ["", 972]],\n    ["u%", ["", 973]],\n    ["w%", ["", 974]],\n    ["\'G", ["", 984]],\n    [",G", ["", 985]],\n    ["T3", ["", 986]],\n    ["t3", ["", 987]],\n    ["M3", ["", 988]],\n    ["m3", ["", 989]],\n    ["K3", ["", 990]],\n    ["k3", ["", 991]],\n    ["P3", ["", 992]],\n    ["p3", ["", 993]],\n    ["\'%", ["", 1012]],\n    ["j3", ["", 1013]],\n    ["IO", ["", 1025]],\n    ["D%", ["", 1026]],\n    ["G%", ["", 1027]],\n    ["IE", ["", 1028]],\n    ["DS", ["", 1029]],\n    ["II", ["", 1030]],\n    ["YI", ["", 1031]],\n    ["J%", ["", 1032]],\n    ["LJ", ["", 1033]],\n    ["NJ", ["", 1034]],\n    ["Ts", ["", 1035]],\n    ["KJ", ["", 1036]],\n    ["V%", ["", 1038]],\n    ["DZ", ["", 1039]],\n    ["A=", ["", 1040]],\n    ["B=", ["", 1041]],\n    ["V=", ["", 1042]],\n    ["G=", ["", 1043]],\n    ["D=", ["", 1044]],\n    ["E=", ["", 1045]],\n    ["Z%", ["", 1046]],\n    ["Z=", ["", 1047]],\n    ["I=", ["", 1048]],\n    ["J=", ["", 1049]],\n    ["K=", ["", 1050]],\n    ["L=", ["", 1051]],\n    ["M=", ["", 1052]],\n    ["N=", ["", 1053]],\n    ["O=", ["", 1054]],\n    ["P=", ["", 1055]],\n    ["R=", ["", 1056]],\n    ["S=", ["", 1057]],\n    ["T=", ["", 1058]],\n    ["U=", ["", 1059]],\n    ["F=", ["", 1060]],\n    ["H=", ["", 1061]],\n    ["C=", ["", 1062]],\n    ["C%", ["", 1063]],\n    ["S%", ["", 1064]],\n    ["Sc", ["", 1065]],\n    ["=\\"", ["", 1066]],\n    ["Y=", ["", 1067]],\n    ["%\\"", ["", 1068]],\n    ["JE", ["", 1069]],\n    ["JU", ["", 1070]],\n    ["JA", ["", 1071]],\n    ["a=", ["", 1072]],\n    ["b=", ["", 1073]],\n    ["v=", ["", 1074]],\n    ["g=", ["", 1075]],\n    ["d=", ["", 1076]],\n    ["e=", ["", 1077]],\n    ["z%", ["", 1078]],\n    ["z=", ["", 1079]],\n    ["i=", ["", 1080]],\n    ["j=", ["", 1081]],\n    ["k=", ["", 1082]],\n    ["l=", ["", 1083]],\n    ["m=", ["", 1084]],\n    ["n=", ["", 1085]],\n    ["o=", ["", 1086]],\n    ["p=", ["", 1087]],\n    ["r=", ["", 1088]],\n    ["s=", ["", 1089]],\n    ["t=", ["", 1090]],\n    ["u=", ["", 1091]],\n    ["f=", ["", 1092]],\n    ["h=", ["", 1093]],\n    ["c=", ["", 1094]],\n    ["c%", ["", 1095]],\n    ["s%", ["", 1096]],\n    ["sc", ["", 1097]],\n    ["=\'", ["", 1098]],\n    ["y=", ["", 1099]],\n    ["%\'", ["", 1100]],\n    ["je", ["", 1101]],\n    ["ju", ["", 1102]],\n    ["ja", ["", 1103]],\n    ["io", ["", 1105]],\n    ["d%", ["", 1106]],\n    ["g%", ["", 1107]],\n    ["ie", ["", 1108]],\n    ["ds", ["", 1109]],\n    ["ii", ["", 1110]],\n    ["yi", ["", 1111]],\n    ["j%", ["", 1112]],\n    ["lj", ["", 1113]],\n    ["nj", ["", 1114]],\n    ["ts", ["", 1115]],\n    ["kj", ["", 1116]],\n    ["v%", ["", 1118]],\n    ["dz", ["", 1119]],\n    ["Y3", ["", 1122]],\n    ["y3", ["", 1123]],\n    ["O3", ["", 1130]],\n    ["o3", ["", 1131]],\n    ["F3", ["", 1138]],\n    ["f3", ["", 1139]],\n    ["V3", ["", 1140]],\n    ["v3", ["", 1141]],\n    ["C3", ["", 1152]],\n    ["c3", ["", 1153]],\n    ["G3", ["", 1168]],\n    ["g3", ["", 1169]],\n    ["A+", ["", 1488]],\n    ["B+", ["", 1489]],\n    ["G+", ["", 1490]],\n    ["D+", ["", 1491]],\n    ["H+", ["", 1492]],\n    ["W+", ["", 1493]],\n    ["Z+", ["", 1494]],\n    ["X+", ["", 1495]],\n    ["Tj", ["", 1496]],\n    ["J+", ["", 1497]],\n    ["K%", ["", 1498]],\n    ["K+", ["", 1499]],\n    ["L+", ["", 1500]],\n    ["M%", ["", 1501]],\n    ["M+", ["", 1502]],\n    ["N%", ["", 1503]],\n    ["N+", ["", 1504]],\n    ["S+", ["", 1505]],\n    ["E+", ["", 1506]],\n    ["P%", ["", 1507]],\n    ["P+", ["", 1508]],\n    ["Zj", ["", 1509]],\n    ["ZJ", ["", 1510]],\n    ["Q+", ["", 1511]],\n    ["R+", ["", 1512]],\n    ["Sh", ["", 1513]],\n    ["T+", ["", 1514]],\n    [",+", ["", 1548]],\n    [";+", ["", 1563]],\n    ["?+", ["", 1567]],\n    ["H\'", ["", 1569]],\n    ["aM", ["", 1570]],\n    ["aH", ["", 1571]],\n    ["wH", ["", 1572]],\n    ["ah", ["", 1573]],\n    ["yH", ["", 1574]],\n    ["a+", ["", 1575]],\n    ["b+", ["", 1576]],\n    ["tm", ["", 1577]],\n    ["t+", ["", 1578]],\n    ["tk", ["", 1579]],\n    ["g+", ["", 1580]],\n    ["hk", ["", 1581]],\n    ["x+", ["", 1582]],\n    ["d+", ["", 1583]],\n    ["dk", ["", 1584]],\n    ["r+", ["", 1585]],\n    ["z+", ["", 1586]],\n    ["s+", ["", 1587]],\n    ["sn", ["", 1588]],\n    ["c+", ["", 1589]],\n    ["dd", ["", 1590]],\n    ["tj", ["", 1591]],\n    ["zH", ["", 1592]],\n    ["e+", ["", 1593]],\n    ["i+", ["", 1594]],\n    ["++", ["", 1600]],\n    ["f+", ["", 1601]],\n    ["q+", ["", 1602]],\n    ["k+", ["", 1603]],\n    ["l+", ["", 1604]],\n    ["m+", ["", 1605]],\n    ["n+", ["", 1606]],\n    ["h+", ["", 1607]],\n    ["w+", ["", 1608]],\n    ["j+", ["", 1609]],\n    ["y+", ["", 1610]],\n    [",+", ["", 1611]],\n    ["\\"+", ["", 1612]],\n    ["=+", ["", 1613]],\n    ["/+", ["", 1614]],\n    ["\'+", ["", 1615]],\n    ["1+", ["", 1616]],\n    ["3+", ["", 1617]],\n    ["0+", ["", 1618]],\n    ["aS", ["", 1648]],\n    ["p+", ["", 1662]],\n    ["v+", ["", 1700]],\n    ["gf", ["", 1711]],\n    ["0a", ["", 1776]],\n    ["1a", ["", 1777]],\n    ["2a", ["", 1778]],\n    ["3a", ["", 1779]],\n    ["4a", ["", 1780]],\n    ["5a", ["", 1781]],\n    ["6a", ["", 1782]],\n    ["7a", ["", 1783]],\n    ["8a", ["", 1784]],\n    ["9a", ["", 1785]],\n    ["B.", ["", 7682]],\n    ["b.", ["", 7683]],\n    ["B_", ["", 7686]],\n    ["b_", ["", 7687]],\n    ["D.", ["", 7690]],\n    ["d.", ["", 7691]],\n    ["D_", ["", 7694]],\n    ["d_", ["", 7695]],\n    ["D,", ["", 7696]],\n    ["d,", ["", 7697]],\n    ["F.", ["", 7710]],\n    ["f.", ["", 7711]],\n    ["G-", ["", 7712]],\n    ["g-", ["", 7713]],\n    ["H.", ["", 7714]],\n    ["h.", ["", 7715]],\n    ["H,", ["", 7718]],\n    ["h,", ["", 7719]],\n    ["H,", ["", 7720]],\n    ["h,", ["", 7721]],\n    ["K\'", ["", 7728]],\n    ["k\'", ["", 7729]],\n    ["K_", ["", 7732]],\n    ["k_", ["", 7733]],\n    ["L_", ["", 7738]],\n    ["l_", ["", 7739]],\n    ["M\'", ["", 7742]],\n    ["m\'", ["", 7743]],\n    ["M.", ["", 7744]],\n    ["m.", ["", 7745]],\n    ["N.", ["", 7748]],\n    ["n.", ["", 7749]],\n    ["N_", ["", 7752]],\n    ["n_", ["", 7753]],\n    ["P\'", ["", 7764]],\n    ["p\'", ["", 7765]],\n    ["P.", ["", 7766]],\n    ["p.", ["", 7767]],\n    ["R.", ["", 7768]],\n    ["r.", ["", 7769]],\n    ["R_", ["", 7774]],\n    ["r_", ["", 7775]],\n    ["S.", ["", 7776]],\n    ["s.", ["", 7777]],\n    ["T.", ["", 7786]],\n    ["t.", ["", 7787]],\n    ["T_", ["", 7790]],\n    ["t_", ["", 7791]],\n    ["V?", ["", 7804]],\n    ["v?", ["", 7805]],\n    ["W!", ["", 7808]],\n    ["w!", ["", 7809]],\n    ["W\'", ["", 7810]],\n    ["w\'", ["", 7811]],\n    ["W,", ["", 7812]],\n    ["w,", ["", 7813]],\n    ["W.", ["", 7814]],\n    ["w.", ["", 7815]],\n    ["X.", ["", 7818]],\n    ["x.", ["", 7819]],\n    ["X,", ["", 7820]],\n    ["x,", ["", 7821]],\n    ["Y.", ["", 7822]],\n    ["y.", ["", 7823]],\n    ["Z>", ["", 7824]],\n    ["z>", ["", 7825]],\n    ["Z_", ["", 7828]],\n    ["z_", ["", 7829]],\n    ["h_", ["", 7830]],\n    ["t,", ["", 7831]],\n    ["w0", ["", 7832]],\n    ["y0", ["", 7833]],\n    ["A2", ["", 7842]],\n    ["a2", ["", 7843]],\n    ["E2", ["", 7866]],\n    ["e2", ["", 7867]],\n    ["E?", ["", 7868]],\n    ["e?", ["", 7869]],\n    ["I2", ["", 7880]],\n    ["i2", ["", 7881]],\n    ["O2", ["", 7886]],\n    ["o2", ["", 7887]],\n    ["U2", ["", 7910]],\n    ["u2", ["", 7911]],\n    ["Y!", ["", 7922]],\n    ["y!", ["", 7923]],\n    ["Y2", ["", 7926]],\n    ["y2", ["", 7927]],\n    ["Y?", ["", 7928]],\n    ["y?", ["", 7929]],\n    [";\'", ["", 7936]],\n    [",\'", ["", 7937]],\n    [";!", ["", 7938]],\n    [",!", ["", 7939]],\n    ["?;", ["", 7940]],\n    ["?,", ["", 7941]],\n    ["!,", ["", 7942]],\n    ["?,", ["", 7943]],\n    ["1N", ["", 8194]],\n    ["1M", ["", 8195]],\n    ["3M", ["", 8196]],\n    ["4M", ["", 8197]],\n    ["6M", ["", 8198]],\n    ["1T", ["", 8201]],\n    ["1H", ["", 8202]],\n    ["-1", ["", 8208]],\n    ["-N", ["", 8211]],\n    ["-M", ["", 8212]],\n    ["-3", ["", 8213]],\n    ["!2", ["", 8214]],\n    ["=2", ["", 8215]],\n    ["\'6", ["", 8216]],\n    ["\'9", ["", 8217]],\n    [".9", ["", 8218]],\n    ["9\'", ["", 8219]],\n    ["\\"6", ["", 8220]],\n    ["\\"9", ["", 8221]],\n    [",9", ["", 8222]],\n    ["9\\"", ["", 8223]],\n    ["/-", ["", 8224]],\n    ["/=", ["", 8225]],\n    ["..", ["", 8229]],\n    [",.", ["", 8230]],\n    ["%0", ["", 8240]],\n    ["1\'", ["", 8242]],\n    ["2\'", ["", 8243]],\n    ["3\'", ["", 8244]],\n    ["1\\"", ["", 8245]],\n    ["2\\"", ["", 8246]],\n    ["3\\"", ["", 8247]],\n    ["Ca", ["", 8248]],\n    ["<1", ["", 8249]],\n    [">1", ["", 8250]],\n    [",X", ["", 8251]],\n    ["\'-", ["", 8254]],\n    ["/f", ["", 8260]],\n    ["0S", ["", 8304]],\n    ["4S", ["", 8308]],\n    ["5S", ["", 8309]],\n    ["6S", ["", 8310]],\n    ["7S", ["", 8311]],\n    ["8S", ["", 8312]],\n    ["9S", ["", 8313]],\n    ["+S", ["", 8314]],\n    ["-S", ["", 8315]],\n    ["=S", ["", 8316]],\n    ["(S", ["", 8317]],\n    [")S", ["", 8318]],\n    ["nS", ["", 8319]],\n    ["0s", ["", 8320]],\n    ["1s", ["", 8321]],\n    ["2s", ["", 8322]],\n    ["3s", ["", 8323]],\n    ["4s", ["", 8324]],\n    ["5s", ["", 8325]],\n    ["6s", ["", 8326]],\n    ["7s", ["", 8327]],\n    ["8s", ["", 8328]],\n    ["9s", ["", 8329]],\n    ["+s", ["", 8330]],\n    ["-s", ["", 8331]],\n    ["=s", ["", 8332]],\n    ["(s", ["", 8333]],\n    [")s", ["", 8334]],\n    ["Li", ["", 8356]],\n    ["Pt", ["", 8359]],\n    ["W=", ["", 8361]],\n    ["=e", ["", 8364]],\n    ["Eu", ["", 8364]],\n    ["=R", ["", 8381]],\n    ["=P", ["", 8381]],\n    ["oC", ["", 8451]],\n    ["co", ["", 8453]],\n    ["oF", ["", 8457]],\n    ["N0", ["", 8470]],\n    ["PO", ["", 8471]],\n    ["Rx", ["", 8478]],\n    ["SM", ["", 8480]],\n    ["TM", ["", 8482]],\n    ["Om", ["", 8486]],\n    ["AO", ["", 8491]],\n    ["13", ["", 8531]],\n    ["23", ["", 8532]],\n    ["15", ["", 8533]],\n    ["25", ["", 8534]],\n    ["35", ["", 8535]],\n    ["45", ["", 8536]],\n    ["16", ["", 8537]],\n    ["56", ["", 8538]],\n    ["18", ["", 8539]],\n    ["38", ["", 8540]],\n    ["58", ["", 8541]],\n    ["78", ["", 8542]],\n    ["1R", ["", 8544]],\n    ["2R", ["", 8545]],\n    ["3R", ["", 8546]],\n    ["4R", ["", 8547]],\n    ["5R", ["", 8548]],\n    ["6R", ["", 8549]],\n    ["7R", ["", 8550]],\n    ["8R", ["", 8551]],\n    ["9R", ["", 8552]],\n    ["aR", ["", 8553]],\n    ["bR", ["", 8554]],\n    ["cR", ["", 8555]],\n    ["1r", ["", 8560]],\n    ["2r", ["", 8561]],\n    ["3r", ["", 8562]],\n    ["4r", ["", 8563]],\n    ["5r", ["", 8564]],\n    ["6r", ["", 8565]],\n    ["7r", ["", 8566]],\n    ["8r", ["", 8567]],\n    ["9r", ["", 8568]],\n    ["ar", ["", 8569]],\n    ["br", ["", 8570]],\n    ["cr", ["", 8571]],\n    ["<-", ["", 8592]],\n    ["-!", ["", 8593]],\n    ["->", ["", 8594]],\n    ["-v", ["", 8595]],\n    ["<>", ["", 8596]],\n    ["UD", ["", 8597]],\n    ["<=", ["", 8656]],\n    ["=>", ["", 8658]],\n    ["==", ["", 8660]],\n    ["FA", ["", 8704]],\n    ["dP", ["", 8706]],\n    ["TE", ["", 8707]],\n    ["/0", ["", 8709]],\n    ["DE", ["", 8710]],\n    ["NB", ["", 8711]],\n    ["(-", ["", 8712]],\n    ["-)", ["", 8715]],\n    ["*P", ["", 8719]],\n    ["+Z", ["", 8721]],\n    ["-2", ["", 8722]],\n    ["-+", ["", 8723]],\n    ["*-", ["", 8727]],\n    ["Ob", ["", 8728]],\n    ["Sb", ["", 8729]],\n    ["RT", ["", 8730]],\n    ["0(", ["", 8733]],\n    ["00", ["", 8734]],\n    ["-L", ["", 8735]],\n    ["-V", ["", 8736]],\n    ["PP", ["", 8741]],\n    ["AN", ["", 8743]],\n    ["OR", ["", 8744]],\n    ["(U", ["", 8745]],\n    [")U", ["", 8746]],\n    ["In", ["", 8747]],\n    ["DI", ["", 8748]],\n    ["Io", ["", 8750]],\n    [".,", ["", 8756]],\n    [",.", ["", 8757]],\n    [",R", ["", 8758]],\n    [",,", ["", 8759]],\n    ["?1", ["", 8764]],\n    ["CG", ["", 8766]],\n    ["?-", ["", 8771]],\n    ["?=", ["", 8773]],\n    ["?2", ["", 8776]],\n    ["=?", ["", 8780]],\n    ["HI", ["", 8787]],\n    ["!=", ["", 8800]],\n    ["=3", ["", 8801]],\n    ["=<", ["", 8804]],\n    [">=", ["", 8805]],\n    ["<*", ["", 8810]],\n    ["*>", ["", 8811]],\n    ["!<", ["", 8814]],\n    ["!>", ["", 8815]],\n    ["(C", ["", 8834]],\n    [")C", ["", 8835]],\n    ["(_", ["", 8838]],\n    [")_", ["", 8839]],\n    ["0.", ["", 8857]],\n    ["02", ["", 8858]],\n    ["-T", ["", 8869]],\n    [".P", ["", 8901]],\n    [",3", ["", 8942]],\n    [".3", ["", 8943]],\n    ["Eh", ["", 8962]],\n    ["<7", ["", 8968]],\n    [">7", ["", 8969]],\n    ["7<", ["", 8970]],\n    ["7>", ["", 8971]],\n    ["NI", ["", 8976]],\n    ["(A", ["", 8978]],\n    ["TR", ["", 8981]],\n    ["Iu", ["", 8992]],\n    ["Il", ["", 8993]],\n    ["</", ["", 9001]],\n    ["/>", ["", 9002]],\n    ["Vs", ["", 9251]],\n    ["1h", ["", 9280]],\n    ["3h", ["", 9281]],\n    ["2h", ["", 9282]],\n    ["4h", ["", 9283]],\n    ["1j", ["", 9286]],\n    ["2j", ["", 9287]],\n    ["3j", ["", 9288]],\n    ["4j", ["", 9289]],\n    ["1.", ["", 9352]],\n    ["2.", ["", 9353]],\n    ["3.", ["", 9354]],\n    ["4.", ["", 9355]],\n    ["5.", ["", 9356]],\n    ["6.", ["", 9357]],\n    ["7.", ["", 9358]],\n    ["8.", ["", 9359]],\n    ["9.", ["", 9360]],\n    ["hh", ["", 9472]],\n    ["HH", ["", 9473]],\n    ["vv", ["", 9474]],\n    ["VV", ["", 9475]],\n    ["3-", ["", 9476]],\n    ["3_", ["", 9477]],\n    ["3!", ["", 9478]],\n    ["3/", ["", 9479]],\n    ["4-", ["", 9480]],\n    ["4_", ["", 9481]],\n    ["4!", ["", 9482]],\n    ["4/", ["", 9483]],\n    ["dr", ["", 9484]],\n    ["dR", ["", 9485]],\n    ["Dr", ["", 9486]],\n    ["DR", ["", 9487]],\n    ["dl", ["", 9488]],\n    ["dL", ["", 9489]],\n    ["Dl", ["", 9490]],\n    ["LD", ["", 9491]],\n    ["ur", ["", 9492]],\n    ["uR", ["", 9493]],\n    ["Ur", ["", 9494]],\n    ["UR", ["", 9495]],\n    ["ul", ["", 9496]],\n    ["uL", ["", 9497]],\n    ["Ul", ["", 9498]],\n    ["UL", ["", 9499]],\n    ["vr", ["", 9500]],\n    ["vR", ["", 9501]],\n    ["Vr", ["", 9504]],\n    ["VR", ["", 9507]],\n    ["vl", ["", 9508]],\n    ["vL", ["", 9509]],\n    ["Vl", ["", 9512]],\n    ["VL", ["", 9515]],\n    ["dh", ["", 9516]],\n    ["dH", ["", 9519]],\n    ["Dh", ["", 9520]],\n    ["DH", ["", 9523]],\n    ["uh", ["", 9524]],\n    ["uH", ["", 9527]],\n    ["Uh", ["", 9528]],\n    ["UH", ["", 9531]],\n    ["vh", ["", 9532]],\n    ["vH", ["", 9535]],\n    ["Vh", ["", 9538]],\n    ["VH", ["", 9547]],\n    ["FD", ["", 9585]],\n    ["BD", ["", 9586]],\n    ["TB", ["", 9600]],\n    ["LB", ["", 9604]],\n    ["FB", ["", 9608]],\n    ["lB", ["", 9612]],\n    ["RB", ["", 9616]],\n    [".S", ["", 9617]],\n    [",S", ["", 9618]],\n    ["?S", ["", 9619]],\n    ["fS", ["", 9632]],\n    ["OS", ["", 9633]],\n    ["RO", ["", 9634]],\n    ["Rr", ["", 9635]],\n    ["RF", ["", 9636]],\n    ["RY", ["", 9637]],\n    ["RH", ["", 9638]],\n    ["RZ", ["", 9639]],\n    ["RK", ["", 9640]],\n    ["RX", ["", 9641]],\n    ["sB", ["", 9642]],\n    ["SR", ["", 9644]],\n    ["Or", ["", 9645]],\n    ["UT", ["", 9650]],\n    ["uT", ["", 9651]],\n    ["PR", ["", 9654]],\n    ["Tr", ["", 9655]],\n    ["Dt", ["", 9660]],\n    ["dT", ["", 9661]],\n    ["PL", ["", 9664]],\n    ["Tl", ["", 9665]],\n    ["Db", ["", 9670]],\n    ["Dw", ["", 9671]],\n    ["LZ", ["", 9674]],\n    ["0m", ["", 9675]],\n    ["0o", ["", 9678]],\n    ["0M", ["", 9679]],\n    ["0L", ["", 9680]],\n    ["0R", ["", 9681]],\n    ["Sn", ["", 9688]],\n    ["Ic", ["", 9689]],\n    ["Fd", ["", 9698]],\n    ["Bd", ["", 9699]],\n    ["*2", ["", 9733]],\n    ["*1", ["", 9734]],\n    ["<H", ["", 9756]],\n    [">H", ["", 9758]],\n    ["0u", ["", 9786]],\n    ["0U", ["", 9787]],\n    ["SU", ["", 9788]],\n    ["Fm", ["", 9792]],\n    ["Ml", ["", 9794]],\n    ["cS", ["", 9824]],\n    ["cH", ["", 9825]],\n    ["cD", ["", 9826]],\n    ["cC", ["", 9827]],\n    ["Md", ["", 9833]],\n    ["M8", ["", 9834]],\n    ["M2", ["", 9835]],\n    ["Mb", ["", 9837]],\n    ["Mx", ["", 9838]],\n    ["MX", ["", 9839]],\n    ["OK", ["", 10003]],\n    ["XX", ["", 10007]],\n    ["-X", ["", 10016]],\n    ["IS", ["", 12288]],\n    [",_", ["", 12289]],\n    ["._", ["", 12290]],\n    ["+\\"", ["", 12291]],\n    ["+_", ["", 12292]],\n    ["*_", ["", 12293]],\n    [";_", ["", 12294]],\n    ["0_", ["", 12295]],\n    ["<+", ["", 12298]],\n    [">+", ["", 12299]],\n    ["<\'", ["", 12300]],\n    [">\'", ["", 12301]],\n    ["<\\"", ["", 12302]],\n    [">\\"", ["", 12303]],\n    ["(\\"", ["", 12304]],\n    [")\\"", ["", 12305]],\n    ["=T", ["", 12306]],\n    ["=_", ["", 12307]],\n    ["(\'", ["", 12308]],\n    [")\'", ["", 12309]],\n    ["(I", ["", 12310]],\n    [")I", ["", 12311]],\n    ["-?", ["", 12316]],\n    ["A5", ["", 12353]],\n    ["a5", ["", 12354]],\n    ["I5", ["", 12355]],\n    ["i5", ["", 12356]],\n    ["U5", ["", 12357]],\n    ["u5", ["", 12358]],\n    ["E5", ["", 12359]],\n    ["e5", ["", 12360]],\n    ["O5", ["", 12361]],\n    ["o5", ["", 12362]],\n    ["ka", ["", 12363]],\n    ["ga", ["", 12364]],\n    ["ki", ["", 12365]],\n    ["gi", ["", 12366]],\n    ["ku", ["", 12367]],\n    ["gu", ["", 12368]],\n    ["ke", ["", 12369]],\n    ["ge", ["", 12370]],\n    ["ko", ["", 12371]],\n    ["go", ["", 12372]],\n    ["sa", ["", 12373]],\n    ["za", ["", 12374]],\n    ["si", ["", 12375]],\n    ["zi", ["", 12376]],\n    ["su", ["", 12377]],\n    ["zu", ["", 12378]],\n    ["se", ["", 12379]],\n    ["ze", ["", 12380]],\n    ["so", ["", 12381]],\n    ["zo", ["", 12382]],\n    ["ta", ["", 12383]],\n    ["da", ["", 12384]],\n    ["ti", ["", 12385]],\n    ["di", ["", 12386]],\n    ["tU", ["", 12387]],\n    ["tu", ["", 12388]],\n    ["du", ["", 12389]],\n    ["te", ["", 12390]],\n    ["de", ["", 12391]],\n    ["to", ["", 12392]],\n    ["do", ["", 12393]],\n    ["na", ["", 12394]],\n    ["ni", ["", 12395]],\n    ["nu", ["", 12396]],\n    ["ne", ["", 12397]],\n    ["no", ["", 12398]],\n    ["ha", ["", 12399]],\n    ["ba", ["", 12400]],\n    ["pa", ["", 12401]],\n    ["hi", ["", 12402]],\n    ["bi", ["", 12403]],\n    ["pi", ["", 12404]],\n    ["hu", ["", 12405]],\n    ["bu", ["", 12406]],\n    ["pu", ["", 12407]],\n    ["he", ["", 12408]],\n    ["be", ["", 12409]],\n    ["pe", ["", 12410]],\n    ["ho", ["", 12411]],\n    ["bo", ["", 12412]],\n    ["po", ["", 12413]],\n    ["ma", ["", 12414]],\n    ["mi", ["", 12415]],\n    ["mu", ["", 12416]],\n    ["me", ["", 12417]],\n    ["mo", ["", 12418]],\n    ["yA", ["", 12419]],\n    ["ya", ["", 12420]],\n    ["yU", ["", 12421]],\n    ["yu", ["", 12422]],\n    ["yO", ["", 12423]],\n    ["yo", ["", 12424]],\n    ["ra", ["", 12425]],\n    ["ri", ["", 12426]],\n    ["ru", ["", 12427]],\n    ["re", ["", 12428]],\n    ["ro", ["", 12429]],\n    ["wA", ["", 12430]],\n    ["wa", ["", 12431]],\n    ["wi", ["", 12432]],\n    ["we", ["", 12433]],\n    ["wo", ["", 12434]],\n    ["n5", ["", 12435]],\n    ["vu", ["", 12436]],\n    ["\\"5", ["", 12443]],\n    ["05", ["", 12444]],\n    ["*5", ["", 12445]],\n    ["+5", ["", 12446]],\n    ["a6", ["", 12449]],\n    ["A6", ["", 12450]],\n    ["i6", ["", 12451]],\n    ["I6", ["", 12452]],\n    ["u6", ["", 12453]],\n    ["U6", ["", 12454]],\n    ["e6", ["", 12455]],\n    ["E6", ["", 12456]],\n    ["o6", ["", 12457]],\n    ["O6", ["", 12458]],\n    ["Ka", ["", 12459]],\n    ["Ga", ["", 12460]],\n    ["Ki", ["", 12461]],\n    ["Gi", ["", 12462]],\n    ["Ku", ["", 12463]],\n    ["Gu", ["", 12464]],\n    ["Ke", ["", 12465]],\n    ["Ge", ["", 12466]],\n    ["Ko", ["", 12467]],\n    ["Go", ["", 12468]],\n    ["Sa", ["", 12469]],\n    ["Za", ["", 12470]],\n    ["Si", ["", 12471]],\n    ["Zi", ["", 12472]],\n    ["Su", ["", 12473]],\n    ["Zu", ["", 12474]],\n    ["Se", ["", 12475]],\n    ["Ze", ["", 12476]],\n    ["So", ["", 12477]],\n    ["Zo", ["", 12478]],\n    ["Ta", ["", 12479]],\n    ["Da", ["", 12480]],\n    ["Ti", ["", 12481]],\n    ["Di", ["", 12482]],\n    ["TU", ["", 12483]],\n    ["Tu", ["", 12484]],\n    ["Du", ["", 12485]],\n    ["Te", ["", 12486]],\n    ["De", ["", 12487]],\n    ["To", ["", 12488]],\n    ["Do", ["", 12489]],\n    ["Na", ["", 12490]],\n    ["Ni", ["", 12491]],\n    ["Nu", ["", 12492]],\n    ["Ne", ["", 12493]],\n    ["No", ["", 12494]],\n    ["Ha", ["", 12495]],\n    ["Ba", ["", 12496]],\n    ["Pa", ["", 12497]],\n    ["Hi", ["", 12498]],\n    ["Bi", ["", 12499]],\n    ["Pi", ["", 12500]],\n    ["Hu", ["", 12501]],\n    ["Bu", ["", 12502]],\n    ["Pu", ["", 12503]],\n    ["He", ["", 12504]],\n    ["Be", ["", 12505]],\n    ["Pe", ["", 12506]],\n    ["Ho", ["", 12507]],\n    ["Bo", ["", 12508]],\n    ["Po", ["", 12509]],\n    ["Ma", ["", 12510]],\n    ["Mi", ["", 12511]],\n    ["Mu", ["", 12512]],\n    ["Me", ["", 12513]],\n    ["Mo", ["", 12514]],\n    ["YA", ["", 12515]],\n    ["Ya", ["", 12516]],\n    ["YU", ["", 12517]],\n    ["Yu", ["", 12518]],\n    ["YO", ["", 12519]],\n    ["Yo", ["", 12520]],\n    ["Ra", ["", 12521]],\n    ["Ri", ["", 12522]],\n    ["Ru", ["", 12523]],\n    ["Re", ["", 12524]],\n    ["Ro", ["", 12525]],\n    ["WA", ["", 12526]],\n    ["Wa", ["", 12527]],\n    ["Wi", ["", 12528]],\n    ["We", ["", 12529]],\n    ["Wo", ["", 12530]],\n    ["N6", ["", 12531]],\n    ["Vu", ["", 12532]],\n    ["KA", ["", 12533]],\n    ["KE", ["", 12534]],\n    ["Va", ["", 12535]],\n    ["Vi", ["", 12536]],\n    ["Ve", ["", 12537]],\n    ["Vo", ["", 12538]],\n    [".6", ["", 12539]],\n    ["-6", ["", 12540]],\n    ["*6", ["", 12541]],\n    ["+6", ["", 12542]],\n    ["b4", ["", 12549]],\n    ["p4", ["", 12550]],\n    ["m4", ["", 12551]],\n    ["f4", ["", 12552]],\n    ["d4", ["", 12553]],\n    ["t4", ["", 12554]],\n    ["n4", ["", 12555]],\n    ["l4", ["", 12556]],\n    ["g4", ["", 12557]],\n    ["k4", ["", 12558]],\n    ["h4", ["", 12559]],\n    ["j4", ["", 12560]],\n    ["q4", ["", 12561]],\n    ["x4", ["", 12562]],\n    ["zh", ["", 12563]],\n    ["ch", ["", 12564]],\n    ["sh", ["", 12565]],\n    ["r4", ["", 12566]],\n    ["z4", ["", 12567]],\n    ["c4", ["", 12568]],\n    ["s4", ["", 12569]],\n    ["a4", ["", 12570]],\n    ["o4", ["", 12571]],\n    ["e4", ["", 12572]],\n    ["ai", ["", 12574]],\n    ["ei", ["", 12575]],\n    ["au", ["", 12576]],\n    ["ou", ["", 12577]],\n    ["an", ["", 12578]],\n    ["en", ["", 12579]],\n    ["aN", ["", 12580]],\n    ["eN", ["", 12581]],\n    ["er", ["", 12582]],\n    ["i4", ["", 12583]],\n    ["u4", ["", 12584]],\n    ["iu", ["", 12585]],\n    ["v4", ["", 12586]],\n    ["nG", ["", 12587]],\n    ["gn", ["", 12588]],\n    ["1c", ["", 12832]],\n    ["2c", ["", 12833]],\n    ["3c", ["", 12834]],\n    ["4c", ["", 12835]],\n    ["5c", ["", 12836]],\n    ["6c", ["", 12837]],\n    ["7c", ["", 12838]],\n    ["8c", ["", 12839]],\n    ["9c", ["", 12840]],\n    ["ff", ["", 64256]],\n    ["fi", ["", 64257]],\n    ["fl", ["", 64258]],\n    ["ft", ["", 64261]],\n    ["st", ["", 64262]],\n    ["W`", ["", 7808]],\n    ["w`", ["", 7809]],\n    ["Y`", ["", 7922]],\n    ["y`", ["", 7923]],\n]);\n\n\n//# sourceURL=webpack://vim/./src/actions/commands/digraphs.ts?')},"./src/actions/commands/fold.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst vscode = __importStar(__webpack_require__(/*! vscode */ \"vscode\"));\nconst cursor_1 = __webpack_require__(/*! ../../common/motion/cursor */ \"./src/common/motion/cursor.ts\");\nconst mode_1 = __webpack_require__(/*! ../../mode/mode */ \"./src/mode/mode.ts\");\nconst base_1 = __webpack_require__(/*! ../base */ \"./src/actions/base.ts\");\nconst operator_1 = __webpack_require__(/*! ../operator */ \"./src/actions/operator.ts\");\nclass CommandFold extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n    }\n    doesActionApply(vimState, keysPressed) {\n        // Don't run if there's an operator because the Sneak plugin uses <operator>z\n        return (super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined);\n    }\n    async exec(position, vimState) {\n        const timesToRepeat = vimState.recordedState.count || 1;\n        const args = this.direction !== undefined\n            ? { levels: timesToRepeat, direction: this.direction }\n            : undefined;\n        vimState.recordedState.transformer.vscodeCommand(this.commandName, args);\n        await vimState.setCurrentMode(mode_1.Mode.Normal);\n    }\n}\nlet CommandToggleFold = class CommandToggleFold extends CommandFold {\n    constructor() {\n        super(...arguments);\n        this.keys = ['z', 'a'];\n        this.commandName = 'editor.toggleFold';\n    }\n};\nCommandToggleFold = __decorate([\n    base_1.RegisterAction\n], CommandToggleFold);\nlet CommandCloseFold = class CommandCloseFold extends CommandFold {\n    constructor() {\n        super(...arguments);\n        this.keys = ['z', 'c'];\n        this.commandName = 'editor.fold';\n        this.direction = 'up';\n    }\n};\nCommandCloseFold = __decorate([\n    base_1.RegisterAction\n], CommandCloseFold);\nlet CommandCloseAllFolds = class CommandCloseAllFolds extends CommandFold {\n    constructor() {\n        super(...arguments);\n        this.keys = ['z', 'M'];\n        this.commandName = 'editor.foldAll';\n    }\n};\nCommandCloseAllFolds = __decorate([\n    base_1.RegisterAction\n], CommandCloseAllFolds);\nlet CommandOpenFold = class CommandOpenFold extends CommandFold {\n    constructor() {\n        super(...arguments);\n        this.keys = ['z', 'o'];\n        this.commandName = 'editor.unfold';\n        this.direction = 'down';\n    }\n};\nCommandOpenFold = __decorate([\n    base_1.RegisterAction\n], CommandOpenFold);\nlet CommandOpenAllFolds = class CommandOpenAllFolds extends CommandFold {\n    constructor() {\n        super(...arguments);\n        this.keys = ['z', 'R'];\n        this.commandName = 'editor.unfoldAll';\n    }\n};\nCommandOpenAllFolds = __decorate([\n    base_1.RegisterAction\n], CommandOpenAllFolds);\nlet CommandCloseAllFoldsRecursively = class CommandCloseAllFoldsRecursively extends CommandFold {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['z', 'C'];\n        this.commandName = 'editor.foldRecursively';\n    }\n};\nCommandCloseAllFoldsRecursively = __decorate([\n    base_1.RegisterAction\n], CommandCloseAllFoldsRecursively);\nlet CommandOpenAllFoldsRecursively = class CommandOpenAllFoldsRecursively extends CommandFold {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['z', 'O'];\n        this.commandName = 'editor.unfoldRecursively';\n    }\n};\nCommandOpenAllFoldsRecursively = __decorate([\n    base_1.RegisterAction\n], CommandOpenAllFoldsRecursively);\nlet AddFold = class AddFold extends operator_1.BaseOperator {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual];\n        this.keys = ['z', 'f'];\n        this.commandName = 'editor.createFoldingRangeFromSelection';\n    }\n    async run(vimState, start, end) {\n        const previousSelections = vimState.lastVisualSelection; // keep in case of Normal mode\n        vimState.editor.selection = new vscode.Selection(start, end);\n        await vscode.commands.executeCommand(this.commandName);\n        vimState.lastVisualSelection = previousSelections;\n        vimState.cursors = [new cursor_1.Cursor(start, start)];\n        await vimState.setCurrentMode(mode_1.Mode.Normal); // Vim behavior\n    }\n};\nAddFold = __decorate([\n    base_1.RegisterAction\n], AddFold);\nlet RemoveFold = class RemoveFold extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual];\n        this.keys = ['z', 'd'];\n        this.commandName = 'editor.removeManualFoldingRanges';\n    }\n    async exec(position, vimState) {\n        await vscode.commands.executeCommand(this.commandName);\n        const newCursorPosition = vimState.currentMode === mode_1.Mode.Visual ? vimState.editor.selection.start : position;\n        vimState.cursors = [new cursor_1.Cursor(newCursorPosition, newCursorPosition)];\n        await vimState.setCurrentMode(mode_1.Mode.Normal); // Vim behavior\n    }\n};\nRemoveFold = __decorate([\n    base_1.RegisterAction\n], RemoveFold);\n\n\n//# sourceURL=webpack://vim/./src/actions/commands/fold.ts?")},"./src/actions/commands/insert.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InsertCharBelow = exports.InsertCharAbove = exports.CommandInsertInInsertMode = exports.CommandBackspaceInInsertMode = exports.CommandInsertPreviousText = exports.CommandEscInsertMode = void 0;\nconst vscode = __importStar(__webpack_require__(/*! vscode */ \"vscode\"));\nconst lineCompletionProvider_1 = __webpack_require__(/*! ../../completion/lineCompletionProvider */ \"./src/completion/lineCompletionProvider.ts\");\nconst error_1 = __webpack_require__(/*! ../../error */ \"./src/error.ts\");\nconst recordedState_1 = __webpack_require__(/*! ../../state/recordedState */ \"./src/state/recordedState.ts\");\nconst statusBar_1 = __webpack_require__(/*! ../../statusBar */ \"./src/statusBar.ts\");\nconst util_1 = __webpack_require__(/*! ../../util/util */ \"./src/util/util.ts\");\nconst position_1 = __webpack_require__(/*! ./../../common/motion/position */ \"./src/common/motion/position.ts\");\nconst configuration_1 = __webpack_require__(/*! ./../../configuration/configuration */ \"./src/configuration/configuration.ts\");\nconst mode_1 = __webpack_require__(/*! ./../../mode/mode */ \"./src/mode/mode.ts\");\nconst register_1 = __webpack_require__(/*! ./../../register/register */ \"./src/register/register.ts\");\nconst textEditor_1 = __webpack_require__(/*! ./../../textEditor */ \"./src/textEditor.ts\");\nconst base_1 = __webpack_require__(/*! ./../base */ \"./src/actions/base.ts\");\nconst motion_1 = __webpack_require__(/*! ./../motion */ \"./src/actions/motion.ts\");\nconst actions_1 = __webpack_require__(/*! ./actions */ \"./src/actions/commands/actions.ts\");\nconst digraphs_1 = __webpack_require__(/*! ./digraphs */ \"./src/actions/commands/digraphs.ts\");\nlet CommandEscInsertMode = class CommandEscInsertMode extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Insert];\n        this.keys = [['<Esc>'], ['<C-c>'], ['<C-[>']];\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        void vscode.commands.executeCommand('closeParameterHints');\n        vimState.cursors = vimState.cursors.map((x) => x.withNewStop(x.stop.getLeft()));\n        if (vimState.returnToInsertAfterCommand && position.character !== 0) {\n            vimState.cursors = vimState.cursors.map((x) => x.withNewStop(x.stop.getRight()));\n        }\n        // only remove leading spaces inserted by vscode.\n        // vscode only inserts them when user enter a new line,\n        // ie, o/O in Normal mode or \\n in Insert mode.\n        const lastActionBeforeEsc = vimState.recordedState.actionsRun[vimState.recordedState.actionsRun.length - 2];\n        if (vimState.document.languageId !== 'plaintext' &&\n            (lastActionBeforeEsc instanceof actions_1.CommandInsertNewLineBefore ||\n                lastActionBeforeEsc instanceof actions_1.CommandInsertNewLineAbove ||\n                (lastActionBeforeEsc instanceof actions_1.DocumentContentChangeAction &&\n                    lastActionBeforeEsc.keysPressed[lastActionBeforeEsc.keysPressed.length - 1] === '\\n'))) {\n            for (const cursor of vimState.cursors) {\n                const line = vimState.document.lineAt(cursor.stop);\n                if (line.text.length > 0 && line.isEmptyOrWhitespace) {\n                    vimState.recordedState.transformer.delete(line.range);\n                }\n            }\n        }\n        await vimState.setCurrentMode(mode_1.Mode.Normal);\n        // If we wanted to repeat this insert (only for i and a), now is the time to do it. Insert\n        // count amount of these strings before returning back to normal mode\n        const shouldRepeatInsert = vimState.recordedState.count > 1 &&\n            vimState.recordedState.actionsRun.find((a) => a instanceof actions_1.CommandInsertAtCursor ||\n                a instanceof actions_1.CommandInsertAfterCursor ||\n                a instanceof actions_1.CommandInsertAtLineBegin ||\n                a instanceof actions_1.CommandInsertAtLineEnd ||\n                a instanceof actions_1.CommandInsertAtFirstCharacter ||\n                a instanceof actions_1.CommandInsertAtLastChange) !== undefined;\n        // If this is the type to repeat insert, do this now\n        if (shouldRepeatInsert) {\n            const changeAction = vimState.recordedState.actionsRun\n                .slice()\n                .reverse()\n                .find((a) => a instanceof actions_1.DocumentContentChangeAction);\n            if (changeAction instanceof actions_1.DocumentContentChangeAction) {\n                // Add count amount of inserts in the case of 4i=<esc>\n                // TODO: A few actions such as <C-t> should be repeated, but are not\n                for (let i = 0; i < vimState.recordedState.count - 1; i++) {\n                    // If this is the last transform, move cursor back one character\n                    const positionDiff = i === vimState.recordedState.count - 2\n                        ? position_1.PositionDiff.offset({ character: -1 })\n                        : position_1.PositionDiff.identity();\n                    // Add a transform containing the change\n                    vimState.recordedState.transformer.addTransformation(changeAction.getTransformation(positionDiff));\n                }\n            }\n        }\n        if (vimState.historyTracker.currentContentChanges.length > 0) {\n            vimState.historyTracker.currentContentChanges = [];\n        }\n        if (vimState.isFakeMultiCursor) {\n            vimState.cursors = [vimState.cursors[0]];\n            vimState.isFakeMultiCursor = false;\n        }\n    }\n};\nexports.CommandEscInsertMode = CommandEscInsertMode;\nexports.CommandEscInsertMode = CommandEscInsertMode = __decorate([\n    base_1.RegisterAction\n], CommandEscInsertMode);\nlet CommandInsertPreviousText = class CommandInsertPreviousText extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Insert];\n        this.keys = ['<C-a>'];\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        const register = await register_1.Register.get('.');\n        if (register === undefined ||\n            !(register.text instanceof recordedState_1.RecordedState) ||\n            !register.text.actionsRun) {\n            throw error_1.VimError.fromCode(error_1.ErrorCode.NoInsertedTextYet);\n        }\n        const recordedState = register.text.clone();\n        // The first action is entering Insert Mode, which is not necessary in this case\n        recordedState.actionsRun.shift();\n        // The last action is leaving Insert Mode, which is not necessary in this case\n        recordedState.actionsRun.pop();\n        if (recordedState.actionsRun?.[0] instanceof motion_1.ArrowsInInsertMode) {\n            // Note, arrow keys are the only Insert action command that can't be repeated here as far as @rebornix knows.\n            recordedState.actionsRun.shift();\n        }\n        vimState.recordedState.transformer.addTransformation({\n            type: 'replayRecordedState',\n            recordedState,\n        });\n    }\n};\nexports.CommandInsertPreviousText = CommandInsertPreviousText;\nexports.CommandInsertPreviousText = CommandInsertPreviousText = __decorate([\n    base_1.RegisterAction\n], CommandInsertPreviousText);\nlet CommandInsertPreviousTextAndQuit = class CommandInsertPreviousTextAndQuit extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Insert];\n        this.keys = ['<C-shift+2>']; // <C-@>\n    }\n    async exec(position, vimState) {\n        await new CommandInsertPreviousText().exec(position, vimState);\n        await vimState.setCurrentMode(mode_1.Mode.Normal);\n    }\n};\nCommandInsertPreviousTextAndQuit = __decorate([\n    base_1.RegisterAction\n], CommandInsertPreviousTextAndQuit);\nclass IndentCommand extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Insert];\n    }\n    async exec(position, vimState) {\n        const line = vimState.document.lineAt(position);\n        const tabSize = Number(vimState.editor.options.tabSize);\n        const indentationWidth = textEditor_1.TextEditor.getIndentationLevel(line.text, tabSize);\n        const newIndentationWidth = (Math.floor(indentationWidth / tabSize) + this.delta) * tabSize;\n        vimState.recordedState.transformer.replace(new vscode.Range(position.getLineBegin(), position.with({ character: line.firstNonWhitespaceCharacterIndex })), textEditor_1.TextEditor.setIndentationLevel(line.text, newIndentationWidth, vimState.editor.options.insertSpaces).match(/^(\\s*)/)[1]);\n    }\n}\nlet IncreaseIndent = class IncreaseIndent extends IndentCommand {\n    constructor() {\n        super(...arguments);\n        this.keys = ['<C-t>'];\n        this.delta = 1;\n    }\n};\nIncreaseIndent = __decorate([\n    base_1.RegisterAction\n], IncreaseIndent);\nlet DecreaseIndent = class DecreaseIndent extends IndentCommand {\n    constructor() {\n        super(...arguments);\n        this.keys = ['<C-d>'];\n        this.delta = -1;\n    }\n};\nDecreaseIndent = __decorate([\n    base_1.RegisterAction\n], DecreaseIndent);\nlet CommandBackspaceInInsertMode = class CommandBackspaceInInsertMode extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Insert];\n        this.keys = [['<BS>'], ['<C-h>']];\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        vimState.recordedState.transformer.vscodeCommand('deleteLeft');\n    }\n};\nexports.CommandBackspaceInInsertMode = CommandBackspaceInInsertMode;\nexports.CommandBackspaceInInsertMode = CommandBackspaceInInsertMode = __decorate([\n    base_1.RegisterAction\n], CommandBackspaceInInsertMode);\nlet CommandDeleteInInsertMode = class CommandDeleteInInsertMode extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Insert];\n        this.keys = ['<Del>'];\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        vimState.recordedState.transformer.vscodeCommand('deleteRight');\n    }\n};\nCommandDeleteInInsertMode = __decorate([\n    base_1.RegisterAction\n], CommandDeleteInInsertMode);\nlet CommandInsertInInsertMode = class CommandInsertInInsertMode extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Insert];\n        this.keys = ['<character>'];\n    }\n    async exec(position, vimState) {\n        const char = this.keysPressed[this.keysPressed.length - 1];\n        let text = char;\n        if (char.length === 1) {\n            const prevHighSurrogate = vimState.modeData.mode === mode_1.Mode.Insert ? vimState.modeData.highSurrogate : undefined;\n            if ((0, util_1.isHighSurrogate)(char.charCodeAt(0))) {\n                await vimState.setModeData({\n                    mode: mode_1.Mode.Insert,\n                    highSurrogate: char,\n                });\n                if (prevHighSurrogate === undefined)\n                    return;\n                text = prevHighSurrogate;\n            }\n            else {\n                if ((0, util_1.isLowSurrogate)(char.charCodeAt(0)) && prevHighSurrogate !== undefined) {\n                    text = prevHighSurrogate + char;\n                }\n                await vimState.setModeData({\n                    mode: mode_1.Mode.Insert,\n                    highSurrogate: undefined,\n                });\n            }\n        }\n        vimState.recordedState.transformer.addTransformation({\n            type: 'insertTextVSCode',\n            text,\n            isMultiCursor: vimState.isMultiCursor,\n        });\n    }\n    toString() {\n        return this.keysPressed[this.keysPressed.length - 1];\n    }\n};\nexports.CommandInsertInInsertMode = CommandInsertInInsertMode;\nexports.CommandInsertInInsertMode = CommandInsertInInsertMode = __decorate([\n    base_1.RegisterAction\n], CommandInsertInInsertMode);\nlet CommandInsertDigraph = class CommandInsertDigraph extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Insert];\n        this.keys = ['<C-k>', '<any>', '<any>'];\n        this.isCompleteAction = false;\n    }\n    async exec(position, vimState) {\n        const digraph = this.keysPressed.slice(1, 3).join('');\n        const reverseDigraph = digraph.split('').reverse().join('');\n        let charCodes = (digraphs_1.DefaultDigraphs.get(digraph) ||\n            digraphs_1.DefaultDigraphs.get(reverseDigraph) ||\n            configuration_1.configuration.digraphs[digraph] ||\n            configuration_1.configuration.digraphs[reverseDigraph])[1];\n        if (!(charCodes instanceof Array)) {\n            charCodes = [charCodes];\n        }\n        const char = String.fromCharCode(...charCodes);\n        vimState.recordedState.transformer.insert(position, char);\n    }\n    doesActionApply(vimState, keysPressed) {\n        if (!super.doesActionApply(vimState, keysPressed)) {\n            return false;\n        }\n        const chars = keysPressed.slice(1, 3).join('');\n        const reverseChars = chars.split('').reverse().join('');\n        return (chars in configuration_1.configuration.digraphs ||\n            reverseChars in configuration_1.configuration.digraphs ||\n            digraphs_1.DefaultDigraphs.has(chars) ||\n            digraphs_1.DefaultDigraphs.has(reverseChars));\n    }\n    couldActionApply(vimState, keysPressed) {\n        if (!super.couldActionApply(vimState, keysPressed)) {\n            return false;\n        }\n        const chars = keysPressed.slice(1, keysPressed.length).join('');\n        const reverseChars = chars.split('').reverse().join('');\n        if (chars.length > 0) {\n            const predicate = (digraph) => {\n                const digraphChars = digraph.substring(0, chars.length);\n                return chars === digraphChars || reverseChars === digraphChars;\n            };\n            const match = Object.keys(configuration_1.configuration.digraphs).find(predicate) ||\n                [...digraphs_1.DefaultDigraphs.keys()].find(predicate);\n            return match !== undefined;\n        }\n        return true;\n    }\n};\nCommandInsertDigraph = __decorate([\n    base_1.RegisterAction\n], CommandInsertDigraph);\nlet CommandInsertRegisterContent = class CommandInsertRegisterContent extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Insert];\n        this.keys = ['<C-r>', '<character>'];\n        this.isCompleteAction = false;\n    }\n    async exec(position, vimState) {\n        if (!register_1.Register.isValidRegister(this.keysPressed[1])) {\n            return;\n        }\n        const register = await register_1.Register.get(this.keysPressed[1], this.multicursorIndex);\n        if (register === undefined) {\n            statusBar_1.StatusBar.displayError(vimState, error_1.VimError.fromCode(error_1.ErrorCode.NothingInRegister, this.keysPressed[1]));\n            return;\n        }\n        if (register.text instanceof recordedState_1.RecordedState) {\n            vimState.recordedState.transformer.addTransformation({\n                type: 'macro',\n                register: vimState.recordedState.registerName,\n                replay: 'keystrokes',\n            });\n            return;\n        }\n        let text = register.text;\n        if (register.registerMode === register_1.RegisterMode.LineWise && !vimState.isMultiCursor) {\n            text += '\\n';\n        }\n        vimState.recordedState.transformer.insert(position, text);\n    }\n};\nCommandInsertRegisterContent = __decorate([\n    base_1.RegisterAction\n], CommandInsertRegisterContent);\nlet CommandOneNormalCommandInInsertMode = class CommandOneNormalCommandInInsertMode extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Insert];\n        this.keys = ['<C-o>'];\n    }\n    async exec(position, vimState) {\n        vimState.returnToInsertAfterCommand = true;\n        vimState.actionCount = 0;\n        await new CommandEscInsertMode().exec(position, vimState);\n    }\n};\nCommandOneNormalCommandInInsertMode = __decorate([\n    base_1.RegisterAction\n], CommandOneNormalCommandInInsertMode);\nlet CommandCtrlW = class CommandCtrlW extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Insert];\n        this.keys = ['<C-w>'];\n    }\n    async exec(position, vimState) {\n        if (position.isAtDocumentBegin()) {\n            return;\n        }\n        let wordBegin;\n        if (position.isInLeadingWhitespace(vimState.document)) {\n            wordBegin = position.getLineBegin();\n        }\n        else if (position.isLineBeginning()) {\n            wordBegin = position.getUp().getLineEnd();\n        }\n        else {\n            wordBegin = position.prevWordStart(vimState.document);\n        }\n        vimState.recordedState.transformer.delete(new vscode.Range(wordBegin, position));\n        vimState.cursorStopPosition = wordBegin;\n    }\n};\nCommandCtrlW = __decorate([\n    base_1.RegisterAction\n], CommandCtrlW);\nlet InsertCharAbove = class InsertCharAbove extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Insert];\n        this.keys = ['<C-y>'];\n    }\n    async exec(position, vimState) {\n        if (position.line === 0) {\n            return;\n        }\n        const charPos = position.getUp();\n        if (charPos.isLineEnd()) {\n            return;\n        }\n        const char = vimState.document.getText(new vscode.Range(charPos, charPos.getRight()));\n        vimState.recordedState.transformer.insert(position, char);\n    }\n};\nexports.InsertCharAbove = InsertCharAbove;\nexports.InsertCharAbove = InsertCharAbove = __decorate([\n    base_1.RegisterAction\n], InsertCharAbove);\nlet InsertCharBelow = class InsertCharBelow extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Insert];\n        this.keys = ['<C-e>'];\n    }\n    async exec(position, vimState) {\n        if (position.line >= vimState.document.lineCount - 1) {\n            return;\n        }\n        const charPos = position.getDown();\n        if (charPos.isLineEnd()) {\n            return;\n        }\n        const char = vimState.document.getText(new vscode.Range(charPos, charPos.getRight()));\n        vimState.recordedState.transformer.insert(position, char);\n    }\n};\nexports.InsertCharBelow = InsertCharBelow;\nexports.InsertCharBelow = InsertCharBelow = __decorate([\n    base_1.RegisterAction\n], InsertCharBelow);\nlet CommandCtrlUInInsertMode = class CommandCtrlUInInsertMode extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Insert];\n        this.keys = ['<C-u>'];\n    }\n    async exec(position, vimState) {\n        let start;\n        if (position.character === 0) {\n            start = position.getLeftThroughLineBreaks(true);\n        }\n        else if (position.isInLeadingWhitespace(vimState.document)) {\n            start = position.getLineBegin();\n        }\n        else {\n            start = position.getLineBeginRespectingIndent(vimState.document);\n        }\n        vimState.recordedState.transformer.delete(new vscode.Range(start, position));\n        vimState.cursorStopPosition = start;\n        vimState.cursorStartPosition = start;\n    }\n};\nCommandCtrlUInInsertMode = __decorate([\n    base_1.RegisterAction\n], CommandCtrlUInInsertMode);\nlet CommandNavigateAutocompleteDown = class CommandNavigateAutocompleteDown extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Insert];\n        this.keys = [['<C-n>'], ['<C-j>']];\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        await vscode.commands.executeCommand('selectNextSuggestion');\n    }\n};\nCommandNavigateAutocompleteDown = __decorate([\n    base_1.RegisterAction\n], CommandNavigateAutocompleteDown);\nlet CommandNavigateAutocompleteUp = class CommandNavigateAutocompleteUp extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Insert];\n        this.keys = ['<C-p>'];\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        await vscode.commands.executeCommand('selectPrevSuggestion');\n    }\n};\nCommandNavigateAutocompleteUp = __decorate([\n    base_1.RegisterAction\n], CommandNavigateAutocompleteUp);\nlet CommandCtrlVInInsertMode = class CommandCtrlVInInsertMode extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Insert];\n        this.keys = ['<C-v>'];\n    }\n    async exec(position, vimState) {\n        const clipboard = await register_1.Register.get('*', this.multicursorIndex);\n        const text = clipboard?.text instanceof recordedState_1.RecordedState ? undefined : clipboard?.text;\n        if (text) {\n            vimState.recordedState.transformer.insert(vimState.cursorStopPosition, text);\n        }\n    }\n};\nCommandCtrlVInInsertMode = __decorate([\n    base_1.RegisterAction\n], CommandCtrlVInInsertMode);\nlet CommandShowLineAutocomplete = class CommandShowLineAutocomplete extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Insert];\n        this.keys = ['<C-x>', '<C-l>'];\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        await lineCompletionProvider_1.lineCompletionProvider.showLineCompletionsQuickPick(position, vimState);\n    }\n};\nCommandShowLineAutocomplete = __decorate([\n    base_1.RegisterAction\n], CommandShowLineAutocomplete);\nlet NewLineInsertMode = class NewLineInsertMode extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Insert];\n        this.keys = [['<C-j>'], ['<C-m>']];\n    }\n    async exec(position, vimState) {\n        vimState.recordedState.transformer.insert(position, '\\n', position_1.PositionDiff.offset({ character: -1 }));\n    }\n};\nNewLineInsertMode = __decorate([\n    base_1.RegisterAction\n], NewLineInsertMode);\nlet CommandReplaceAtCursorFromInsertMode = class CommandReplaceAtCursorFromInsertMode extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Insert];\n        this.keys = ['<Insert>'];\n    }\n    async exec(position, vimState) {\n        await new actions_1.CommandReplaceAtCursorFromNormalMode().exec(position, vimState);\n    }\n};\nCommandReplaceAtCursorFromInsertMode = __decorate([\n    base_1.RegisterAction\n], CommandReplaceAtCursorFromInsertMode);\nlet CreateUndoPoint = class CreateUndoPoint extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Insert];\n        this.keys = ['<C-g>', 'u'];\n    }\n    async exec(position, vimState) {\n        vimState.historyTracker.addChange(true);\n        vimState.historyTracker.finishCurrentStep();\n    }\n};\nCreateUndoPoint = __decorate([\n    base_1.RegisterAction\n], CreateUndoPoint);\n\n\n//# sourceURL=webpack://vim/./src/actions/commands/insert.ts?")},"./src/actions/commands/put.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PutBeforeFromCmdLine = exports.PutFromCmdLine = void 0;\nconst vscode = __importStar(__webpack_require__(/*! vscode */ \"vscode\"));\nconst vscode_1 = __webpack_require__(/*! vscode */ \"vscode\");\nconst position_1 = __webpack_require__(/*! ../../common/motion/position */ \"./src/common/motion/position.ts\");\nconst configuration_1 = __webpack_require__(/*! ../../configuration/configuration */ \"./src/configuration/configuration.ts\");\nconst mode_1 = __webpack_require__(/*! ../../mode/mode */ \"./src/mode/mode.ts\");\nconst register_1 = __webpack_require__(/*! ../../register/register */ \"./src/register/register.ts\");\nconst recordedState_1 = __webpack_require__(/*! ../../state/recordedState */ \"./src/state/recordedState.ts\");\nconst textEditor_1 = __webpack_require__(/*! ../../textEditor */ \"./src/textEditor.ts\");\nconst statusBarTextUtils_1 = __webpack_require__(/*! ../../util/statusBarTextUtils */ \"./src/util/statusBarTextUtils.ts\");\nconst base_1 = __webpack_require__(/*! ../base */ \"./src/actions/base.ts\");\nconst statusBar_1 = __webpack_require__(/*! ../../statusBar */ \"./src/statusBar.ts\");\nconst error_1 = __webpack_require__(/*! ../../error */ \"./src/error.ts\");\nfunction firstNonBlankChar(text) {\n    return text.match(/\\S/)?.index ?? 0;\n}\nclass BasePutCommand extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n        this.createsUndoPoint = true;\n        this.overwritesRegisterWithSelection = true;\n    }\n    async exec(position, vimState) {\n        const register = await register_1.Register.get(vimState.recordedState.registerName, this.multicursorIndex);\n        if (register === undefined) {\n            statusBar_1.StatusBar.displayError(vimState, error_1.VimError.fromCode(error_1.ErrorCode.NothingInRegister, vimState.recordedState.registerName));\n            return;\n        }\n        const count = vimState.recordedState.count || 1;\n        const mode = vimState.currentMode === mode_1.Mode.CommandlineInProgress ? mode_1.Mode.Normal : vimState.currentMode;\n        const registerMode = this.getRegisterMode(register);\n        const replaceRange = this.getReplaceRange(mode, vimState.cursors[0], registerMode);\n        let text = this.getRegisterText(mode, register, count);\n        if (this.shouldAdjustIndent(mode, registerMode)) {\n            let lineToMatch;\n            if (mode === mode_1.Mode.VisualLine) {\n                const [start, end] = (0, position_1.sorted)(vimState.cursorStartPosition, vimState.cursorStopPosition);\n                if (end.line < vimState.document.lineCount - 1) {\n                    lineToMatch = end.line + 1;\n                }\n                else if (start.line > 0) {\n                    lineToMatch = start.line - 1;\n                }\n            }\n            else {\n                lineToMatch = position.line;\n            }\n            text = this.adjustIndent(lineToMatch !== undefined ? vimState.document.lineAt(lineToMatch).text : '', text);\n        }\n        const newCursorPosition = this.getCursorPosition(vimState.document, mode, replaceRange, registerMode, count, text);\n        vimState.recordedState.transformer.moveCursor(position_1.PositionDiff.exactPosition(newCursorPosition), this.multicursorIndex ?? 0);\n        if (registerMode === register_1.RegisterMode.LineWise) {\n            text = this.adjustLinewiseRegisterText(mode, text);\n        }\n        for (const transformation of this.getTransformations(vimState.document, mode, replaceRange, registerMode, text)) {\n            vimState.recordedState.transformer.addTransformation(transformation);\n        }\n        // We do not run this in multi-cursor mode as it will overwrite the register for upcoming put iterations\n        if ((0, mode_1.isVisualMode)(mode) && !vimState.isMultiCursor) {\n            // After using \"p\" or \"P\" in Visual mode the text that was put will be selected (from Vim's \":help gv\").\n            vimState.lastVisualSelection = {\n                mode,\n                start: replaceRange.start,\n                end: replaceRange.start.advancePositionByText(text),\n            };\n            if (this.overwritesRegisterWithSelection) {\n                vimState.recordedState.registerName = configuration_1.configuration.useSystemClipboard ? '*' : '\"';\n                register_1.Register.put(vimState, vimState.document.getText(replaceRange), this.multicursorIndex, true);\n            }\n        }\n        // Report lines changed\n        let numNewlinesAfterPut = text.split('\\n').length;\n        if (registerMode === register_1.RegisterMode.LineWise) {\n            numNewlinesAfterPut--;\n        }\n        (0, statusBarTextUtils_1.reportLinesChanged)(numNewlinesAfterPut, vimState);\n        const isLastCursor = !vimState.isMultiCursor || vimState.cursors.length - 1 === this.multicursorIndex;\n        // Place the cursor back into normal mode after all puts are completed\n        if (isLastCursor) {\n            await vimState.setCurrentMode(mode_1.Mode.Normal);\n        }\n    }\n    getRegisterText(mode, register, count) {\n        if (register.text instanceof recordedState_1.RecordedState) {\n            return register.text.actionsRun\n                .map((action) => action.keysPressed.join(''))\n                .join('')\n                .repeat(count);\n        }\n        if (register.registerMode === register_1.RegisterMode.CharacterWise) {\n            return mode === mode_1.Mode.VisualLine\n                ? Array(count).fill(register.text).join('\\n')\n                : register.text.repeat(count);\n        }\n        else if (register.registerMode === register_1.RegisterMode.LineWise || mode === mode_1.Mode.VisualLine) {\n            return Array(count).fill(register.text).join('\\n');\n        }\n        else if (register.registerMode === register_1.RegisterMode.BlockWise) {\n            const lines = register.text.split('\\n');\n            const longestLength = Math.max(...lines.map((line) => line.length));\n            return lines\n                .map((line) => {\n                const space = longestLength - line.length;\n                const lineWithSpace = line + ' '.repeat(space);\n                return lineWithSpace.repeat(count - 1) + line;\n            })\n                .join('\\n');\n        }\n        else {\n            throw new Error(`Unexpected RegisterMode ${register.registerMode}`);\n        }\n    }\n    adjustIndent(lineToMatch, text) {\n        const lines = text.split('\\n');\n        // Adjust indent to current line\n        const tabSize = configuration_1.configuration.tabstop; // TODO: Use `editor.options.tabSize`, I think\n        const indentationWidth = textEditor_1.TextEditor.getIndentationLevel(lineToMatch, tabSize);\n        const firstLineIdentationWidth = textEditor_1.TextEditor.getIndentationLevel(lines[0], tabSize);\n        return lines\n            .map((line) => {\n            const currentIdentationWidth = textEditor_1.TextEditor.getIndentationLevel(line, tabSize);\n            const newIndentationWidth = currentIdentationWidth - firstLineIdentationWidth + indentationWidth;\n            // TODO: Use `editor.options.insertSpaces`, I think\n            return textEditor_1.TextEditor.setIndentationLevel(line, newIndentationWidth, configuration_1.configuration.expandtab);\n        })\n            .join('\\n');\n    }\n    getTransformations(document, mode, replaceRange, registerMode, text) {\n        // Pasting block-wise content is very different, except in VisualLine mode, where it works exactly like line-wise\n        if (registerMode === register_1.RegisterMode.BlockWise && mode !== mode_1.Mode.VisualLine) {\n            const transformations = [];\n            const lines = text.split('\\n');\n            const lineCount = Math.max(lines.length, replaceRange.end.line - replaceRange.start.line + 1);\n            const longestLength = Math.max(...lines.map((line) => line.length));\n            // Only relevant for Visual mode\n            // If we replace 2 newlines, subsequent transformations need to take that into account (otherwise we get overlaps)\n            let deletedNewlines = 0;\n            for (let idx = 0; idx < lineCount; idx++) {\n                const lineText = lines[idx] ?? '';\n                let range;\n                if (mode === mode_1.Mode.VisualBlock) {\n                    if (replaceRange.start.line + idx > replaceRange.end.line) {\n                        const pos = replaceRange.start.with({ line: replaceRange.start.line + idx });\n                        range = new vscode.Range(pos, pos);\n                    }\n                    else {\n                        range = new vscode.Range(replaceRange.start.with({ line: replaceRange.start.line + idx }), replaceRange.end.with({ line: replaceRange.start.line + idx }));\n                    }\n                }\n                else {\n                    if (idx > 0) {\n                        const pos = replaceRange.start.with({\n                            line: replaceRange.start.line + idx + deletedNewlines,\n                        });\n                        range = new vscode.Range(pos, pos);\n                    }\n                    else {\n                        range = new vscode.Range(replaceRange.start, replaceRange.end);\n                        deletedNewlines = document.getText(range).split('\\n').length - 1;\n                    }\n                }\n                const lineNumber = replaceRange.start.line + idx;\n                if (lineNumber > document.lineCount - 1) {\n                    transformations.push({\n                        type: 'replaceText',\n                        range,\n                        text: '\\n' + ' '.repeat(replaceRange.start.character) + lineText,\n                    });\n                }\n                else {\n                    const lineLength = document.lineAt(lineNumber).text.length;\n                    const leftPadding = Math.max(replaceRange.start.character - lineLength, 0);\n                    let rightPadding = 0;\n                    if (mode !== mode_1.Mode.VisualBlock &&\n                        ((lineNumber <= replaceRange.end.line && replaceRange.end.character < lineLength) ||\n                            (lineNumber > replaceRange.end.line && replaceRange.start.character < lineLength))) {\n                        rightPadding = longestLength - lineText.length;\n                    }\n                    transformations.push({\n                        type: 'replaceText',\n                        range,\n                        text: ' '.repeat(leftPadding) + lineText + ' '.repeat(rightPadding),\n                    });\n                }\n            }\n            return transformations;\n        }\n        if (mode === mode_1.Mode.Normal || mode === mode_1.Mode.Visual || mode === mode_1.Mode.VisualLine) {\n            return [\n                {\n                    type: 'replaceText',\n                    range: replaceRange,\n                    text,\n                },\n            ];\n        }\n        else if (mode === mode_1.Mode.VisualBlock) {\n            const transformations = [];\n            if (registerMode === register_1.RegisterMode.CharacterWise) {\n                for (let line = replaceRange.start.line; line <= replaceRange.end.line; line++) {\n                    const range = new vscode.Range(new vscode_1.Position(line, replaceRange.start.character), new vscode_1.Position(line, replaceRange.end.character));\n                    const lineText = !text.includes('\\n') || line === replaceRange.start.line ? text : '';\n                    transformations.push({\n                        type: 'replaceText',\n                        range,\n                        text: lineText,\n                    });\n                }\n            }\n            else if (registerMode === register_1.RegisterMode.LineWise) {\n                // Weird case: first delete the block...\n                for (let line = replaceRange.start.line; line <= replaceRange.end.line; line++) {\n                    const range = new vscode.Range(new vscode_1.Position(line, replaceRange.start.character), new vscode_1.Position(line, replaceRange.end.character));\n                    transformations.push({\n                        type: 'replaceText',\n                        range,\n                        text: '',\n                    });\n                }\n                // ...then paste the lines before/after the block\n                const insertPos = this.putBefore()\n                    ? new vscode_1.Position(replaceRange.start.line, 0)\n                    : new vscode_1.Position(replaceRange.end.line, 0).getLineEnd();\n                transformations.push({\n                    type: 'replaceText',\n                    range: new vscode.Range(insertPos, insertPos),\n                    text,\n                });\n            }\n            else {\n                throw new Error(`Unexpected RegisterMode ${registerMode}`);\n            }\n            return transformations;\n        }\n        else {\n            throw new Error(`Unexpected Mode ${mode}`);\n        }\n    }\n}\nlet PutCommand = class PutCommand extends BasePutCommand {\n    constructor() {\n        super(...arguments);\n        this.keys = ['p'];\n    }\n    putBefore() {\n        return false;\n    }\n    getRegisterMode(register) {\n        return register.registerMode;\n    }\n    getReplaceRange(mode, cursor, registerMode) {\n        if (mode === mode_1.Mode.Normal) {\n            let pos;\n            if (registerMode === register_1.RegisterMode.CharacterWise || registerMode === register_1.RegisterMode.BlockWise) {\n                pos = cursor.stop.getRight();\n            }\n            else if (registerMode === register_1.RegisterMode.LineWise) {\n                pos = cursor.stop.getLineEnd();\n            }\n            else {\n                throw new Error(`Unexpected RegisterMode ${registerMode}`);\n            }\n            return new vscode.Range(pos, pos);\n        }\n        else if (mode === mode_1.Mode.Visual) {\n            const [start, end] = (0, position_1.sorted)(cursor.start, cursor.stop);\n            return new vscode.Range(start, end.getRight());\n        }\n        else if (mode === mode_1.Mode.VisualLine) {\n            const [start, end] = (0, position_1.sorted)(cursor.start, cursor.stop);\n            return new vscode.Range(start.getLineBegin(), end.getLineEnd());\n        }\n        else {\n            const [start, end] = (0, position_1.sorted)(cursor.start, cursor.stop);\n            return new vscode.Range(start, end.getRight());\n        }\n    }\n    adjustLinewiseRegisterText(mode, text) {\n        if (mode === mode_1.Mode.Normal || mode === mode_1.Mode.VisualBlock) {\n            return '\\n' + text;\n        }\n        else if (mode === mode_1.Mode.Visual) {\n            return '\\n' + text + '\\n';\n        }\n        else {\n            return text;\n        }\n    }\n    shouldAdjustIndent(mode, registerMode) {\n        return false;\n    }\n    getCursorPosition(document, mode, replaceRange, registerMode, count, text) {\n        const rangeStart = replaceRange.start;\n        if (mode === mode_1.Mode.Normal || mode === mode_1.Mode.Visual) {\n            if (registerMode === register_1.RegisterMode.CharacterWise) {\n                return text.includes('\\n') ? rangeStart : rangeStart.advancePositionByText(text).getLeft();\n            }\n            else if (registerMode === register_1.RegisterMode.LineWise) {\n                return new vscode_1.Position(rangeStart.line + 1, firstNonBlankChar(text));\n            }\n            else if (registerMode === register_1.RegisterMode.BlockWise) {\n                return rangeStart;\n            }\n            else {\n                throw new Error(`Unexpected RegisterMode ${registerMode}`);\n            }\n        }\n        else if (mode === mode_1.Mode.VisualLine) {\n            return rangeStart.with({ character: firstNonBlankChar(text) });\n        }\n        else if (mode === mode_1.Mode.VisualBlock) {\n            if (registerMode === register_1.RegisterMode.LineWise) {\n                return new vscode_1.Position(replaceRange.end.line + 1, firstNonBlankChar(text));\n            }\n            else if (registerMode === register_1.RegisterMode.BlockWise) {\n                return rangeStart;\n            }\n            else {\n                return rangeStart.with({ character: rangeStart.character + text.length - 1 });\n            }\n        }\n        else {\n            throw new Error(`Unexpected Mode ${mode}`);\n        }\n    }\n};\nPutCommand = __decorate([\n    base_1.RegisterAction\n], PutCommand);\nlet PutBeforeCommand = class PutBeforeCommand extends PutCommand {\n    constructor() {\n        super(...arguments);\n        this.keys = ['P'];\n        // Since Vim 9.0, Visual `P` does not overwrite the unnamed register with selection's contents\n        this.overwritesRegisterWithSelection = false;\n    }\n    putBefore() {\n        return true;\n    }\n    adjustLinewiseRegisterText(mode, text) {\n        if (mode === mode_1.Mode.Normal || mode === mode_1.Mode.VisualBlock) {\n            return text + '\\n';\n        }\n        return super.adjustLinewiseRegisterText(mode, text);\n    }\n    getReplaceRange(mode, cursor, registerMode) {\n        if (mode === mode_1.Mode.Normal) {\n            if (registerMode === register_1.RegisterMode.CharacterWise || registerMode === register_1.RegisterMode.BlockWise) {\n                const pos = cursor.stop;\n                return new vscode.Range(pos, pos);\n            }\n            else if (registerMode === register_1.RegisterMode.LineWise) {\n                const pos = cursor.stop.getLineBegin();\n                return new vscode.Range(pos, pos);\n            }\n        }\n        return super.getReplaceRange(mode, cursor, registerMode);\n    }\n    getCursorPosition(document, mode, replaceRange, registerMode, count, text) {\n        const rangeStart = replaceRange.start;\n        if (mode === mode_1.Mode.Normal || mode === mode_1.Mode.VisualBlock) {\n            if (registerMode === register_1.RegisterMode.LineWise) {\n                return rangeStart.with({ character: firstNonBlankChar(text) });\n            }\n        }\n        return super.getCursorPosition(document, mode, replaceRange, registerMode, count, text);\n    }\n};\nPutBeforeCommand = __decorate([\n    base_1.RegisterAction\n], PutBeforeCommand);\nfunction PlaceCursorAfterText(Base) {\n    return class CursorAfterText extends Base {\n        getCursorPosition(document, mode, replaceRange, registerMode, count, text) {\n            const rangeStart = replaceRange.start;\n            if (mode === mode_1.Mode.Normal || mode === mode_1.Mode.Visual) {\n                if (registerMode === register_1.RegisterMode.CharacterWise) {\n                    if (text.includes('\\n')) {\n                        // Weird case: if there's a newline, the cursor goes to the same place, regardless of [count]\n                        // HACK: We're undoing the repeat() here - definitely a bit janky\n                        text = text.slice(0, text.length / count);\n                    }\n                    return rangeStart.advancePositionByText(text);\n                }\n                else if (registerMode === register_1.RegisterMode.LineWise) {\n                    let line = rangeStart.line + text.split('\\n').length;\n                    if (mode === mode_1.Mode.Visual ||\n                        (!this.putBefore() && rangeStart.line < document.lineCount - 1)) {\n                        line++;\n                    }\n                    return new vscode_1.Position(line, 0);\n                }\n                else if (registerMode === register_1.RegisterMode.BlockWise) {\n                    const lines = text.split('\\n');\n                    const lastLine = rangeStart.line + lines.length - 1;\n                    const longestLineLength = Math.max(...lines.map((line) => line.length));\n                    return new vscode_1.Position(lastLine, rangeStart.character + longestLineLength);\n                }\n            }\n            else if (mode === mode_1.Mode.VisualLine) {\n                return new vscode_1.Position(rangeStart.line + text.split('\\n').length, 0);\n            }\n            else if (mode === mode_1.Mode.VisualBlock) {\n                const lines = text.split('\\n');\n                if (registerMode === register_1.RegisterMode.LineWise) {\n                    if (this.putBefore()) {\n                        return new vscode_1.Position(rangeStart.line + lines.length, 0);\n                    }\n                    else {\n                        return new vscode_1.Position(replaceRange.end.line + lines.length + 1, 0);\n                    }\n                }\n                else if (registerMode === register_1.RegisterMode.BlockWise) {\n                    return new vscode_1.Position(replaceRange.start.line + lines.length - 1, replaceRange.start.character + lines[lines.length - 1].length);\n                }\n                else {\n                    return rangeStart.with({ character: rangeStart.character + text.length });\n                }\n            }\n            return super.getCursorPosition(document, mode, replaceRange, registerMode, count, text);\n        }\n    };\n}\nlet GPutCommand = class GPutCommand extends PutCommand {\n    constructor() {\n        super(...arguments);\n        this.keys = ['g', 'p'];\n    }\n};\nGPutCommand = __decorate([\n    base_1.RegisterAction,\n    PlaceCursorAfterText\n], GPutCommand);\nlet GPutBeforeCommand = class GPutBeforeCommand extends PutBeforeCommand {\n    constructor() {\n        super(...arguments);\n        this.keys = ['g', 'P'];\n        this.overwritesRegisterWithSelection = true;\n    }\n};\nGPutBeforeCommand = __decorate([\n    base_1.RegisterAction,\n    PlaceCursorAfterText\n], GPutBeforeCommand);\nfunction AdjustIndent(Base) {\n    return class AdjustedIndent extends Base {\n        shouldAdjustIndent(mode, registerMode) {\n            return ((mode === mode_1.Mode.Normal || mode === mode_1.Mode.VisualLine) && registerMode === register_1.RegisterMode.LineWise);\n        }\n    };\n}\nlet PutWithIndentCommand = class PutWithIndentCommand extends PutCommand {\n    constructor() {\n        super(...arguments);\n        this.keys = [']', 'p'];\n    }\n};\nPutWithIndentCommand = __decorate([\n    base_1.RegisterAction,\n    AdjustIndent\n], PutWithIndentCommand);\nlet PutBeforeWithIndentCommand = class PutBeforeWithIndentCommand extends PutBeforeCommand {\n    constructor() {\n        super(...arguments);\n        this.keys = [\n            ['[', 'P'],\n            [']', 'P'],\n            ['[', 'p'],\n        ];\n    }\n};\nPutBeforeWithIndentCommand = __decorate([\n    base_1.RegisterAction,\n    AdjustIndent\n], PutBeforeWithIndentCommand);\nfunction ExCommand(Base) {\n    return class Ex extends Base {\n        setInsertionLine(insertLine) {\n            this.insertLine = insertLine;\n        }\n        getRegisterMode(register) {\n            return register_1.RegisterMode.LineWise;\n        }\n        getReplaceRange(mode, cursor, registerMode) {\n            const line = this.insertLine ?? (0, position_1.laterOf)(cursor.start, cursor.stop).line;\n            const pos = this.putBefore() ? new vscode_1.Position(line, 0) : new vscode_1.Position(line, 0).getLineEnd();\n            return new vscode.Range(pos, pos);\n        }\n        getCursorPosition(document, mode, replaceRange, registerMode, count, text) {\n            const lines = text.split('\\n');\n            return new vscode_1.Position(replaceRange.start.line + lines.length - (this.putBefore() ? 1 : 0), firstNonBlankChar(lines[lines.length - 1]));\n        }\n    };\n}\nexports.PutFromCmdLine = ExCommand(PutCommand);\nexports.PutBeforeFromCmdLine = ExCommand(PutBeforeCommand);\n\n\n//# sourceURL=webpack://vim/./src/actions/commands/put.ts?")},"./src/actions/commands/replace.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst vscode_1 = __webpack_require__(/*! vscode */ \"vscode\");\nconst position_1 = __webpack_require__(/*! ../../common/motion/position */ \"./src/common/motion/position.ts\");\nconst mode_1 = __webpack_require__(/*! ../../mode/mode */ \"./src/mode/mode.ts\");\nconst base_1 = __webpack_require__(/*! ../base */ \"./src/actions/base.ts\");\nlet ExitReplaceMode = class ExitReplaceMode extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Replace];\n        this.keys = [['<Esc>'], ['<C-c>'], ['<C-[>']];\n    }\n    async exec(position, vimState) {\n        if (vimState.modeData.mode !== mode_1.Mode.Replace) {\n            throw new Error(`Unexpected mode ${vimState.modeData.mode} in ExitReplaceMode`);\n        }\n        const timesToRepeat = vimState.modeData.replaceState.timesToRepeat;\n        const cursorIdx = this.multicursorIndex ?? 0;\n        const changes = vimState.modeData.replaceState.getChanges(cursorIdx);\n        // `3Rabc` results in 'abc' replacing the next characters 2 more times\n        if (changes && timesToRepeat > 1) {\n            const newText = changes\n                .map((change) => change.after)\n                .join('')\n                .repeat(timesToRepeat - 1);\n            vimState.recordedState.transformer.replace(new vscode_1.Range(position, position.getRight(newText.length)), newText);\n        }\n        else {\n            vimState.cursorStopPosition = vimState.cursorStopPosition.getLeft();\n        }\n        if (this.multicursorIndex === vimState.cursors.length - 1) {\n            await vimState.setCurrentMode(mode_1.Mode.Normal);\n        }\n    }\n};\nExitReplaceMode = __decorate([\n    base_1.RegisterAction\n], ExitReplaceMode);\nlet ReplaceModeToInsertMode = class ReplaceModeToInsertMode extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Replace];\n        this.keys = ['<Insert>'];\n    }\n    async exec(position, vimState) {\n        await vimState.setCurrentMode(mode_1.Mode.Insert);\n    }\n};\nReplaceModeToInsertMode = __decorate([\n    base_1.RegisterAction\n], ReplaceModeToInsertMode);\nlet BackspaceInReplaceMode = class BackspaceInReplaceMode extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Replace];\n        this.keys = [['<BS>'], ['<S-BS>'], ['<C-BS>'], ['<C-h>']];\n    }\n    async exec(position, vimState) {\n        if (vimState.modeData.mode !== mode_1.Mode.Replace) {\n            throw new Error(`Unexpected mode ${vimState.modeData.mode} in BackspaceInReplaceMode`);\n        }\n        const cursorIdx = this.multicursorIndex ?? 0;\n        const changes = vimState.modeData.replaceState.getChanges(cursorIdx);\n        if (changes.length === 0) {\n            // If you backspace before the beginning of where you started to replace, just move the cursor back.\n            const newPosition = position.getLeftThroughLineBreaks();\n            vimState.modeData.replaceState.resetChanges(cursorIdx);\n            vimState.cursorStopPosition = newPosition;\n            vimState.cursorStartPosition = newPosition;\n        }\n        else {\n            const { before } = changes.pop();\n            if (before === '') {\n                // We've gone beyond the originally existing text; just backspace.\n                // TODO: should this use a 'deleteLeft' transformation?\n                vimState.recordedState.transformer.addTransformation({\n                    type: 'deleteRange',\n                    range: new vscode_1.Range(position.getLeftThroughLineBreaks(), position),\n                });\n            }\n            else {\n                vimState.recordedState.transformer.addTransformation({\n                    type: 'replaceText',\n                    text: before,\n                    range: new vscode_1.Range(position.getLeft(), position),\n                    diff: position_1.PositionDiff.offset({ character: -1 }),\n                });\n            }\n        }\n    }\n};\nBackspaceInReplaceMode = __decorate([\n    base_1.RegisterAction\n], BackspaceInReplaceMode);\nlet ReplaceInReplaceMode = class ReplaceInReplaceMode extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Replace];\n        this.keys = ['<character>'];\n        this.createsUndoPoint = true;\n    }\n    async exec(position, vimState) {\n        if (vimState.modeData.mode !== mode_1.Mode.Replace) {\n            throw new Error(`Unexpected mode ${vimState.modeData.mode} in ReplaceInReplaceMode`);\n        }\n        const char = this.keysPressed[0];\n        const isNewLineOrTab = char === '\\n' || char === '<tab>';\n        const replaceRange = new vscode_1.Range(position, position.getRight());\n        let before = vimState.document.getText(replaceRange);\n        if (!position.isLineEnd() && !isNewLineOrTab) {\n            vimState.recordedState.transformer.addTransformation({\n                type: 'replaceText',\n                text: char,\n                range: replaceRange,\n                diff: position_1.PositionDiff.offset({ character: 1 }),\n            });\n        }\n        else if (char === '<tab>') {\n            vimState.recordedState.transformer.delete(replaceRange);\n            vimState.recordedState.transformer.vscodeCommand('tab');\n        }\n        else {\n            vimState.recordedState.transformer.insert(position, char);\n            before = '';\n        }\n        vimState.modeData.replaceState.getChanges(this.multicursorIndex ?? 0).push({\n            before,\n            after: char,\n        });\n    }\n};\nReplaceInReplaceMode = __decorate([\n    base_1.RegisterAction\n], ReplaceInReplaceMode);\nlet CreateUndoPoint = class CreateUndoPoint extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Replace];\n        this.keys = ['<C-g>', 'u'];\n    }\n    async exec(position, vimState) {\n        vimState.historyTracker.addChange(true);\n        vimState.historyTracker.finishCurrentStep();\n    }\n};\nCreateUndoPoint = __decorate([\n    base_1.RegisterAction\n], CreateUndoPoint);\n\n\n//# sourceURL=webpack://vim/./src/actions/commands/replace.ts?")},"./src/actions/commands/scroll.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst vscode = __importStar(__webpack_require__(/*! vscode */ \"vscode\"));\nconst lodash_1 = __webpack_require__(/*! lodash */ \"./node_modules/lodash/lodash.js\");\nconst vscode_1 = __webpack_require__(/*! vscode */ \"vscode\");\nconst configuration_1 = __webpack_require__(/*! ../../configuration/configuration */ \"./src/configuration/configuration.ts\");\nconst mode_1 = __webpack_require__(/*! ../../mode/mode */ \"./src/mode/mode.ts\");\nconst textEditor_1 = __webpack_require__(/*! ../../textEditor */ \"./src/textEditor.ts\");\nconst base_1 = __webpack_require__(/*! ../base */ \"./src/actions/base.ts\");\nclass CommandEditorScroll extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n        this.runsOnceForEachCountPrefix = false;\n    }\n    async exec(position, vimState) {\n        const timesToRepeat = vimState.recordedState.count || 1;\n        const scrolloff = configuration_1.configuration\n            .getConfiguration('editor')\n            .get('cursorSurroundingLines', 0);\n        const visibleRange = vimState.editor.visibleRanges[0];\n        if (visibleRange === undefined) {\n            return;\n        }\n        const linesAboveCursor = visibleRange.end.line - vimState.cursorStopPosition.line - timesToRepeat;\n        const linesBelowCursor = vimState.cursorStopPosition.line - visibleRange.start.line - timesToRepeat;\n        if (this.to === 'up' && scrolloff > linesAboveCursor) {\n            vimState.cursorStopPosition = vimState.cursorStopPosition\n                .getUp(scrolloff - linesAboveCursor)\n                .withColumn(vimState.desiredColumn);\n        }\n        else if (this.to === 'down' && scrolloff > linesBelowCursor) {\n            vimState.cursorStopPosition = vimState.cursorStopPosition\n                .getDown(scrolloff - linesBelowCursor)\n                .withColumn(vimState.desiredColumn);\n        }\n        vimState.postponedCodeViewChanges.push({\n            command: 'editorScroll',\n            args: {\n                to: this.to,\n                by: this.by,\n                value: timesToRepeat,\n                select: (0, mode_1.isVisualMode)(vimState.currentMode),\n            },\n        });\n    }\n}\nlet CommandCtrlE = class CommandCtrlE extends CommandEditorScroll {\n    constructor() {\n        super(...arguments);\n        this.keys = ['<C-e>'];\n        this.preservesDesiredColumn = true;\n        this.to = 'down';\n        this.by = 'line';\n    }\n};\nCommandCtrlE = __decorate([\n    base_1.RegisterAction\n], CommandCtrlE);\nlet CommandCtrlY = class CommandCtrlY extends CommandEditorScroll {\n    constructor() {\n        super(...arguments);\n        this.keys = ['<C-y>'];\n        this.preservesDesiredColumn = true;\n        this.to = 'up';\n        this.by = 'line';\n    }\n};\nCommandCtrlY = __decorate([\n    base_1.RegisterAction\n], CommandCtrlY);\n/**\n * Commands like `<C-d>` and `<C-f>` act *sort* of like `<count><C-e>`, but they move\n * your cursor down and put it on the first non-whitespace character of the line.\n */\nclass CommandScrollAndMoveCursor extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n        this.runsOnceForEachCountPrefix = false;\n    }\n    async exec(position, vimState) {\n        const { visibleRanges } = vimState.editor;\n        if (visibleRanges.length === 0) {\n            return;\n        }\n        const smoothScrolling = configuration_1.configuration\n            .getConfiguration('editor')\n            .get('smoothScrolling', false);\n        const timesToRepeat = vimState.recordedState.count || 1;\n        const moveLines = timesToRepeat * this.getNumLines(visibleRanges);\n        let scrollLines = moveLines;\n        if (this.to === 'down') {\n            // This makes <C-d> less wonky when `editor.scrollBeyondLastLine` is enabled\n            scrollLines = Math.min(moveLines, vimState.document.lineCount - 1 - visibleRanges[visibleRanges.length - 1].end.line);\n        }\n        if (scrollLines > 0) {\n            const args = {\n                to: this.to,\n                by: 'line',\n                value: scrollLines,\n                revealCursor: smoothScrolling,\n                select: (0, mode_1.isVisualMode)(vimState.currentMode),\n            };\n            if (smoothScrolling) {\n                await vscode.commands.executeCommand('editorScroll', args);\n            }\n            else {\n                vimState.postponedCodeViewChanges.push({\n                    command: 'editorScroll',\n                    args,\n                });\n            }\n        }\n        const newPositionLine = (0, lodash_1.clamp)(position.line + (this.to === 'down' ? moveLines : -moveLines), 0, vimState.document.lineCount - 1);\n        vimState.cursorStopPosition = new vscode_1.Position(newPositionLine, vimState.desiredColumn).obeyStartOfLine(vimState.document);\n    }\n}\nlet CommandMoveFullPageUp = class CommandMoveFullPageUp extends CommandScrollAndMoveCursor {\n    constructor() {\n        super(...arguments);\n        this.keys = ['<C-b>'];\n        this.to = 'up';\n    }\n    getNumLines(visibleRanges) {\n        return visibleRanges[0].end.line - visibleRanges[0].start.line;\n    }\n};\nCommandMoveFullPageUp = __decorate([\n    base_1.RegisterAction\n], CommandMoveFullPageUp);\nlet CommandMoveFullPageDown = class CommandMoveFullPageDown extends CommandScrollAndMoveCursor {\n    constructor() {\n        super(...arguments);\n        this.keys = ['<C-f>'];\n        this.to = 'down';\n    }\n    getNumLines(visibleRanges) {\n        return visibleRanges[0].end.line - visibleRanges[0].start.line;\n    }\n};\nCommandMoveFullPageDown = __decorate([\n    base_1.RegisterAction\n], CommandMoveFullPageDown);\nlet CommandMoveHalfPageDown = class CommandMoveHalfPageDown extends CommandScrollAndMoveCursor {\n    constructor() {\n        super(...arguments);\n        this.keys = ['<C-d>'];\n        this.to = 'down';\n    }\n    getNumLines(visibleRanges) {\n        return configuration_1.configuration.getScrollLines(visibleRanges);\n    }\n};\nCommandMoveHalfPageDown = __decorate([\n    base_1.RegisterAction\n], CommandMoveHalfPageDown);\nlet CommandMoveHalfPageUp = class CommandMoveHalfPageUp extends CommandScrollAndMoveCursor {\n    constructor() {\n        super(...arguments);\n        this.keys = ['<C-u>'];\n        this.to = 'up';\n    }\n    getNumLines(visibleRanges) {\n        return configuration_1.configuration.getScrollLines(visibleRanges);\n    }\n};\nCommandMoveHalfPageUp = __decorate([\n    base_1.RegisterAction\n], CommandMoveHalfPageUp);\nlet CommandCenterScroll = class CommandCenterScroll extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n        this.keys = ['z', 'z'];\n        this.preservesDesiredColumn = true;\n    }\n    doesActionApply(vimState, keysPressed) {\n        // Don't run if there's an operator because the Sneak plugin uses <operator>z\n        return (super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined);\n    }\n    async exec(position, vimState) {\n        // In these modes you want to center on the cursor position\n        vimState.editor.revealRange(new vscode.Range(vimState.cursorStopPosition, vimState.cursorStopPosition), vscode.TextEditorRevealType.InCenter);\n    }\n};\nCommandCenterScroll = __decorate([\n    base_1.RegisterAction\n], CommandCenterScroll);\nlet CommandCenterScrollFirstChar = class CommandCenterScrollFirstChar extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n        this.keys = ['z', '.'];\n    }\n    doesActionApply(vimState, keysPressed) {\n        // Don't run if there's an operator because the Sneak plugin uses <operator>z\n        return (super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined);\n    }\n    async exec(position, vimState) {\n        // In these modes you want to center on the cursor position\n        // This particular one moves cursor to first non blank char though\n        vimState.editor.revealRange(new vscode.Range(vimState.cursorStopPosition, vimState.cursorStopPosition), vscode.TextEditorRevealType.InCenter);\n        // Move cursor to first char of line\n        vimState.cursorStopPosition = textEditor_1.TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, vimState.cursorStopPosition.line);\n    }\n};\nCommandCenterScrollFirstChar = __decorate([\n    base_1.RegisterAction\n], CommandCenterScrollFirstChar);\nlet CommandTopScroll = class CommandTopScroll extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n        this.keys = ['z', 't'];\n        this.preservesDesiredColumn = true;\n    }\n    doesActionApply(vimState, keysPressed) {\n        // Don't run if there's an operator because the Sneak plugin uses <operator>z\n        return (super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined);\n    }\n    async exec(position, vimState) {\n        vimState.postponedCodeViewChanges.push({\n            command: 'revealLine',\n            args: {\n                lineNumber: position.line,\n                at: 'top',\n            },\n        });\n    }\n};\nCommandTopScroll = __decorate([\n    base_1.RegisterAction\n], CommandTopScroll);\nlet CommandTopScrollFirstChar = class CommandTopScrollFirstChar extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n        this.keys = ['z', '\\n'];\n    }\n    doesActionApply(vimState, keysPressed) {\n        // Don't run if there's an operator because the Sneak plugin uses <operator>z\n        return (super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined);\n    }\n    async exec(position, vimState) {\n        // In these modes you want to center on the cursor position\n        // This particular one moves cursor to first non blank char though\n        vimState.postponedCodeViewChanges.push({\n            command: 'revealLine',\n            args: {\n                lineNumber: position.line,\n                at: 'top',\n            },\n        });\n        // Move cursor to first char of line\n        vimState.cursorStopPosition = textEditor_1.TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, vimState.cursorStopPosition.line);\n    }\n};\nCommandTopScrollFirstChar = __decorate([\n    base_1.RegisterAction\n], CommandTopScrollFirstChar);\nlet CommandBottomScroll = class CommandBottomScroll extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n        this.keys = ['z', 'b'];\n        this.preservesDesiredColumn = true;\n    }\n    doesActionApply(vimState, keysPressed) {\n        // Don't run if there's an operator because the Sneak plugin uses <operator>z\n        return (super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined);\n    }\n    async exec(position, vimState) {\n        vimState.postponedCodeViewChanges.push({\n            command: 'revealLine',\n            args: {\n                lineNumber: position.line,\n                at: 'bottom',\n            },\n        });\n    }\n};\nCommandBottomScroll = __decorate([\n    base_1.RegisterAction\n], CommandBottomScroll);\nlet CommandBottomScrollFirstChar = class CommandBottomScrollFirstChar extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n        this.keys = ['z', '-'];\n    }\n    doesActionApply(vimState, keysPressed) {\n        // Don't run if there's an operator because the Sneak plugin uses <operator>z\n        return (super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined);\n    }\n    async exec(position, vimState) {\n        // In these modes you want to center on the cursor position\n        // This particular one moves cursor to first non blank char though\n        vimState.postponedCodeViewChanges.push({\n            command: 'revealLine',\n            args: {\n                lineNumber: position.line,\n                at: 'bottom',\n            },\n        });\n        // Move cursor to first char of line\n        vimState.cursorStopPosition = textEditor_1.TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, vimState.cursorStopPosition.line);\n    }\n};\nCommandBottomScrollFirstChar = __decorate([\n    base_1.RegisterAction\n], CommandBottomScrollFirstChar);\n\n\n//# sourceURL=webpack://vim/./src/actions/commands/scroll.ts?")},"./src/actions/commands/search.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst _ = __importStar(__webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js"));\nconst lodash_1 = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");\nconst vscode_1 = __webpack_require__(/*! vscode */ "vscode");\nconst commandLine_1 = __webpack_require__(/*! ../../cmd_line/commandLine */ "./src/cmd_line/commandLine.ts");\nconst position_1 = __webpack_require__(/*! ../../common/motion/position */ "./src/common/motion/position.ts");\nconst configuration_1 = __webpack_require__(/*! ../../configuration/configuration */ "./src/configuration/configuration.ts");\nconst error_1 = __webpack_require__(/*! ../../error */ "./src/error.ts");\nconst mode_1 = __webpack_require__(/*! ../../mode/mode */ "./src/mode/mode.ts");\nconst register_1 = __webpack_require__(/*! ../../register/register */ "./src/register/register.ts");\nconst globalState_1 = __webpack_require__(/*! ../../state/globalState */ "./src/state/globalState.ts");\nconst searchState_1 = __webpack_require__(/*! ../../state/searchState */ "./src/state/searchState.ts");\nconst statusBar_1 = __webpack_require__(/*! ../../statusBar */ "./src/statusBar.ts");\nconst textEditor_1 = __webpack_require__(/*! ../../textEditor */ "./src/textEditor.ts");\nconst textobject_1 = __webpack_require__(/*! ../../textobject/textobject */ "./src/textobject/textobject.ts");\nconst statusBarTextUtils_1 = __webpack_require__(/*! ../../util/statusBarTextUtils */ "./src/util/statusBarTextUtils.ts");\nconst pattern_1 = __webpack_require__(/*! ../../vimscript/pattern */ "./src/vimscript/pattern.ts");\nconst base_1 = __webpack_require__(/*! ../base */ "./src/actions/base.ts");\nconst baseMotion_1 = __webpack_require__(/*! ../baseMotion */ "./src/actions/baseMotion.ts");\n/**\n * Search for the word under the cursor; used by [g]* and [g]#\n */\nasync function searchCurrentWord(position, vimState, direction, isExact) {\n    let currentWord = textEditor_1.TextEditor.getWord(vimState.document, position);\n    if (currentWord) {\n        if (/\\W/.test(currentWord[0]) || /\\W/.test(currentWord[currentWord.length - 1])) {\n            // TODO: this kind of sucks. JS regex does not consider the boundary between a special\n            // character and whitespace to be a "word boundary", so we can\'t easily do an exact search.\n            isExact = false;\n        }\n        if (isExact) {\n            currentWord = _.escapeRegExp(currentWord);\n        }\n        // If the search is going left then use `getWordLeft()` on position to start\n        // at the beginning of the word. This ensures that any matches happen\n        // outside of the currently selected word.\n        const searchStartCursorPosition = direction === pattern_1.SearchDirection.Backward\n            ? vimState.cursorStopPosition.prevWordStart(vimState.document, { inclusive: true })\n            : vimState.cursorStopPosition;\n        await createSearchStateAndMoveToMatch({\n            needle: currentWord,\n            vimState,\n            direction,\n            isExact,\n            searchStartCursorPosition,\n        });\n    }\n    else {\n        statusBar_1.StatusBar.displayError(vimState, error_1.VimError.fromCode(error_1.ErrorCode.NoStringUnderCursor));\n    }\n}\n/**\n * Search for the word under the cursor; used by [g]* and [g]# in visual mode when `visualstar` is enabled\n */\nasync function searchCurrentSelection(vimState, direction) {\n    const currentSelection = vimState.document.getText(vimState.editor.selection);\n    // Go back to Normal mode, otherwise the selection grows to the next match.\n    await vimState.setCurrentMode(mode_1.Mode.Normal);\n    const [start, end] = (0, position_1.sorted)(vimState.cursorStartPosition, vimState.cursorStopPosition);\n    // Ensure that any matches happen outside of the currently selected word.\n    const searchStartCursorPosition = direction === pattern_1.SearchDirection.Backward ? start.getLeft() : end.getRight();\n    await createSearchStateAndMoveToMatch({\n        needle: currentSelection,\n        vimState,\n        direction,\n        isExact: false,\n        searchStartCursorPosition,\n    });\n}\n/**\n * Used by [g]* and [g]#\n */\nasync function createSearchStateAndMoveToMatch(args) {\n    const { needle, vimState, isExact } = args;\n    if (needle.length === 0) {\n        return;\n    }\n    const escapedNeedle = (0, lodash_1.escapeRegExp)(needle).replace(\'/\', \'\\\\/\');\n    const searchString = isExact ? `\\\\<${escapedNeedle}\\\\>` : escapedNeedle;\n    // Start a search for the given term.\n    globalState_1.globalState.searchState = new searchState_1.SearchState(args.direction, vimState.cursorStopPosition, searchString, { ignoreSmartcase: true });\n    register_1.Register.setReadonlyRegister(\'/\', globalState_1.globalState.searchState.searchString);\n    void commandLine_1.SearchCommandLine.addSearchStateToHistory(globalState_1.globalState.searchState);\n    // Turn one of the highlighting flags back on (turned off with :nohl)\n    globalState_1.globalState.hl = true;\n    const nextMatch = globalState_1.globalState.searchState.getNextSearchMatchPosition(vimState, args.searchStartCursorPosition);\n    if (nextMatch) {\n        vimState.cursorStopPosition = nextMatch.pos;\n        (0, statusBarTextUtils_1.reportSearch)(nextMatch.index, globalState_1.globalState.searchState.getMatchRanges(vimState).length, vimState);\n    }\n    else {\n        statusBar_1.StatusBar.displayError(vimState, error_1.VimError.fromCode(args.direction === pattern_1.SearchDirection.Forward\n            ? error_1.ErrorCode.SearchHitBottom\n            : error_1.ErrorCode.SearchHitTop, globalState_1.globalState.searchState.searchString));\n    }\n}\nlet CommandSearchCurrentWordExactForward = class CommandSearchCurrentWordExactForward extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n        this.keys = [\'*\'];\n        this.actionType = \'motion\';\n        this.runsOnceForEachCountPrefix = true;\n        this.isJump = true;\n    }\n    async exec(position, vimState) {\n        if ((0, mode_1.isVisualMode)(vimState.currentMode) && configuration_1.configuration.visualstar) {\n            await searchCurrentSelection(vimState, pattern_1.SearchDirection.Forward);\n        }\n        else {\n            await searchCurrentWord(position, vimState, pattern_1.SearchDirection.Forward, true);\n        }\n    }\n};\nCommandSearchCurrentWordExactForward = __decorate([\n    base_1.RegisterAction\n], CommandSearchCurrentWordExactForward);\nlet CommandSearchCurrentWordForward = class CommandSearchCurrentWordForward extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n        this.keys = [\'g\', \'*\'];\n        this.actionType = \'motion\';\n        this.runsOnceForEachCountPrefix = true;\n        this.isJump = true;\n    }\n    async exec(position, vimState) {\n        await searchCurrentWord(position, vimState, pattern_1.SearchDirection.Forward, false);\n    }\n};\nCommandSearchCurrentWordForward = __decorate([\n    base_1.RegisterAction\n], CommandSearchCurrentWordForward);\nlet CommandSearchCurrentWordExactBackward = class CommandSearchCurrentWordExactBackward extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n        this.keys = [\'#\'];\n        this.actionType = \'motion\';\n        this.runsOnceForEachCountPrefix = true;\n        this.isJump = true;\n    }\n    async exec(position, vimState) {\n        if ((0, mode_1.isVisualMode)(vimState.currentMode) && configuration_1.configuration.visualstar) {\n            await searchCurrentSelection(vimState, pattern_1.SearchDirection.Backward);\n        }\n        else {\n            await searchCurrentWord(position, vimState, pattern_1.SearchDirection.Backward, true);\n        }\n    }\n};\nCommandSearchCurrentWordExactBackward = __decorate([\n    base_1.RegisterAction\n], CommandSearchCurrentWordExactBackward);\nlet CommandSearchCurrentWordBackward = class CommandSearchCurrentWordBackward extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n        this.keys = [\'g\', \'#\'];\n        this.actionType = \'motion\';\n        this.runsOnceForEachCountPrefix = true;\n        this.isJump = true;\n    }\n    async exec(position, vimState) {\n        await searchCurrentWord(position, vimState, pattern_1.SearchDirection.Backward, false);\n    }\n};\nCommandSearchCurrentWordBackward = __decorate([\n    base_1.RegisterAction\n], CommandSearchCurrentWordBackward);\nlet CommandSearchForwards = class CommandSearchForwards extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n        this.keys = [\'/\'];\n        this.actionType = \'motion\';\n        this.isJump = true;\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        await vimState.setCurrentMode(mode_1.Mode.SearchInProgressMode);\n    }\n};\nCommandSearchForwards = __decorate([\n    base_1.RegisterAction\n], CommandSearchForwards);\nlet CommandSearchBackwards = class CommandSearchBackwards extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n        this.keys = [\'?\'];\n        this.actionType = \'motion\';\n        this.isJump = true;\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async exec(position, vimState) {\n        // TODO: Better VimState API than this...\n        await vimState.setModeData({\n            mode: mode_1.Mode.SearchInProgressMode,\n            commandLine: new commandLine_1.SearchCommandLine(vimState, \'\', pattern_1.SearchDirection.Backward),\n            firstVisibleLineBeforeSearch: vimState.editor.visibleRanges[0].start.line,\n        });\n    }\n};\nCommandSearchBackwards = __decorate([\n    base_1.RegisterAction\n], CommandSearchBackwards);\nclass SearchObject extends textobject_1.TextObject {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualBlock];\n    }\n    async execAction(position, vimState) {\n        const searchState = globalState_1.globalState.searchState;\n        if (!searchState || searchState.searchString === \'\') {\n            return (0, baseMotion_1.failedMovement)(vimState);\n        }\n        const newSearchState = new searchState_1.SearchState(this.direction, vimState.cursorStopPosition, searchState.searchString, {});\n        // At first, try to search for current word, and stop searching if matched.\n        // Try to search for the next word if not matched or\n        // if the cursor is at the end of a match string in visual-mode.\n        let result = newSearchState.findContainingMatchRange(vimState, vimState.cursorStopPosition);\n        if (result &&\n            vimState.currentMode === mode_1.Mode.Visual &&\n            vimState.cursorStopPosition.isEqual(result.range.end.getLeftThroughLineBreaks())) {\n            result = undefined;\n        }\n        if (result === undefined) {\n            // Try to search for the next word\n            result = newSearchState.getNextSearchMatchRange(vimState, vimState.cursorStopPosition);\n            if (result === undefined) {\n                return (0, baseMotion_1.failedMovement)(vimState);\n            }\n        }\n        (0, statusBarTextUtils_1.reportSearch)(result.index, searchState.getMatchRanges(vimState).length, vimState);\n        const [start, stop] = [\n            vimState.currentMode === mode_1.Mode.Normal ? result.range.start : vimState.cursorStopPosition,\n            result.range.end.getLeftThroughLineBreaks(),\n        ];\n        // Move the cursor, this is a bit hacky...\n        vimState.cursorStartPosition = start;\n        vimState.cursorStopPosition = stop;\n        vimState.editor.selection = new vscode_1.Selection(start, stop);\n        await vimState.setCurrentMode(mode_1.Mode.Visual);\n        return {\n            start,\n            stop,\n        };\n    }\n    async execActionForOperator(position, vimState) {\n        return this.execAction(position, vimState);\n    }\n}\nlet SearchObjectForward = class SearchObjectForward extends SearchObject {\n    constructor() {\n        super(...arguments);\n        this.keys = [\'g\', \'n\'];\n        this.direction = pattern_1.SearchDirection.Forward;\n    }\n};\nSearchObjectForward = __decorate([\n    base_1.RegisterAction\n], SearchObjectForward);\nlet SearchObjectBackward = class SearchObjectBackward extends SearchObject {\n    constructor() {\n        super(...arguments);\n        this.keys = [\'g\', \'N\'];\n        this.direction = pattern_1.SearchDirection.Backward;\n    }\n};\nSearchObjectBackward = __decorate([\n    base_1.RegisterAction\n], SearchObjectBackward);\n\n\n//# sourceURL=webpack://vim/./src/actions/commands/search.ts?')},"./src/actions/commands/window.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst only_1 = __webpack_require__(/*! ../../cmd_line/commands/only */ \"./src/cmd_line/commands/only.ts\");\nconst quit_1 = __webpack_require__(/*! ../../cmd_line/commands/quit */ \"./src/cmd_line/commands/quit.ts\");\nconst mode_1 = __webpack_require__(/*! ../../mode/mode */ \"./src/mode/mode.ts\");\nconst base_1 = __webpack_require__(/*! ../base */ \"./src/actions/base.ts\");\nlet CommandQuit = class CommandQuit extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = [\n            ['<C-w>', 'q'],\n            ['<C-w>', '<C-q>'],\n            ['<C-w>', 'c'],\n            ['<C-w>', '<C-c>'],\n        ];\n    }\n    async exec(position, vimState) {\n        void new quit_1.QuitCommand({}).execute(vimState);\n    }\n};\nCommandQuit = __decorate([\n    base_1.RegisterAction\n], CommandQuit);\nlet CommandOnly = class CommandOnly extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = [\n            ['<C-w>', 'o'],\n            ['<C-w>', '<C-o>'],\n        ];\n    }\n    async exec(position, vimState) {\n        void new only_1.OnlyCommand().execute(vimState);\n    }\n};\nCommandOnly = __decorate([\n    base_1.RegisterAction\n], CommandOnly);\nlet MoveToRightPane = class MoveToRightPane extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n        this.keys = [\n            ['<C-w>', 'l'],\n            ['<C-w>', '<right>'],\n            ['<C-w>', '<C-l>'],\n        ];\n        this.isJump = true;\n    }\n    async exec(position, vimState) {\n        vimState.postponedCodeViewChanges.push({\n            command: 'workbench.action.navigateRight',\n            args: {},\n        });\n    }\n};\nMoveToRightPane = __decorate([\n    base_1.RegisterAction\n], MoveToRightPane);\nlet MoveToLowerPane = class MoveToLowerPane extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n        this.keys = [\n            ['<C-w>', 'j'],\n            ['<C-w>', '<down>'],\n            ['<C-w>', '<C-j>'],\n        ];\n        this.isJump = true;\n    }\n    async exec(position, vimState) {\n        vimState.postponedCodeViewChanges.push({\n            command: 'workbench.action.navigateDown',\n            args: {},\n        });\n    }\n};\nMoveToLowerPane = __decorate([\n    base_1.RegisterAction\n], MoveToLowerPane);\nlet MoveToUpperPane = class MoveToUpperPane extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n        this.keys = [\n            ['<C-w>', 'k'],\n            ['<C-w>', '<up>'],\n            ['<C-w>', '<C-k>'],\n        ];\n        this.isJump = true;\n    }\n    async exec(position, vimState) {\n        vimState.postponedCodeViewChanges.push({\n            command: 'workbench.action.navigateUp',\n            args: {},\n        });\n    }\n};\nMoveToUpperPane = __decorate([\n    base_1.RegisterAction\n], MoveToUpperPane);\nlet MoveToLeftPane = class MoveToLeftPane extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n        this.keys = [\n            ['<C-w>', 'h'],\n            ['<C-w>', '<left>'],\n            ['<C-w>', '<C-h>'],\n        ];\n        this.isJump = true;\n    }\n    async exec(position, vimState) {\n        vimState.postponedCodeViewChanges.push({\n            command: 'workbench.action.navigateLeft',\n            args: {},\n        });\n    }\n};\nMoveToLeftPane = __decorate([\n    base_1.RegisterAction\n], MoveToLeftPane);\nlet CycleThroughPanes = class CycleThroughPanes extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n        this.keys = [\n            ['<C-w>', '<C-w>'],\n            ['<C-w>', 'w'],\n        ];\n        this.isJump = true;\n    }\n    async exec(position, vimState) {\n        vimState.postponedCodeViewChanges.push({\n            command: 'workbench.action.navigateEditorGroups',\n            args: {},\n        });\n    }\n};\nCycleThroughPanes = __decorate([\n    base_1.RegisterAction\n], CycleThroughPanes);\nlet VerticalSplit = class VerticalSplit extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n        this.keys = [\n            ['<C-w>', 'v'],\n            ['<C-w>', '<C-v>'],\n        ];\n    }\n    async exec(position, vimState) {\n        vimState.postponedCodeViewChanges.push({\n            command: 'workbench.action.splitEditor',\n            args: {},\n        });\n    }\n};\nVerticalSplit = __decorate([\n    base_1.RegisterAction\n], VerticalSplit);\nlet OrthogonalSplit = class OrthogonalSplit extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n        this.keys = [\n            ['<C-w>', 's'],\n            ['<C-w>', '<C-s>'],\n        ];\n    }\n    async exec(position, vimState) {\n        vimState.postponedCodeViewChanges.push({\n            command: 'workbench.action.splitEditorOrthogonal',\n            args: {},\n        });\n    }\n};\nOrthogonalSplit = __decorate([\n    base_1.RegisterAction\n], OrthogonalSplit);\nlet EvenPaneWidths = class EvenPaneWidths extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n        this.keys = ['<C-w>', '='];\n    }\n    async exec(position, vimState) {\n        vimState.postponedCodeViewChanges.push({\n            command: 'workbench.action.evenEditorWidths',\n            args: {},\n        });\n    }\n};\nEvenPaneWidths = __decorate([\n    base_1.RegisterAction\n], EvenPaneWidths);\nlet IncreasePaneWidth = class IncreasePaneWidth extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n        this.keys = ['<C-w>', '>'];\n    }\n    async exec(position, vimState) {\n        vimState.postponedCodeViewChanges.push({\n            command: 'workbench.action.increaseViewWidth',\n            args: {},\n        });\n    }\n};\nIncreasePaneWidth = __decorate([\n    base_1.RegisterAction\n], IncreasePaneWidth);\nlet DecreasePaneWidth = class DecreasePaneWidth extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n        this.keys = ['<C-w>', '<'];\n    }\n    async exec(position, vimState) {\n        vimState.postponedCodeViewChanges.push({\n            command: 'workbench.action.decreaseViewWidth',\n            args: {},\n        });\n    }\n};\nDecreasePaneWidth = __decorate([\n    base_1.RegisterAction\n], DecreasePaneWidth);\nlet IncreasePaneHeight = class IncreasePaneHeight extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n        this.keys = ['<C-w>', '+'];\n    }\n    async exec(position, vimState) {\n        vimState.postponedCodeViewChanges.push({\n            command: 'workbench.action.increaseViewHeight',\n            args: {},\n        });\n    }\n};\nIncreasePaneHeight = __decorate([\n    base_1.RegisterAction\n], IncreasePaneHeight);\nlet DecreasePaneHeight = class DecreasePaneHeight extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n        this.keys = ['<C-w>', '-'];\n    }\n    async exec(position, vimState) {\n        vimState.postponedCodeViewChanges.push({\n            command: 'workbench.action.decreaseViewHeight',\n            args: {},\n        });\n    }\n};\nDecreasePaneHeight = __decorate([\n    base_1.RegisterAction\n], DecreasePaneHeight);\n\n\n//# sourceURL=webpack://vim/./src/actions/commands/window.ts?")},"./src/actions/include-main.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n__webpack_require__(/*! ./base */ "./src/actions/base.ts");\n__webpack_require__(/*! ./operator */ "./src/actions/operator.ts");\n__webpack_require__(/*! ./motion */ "./src/actions/motion.ts");\n__webpack_require__(/*! ../textobject/textobject */ "./src/textobject/textobject.ts");\n// commands\n__webpack_require__(/*! ./commands/insert */ "./src/actions/commands/insert.ts");\n__webpack_require__(/*! ./commands/replace */ "./src/actions/commands/replace.ts");\n__webpack_require__(/*! ./commands/actions */ "./src/actions/commands/actions.ts");\n__webpack_require__(/*! ./commands/commandLine */ "./src/actions/commands/commandLine.ts");\n__webpack_require__(/*! ./commands/search */ "./src/actions/commands/search.ts");\n__webpack_require__(/*! ./commands/put */ "./src/actions/commands/put.ts");\n__webpack_require__(/*! ./commands/digraphs */ "./src/actions/commands/digraphs.ts");\n__webpack_require__(/*! ./commands/window */ "./src/actions/commands/window.ts");\n__webpack_require__(/*! ./commands/fold */ "./src/actions/commands/fold.ts");\n__webpack_require__(/*! ./commands/scroll */ "./src/actions/commands/scroll.ts");\n\n\n//# sourceURL=webpack://vim/./src/actions/include-main.ts?')},"./src/actions/languages/python/motion.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PythonDocument = void 0;\nconst vscode_1 = __webpack_require__(/*! vscode */ \"vscode\");\nconst base_1 = __webpack_require__(/*! ../../base */ \"./src/actions/base.ts\");\nconst baseMotion_1 = __webpack_require__(/*! ../../baseMotion */ \"./src/actions/baseMotion.ts\");\n// Older browsers don't support lookbehind - in this case, use an inferior regex rather than crashing\nlet supportsLookbehind = true;\ntry {\n    new RegExp('(?<=x)');\n}\ncatch {\n    supportsLookbehind = false;\n}\n/*\n * Utility class used to parse the lines in the document and\n * determine class and function boundaries\n *\n * The class keeps track of two positions: the ORIGINAL and the CURRENT\n * using their relative locations to make decisions.\n */\nclass PythonDocument {\n    constructor(document) {\n        this._document = document;\n        const parsed = PythonDocument._parseLines(document);\n        this.structure = PythonDocument._parseStructure(parsed);\n    }\n    /*\n     * Generator of the lines of text in the document\n     */\n    static *lines(document) {\n        for (let index = 0; index < document.lineCount; index++) {\n            yield document.lineAt(index).text;\n        }\n    }\n    /*\n     * Calculate the indentation of a line of text.\n     * Lines consisting entirely of whitespace of \"starting\" with a comment are defined\n     * to have an indentation of \"undefined\".\n     */\n    static _indentation(line) {\n        const index = line.search(PythonDocument.reOnlyWhitespace);\n        // Return undefined if line is empty, just whitespace, or starts with a comment\n        if (index === -1 || line[index] === '#') {\n            return undefined;\n        }\n        return index;\n    }\n    /*\n     * Parse a line of text to extract LineInfo\n     * Return undefined if the line is empty or starts with a comment\n     */\n    static _parseLine(index, text) {\n        const indentation = this._indentation(text);\n        // Since indentation === 0 is a valid result we need to check for undefined explicitly\n        return indentation !== undefined ? { line: index, indentation, text } : undefined;\n    }\n    static _parseLines(document) {\n        const lines = [...this.lines(document)]; // convert generator to Array\n        const infos = lines.map((text, index) => this._parseLine(index, text));\n        return infos.filter((x) => x); // filter out empty/comment lines (undefined info)\n    }\n    static _parseStructure(lines) {\n        const last = lines.length;\n        const structure = [];\n        for (let index = 0; index < last; index++) {\n            const info = lines[index];\n            const text = info.text;\n            const match = text.match(PythonDocument.reDefOrClass);\n            if (match) {\n                const type = match[1] === 'def' ? 'function' : 'class';\n                // Find the end of the current function/class\n                let idx = index + 1;\n                for (; idx < last; idx++) {\n                    if (lines[idx].indentation <= info.indentation) {\n                        break;\n                    }\n                }\n                // Since we stop when we find the first line with a less indentation\n                // we pull back one line to get to the end of the function/class\n                idx--;\n                const endLine = lines[idx];\n                structure.push({\n                    type,\n                    start: new vscode_1.Position(info.line, info.indentation),\n                    // Calculate position of last non-white character)\n                    end: new vscode_1.Position(endLine.line, endLine.text.search(PythonDocument.reLastNonWhiteSpaceCharacter) - 1),\n                });\n            }\n        }\n        return structure;\n    }\n    /*\n     * Find the position of the specified:\n     *    type: function or class\n     *    direction: next or prev\n     *    edge: start or end\n     *\n     * With this information one can determine all of the required motions\n     */\n    find(type, direction, edge, position) {\n        // Choose the ordering method name based on direction\n        const isDirection = direction === 'next' ? 'isAfter' : 'isBefore';\n        // Filter function for all elements whose \"edge\" is in the correct \"direction\"\n        // relative to the cursor's position\n        const dir = (element) => element[edge][isDirection](position);\n        // Filter out elements from structure based on type and direction\n        const elements = this.structure.filter((elem) => elem.type === type).filter(dir);\n        if (edge === 'end') {\n            // When moving to an 'end' the elements should be started by the end position\n            elements.sort((a, b) => a.end.line - b.end.line);\n        }\n        // Return the first match if any exist\n        if (elements.length) {\n            // If direction === 'next' return the first element\n            // otherwise return the last element\n            const index = direction === 'next' ? 0 : elements.length - 1;\n            const element = elements[index];\n            const pos = element[edge];\n            // execAction MUST return a fully realized Position object created using new\n            return pos;\n        }\n        return undefined;\n    }\n    // Use PythonDocument instance to move to specified class boundary\n    static moveClassBoundary(document, position, vimState, forward, start) {\n        const direction = forward ? 'next' : 'prev';\n        const edge = start ? 'start' : 'end';\n        return (new PythonDocument(document).find('class', direction, edge, position) ??\n            (0, baseMotion_1.failedMovement)(vimState));\n    }\n}\nexports.PythonDocument = PythonDocument;\nPythonDocument.reOnlyWhitespace = /\\S/;\nPythonDocument.reLastNonWhiteSpaceCharacter = supportsLookbehind\n    ? new RegExp('(?<=\\\\S)\\\\s*$')\n    : /(\\S)\\s*$/;\nPythonDocument.reDefOrClass = /^\\s*(def|class) /;\n// Uses the specified findFunction to execute the motion coupled to the shortcut (keys)\nclass BasePythonMovement extends baseMotion_1.BaseMovement {\n    doesActionApply(vimState, keysPressed) {\n        return (super.doesActionApply(vimState, keysPressed) && vimState.document.languageId === 'python');\n    }\n    async execAction(position, vimState) {\n        const document = vimState.document;\n        return (new PythonDocument(document).find(this.type, this.direction, this.edge, position) ??\n            (0, baseMotion_1.failedMovement)(vimState));\n    }\n}\nlet MovePythonNextFunctionStart = class MovePythonNextFunctionStart extends BasePythonMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = [']', 'm'];\n        this.type = 'function';\n        this.direction = 'next';\n        this.edge = 'start';\n    }\n};\nMovePythonNextFunctionStart = __decorate([\n    base_1.RegisterAction\n], MovePythonNextFunctionStart);\nlet MovePythonPrevFunctionStart = class MovePythonPrevFunctionStart extends BasePythonMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = ['[', 'm'];\n        this.type = 'function';\n        this.direction = 'prev';\n        this.edge = 'start';\n    }\n};\nMovePythonPrevFunctionStart = __decorate([\n    base_1.RegisterAction\n], MovePythonPrevFunctionStart);\nlet MovePythonNextFunctionEnd = class MovePythonNextFunctionEnd extends BasePythonMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = [']', 'M'];\n        this.type = 'function';\n        this.direction = 'next';\n        this.edge = 'end';\n    }\n};\nMovePythonNextFunctionEnd = __decorate([\n    base_1.RegisterAction\n], MovePythonNextFunctionEnd);\nlet MovePythonPrevFunctionEnd = class MovePythonPrevFunctionEnd extends BasePythonMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = ['[', 'M'];\n        this.type = 'function';\n        this.direction = 'prev';\n        this.edge = 'end';\n    }\n};\nMovePythonPrevFunctionEnd = __decorate([\n    base_1.RegisterAction\n], MovePythonPrevFunctionEnd);\n\n\n//# sourceURL=webpack://vim/./src/actions/languages/python/motion.ts?")},"./src/actions/motion.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar MoveFindForward_1, MoveFindBackward_1, MoveTilForward_1, MoveTilBackward_1, MoveToMatchingBracket_1;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MoveAroundTag = exports.MoveInsideTag = exports.MoveAroundBacktick = exports.MoveAroundDoubleQuotes = exports.MoveAroundSingleQuotes = exports.MoveQuoteMatch = exports.MoveAroundSquareBracket = exports.MoveInsideSquareBracket = exports.MoveAroundCaret = exports.MoveInsideCaret = exports.MoveAroundCurlyBrace = exports.MoveInsideCurlyBrace = exports.MoveCurlyBrace = exports.MoveAroundParentheses = exports.MoveInsideParentheses = exports.MoveInsideCharacter = exports.MoveFullWordBegin = exports.MoveWordBegin = exports.ArrowsInInsertMode = exports.ExpandingSelection = void 0;\nconst vscode = __importStar(__webpack_require__(/*! vscode */ \"vscode\"));\nconst operator_1 = __webpack_require__(/*! ./operator */ \"./src/actions/operator.ts\");\nconst textEditor_1 = __webpack_require__(/*! ./../textEditor */ \"./src/textEditor.ts\");\nconst mode_1 = __webpack_require__(/*! ./../mode/mode */ \"./src/mode/mode.ts\");\nconst matcher_1 = __webpack_require__(/*! ./../common/matching/matcher */ \"./src/common/matching/matcher.ts\");\nconst quoteMatcher_1 = __webpack_require__(/*! ./../common/matching/quoteMatcher */ \"./src/common/matching/quoteMatcher.ts\");\nconst base_1 = __webpack_require__(/*! ./base */ \"./src/actions/base.ts\");\nconst register_1 = __webpack_require__(/*! ./../register/register */ \"./src/register/register.ts\");\nconst tagMatcher_1 = __webpack_require__(/*! ./../common/matching/tagMatcher */ \"./src/common/matching/tagMatcher.ts\");\nconst configuration_1 = __webpack_require__(/*! ./../configuration/configuration */ \"./src/configuration/configuration.ts\");\nconst wrapping_1 = __webpack_require__(/*! ./wrapping */ \"./src/actions/wrapping.ts\");\nconst error_1 = __webpack_require__(/*! ../error */ \"./src/error.ts\");\nconst baseMotion_1 = __webpack_require__(/*! ./baseMotion */ \"./src/actions/baseMotion.ts\");\nconst globalState_1 = __webpack_require__(/*! ../state/globalState */ \"./src/state/globalState.ts\");\nconst statusBarTextUtils_1 = __webpack_require__(/*! ../util/statusBarTextUtils */ \"./src/util/statusBarTextUtils.ts\");\nconst sneak_1 = __webpack_require__(/*! ./plugins/sneak */ \"./src/actions/plugins/sneak.ts\");\nconst notation_1 = __webpack_require__(/*! ../configuration/notation */ \"./src/configuration/notation.ts\");\nconst statusBar_1 = __webpack_require__(/*! ../statusBar */ \"./src/statusBar.ts\");\nconst util_1 = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\nconst paragraph_1 = __webpack_require__(/*! ../textobject/paragraph */ \"./src/textobject/paragraph.ts\");\nconst motion_1 = __webpack_require__(/*! ./languages/python/motion */ \"./src/actions/languages/python/motion.ts\");\nconst vscode_1 = __webpack_require__(/*! vscode */ \"vscode\");\nconst position_1 = __webpack_require__(/*! ../common/motion/position */ \"./src/common/motion/position.ts\");\nconst word_1 = __webpack_require__(/*! ../textobject/word */ \"./src/textobject/word.ts\");\nconst actions_1 = __webpack_require__(/*! ./commands/actions */ \"./src/actions/commands/actions.ts\");\nconst pattern_1 = __webpack_require__(/*! ../vimscript/pattern */ \"./src/vimscript/pattern.ts\");\nconst smartQuotesMatcher_1 = __webpack_require__(/*! ./plugins/targets/smartQuotesMatcher */ \"./src/actions/plugins/targets/smartQuotesMatcher.ts\");\nconst targetsConfig_1 = __webpack_require__(/*! ./plugins/targets/targetsConfig */ \"./src/actions/plugins/targets/targetsConfig.ts\");\n/**\n * A movement is something like 'h', 'k', 'w', 'b', 'gg', etc.\n */\nclass ExpandingSelection extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.selectionType = baseMotion_1.SelectionType.Expanding;\n    }\n    adjustPosition(position, result, lastIteration) {\n        if (!lastIteration) {\n            position = result.stop;\n        }\n        return position;\n    }\n}\nexports.ExpandingSelection = ExpandingSelection;\nclass MoveByScreenLine extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n        this.value = 1;\n    }\n    async execAction(position, vimState) {\n        return this.execActionWithCount(position, vimState, 1);\n    }\n    async execActionWithCount(position, vimState, count) {\n        const multicursorIndex = this.multicursorIndex ?? 0;\n        if (multicursorIndex === 0) {\n            if (vimState.currentMode === mode_1.Mode.Visual) {\n                // If we change the `vimState.editor.selections` directly with the forEach\n                // for some reason vscode doesn't update them. But doing it this way does\n                // update vscode's selections.\n                vimState.editor.selections = vimState.editor.selections.map((s, i) => {\n                    if (s.active.isAfter(s.anchor)) {\n                        // The selection is on the right side of the cursor, while our representation\n                        // considers the cursor to be the left edge, so we need to move the selection\n                        // to the right place before executing the 'cursorMove' command.\n                        const active = s.active.getLeftThroughLineBreaks();\n                        return new vscode.Selection(s.anchor, active);\n                    }\n                    else {\n                        return s;\n                    }\n                });\n            }\n            // When we have multicursors and run a 'cursorMove' command, vscode applies that command\n            // to all cursors at the same time. So we should only run it once.\n            await vscode.commands.executeCommand('cursorMove', {\n                to: this.movementType,\n                select: vimState.currentMode !== mode_1.Mode.Normal,\n                // select: ![Mode.Normal, Mode.Insert].includes(vimState.currentMode),\n                by: this.by,\n                value: this.value * count,\n            });\n        }\n        /**\n         * HACK:\n         * The `cursorMove` command is handling the selection for us.\n         * So we are not following our design principal (do no real movement inside an action) here\n         */\n        if (!vimState.editor.selections[multicursorIndex]) {\n            // VS Code selections no longer have the same amount of cursors as we do. This means that\n            // two or more selections combined into one. In this case we return these cursors as they\n            // were with the removed flag so that they can be removed.\n            // TODO: does this work in VisualBlock (where cursors are not 1 to 1 with selections)?\n            return {\n                start: vimState.cursorStartPosition,\n                stop: vimState.cursorStopPosition,\n                removed: true,\n            };\n        }\n        if (vimState.currentMode === mode_1.Mode.Normal) {\n            return vimState.editor.selections[multicursorIndex].active;\n        }\n        else {\n            let start = vimState.editor.selections[multicursorIndex].anchor;\n            const stop = vimState.editor.selections[multicursorIndex].active;\n            // If we are moving up we need to keep getting the left of anchor/start because vscode is\n            // to the right of the character in order to include it but our positions are always on the\n            // left side of the character.\n            // Also when we switch from being before anchor to being after anchor we need to move\n            // the anchor/start to the left as well in order to include the character.\n            if ((start.isAfter(stop) &&\n                vimState.cursorStartPosition.isAfter(vimState.cursorStopPosition)) ||\n                (vimState.cursorStartPosition.isAfter(vimState.cursorStopPosition) &&\n                    start.isBeforeOrEqual(stop))) {\n                start = start.getLeft();\n            }\n            return { start, stop };\n        }\n    }\n    async execActionForOperator(position, vimState) {\n        const multicursorIndex = this.multicursorIndex ?? 0;\n        if (multicursorIndex === 0) {\n            // When we have multicursors and run a 'cursorMove' command, vscode applies that command\n            // to all cursors at the same time. So we should only run it once.\n            await vscode.commands.executeCommand('cursorMove', {\n                to: this.movementType,\n                select: true,\n                by: this.by,\n                value: this.value,\n            });\n        }\n        if (!vimState.editor.selections[multicursorIndex]) {\n            // Vscode selections no longer have the same amount of cursors as we do. This means that\n            // two or more selections combined into one. In this case we return these cursors as they\n            // were with the removed flag so that they can be removed.\n            return {\n                start: vimState.cursorStartPosition,\n                stop: vimState.cursorStopPosition,\n                removed: true,\n            };\n        }\n        return {\n            start: vimState.editor.selections[multicursorIndex].start,\n            stop: vimState.editor.selections[multicursorIndex].end,\n        };\n    }\n}\nclass MoveUpByScreenLine extends MoveByScreenLine {\n    constructor() {\n        super(...arguments);\n        this.keys = [];\n        this.movementType = 'up';\n        this.by = 'wrappedLine';\n        this.value = 1;\n    }\n}\nclass MoveDownByScreenLine extends MoveByScreenLine {\n    constructor() {\n        super(...arguments);\n        this.keys = [];\n        this.movementType = 'down';\n        this.by = 'wrappedLine';\n        this.value = 1;\n    }\n}\nclass MoveByScreenLineMaintainDesiredColumn extends MoveByScreenLine {\n    constructor() {\n        super(...arguments);\n        this.preservesDesiredColumn = true;\n    }\n    async execAction(position, vimState) {\n        const prevDesiredColumn = vimState.desiredColumn;\n        const prevLine = vimState.editor.selection.active.line;\n        if (vimState.currentMode !== mode_1.Mode.Normal) {\n            /**\n             * As VIM and VSCode handle the end of selection index a little\n             * differently we need to sometimes move the cursor at the end\n             * of the selection back by a character.\n             */\n            const start = vimState.editor.selection.start;\n            if ((this.movementType === 'down' && position.line > start.line) ||\n                (this.movementType === 'up' && position.line < prevLine)) {\n                await vscode.commands.executeCommand('cursorMove', {\n                    to: 'left',\n                    select: true,\n                    by: 'character',\n                    value: 1,\n                });\n            }\n        }\n        await vscode.commands.executeCommand('cursorMove', {\n            to: this.movementType,\n            select: vimState.currentMode !== mode_1.Mode.Normal,\n            by: this.by,\n            value: this.value,\n        });\n        if (vimState.currentMode === mode_1.Mode.Normal) {\n            let returnedPos = vimState.editor.selection.active;\n            if (prevLine !== returnedPos.line) {\n                returnedPos = returnedPos.withColumn(prevDesiredColumn);\n            }\n            return returnedPos;\n        }\n        else {\n            /**\n             * cursorMove command is handling the selection for us.\n             * So we are not following our design principal (do no real movement inside an action) here.\n             */\n            let start = vimState.editor.selection.start;\n            let stop = vimState.editor.selection.end;\n            const curPos = vimState.editor.selection.active;\n            // We want to swap the cursor start stop positions based on which direction we are moving, up or down\n            if (start.isEqual(curPos) && !start.isEqual(stop)) {\n                [start, stop] = [stop, start];\n                if (prevLine !== start.line) {\n                    start = start.getLeft();\n                }\n            }\n            if (position.line !== stop.line) {\n                stop = stop.withColumn(prevDesiredColumn);\n            }\n            return { start, stop };\n        }\n    }\n}\nclass MoveDownFoldFix extends MoveByScreenLineMaintainDesiredColumn {\n    constructor() {\n        super(...arguments);\n        this.keys = [];\n        this.movementType = 'down';\n        this.by = 'line';\n        this.value = 1;\n    }\n    async execAction(position, vimState) {\n        if (position.line >= vimState.document.lineCount - 1) {\n            return position;\n        }\n        let t = position;\n        let prevLine = position.line;\n        let prevChar = position.character;\n        const moveDownByScreenLine = new MoveDownByScreenLine();\n        do {\n            t = await moveDownByScreenLine.execAction(t, vimState);\n            t = t instanceof vscode_1.Position ? t : t.stop;\n            const lineChanged = prevLine !== t.line;\n            // wrappedLine movement goes to eol character only when at the last line\n            // thus a column change on wrappedLine movement represents a visual last line\n            const colChanged = prevChar !== t.character;\n            if (lineChanged || !colChanged) {\n                break;\n            }\n            prevChar = t.character;\n            prevLine = t.line;\n        } while (t.line === position.line);\n        return t;\n    }\n}\nlet MoveDown = class MoveDown extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = [['j'], ['<down>'], ['<C-j>'], ['<C-n>']];\n        this.preservesDesiredColumn = true;\n    }\n    async execAction(position, vimState) {\n        if (vimState.currentMode === mode_1.Mode.Insert &&\n            this.keysPressed[0] === '<down>' &&\n            vimState.editor.document.uri.scheme === 'vscode-interactive-input' &&\n            position.line === vimState.document.lineCount - 1 &&\n            vimState.editor.selection.isEmpty) {\n            // navigate history in interactive window\n            await vscode.commands.executeCommand('interactive.history.next');\n            return vimState.editor.selection.active;\n        }\n        if (configuration_1.configuration.foldfix && vimState.currentMode !== mode_1.Mode.VisualBlock) {\n            return new MoveDownFoldFix().execAction(position, vimState);\n        }\n        if (position.line < vimState.document.lineCount - 1) {\n            return position.with({ character: vimState.desiredColumn }).getDown();\n        }\n        else {\n            return position;\n        }\n    }\n    async execActionForOperator(position, vimState) {\n        vimState.currentRegisterMode = register_1.RegisterMode.LineWise;\n        return position.getDown();\n    }\n};\nMoveDown = __decorate([\n    base_1.RegisterAction\n], MoveDown);\nlet MoveUp = class MoveUp extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = [['k'], ['<up>'], ['<C-p>']];\n        this.preservesDesiredColumn = true;\n    }\n    async execAction(position, vimState) {\n        if (vimState.currentMode === mode_1.Mode.Insert &&\n            this.keysPressed[0] === '<up>' &&\n            vimState.editor.document.uri.scheme === 'vscode-interactive-input' &&\n            position.line === 0 &&\n            vimState.editor.selection.isEmpty) {\n            // navigate history in interactive window\n            await vscode.commands.executeCommand('interactive.history.previous');\n            return vimState.editor.selection.active;\n        }\n        if (configuration_1.configuration.foldfix && vimState.currentMode !== mode_1.Mode.VisualBlock) {\n            return new MoveUpFoldFix().execAction(position, vimState);\n        }\n        if (position.line > 0) {\n            return position.with({ character: vimState.desiredColumn }).getUp();\n        }\n        else {\n            return position;\n        }\n    }\n    async execActionForOperator(position, vimState) {\n        vimState.currentRegisterMode = register_1.RegisterMode.LineWise;\n        return position.getUp();\n    }\n};\nMoveUp = __decorate([\n    base_1.RegisterAction\n], MoveUp);\nlet MoveUpFoldFix = class MoveUpFoldFix extends MoveByScreenLineMaintainDesiredColumn {\n    constructor() {\n        super(...arguments);\n        this.keys = [];\n        this.movementType = 'up';\n        this.by = 'line';\n        this.value = 1;\n    }\n    async execAction(position, vimState) {\n        if (position.line === 0) {\n            return position;\n        }\n        let t;\n        const moveUpByScreenLine = new MoveUpByScreenLine();\n        do {\n            t = await moveUpByScreenLine.execAction(position, vimState);\n            t = t instanceof vscode_1.Position ? t : t.stop;\n        } while (t.line === position.line);\n        return t;\n    }\n};\nMoveUpFoldFix = __decorate([\n    base_1.RegisterAction\n], MoveUpFoldFix);\nlet ArrowsInInsertMode = class ArrowsInInsertMode extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Insert];\n        this.keys = [['<up>'], ['<down>'], ['<left>'], ['<right>']];\n    }\n    async execAction(position, vimState) {\n        // Moving with the arrow keys in Insert mode \"resets\" our insertion for the purpose of repeating with dot or `<C-a>`.\n        // No matter how we got into Insert mode, repeating will now be done as if we started with `i`.\n        // Note that this does not affect macros, which re-construct a list of actions based on keypresses.\n        // TODO: ACTUALLY, we should reset this only after something is typed (`Axyz<Left><Esc>.` does repeat the insertion)\n        // TODO: This also should mark an \"insertion end\" for the purpose of `<C-a>` (try `ixyz<Right><C-a>`)\n        vimState.recordedState.actionsRun = [new actions_1.CommandInsertAtCursor()];\n        // Force an undo point to be created\n        vimState.historyTracker.addChange(true);\n        vimState.historyTracker.finishCurrentStep();\n        let newPosition;\n        switch (this.keysPressed[0]) {\n            case '<up>':\n                newPosition = await new MoveUp(this.keysPressed).execAction(position, vimState);\n                break;\n            case '<down>':\n                newPosition = await new MoveDown(this.keysPressed).execAction(position, vimState);\n                break;\n            case '<left>':\n                newPosition = await new MoveLeft(this.keysPressed).execAction(position, vimState);\n                break;\n            case '<right>':\n                newPosition = await new MoveRight(this.keysPressed).execAction(position, vimState);\n                break;\n            default:\n                throw new Error(`Unexpected 'arrow' key: ${this.keys[0]}`);\n        }\n        return newPosition;\n    }\n};\nexports.ArrowsInInsertMode = ArrowsInInsertMode;\nexports.ArrowsInInsertMode = ArrowsInInsertMode = __decorate([\n    base_1.RegisterAction\n], ArrowsInInsertMode);\nlet ArrowsInReplaceMode = class ArrowsInReplaceMode extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Replace];\n        this.keys = [['<up>'], ['<down>'], ['<left>'], ['<right>']];\n    }\n    async execAction(position, vimState) {\n        // Force an undo point to be created\n        vimState.historyTracker.addChange(true);\n        vimState.historyTracker.finishCurrentStep();\n        let newPosition = position;\n        switch (this.keysPressed[0]) {\n            case '<up>':\n                newPosition = await new MoveUp(this.keysPressed).execAction(position, vimState);\n                break;\n            case '<down>':\n                newPosition = await new MoveDown(this.keysPressed).execAction(position, vimState);\n                break;\n            case '<left>':\n                newPosition = await new MoveLeft(this.keysPressed).execAction(position, vimState);\n                break;\n            case '<right>':\n                newPosition = await new MoveRight(this.keysPressed).execAction(position, vimState);\n                break;\n            default:\n                throw new Error(`Unexpected 'arrow' key: ${this.keys[0]}`);\n        }\n        vimState.modeData.replaceState.resetChanges(this.multicursorIndex ?? 0);\n        return newPosition;\n    }\n};\nArrowsInReplaceMode = __decorate([\n    base_1.RegisterAction\n], ArrowsInReplaceMode);\nlet CommandNextSearchMatch = class CommandNextSearchMatch extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = ['n'];\n        this.isJump = true;\n    }\n    async execAction(position, vimState) {\n        const searchState = globalState_1.globalState.searchState;\n        if (!searchState || searchState.searchString === '') {\n            return position;\n        }\n        // Turn one of the highlighting flags back on (turned off with :nohl)\n        globalState_1.globalState.hl = true;\n        if (searchState.getMatchRanges(vimState).length === 0) {\n            statusBar_1.StatusBar.displayError(vimState, error_1.VimError.fromCode(error_1.ErrorCode.PatternNotFound, searchState.searchString));\n            return (0, baseMotion_1.failedMovement)(vimState);\n        }\n        // we have to handle a special case here: searching for $ or \\n,\n        // which we approximate by positionIsEOL. In that case (but only when searching forward)\n        // we need to \"offset\" by getRight for searching the next match, otherwise we get stuck.\n        const searchForward = searchState.direction === pattern_1.SearchDirection.Forward;\n        const positionIsEOL = position.getRight().isEqual(position.getLineEnd());\n        const nextMatch = positionIsEOL && searchForward\n            ? searchState.getNextSearchMatchPosition(vimState, position.getRight())\n            : searchState.getNextSearchMatchPosition(vimState, position);\n        if (!nextMatch) {\n            statusBar_1.StatusBar.displayError(vimState, error_1.VimError.fromCode(searchState.direction === pattern_1.SearchDirection.Forward\n                ? error_1.ErrorCode.SearchHitBottom\n                : error_1.ErrorCode.SearchHitTop, searchState.searchString));\n            return (0, baseMotion_1.failedMovement)(vimState);\n        }\n        (0, statusBarTextUtils_1.reportSearch)(nextMatch.index, searchState.getMatchRanges(vimState).length, vimState);\n        return nextMatch.pos;\n    }\n};\nCommandNextSearchMatch = __decorate([\n    base_1.RegisterAction\n], CommandNextSearchMatch);\nlet CommandPreviousSearchMatch = class CommandPreviousSearchMatch extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = ['N'];\n        this.isJump = true;\n    }\n    async execAction(position, vimState) {\n        const searchState = globalState_1.globalState.searchState;\n        if (!searchState || searchState.searchString === '') {\n            return position;\n        }\n        // Turn one of the highlighting flags back on (turned off with :nohl)\n        globalState_1.globalState.hl = true;\n        if (searchState.getMatchRanges(vimState).length === 0) {\n            statusBar_1.StatusBar.displayError(vimState, error_1.VimError.fromCode(error_1.ErrorCode.PatternNotFound, searchState.searchString));\n            return (0, baseMotion_1.failedMovement)(vimState);\n        }\n        const searchForward = searchState.direction === pattern_1.SearchDirection.Forward;\n        const positionIsEOL = position.getRight().isEqual(position.getLineEnd());\n        // see implementation of n, above.\n        const prevMatch = positionIsEOL && !searchForward\n            ? searchState.getNextSearchMatchPosition(vimState, position.getRight(), pattern_1.SearchDirection.Backward)\n            : searchState.getNextSearchMatchPosition(vimState, position, pattern_1.SearchDirection.Backward);\n        if (!prevMatch) {\n            statusBar_1.StatusBar.displayError(vimState, error_1.VimError.fromCode(searchState.direction === pattern_1.SearchDirection.Forward\n                ? error_1.ErrorCode.SearchHitTop\n                : error_1.ErrorCode.SearchHitBottom, searchState.searchString));\n            return (0, baseMotion_1.failedMovement)(vimState);\n        }\n        (0, statusBarTextUtils_1.reportSearch)(prevMatch.index, searchState.getMatchRanges(vimState).length, vimState);\n        return prevMatch.pos;\n    }\n};\nCommandPreviousSearchMatch = __decorate([\n    base_1.RegisterAction\n], CommandPreviousSearchMatch);\nlet MarkMovementBOL = class MarkMovementBOL extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = [\"'\", '<character>'];\n        this.isJump = true;\n    }\n    async execAction(position, vimState) {\n        const markName = this.keysPressed[1];\n        const mark = vimState.historyTracker.getMark(markName);\n        if (mark === undefined) {\n            throw error_1.VimError.fromCode(error_1.ErrorCode.MarkNotSet);\n        }\n        vimState.currentRegisterMode = register_1.RegisterMode.LineWise;\n        if (mark.isUppercaseMark && mark.document !== undefined) {\n            if (vimState.recordedState.operator && mark.document !== vimState.document) {\n                // Operators don't work across files\n                throw error_1.VimError.fromCode(error_1.ErrorCode.MarkNotSet);\n            }\n            await ensureEditorIsActive(mark.document);\n        }\n        return textEditor_1.TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, mark.position.line);\n    }\n};\nMarkMovementBOL = __decorate([\n    base_1.RegisterAction\n], MarkMovementBOL);\nlet MarkMovement = class MarkMovement extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = ['`', '<character>'];\n        this.isJump = true;\n    }\n    async execAction(position, vimState) {\n        const markName = this.keysPressed[1];\n        const mark = vimState.historyTracker.getMark(markName);\n        if (mark === undefined) {\n            throw error_1.VimError.fromCode(error_1.ErrorCode.MarkNotSet);\n        }\n        if (mark.isUppercaseMark && mark.document !== undefined) {\n            if (vimState.recordedState.operator && mark.document !== vimState.document) {\n                // Operators don't work across files\n                throw error_1.VimError.fromCode(error_1.ErrorCode.MarkNotSet);\n            }\n            await ensureEditorIsActive(mark.document);\n        }\n        return mark.position;\n    }\n};\nMarkMovement = __decorate([\n    base_1.RegisterAction\n], MarkMovement);\nlet NextMark = class NextMark extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = [']', '`'];\n        this.isJump = true;\n    }\n    async execAction(position, vimState) {\n        const positions = vimState.historyTracker\n            .getLocalMarks()\n            .filter((mark) => mark.position.isAfter(position))\n            .map((mark) => mark.position)\n            .sort((x, y) => x.compareTo(y));\n        return positions.length === 0 ? position : positions[0];\n    }\n};\nNextMark = __decorate([\n    base_1.RegisterAction\n], NextMark);\nlet PrevMark = class PrevMark extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = ['[', '`'];\n        this.isJump = true;\n    }\n    async execAction(position, vimState) {\n        const positions = vimState.historyTracker\n            .getLocalMarks()\n            .filter((mark) => mark.position.isBefore(position))\n            .map((mark) => mark.position)\n            .sort((x, y) => y.compareTo(x));\n        return positions.length === 0 ? position : positions[0];\n    }\n};\nPrevMark = __decorate([\n    base_1.RegisterAction\n], PrevMark);\nlet NextMarkLinewise = class NextMarkLinewise extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = [']', \"'\"];\n        this.isJump = true;\n    }\n    async execAction(position, vimState) {\n        vimState.currentRegisterMode = register_1.RegisterMode.LineWise;\n        const lines = vimState.historyTracker\n            .getLocalMarks()\n            .filter((mark) => mark.position.line > position.line)\n            .map((mark) => mark.position.line);\n        const line = lines.length === 0 ? position.line : Math.min(...lines);\n        return new vscode_1.Position(line, 0).getLineBeginRespectingIndent(vimState.document);\n    }\n};\nNextMarkLinewise = __decorate([\n    base_1.RegisterAction\n], NextMarkLinewise);\nlet PrevMarkLinewise = class PrevMarkLinewise extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = ['[', \"'\"];\n        this.isJump = true;\n    }\n    async execAction(position, vimState) {\n        vimState.currentRegisterMode = register_1.RegisterMode.LineWise;\n        const lines = vimState.historyTracker\n            .getLocalMarks()\n            .filter((mark) => mark.position.line < position.line)\n            .map((mark) => mark.position.line);\n        const line = lines.length === 0 ? position.line : Math.max(...lines);\n        return new vscode_1.Position(line, 0).getLineBeginRespectingIndent(vimState.document);\n    }\n};\nPrevMarkLinewise = __decorate([\n    base_1.RegisterAction\n], PrevMarkLinewise);\nasync function ensureEditorIsActive(document) {\n    if (document !== vscode.window.activeTextEditor?.document) {\n        await vscode.window.showTextDocument(document);\n    }\n}\nlet MoveLeft = class MoveLeft extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = [['h'], ['<left>'], ['<BS>'], ['<C-BS>'], ['<S-BS>']];\n    }\n    async execAction(position, vimState) {\n        const getLeftWhile = (p) => {\n            const line = vimState.document.lineAt(p.line).text;\n            const newPosition = p.getLeft();\n            if (newPosition.character === 0) {\n                return newPosition;\n            }\n            if ((0, util_1.isLowSurrogate)(line.charCodeAt(newPosition.character)) &&\n                (0, util_1.isHighSurrogate)(line.charCodeAt(newPosition.character - 1))) {\n                return newPosition.getLeft();\n            }\n            else {\n                return newPosition;\n            }\n        };\n        return (0, wrapping_1.shouldWrapKey)(vimState.currentMode, this.keysPressed[0])\n            ? position.getLeftThroughLineBreaks([mode_1.Mode.Insert, mode_1.Mode.Replace].includes(vimState.currentMode))\n            : getLeftWhile(position);\n    }\n};\nMoveLeft = __decorate([\n    base_1.RegisterAction\n], MoveLeft);\nlet MoveRight = class MoveRight extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = [['l'], ['<right>'], [' ']];\n    }\n    async execAction(position, vimState) {\n        const getRightWhile = (p) => {\n            const line = vimState.document.lineAt(p.line).text;\n            const newPosition = p.getRight();\n            if (newPosition.character >= vimState.document.lineAt(newPosition.line).text.length) {\n                return newPosition;\n            }\n            if ((0, util_1.isLowSurrogate)(line.charCodeAt(newPosition.character)) &&\n                (0, util_1.isHighSurrogate)(line.charCodeAt(p.character))) {\n                return newPosition.getRight();\n            }\n            else {\n                return newPosition;\n            }\n        };\n        return (0, wrapping_1.shouldWrapKey)(vimState.currentMode, this.keysPressed[0])\n            ? position.getRightThroughLineBreaks([mode_1.Mode.Insert, mode_1.Mode.Replace].includes(vimState.currentMode))\n            : getRightWhile(position);\n    }\n};\nMoveRight = __decorate([\n    base_1.RegisterAction\n], MoveRight);\nlet MoveDownNonBlank = class MoveDownNonBlank extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = [['+'], ['\\n'], ['<C-m>']];\n    }\n    async execActionWithCount(position, vimState, count) {\n        vimState.currentRegisterMode = register_1.RegisterMode.LineWise;\n        return textEditor_1.TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, position.getDown(Math.max(count, 1)).line);\n    }\n};\nMoveDownNonBlank = __decorate([\n    base_1.RegisterAction\n], MoveDownNonBlank);\nlet MoveUpNonBlank = class MoveUpNonBlank extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = ['-'];\n    }\n    async execActionWithCount(position, vimState, count) {\n        vimState.currentRegisterMode = register_1.RegisterMode.LineWise;\n        return textEditor_1.TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, position.getUp(Math.max(count, 1)).line);\n    }\n};\nMoveUpNonBlank = __decorate([\n    base_1.RegisterAction\n], MoveUpNonBlank);\nlet MoveDownUnderscore = class MoveDownUnderscore extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = ['_'];\n    }\n    async execActionWithCount(position, vimState, count) {\n        vimState.currentRegisterMode = register_1.RegisterMode.LineWise;\n        const pos = position.getDown(Math.max(count - 1, 0));\n        return vimState.recordedState.operator\n            ? pos\n            : textEditor_1.TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, pos.line);\n    }\n};\nMoveDownUnderscore = __decorate([\n    base_1.RegisterAction\n], MoveDownUnderscore);\nlet MoveToColumn = class MoveToColumn extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = ['|'];\n    }\n    async execActionWithCount(position, vimState, count) {\n        return new vscode_1.Position(position.line, Math.max(0, count - 1));\n    }\n};\nMoveToColumn = __decorate([\n    base_1.RegisterAction\n], MoveToColumn);\n/**\n * Returns the Postion of the next instance of `char` on the line\n * @param char character to look for\n * @param count number of times to look\n * @param direction direction to look in\n */\nfunction findHelper(vimState, start, char, count, direction) {\n    const line = vimState.document.lineAt(start);\n    let index = start.character;\n    while (count > 0 && index >= 0) {\n        if (direction === 'forward') {\n            index = line.text.indexOf(char, index + 1);\n        }\n        else {\n            index = line.text.lastIndexOf(char, index - 1);\n        }\n        count--;\n    }\n    if (index >= 0) {\n        return new vscode_1.Position(start.line, index);\n    }\n    return undefined;\n}\nlet MoveFindForward = MoveFindForward_1 = class MoveFindForward extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = ['f', '<character>'];\n    }\n    async execActionWithCount(position, vimState, count) {\n        if (configuration_1.configuration.sneakReplacesF) {\n            const pos = await new sneak_1.SneakForward(this.keysPressed.concat('\\n'), this.isRepeat).execActionWithCount(position, vimState, count);\n            if (vimState.recordedState.operator && !(0, baseMotion_1.isIMovement)(pos)) {\n                return pos.getRight();\n            }\n            return pos;\n        }\n        count ||= 1;\n        const toFind = notation_1.Notation.ToControlCharacter(this.keysPressed[1]);\n        let result = findHelper(vimState, position, toFind, count, 'forward');\n        vimState.lastSemicolonRepeatableMovement = new MoveFindForward_1(this.keysPressed, true);\n        vimState.lastCommaRepeatableMovement = new MoveFindBackward(this.keysPressed, true);\n        if (!result) {\n            return (0, baseMotion_1.failedMovement)(vimState);\n        }\n        if (vimState.recordedState.operator) {\n            result = result.getRight();\n        }\n        return result;\n    }\n};\nMoveFindForward = MoveFindForward_1 = __decorate([\n    base_1.RegisterAction\n], MoveFindForward);\nlet MoveFindBackward = MoveFindBackward_1 = class MoveFindBackward extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = ['F', '<character>'];\n    }\n    async execActionWithCount(position, vimState, count) {\n        if (configuration_1.configuration.sneakReplacesF) {\n            return new sneak_1.SneakBackward(this.keysPressed.concat('\\n'), this.isRepeat).execActionWithCount(position, vimState, count);\n        }\n        count ||= 1;\n        const toFind = notation_1.Notation.ToControlCharacter(this.keysPressed[1]);\n        const result = findHelper(vimState, position, toFind, count, 'backward');\n        vimState.lastSemicolonRepeatableMovement = new MoveFindBackward_1(this.keysPressed, true);\n        vimState.lastCommaRepeatableMovement = new MoveFindForward(this.keysPressed, true);\n        if (!result) {\n            return (0, baseMotion_1.failedMovement)(vimState);\n        }\n        return result;\n    }\n};\nMoveFindBackward = MoveFindBackward_1 = __decorate([\n    base_1.RegisterAction\n], MoveFindBackward);\nfunction tilHelper(vimState, start, char, count, direction) {\n    const result = findHelper(vimState, start, char, count, direction);\n    return direction === 'forward' ? result?.getLeft() : result?.getRight();\n}\nlet MoveTilForward = MoveTilForward_1 = class MoveTilForward extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = ['t', '<character>'];\n    }\n    async execActionWithCount(position, vimState, count) {\n        count ||= 1;\n        const toFind = notation_1.Notation.ToControlCharacter(this.keysPressed[1]);\n        let result = tilHelper(vimState, position, toFind, count, 'forward');\n        // For t<character> vim executes ; as 2; and , as 2,\n        if (result && this.isRepeat && position.isEqual(result) && count === 1) {\n            result = tilHelper(vimState, position, toFind, 2, 'forward');\n        }\n        vimState.lastSemicolonRepeatableMovement = new MoveTilForward_1(this.keysPressed, true);\n        vimState.lastCommaRepeatableMovement = new MoveTilBackward(this.keysPressed, true);\n        if (!result) {\n            return (0, baseMotion_1.failedMovement)(vimState);\n        }\n        if (vimState.recordedState.operator) {\n            result = result.getRight();\n        }\n        return result;\n    }\n};\nMoveTilForward = MoveTilForward_1 = __decorate([\n    base_1.RegisterAction\n], MoveTilForward);\nlet MoveTilBackward = MoveTilBackward_1 = class MoveTilBackward extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = ['T', '<character>'];\n    }\n    async execActionWithCount(position, vimState, count) {\n        count ||= 1;\n        const toFind = notation_1.Notation.ToControlCharacter(this.keysPressed[1]);\n        let result = tilHelper(vimState, position, toFind, count, 'backward');\n        // For T<character> vim executes ; as 2; and , as 2,\n        if (result && this.isRepeat && position.isEqual(result) && count === 1) {\n            result = tilHelper(vimState, position, toFind, 2, 'backward');\n        }\n        vimState.lastSemicolonRepeatableMovement = new MoveTilBackward_1(this.keysPressed, true);\n        vimState.lastCommaRepeatableMovement = new MoveTilForward(this.keysPressed, true);\n        if (!result) {\n            return (0, baseMotion_1.failedMovement)(vimState);\n        }\n        return result;\n    }\n};\nMoveTilBackward = MoveTilBackward_1 = __decorate([\n    base_1.RegisterAction\n], MoveTilBackward);\nlet MoveRepeat = class MoveRepeat extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = [';'];\n    }\n    async execActionWithCount(position, vimState, count) {\n        const movement = vimState.lastSemicolonRepeatableMovement;\n        if (movement) {\n            return movement.execActionWithCount(position, vimState, count);\n        }\n        return position;\n    }\n};\nMoveRepeat = __decorate([\n    base_1.RegisterAction\n], MoveRepeat);\nlet MoveRepeatReversed = class MoveRepeatReversed extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = [','];\n    }\n    async execActionWithCount(position, vimState, count) {\n        const semiColonMovement = vimState.lastSemicolonRepeatableMovement;\n        const commaMovement = vimState.lastCommaRepeatableMovement;\n        if (commaMovement) {\n            const result = commaMovement.execActionWithCount(position, vimState, count);\n            // Make sure these don't change. Otherwise, comma's direction flips back\n            // and forth when done repeatedly. This is a bit hacky, so feel free to refactor.\n            vimState.lastSemicolonRepeatableMovement = semiColonMovement;\n            vimState.lastCommaRepeatableMovement = commaMovement;\n            return result;\n        }\n        return position;\n    }\n};\nMoveRepeatReversed = __decorate([\n    base_1.RegisterAction\n], MoveRepeatReversed);\nlet MoveLineEnd = class MoveLineEnd extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = [['$'], ['<End>'], ['<D-right>']];\n        this.setsDesiredColumnToEOL = true;\n    }\n    async execActionWithCount(position, vimState, count) {\n        return position.getDown(Math.max(count - 1, 0)).getLineEnd();\n    }\n};\nMoveLineEnd = __decorate([\n    base_1.RegisterAction\n], MoveLineEnd);\nlet MoveLineBegin = class MoveLineBegin extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = [['0'], ['<Home>'], ['<D-left>']];\n    }\n    async execAction(position, vimState) {\n        return position.getLineBegin();\n    }\n    doesActionApply(vimState, keysPressed) {\n        return super.doesActionApply(vimState, keysPressed) && vimState.recordedState.count === 0;\n    }\n    couldActionApply(vimState, keysPressed) {\n        return super.couldActionApply(vimState, keysPressed) && vimState.recordedState.count === 0;\n    }\n};\nMoveLineBegin = __decorate([\n    base_1.RegisterAction\n], MoveLineBegin);\nlet MoveScreenLineBegin = class MoveScreenLineBegin extends MoveByScreenLine {\n    constructor() {\n        super(...arguments);\n        this.keys = ['g', '0'];\n        this.movementType = 'wrappedLineStart';\n    }\n};\nMoveScreenLineBegin = __decorate([\n    base_1.RegisterAction\n], MoveScreenLineBegin);\nlet MoveScreenNonBlank = class MoveScreenNonBlank extends MoveByScreenLine {\n    constructor() {\n        super(...arguments);\n        this.keys = ['g', '^'];\n        this.movementType = 'wrappedLineFirstNonWhitespaceCharacter';\n    }\n};\nMoveScreenNonBlank = __decorate([\n    base_1.RegisterAction\n], MoveScreenNonBlank);\nlet MoveScreenLineEnd = class MoveScreenLineEnd extends MoveByScreenLine {\n    constructor() {\n        super(...arguments);\n        this.keys = ['g', '$'];\n        this.movementType = 'wrappedLineEnd';\n    }\n};\nMoveScreenLineEnd = __decorate([\n    base_1.RegisterAction\n], MoveScreenLineEnd);\nlet MoveScreenLineEndNonBlank = class MoveScreenLineEndNonBlank extends MoveByScreenLine {\n    constructor() {\n        super(...arguments);\n        this.keys = ['g', '_'];\n        this.movementType = 'wrappedLineLastNonWhitespaceCharacter';\n    }\n    async execActionWithCount(position, vimState, count) {\n        count ||= 1;\n        const pos = await super.execActionWithCount(position, vimState, count);\n        // If in visual, return a selection\n        if (pos instanceof vscode_1.Position) {\n            return pos.getDown(count - 1);\n        }\n        else {\n            return { start: pos.start, stop: pos.stop.getDown(count - 1).getLeftThroughLineBreaks() };\n        }\n    }\n};\nMoveScreenLineEndNonBlank = __decorate([\n    base_1.RegisterAction\n], MoveScreenLineEndNonBlank);\nlet MoveScreenLineCenter = class MoveScreenLineCenter extends MoveByScreenLine {\n    constructor() {\n        super(...arguments);\n        this.keys = ['g', 'm'];\n        this.movementType = 'wrappedLineColumnCenter';\n    }\n};\nMoveScreenLineCenter = __decorate([\n    base_1.RegisterAction\n], MoveScreenLineCenter);\nlet MoveUpByDisplayLine = class MoveUpByDisplayLine extends MoveByScreenLine {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual];\n        this.keys = [\n            ['g', 'k'],\n            ['g', '<up>'],\n        ];\n        this.movementType = 'up';\n        this.by = 'wrappedLine';\n        this.value = 1;\n    }\n};\nMoveUpByDisplayLine = __decorate([\n    base_1.RegisterAction\n], MoveUpByDisplayLine);\nlet MoveDownByDisplayLine = class MoveDownByDisplayLine extends MoveByScreenLine {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual];\n        this.keys = [\n            ['g', 'j'],\n            ['g', '<down>'],\n        ];\n        this.movementType = 'down';\n        this.by = 'wrappedLine';\n        this.value = 1;\n    }\n};\nMoveDownByDisplayLine = __decorate([\n    base_1.RegisterAction\n], MoveDownByDisplayLine);\n// Because we can't support moving by screen line when in visualLine mode,\n// we change to moving by regular line in visualLine mode. We can't move by\n// screen line is that our ranges only support a start and stop attribute,\n// and moving by screen line just snaps us back to the original position.\n// Check PR #1600 for discussion.\nlet MoveUpByScreenLineVisualLine = class MoveUpByScreenLineVisualLine extends MoveByScreenLine {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.VisualLine];\n        this.keys = [\n            ['g', 'k'],\n            ['g', '<up>'],\n        ];\n        this.movementType = 'up';\n        this.by = 'line';\n        this.value = 1;\n    }\n};\nMoveUpByScreenLineVisualLine = __decorate([\n    base_1.RegisterAction\n], MoveUpByScreenLineVisualLine);\nlet MoveDownByScreenLineVisualLine = class MoveDownByScreenLineVisualLine extends MoveByScreenLine {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.VisualLine];\n        this.keys = [\n            ['g', 'j'],\n            ['g', '<down>'],\n        ];\n        this.movementType = 'down';\n        this.by = 'line';\n        this.value = 1;\n    }\n};\nMoveDownByScreenLineVisualLine = __decorate([\n    base_1.RegisterAction\n], MoveDownByScreenLineVisualLine);\nlet MoveUpByScreenLineVisualBlock = class MoveUpByScreenLineVisualBlock extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.VisualBlock];\n        this.keys = [\n            ['g', 'k'],\n            ['g', '<up>'],\n        ];\n        this.preservesDesiredColumn = true;\n    }\n    async execAction(position, vimState) {\n        if (position.line > 0) {\n            return position.with({ character: vimState.desiredColumn }).getUp();\n        }\n        else {\n            return position;\n        }\n    }\n    async execActionForOperator(position, vimState) {\n        vimState.currentRegisterMode = register_1.RegisterMode.LineWise;\n        return position.getUp();\n    }\n};\nMoveUpByScreenLineVisualBlock = __decorate([\n    base_1.RegisterAction\n], MoveUpByScreenLineVisualBlock);\nlet MoveDownByScreenLineVisualBlock = class MoveDownByScreenLineVisualBlock extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.VisualBlock];\n        this.keys = [\n            ['g', 'j'],\n            ['g', '<down>'],\n        ];\n        this.preservesDesiredColumn = true;\n    }\n    async execAction(position, vimState) {\n        if (position.line < vimState.document.lineCount - 1) {\n            return position.with({ character: vimState.desiredColumn }).getDown();\n        }\n        else {\n            return position;\n        }\n    }\n    async execActionForOperator(position, vimState) {\n        vimState.currentRegisterMode = register_1.RegisterMode.LineWise;\n        return position.getDown();\n    }\n};\nMoveDownByScreenLineVisualBlock = __decorate([\n    base_1.RegisterAction\n], MoveDownByScreenLineVisualBlock);\nlet MoveScreenToRight = class MoveScreenToRight extends MoveByScreenLine {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n        this.keys = ['z', 'h'];\n        this.movementType = 'right';\n        this.by = 'character';\n        this.value = 1;\n    }\n    doesActionApply(vimState, keysPressed) {\n        // Don't run if there's an operator because the Sneak plugin uses <operator>z\n        return (super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined);\n    }\n};\nMoveScreenToRight = __decorate([\n    base_1.RegisterAction\n], MoveScreenToRight);\nlet MoveScreenToLeft = class MoveScreenToLeft extends MoveByScreenLine {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n        this.keys = ['z', 'l'];\n        this.movementType = 'left';\n        this.by = 'character';\n        this.value = 1;\n    }\n    doesActionApply(vimState, keysPressed) {\n        // Don't run if there's an operator because the Sneak plugin uses <operator>z\n        return (super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined);\n    }\n};\nMoveScreenToLeft = __decorate([\n    base_1.RegisterAction\n], MoveScreenToLeft);\nlet MoveScreenToRightHalf = class MoveScreenToRightHalf extends MoveByScreenLine {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n        this.keys = ['z', 'H'];\n        this.movementType = 'right';\n        this.by = 'halfLine';\n        this.value = 1;\n    }\n    doesActionApply(vimState, keysPressed) {\n        // Don't run if there's an operator because the Sneak plugin uses <operator>z\n        return (super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined);\n    }\n};\nMoveScreenToRightHalf = __decorate([\n    base_1.RegisterAction\n], MoveScreenToRightHalf);\nlet MoveScreenToLeftHalf = class MoveScreenToLeftHalf extends MoveByScreenLine {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n        this.keys = ['z', 'L'];\n        this.movementType = 'left';\n        this.by = 'halfLine';\n        this.value = 1;\n        this.isJump = true;\n    }\n    doesActionApply(vimState, keysPressed) {\n        // Don't run if there's an operator because the Sneak plugin uses <operator>z\n        return (super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined);\n    }\n};\nMoveScreenToLeftHalf = __decorate([\n    base_1.RegisterAction\n], MoveScreenToLeftHalf);\nlet MoveToLineFromViewPortTop = class MoveToLineFromViewPortTop extends MoveByScreenLine {\n    constructor() {\n        super(...arguments);\n        this.keys = ['H'];\n        this.movementType = 'viewPortTop';\n        this.by = 'line';\n        this.value = 1;\n        this.isJump = true;\n    }\n};\nMoveToLineFromViewPortTop = __decorate([\n    base_1.RegisterAction\n], MoveToLineFromViewPortTop);\nlet MoveToLineFromViewPortBottom = class MoveToLineFromViewPortBottom extends MoveByScreenLine {\n    constructor() {\n        super(...arguments);\n        this.keys = ['L'];\n        this.movementType = 'viewPortBottom';\n        this.by = 'line';\n        this.value = 1;\n        this.isJump = true;\n    }\n};\nMoveToLineFromViewPortBottom = __decorate([\n    base_1.RegisterAction\n], MoveToLineFromViewPortBottom);\nlet MoveToMiddleLineInViewPort = class MoveToMiddleLineInViewPort extends MoveByScreenLine {\n    constructor() {\n        super(...arguments);\n        this.keys = ['M'];\n        this.movementType = 'viewPortCenter';\n        this.by = 'line';\n        this.isJump = true;\n    }\n};\nMoveToMiddleLineInViewPort = __decorate([\n    base_1.RegisterAction\n], MoveToMiddleLineInViewPort);\nlet MoveNonBlank = class MoveNonBlank extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = ['^'];\n    }\n    async execAction(position, vimState) {\n        return textEditor_1.TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, position.line);\n    }\n};\nMoveNonBlank = __decorate([\n    base_1.RegisterAction\n], MoveNonBlank);\nlet MoveNonBlankFirst = class MoveNonBlankFirst extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = [['g', 'g'], ['<C-Home>']];\n        this.isJump = true;\n    }\n    async execActionWithCount(position, vimState, count) {\n        vimState.currentRegisterMode = register_1.RegisterMode.LineWise;\n        const line = (0, util_1.clamp)(count, 1, vimState.document.lineCount) - 1;\n        return {\n            start: vimState.cursorStartPosition,\n            stop: position.with({ line }).obeyStartOfLine(vimState.document),\n        };\n    }\n};\nMoveNonBlankFirst = __decorate([\n    base_1.RegisterAction\n], MoveNonBlankFirst);\nlet MoveNonBlankLast = class MoveNonBlankLast extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = ['G'];\n        this.isJump = true;\n    }\n    async execActionWithCount(position, vimState, count) {\n        vimState.currentRegisterMode = register_1.RegisterMode.LineWise;\n        let stop;\n        if (count === 0) {\n            stop = new vscode_1.Position(vimState.document.lineCount - 1, position.character).obeyStartOfLine(vimState.document);\n        }\n        else {\n            stop = new vscode_1.Position(Math.min(count, vimState.document.lineCount) - 1, position.character).obeyStartOfLine(vimState.document);\n        }\n        return {\n            start: vimState.cursorStartPosition,\n            stop,\n        };\n    }\n};\nMoveNonBlankLast = __decorate([\n    base_1.RegisterAction\n], MoveNonBlankLast);\nlet EndOfSpecificLine = class EndOfSpecificLine extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = ['<C-End>'];\n    }\n    async execActionWithCount(position, vimState, count) {\n        const line = count\n            ? (0, util_1.clamp)(count - 1, 0, vimState.document.lineCount - 1)\n            : vimState.document.lineCount - 1;\n        return new vscode_1.Position(line, 0).getLineEnd();\n    }\n};\nEndOfSpecificLine = __decorate([\n    base_1.RegisterAction\n], EndOfSpecificLine);\nlet MoveWordBegin = class MoveWordBegin extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = ['w'];\n    }\n    async execAction(position, vimState, firstIteration, lastIteration) {\n        if (lastIteration &&\n            !configuration_1.configuration.changeWordIncludesWhitespace &&\n            vimState.recordedState.operator instanceof operator_1.ChangeOperator) {\n            const line = vimState.document.lineAt(position);\n            if (line.text.length === 0) {\n                return position;\n            }\n            const char = line.text[position.character];\n            /*\n            From the Vim manual:\n      \n            Special case: \"cw\" and \"cW\" are treated like \"ce\" and \"cE\" if the cursor is\n            on a non-blank.  This is because \"cw\" is interpreted as change-word, and a\n            word does not include the following white space.\n            */\n            if (' \\t'.includes(char)) {\n                return position.nextWordStart(vimState.document);\n            }\n            else {\n                return position.nextWordEnd(vimState.document, { inclusive: true }).getRight();\n            }\n        }\n        else {\n            return position.nextWordStart(vimState.document);\n        }\n    }\n    async execActionForOperator(position, vimState, firstIteration, lastIteration) {\n        const result = await this.execAction(position, vimState, firstIteration, lastIteration);\n        /*\n        From the Vim documentation:\n    \n        Another special case: When using the \"w\" motion in combination with an\n        operator and the last word moved over is at the end of a line, the end of\n        that word becomes the end of the operated text, not the first word in the\n        next line.\n        */\n        if (result.line > position.line + 1 ||\n            (result.line === position.line + 1 && result.isFirstWordOfLine(vimState.document))) {\n            return position.getLineEnd();\n        }\n        if (result.isLineEnd()) {\n            return new vscode_1.Position(result.line, result.character + 1);\n        }\n        return result;\n    }\n};\nexports.MoveWordBegin = MoveWordBegin;\nexports.MoveWordBegin = MoveWordBegin = __decorate([\n    base_1.RegisterAction\n], MoveWordBegin);\nlet MoveFullWordBegin = class MoveFullWordBegin extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = [['W'], ['<C-right>']];\n    }\n    async execAction(position, vimState) {\n        if (!configuration_1.configuration.changeWordIncludesWhitespace &&\n            vimState.recordedState.operator instanceof operator_1.ChangeOperator) {\n            // TODO use execForOperator? Or maybe dont?\n            // See note for w\n            return position\n                .nextWordEnd(vimState.document, { wordType: word_1.WordType.Big, inclusive: true })\n                .getRight();\n        }\n        else {\n            return position.nextWordStart(vimState.document, { wordType: word_1.WordType.Big });\n        }\n    }\n};\nexports.MoveFullWordBegin = MoveFullWordBegin;\nexports.MoveFullWordBegin = MoveFullWordBegin = __decorate([\n    base_1.RegisterAction\n], MoveFullWordBegin);\nlet MoveWordEnd = class MoveWordEnd extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = ['e'];\n    }\n    async execAction(position, vimState) {\n        return position.nextWordEnd(vimState.document);\n    }\n    async execActionForOperator(position, vimState) {\n        const end = position.nextWordEnd(vimState.document);\n        return new vscode_1.Position(end.line, end.character + 1);\n    }\n};\nMoveWordEnd = __decorate([\n    base_1.RegisterAction\n], MoveWordEnd);\nlet MoveFullWordEnd = class MoveFullWordEnd extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = ['E'];\n    }\n    async execAction(position, vimState) {\n        return position.nextWordEnd(vimState.document, { wordType: word_1.WordType.Big });\n    }\n    async execActionForOperator(position, vimState) {\n        return position.nextWordEnd(vimState.document, { wordType: word_1.WordType.Big }).getRight();\n    }\n};\nMoveFullWordEnd = __decorate([\n    base_1.RegisterAction\n], MoveFullWordEnd);\nlet MoveLastWordEnd = class MoveLastWordEnd extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = ['g', 'e'];\n    }\n    async execAction(position, vimState) {\n        return position.prevWordEnd(vimState.document);\n    }\n};\nMoveLastWordEnd = __decorate([\n    base_1.RegisterAction\n], MoveLastWordEnd);\nlet MoveLastFullWordEnd = class MoveLastFullWordEnd extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = ['g', 'E'];\n    }\n    async execAction(position, vimState) {\n        return position.prevWordEnd(vimState.document, { wordType: word_1.WordType.Big });\n    }\n};\nMoveLastFullWordEnd = __decorate([\n    base_1.RegisterAction\n], MoveLastFullWordEnd);\nlet MoveBeginningWord = class MoveBeginningWord extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = [['b'], ['<C-left>']];\n    }\n    async execAction(position, vimState) {\n        return position.prevWordStart(vimState.document);\n    }\n};\nMoveBeginningWord = __decorate([\n    base_1.RegisterAction\n], MoveBeginningWord);\nlet MoveBeginningFullWord = class MoveBeginningFullWord extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = ['B'];\n    }\n    async execAction(position, vimState) {\n        return position.prevWordStart(vimState.document, { wordType: word_1.WordType.Big });\n    }\n};\nMoveBeginningFullWord = __decorate([\n    base_1.RegisterAction\n], MoveBeginningFullWord);\nlet MovePreviousSentenceBegin = class MovePreviousSentenceBegin extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = ['('];\n        this.isJump = true;\n    }\n    async execAction(position, vimState) {\n        return position.getSentenceBegin({ forward: false });\n    }\n};\nMovePreviousSentenceBegin = __decorate([\n    base_1.RegisterAction\n], MovePreviousSentenceBegin);\nlet GoToOffset = class GoToOffset extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = ['g', 'o'];\n        this.isJump = true;\n    }\n    async execActionWithCount(position, vimState, count) {\n        vimState.currentRegisterMode = register_1.RegisterMode.LineWise;\n        return vimState.document.positionAt((count || 1) - 1);\n    }\n};\nGoToOffset = __decorate([\n    base_1.RegisterAction\n], GoToOffset);\nlet MoveNextSentenceBegin = class MoveNextSentenceBegin extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = [')'];\n        this.isJump = true;\n    }\n    async execAction(position, vimState) {\n        return position.getSentenceBegin({ forward: true });\n    }\n};\nMoveNextSentenceBegin = __decorate([\n    base_1.RegisterAction\n], MoveNextSentenceBegin);\nlet MoveParagraphEnd = class MoveParagraphEnd extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = ['}'];\n        this.isJump = true;\n        this.iteration = 0;\n        this.isFirstLineWise = false;\n    }\n    async execAction(position, vimState) {\n        const hasOperator = vimState.recordedState.operator;\n        const paragraphEnd = (0, paragraph_1.getCurrentParagraphEnd)(position);\n        if (hasOperator) {\n            /**\n             * When paired with an `operator` and a `count` this move will be executed\n             * multiple times which could cause issues like https://github.com/VSCodeVim/Vim/issues/4488\n             * because subsequent runs will receive back whatever position we return\n             * (See comment in `BaseMotion.execActionWithCount()`).\n             *\n             * We keep track of the iteration we are in, this way we can\n             * return the correct position when on the last iteration, and we don't\n             * accidentally set the `registerMode` incorrectly.\n             */\n            this.iteration++;\n            const isLineWise = position.isLineBeginning() && vimState.currentMode === mode_1.Mode.Normal;\n            // TODO: `execAction` receives `firstIteration` and `lastIteration` - don't reinvent the wheel\n            const isLastIteration = vimState.recordedState.count\n                ? vimState.recordedState.count === this.iteration\n                : true;\n            /**\n             * `position` may not represent the position of the cursor from which the command was initiated.\n             * In the case that we will be repeating this move more than once\n             * we want to respect whether the starting position was at the beginning of line or not.\n             */\n            this.isFirstLineWise = this.iteration === 1 ? isLineWise : this.isFirstLineWise;\n            vimState.currentRegisterMode = this.isFirstLineWise ? register_1.RegisterMode.LineWise : undefined;\n            /**\n             * `paragraphEnd` is the first blank line after the last word in the\n             * current paragraph, we want the position just before that one to\n             * accurately emulate Vim's behaviour, unless we are at EOF.\n             */\n            return isLastIteration && !paragraphEnd.isAtDocumentEnd()\n                ? paragraphEnd.getLeftThroughLineBreaks(true)\n                : paragraphEnd;\n        }\n        return paragraphEnd;\n    }\n};\nMoveParagraphEnd = __decorate([\n    base_1.RegisterAction\n], MoveParagraphEnd);\nlet MoveParagraphBegin = class MoveParagraphBegin extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = ['{'];\n        this.isJump = true;\n    }\n    async execAction(position, vimState) {\n        return (0, paragraph_1.getCurrentParagraphBeginning)(position);\n    }\n};\nMoveParagraphBegin = __decorate([\n    base_1.RegisterAction\n], MoveParagraphBegin);\nclass MoveSectionBoundary extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.isJump = true;\n    }\n    async execAction(position, vimState) {\n        const document = vimState.document;\n        switch (document.languageId) {\n            case 'python':\n                return motion_1.PythonDocument.moveClassBoundary(document, position, vimState, this.forward, this.begin);\n        }\n        const boundary = this.begin ? '{' : '}';\n        let line = position.line;\n        if ((this.forward && line === vimState.document.lineCount - 1) ||\n            (!this.forward && line === 0)) {\n            return textEditor_1.TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, line);\n        }\n        line = this.forward ? line + 1 : line - 1;\n        while (!vimState.document.lineAt(line).text.startsWith(boundary)) {\n            if (this.forward) {\n                if (line === vimState.document.lineCount - 1) {\n                    break;\n                }\n                line++;\n            }\n            else {\n                if (line === 0) {\n                    break;\n                }\n                line--;\n            }\n        }\n        return textEditor_1.TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, line);\n    }\n}\nlet MoveNextSectionBegin = class MoveNextSectionBegin extends MoveSectionBoundary {\n    constructor() {\n        super(...arguments);\n        this.keys = [']', ']'];\n        this.begin = true;\n        this.forward = true;\n    }\n};\nMoveNextSectionBegin = __decorate([\n    base_1.RegisterAction\n], MoveNextSectionBegin);\nlet MoveNextSectionEnd = class MoveNextSectionEnd extends MoveSectionBoundary {\n    constructor() {\n        super(...arguments);\n        this.keys = [']', '['];\n        this.begin = false;\n        this.forward = true;\n    }\n};\nMoveNextSectionEnd = __decorate([\n    base_1.RegisterAction\n], MoveNextSectionEnd);\nlet MovePreviousSectionBegin = class MovePreviousSectionBegin extends MoveSectionBoundary {\n    constructor() {\n        super(...arguments);\n        this.keys = ['[', '['];\n        this.begin = true;\n        this.forward = false;\n    }\n};\nMovePreviousSectionBegin = __decorate([\n    base_1.RegisterAction\n], MovePreviousSectionBegin);\nlet MovePreviousSectionEnd = class MovePreviousSectionEnd extends MoveSectionBoundary {\n    constructor() {\n        super(...arguments);\n        this.keys = ['[', ']'];\n        this.begin = false;\n        this.forward = false;\n    }\n};\nMovePreviousSectionEnd = __decorate([\n    base_1.RegisterAction\n], MovePreviousSectionEnd);\nlet MoveToMatchingBracket = MoveToMatchingBracket_1 = class MoveToMatchingBracket extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = ['%'];\n        this.isJump = true;\n    }\n    async execAction(position, vimState) {\n        position = position.getLeftIfEOL();\n        const lineText = vimState.document.lineAt(position).text;\n        const failure = (0, baseMotion_1.failedMovement)(vimState);\n        for (let col = position.character; col < lineText.length; col++) {\n            const currentChar = lineText[col];\n            const pairing = matcher_1.PairMatcher.getPercentPairing(currentChar);\n            // we need to check pairing, because with text: bla |bla < blub > blub\n            // this for loop will walk over bla and check for a pairing till it finds <\n            if (pairing) {\n                // We found an opening char, now move to the matching closing char\n                return (matcher_1.PairMatcher.nextPairedChar(new vscode_1.Position(position.line, col), lineText[col], vimState, false) || failure);\n            }\n        }\n        // No matchable character on the line; admit defeat\n        return failure;\n    }\n    async execActionForOperator(position, vimState) {\n        const result = await this.execAction(position, vimState);\n        if ((0, baseMotion_1.isIMovement)(result)) {\n            if (result.failed) {\n                return result;\n            }\n            else {\n                throw new Error('Did not ever handle this case!');\n            }\n        }\n        if (position.isAfter(result)) {\n            return {\n                start: result,\n                stop: position.getRight(),\n            };\n        }\n        else {\n            return result.getRight();\n        }\n    }\n    async execActionWithCount(position, vimState, count) {\n        // % has a special mode that lets you use it to jump to a percentage of the file\n        // However, some other bracket motions inherit from this so only do this behavior for % explicitly\n        if (Object.getPrototypeOf(this) === MoveToMatchingBracket_1.prototype) {\n            if (count === 0) {\n                if (vimState.recordedState.operator) {\n                    return this.execActionForOperator(position, vimState);\n                }\n                else {\n                    return this.execAction(position, vimState);\n                }\n            }\n            // Check to make sure this is a valid percentage\n            if (count < 0 || count > 100) {\n                return (0, baseMotion_1.failedMovement)(vimState);\n            }\n            // See `:help N%`\n            const targetLine = Math.trunc((count * vimState.document.lineCount + 99) / 100) - 1;\n            return position.with({ line: targetLine }).obeyStartOfLine(vimState.document);\n        }\n        else {\n            return super.execActionWithCount(position, vimState, count);\n        }\n    }\n};\nMoveToMatchingBracket = MoveToMatchingBracket_1 = __decorate([\n    base_1.RegisterAction\n], MoveToMatchingBracket);\nclass MoveInsideCharacter extends ExpandingSelection {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n        /** True for \"around\" actions, such as `a(`, and false for \"inside\" actions, such as `i(`  */\n        this.includeSurrounding = false;\n        this.isJump = true;\n    }\n    async execAction(position, vimState, firstIteration, lastIteration) {\n        const closingChar = matcher_1.PairMatcher.pairings[this.charToMatch].match;\n        const [selStart, selEnd] = (0, position_1.sorted)(vimState.cursorStartPosition, position);\n        // First, search backwards for the opening character of the sequence\n        let openPos = matcher_1.PairMatcher.nextPairedChar(selStart, closingChar, vimState, true);\n        if (openPos === undefined) {\n            // If opening character not found, search forwards\n            let lineNum = selStart.line;\n            while (true) {\n                if (lineNum >= vimState.document.lineCount) {\n                    break;\n                }\n                const lineText = vimState.document.lineAt(lineNum).text;\n                const matchIndex = lineText.indexOf(this.charToMatch);\n                if (matchIndex !== -1) {\n                    openPos = new vscode_1.Position(lineNum, matchIndex);\n                    break;\n                }\n                ++lineNum;\n            }\n            if (openPos === undefined)\n                return (0, baseMotion_1.failedMovement)(vimState);\n        }\n        // Next, search forwards for the closing character which matches\n        let closePos = matcher_1.PairMatcher.nextPairedChar(openPos, this.charToMatch, vimState, true);\n        if (closePos === undefined) {\n            return (0, baseMotion_1.failedMovement)(vimState);\n        }\n        if (!this.includeSurrounding &&\n            ((0, mode_1.isVisualMode)(vimState.currentMode) || !firstIteration) &&\n            selStart.getLeftThroughLineBreaks(false).isBeforeOrEqual(openPos) &&\n            selEnd.getRightThroughLineBreaks(false).isAfterOrEqual(closePos)) {\n            // Special case: inner, with all inner content already selected\n            const outerOpenPos = matcher_1.PairMatcher.nextPairedChar(openPos, closingChar, vimState, false);\n            const outerClosePos = outerOpenPos\n                ? matcher_1.PairMatcher.nextPairedChar(outerOpenPos, this.charToMatch, vimState, false)\n                : undefined;\n            if (outerOpenPos && outerClosePos) {\n                openPos = outerOpenPos;\n                closePos = outerClosePos;\n            }\n        }\n        if (this.includeSurrounding) {\n            if (vimState.currentMode !== mode_1.Mode.Visual) {\n                closePos = new vscode_1.Position(closePos.line, closePos.character + 1);\n            }\n        }\n        else {\n            openPos = openPos.getRightThroughLineBreaks();\n            // If the closing character is the first on the line, don't swallow it.\n            if (closePos.isInLeadingWhitespace(vimState.document)) {\n                closePos = closePos.getLineBegin();\n            }\n            if (vimState.currentMode === mode_1.Mode.Visual) {\n                closePos = closePos.getLeftThroughLineBreaks();\n            }\n        }\n        if (lastIteration && !(0, mode_1.isVisualMode)(vimState.currentMode) && selStart.isBefore(openPos)) {\n            vimState.recordedState.operatorPositionDiff = openPos.subtract(selStart);\n        }\n        // TODO: setting the cursor manually like this shouldn't be necessary (probably a Cursor, not Position, should be passed to `exec`)\n        vimState.cursorStartPosition = openPos;\n        return {\n            start: openPos,\n            stop: closePos,\n        };\n    }\n}\nexports.MoveInsideCharacter = MoveInsideCharacter;\nlet MoveInsideParentheses = class MoveInsideParentheses extends MoveInsideCharacter {\n    constructor() {\n        super(...arguments);\n        this.keys = [\n            ['i', '('],\n            ['i', ')'],\n            ['i', 'b'],\n        ];\n        this.charToMatch = '(';\n    }\n};\nexports.MoveInsideParentheses = MoveInsideParentheses;\nexports.MoveInsideParentheses = MoveInsideParentheses = __decorate([\n    base_1.RegisterAction\n], MoveInsideParentheses);\nlet MoveAroundParentheses = class MoveAroundParentheses extends MoveInsideCharacter {\n    constructor() {\n        super(...arguments);\n        this.keys = [\n            ['a', '('],\n            ['a', ')'],\n            ['a', 'b'],\n        ];\n        this.charToMatch = '(';\n        this.includeSurrounding = true;\n    }\n};\nexports.MoveAroundParentheses = MoveAroundParentheses;\nexports.MoveAroundParentheses = MoveAroundParentheses = __decorate([\n    base_1.RegisterAction\n], MoveAroundParentheses);\n// special treatment for curly braces\nclass MoveCurlyBrace extends MoveInsideCharacter {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n        this.charToMatch = '{';\n    }\n    async execAction(position, vimState, firstIteration, lastIteration) {\n        // curly braces has a special treatment. In case the cursor is before an opening curly brace,\n        // and there are no characters before the opening curly brace in the same line, it should jump\n        // to the next opening curly brace, even if it already inside a pair of curly braces.\n        const text = vimState.document.lineAt(position).text;\n        const openCurlyBraceIndexFromCursor = text.substring(position.character).indexOf('{');\n        const startSameAsEnd = vimState.cursorStartPosition.isEqual(position);\n        if (openCurlyBraceIndexFromCursor !== -1 &&\n            text.substring(0, position.character + openCurlyBraceIndexFromCursor).trim().length === 0 &&\n            startSameAsEnd) {\n            const curlyPos = position.with(position.line, position.character + openCurlyBraceIndexFromCursor);\n            vimState.cursorStartPosition = vimState.cursorStopPosition = curlyPos;\n            const movement = await super.execAction(curlyPos, vimState, firstIteration, lastIteration);\n            if (movement.failed) {\n                return movement;\n            }\n            const { start, stop } = movement;\n            if (!(0, mode_1.isVisualMode)(vimState.currentMode) && position.isBefore(start)) {\n                vimState.recordedState.operatorPositionDiff = start.subtract(position);\n            }\n            else if (!(0, mode_1.isVisualMode)(vimState.currentMode) && position.isAfter(stop)) {\n                if (position.line === stop.line) {\n                    vimState.recordedState.operatorPositionDiff = stop.subtract(position);\n                }\n                else {\n                    vimState.recordedState.operatorPositionDiff = start.subtract(position);\n                }\n            }\n            vimState.cursorStartPosition = start;\n            vimState.cursorStopPosition = stop;\n            return movement;\n        }\n        else {\n            return super.execAction(position, vimState, firstIteration, lastIteration);\n        }\n    }\n}\nexports.MoveCurlyBrace = MoveCurlyBrace;\nlet MoveInsideCurlyBrace = class MoveInsideCurlyBrace extends MoveCurlyBrace {\n    constructor() {\n        super(...arguments);\n        this.keys = [\n            ['i', '{'],\n            ['i', '}'],\n            ['i', 'B'],\n        ];\n    }\n};\nexports.MoveInsideCurlyBrace = MoveInsideCurlyBrace;\nexports.MoveInsideCurlyBrace = MoveInsideCurlyBrace = __decorate([\n    base_1.RegisterAction\n], MoveInsideCurlyBrace);\nlet MoveAroundCurlyBrace = class MoveAroundCurlyBrace extends MoveCurlyBrace {\n    constructor() {\n        super(...arguments);\n        this.keys = [\n            ['a', '{'],\n            ['a', '}'],\n            ['a', 'B'],\n        ];\n        this.includeSurrounding = true;\n    }\n};\nexports.MoveAroundCurlyBrace = MoveAroundCurlyBrace;\nexports.MoveAroundCurlyBrace = MoveAroundCurlyBrace = __decorate([\n    base_1.RegisterAction\n], MoveAroundCurlyBrace);\nlet MoveInsideCaret = class MoveInsideCaret extends MoveInsideCharacter {\n    constructor() {\n        super(...arguments);\n        this.keys = [\n            ['i', '<'],\n            ['i', '>'],\n        ];\n        this.charToMatch = '<';\n    }\n};\nexports.MoveInsideCaret = MoveInsideCaret;\nexports.MoveInsideCaret = MoveInsideCaret = __decorate([\n    base_1.RegisterAction\n], MoveInsideCaret);\nlet MoveAroundCaret = class MoveAroundCaret extends MoveInsideCharacter {\n    constructor() {\n        super(...arguments);\n        this.keys = [\n            ['a', '<'],\n            ['a', '>'],\n        ];\n        this.charToMatch = '<';\n        this.includeSurrounding = true;\n    }\n};\nexports.MoveAroundCaret = MoveAroundCaret;\nexports.MoveAroundCaret = MoveAroundCaret = __decorate([\n    base_1.RegisterAction\n], MoveAroundCaret);\nlet MoveInsideSquareBracket = class MoveInsideSquareBracket extends MoveInsideCharacter {\n    constructor() {\n        super(...arguments);\n        this.keys = [\n            ['i', '['],\n            ['i', ']'],\n        ];\n        this.charToMatch = '[';\n    }\n};\nexports.MoveInsideSquareBracket = MoveInsideSquareBracket;\nexports.MoveInsideSquareBracket = MoveInsideSquareBracket = __decorate([\n    base_1.RegisterAction\n], MoveInsideSquareBracket);\nlet MoveAroundSquareBracket = class MoveAroundSquareBracket extends MoveInsideCharacter {\n    constructor() {\n        super(...arguments);\n        this.keys = [\n            ['a', '['],\n            ['a', ']'],\n        ];\n        this.charToMatch = '[';\n        this.includeSurrounding = true;\n    }\n};\nexports.MoveAroundSquareBracket = MoveAroundSquareBracket;\nexports.MoveAroundSquareBracket = MoveAroundSquareBracket = __decorate([\n    base_1.RegisterAction\n], MoveAroundSquareBracket);\n// TODO: Shouldn't this be a TextObject? A clearer delineation between motions and objects should be made.\nclass MoveQuoteMatch extends baseMotion_1.BaseMovement {\n    constructor(adjustForTrailingWhitespace = true) {\n        super();\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualBlock];\n        this.anyQuote = false;\n        this.includeQuotes = false;\n        this.isJump = true;\n        this.which = 'current';\n        // HACK: surround uses these classes, but does not want trailing whitespace to be included\n        this.adjustForTrailingWhitespace = true;\n        this.adjustForTrailingWhitespace = adjustForTrailingWhitespace;\n    }\n    async execActionWithCount(position, vimState, count) {\n        // TODO: this is super janky\n        return (await super.execActionWithCount(position, vimState, 1));\n    }\n    async execAction(position, vimState) {\n        if (!this.includeQuotes &&\n            (vimState.recordedState.count > 1 || vimState.recordedState.operatorCount > 1)) {\n            // i\" special case: With a count of 2 the quotes are included, but no extra white space as with a\"/a'/a`.\n            // (a\" does not make use of count)\n            this.includeQuotes = true;\n            this.adjustForTrailingWhitespace = false;\n        }\n        if ((0, targetsConfig_1.useSmartQuotes)()) {\n            const quoteMatcher = new smartQuotesMatcher_1.SmartQuoteMatcher(this.anyQuote ? 'any' : this.charToMatch, vimState.document);\n            const res = quoteMatcher.smartSurroundingQuotes(position, this.which);\n            if (res === undefined) {\n                return (0, baseMotion_1.failedMovement)(vimState);\n            }\n            let { start, stop, lineText } = res;\n            if (!this.includeQuotes) {\n                // Don't include the quotes\n                start = start.translate({ characterDelta: 1 });\n                stop = stop.translate({ characterDelta: -1 });\n            }\n            else if (this.adjustForTrailingWhitespace &&\n                configuration_1.configuration.targets.smartQuotes.aIncludesSurroundingSpaces) {\n                // Include trailing whitespace if there is any...\n                const trailingWhitespace = lineText.substring(stop.character + 1).search(/\\S|$/);\n                if (trailingWhitespace > 0) {\n                    stop = stop.translate({ characterDelta: trailingWhitespace });\n                }\n                else {\n                    // ...otherwise include leading whitespace\n                    start = start.with({ character: lineText.substring(0, start.character).search(/\\s*$/) });\n                }\n            }\n            if (!(0, mode_1.isVisualMode)(vimState.currentMode) && position.isBefore(start)) {\n                vimState.recordedState.operatorPositionDiff = start.subtract(position);\n            }\n            else if (!(0, mode_1.isVisualMode)(vimState.currentMode) && position.isAfter(stop)) {\n                if (position.line === stop.line) {\n                    vimState.recordedState.operatorPositionDiff = stop.getRight().subtract(position);\n                }\n                else {\n                    vimState.recordedState.operatorPositionDiff = start.subtract(position);\n                }\n            }\n            vimState.cursorStartPosition = start;\n            return {\n                start,\n                stop,\n            };\n        }\n        else {\n            const text = vimState.document.lineAt(position).text;\n            const quoteMatcher = new quoteMatcher_1.QuoteMatcher(this.charToMatch, text);\n            const quoteIndices = quoteMatcher.surroundingQuotes(position.character);\n            if (quoteIndices === undefined) {\n                return (0, baseMotion_1.failedMovement)(vimState);\n            }\n            let [start, end] = quoteIndices;\n            if (!this.includeQuotes) {\n                // Don't include the quotes\n                start++;\n                end--;\n            }\n            else if (this.adjustForTrailingWhitespace) {\n                // Include trailing whitespace if there is any...\n                const trailingWhitespace = text.substring(end + 1).search(/\\S|$/);\n                if (trailingWhitespace > 0) {\n                    end += trailingWhitespace;\n                }\n                else {\n                    // ...otherwise include leading whitespace\n                    start = text.substring(0, start).search(/\\s*$/);\n                }\n            }\n            const startPos = new vscode_1.Position(position.line, start);\n            const endPos = new vscode_1.Position(position.line, end);\n            if (!(0, mode_1.isVisualMode)(vimState.currentMode) && position.isBefore(startPos)) {\n                vimState.recordedState.operatorPositionDiff = startPos.subtract(position);\n            }\n            return {\n                start: startPos,\n                stop: endPos,\n            };\n        }\n    }\n    async execActionForOperator(position, vimState) {\n        const result = await this.execAction(position, vimState);\n        if ((0, baseMotion_1.isIMovement)(result)) {\n            if (result.failed) {\n                vimState.recordedState.hasRunOperator = false;\n                vimState.recordedState.actionsRun = [];\n            }\n            else {\n                result.stop = result.stop.getRight();\n            }\n        }\n        return result;\n    }\n}\nexports.MoveQuoteMatch = MoveQuoteMatch;\nlet MoveInsideSingleQuotes = class MoveInsideSingleQuotes extends MoveQuoteMatch {\n    constructor() {\n        super(...arguments);\n        this.keys = ['i', \"'\"];\n        this.charToMatch = \"'\";\n        this.includeQuotes = false;\n    }\n};\nMoveInsideSingleQuotes = __decorate([\n    base_1.RegisterAction\n], MoveInsideSingleQuotes);\nlet MoveAroundSingleQuotes = class MoveAroundSingleQuotes extends MoveQuoteMatch {\n    constructor() {\n        super(...arguments);\n        this.keys = ['a', \"'\"];\n        this.charToMatch = \"'\";\n        this.includeQuotes = true;\n    }\n};\nexports.MoveAroundSingleQuotes = MoveAroundSingleQuotes;\nexports.MoveAroundSingleQuotes = MoveAroundSingleQuotes = __decorate([\n    base_1.RegisterAction\n], MoveAroundSingleQuotes);\nlet MoveInsideDoubleQuotes = class MoveInsideDoubleQuotes extends MoveQuoteMatch {\n    constructor() {\n        super(...arguments);\n        this.keys = ['i', '\"'];\n        this.charToMatch = '\"';\n        this.includeQuotes = false;\n    }\n};\nMoveInsideDoubleQuotes = __decorate([\n    base_1.RegisterAction\n], MoveInsideDoubleQuotes);\nlet MoveAroundDoubleQuotes = class MoveAroundDoubleQuotes extends MoveQuoteMatch {\n    constructor() {\n        super(...arguments);\n        this.keys = ['a', '\"'];\n        this.charToMatch = '\"';\n        this.includeQuotes = true;\n    }\n};\nexports.MoveAroundDoubleQuotes = MoveAroundDoubleQuotes;\nexports.MoveAroundDoubleQuotes = MoveAroundDoubleQuotes = __decorate([\n    base_1.RegisterAction\n], MoveAroundDoubleQuotes);\nlet MoveInsideBacktick = class MoveInsideBacktick extends MoveQuoteMatch {\n    constructor() {\n        super(...arguments);\n        this.keys = ['i', '`'];\n        this.charToMatch = '`';\n        this.includeQuotes = false;\n    }\n};\nMoveInsideBacktick = __decorate([\n    base_1.RegisterAction\n], MoveInsideBacktick);\nlet MoveAroundBacktick = class MoveAroundBacktick extends MoveQuoteMatch {\n    constructor() {\n        super(...arguments);\n        this.keys = ['a', '`'];\n        this.charToMatch = '`';\n        this.includeQuotes = true;\n    }\n};\nexports.MoveAroundBacktick = MoveAroundBacktick;\nexports.MoveAroundBacktick = MoveAroundBacktick = __decorate([\n    base_1.RegisterAction\n], MoveAroundBacktick);\nlet MoveToUnclosedRoundBracketBackward = class MoveToUnclosedRoundBracketBackward extends MoveToMatchingBracket {\n    constructor() {\n        super(...arguments);\n        this.keys = ['[', '('];\n    }\n    async execAction(position, vimState) {\n        const charToMatch = ')';\n        const result = matcher_1.PairMatcher.nextPairedChar(position, charToMatch, vimState, false);\n        if (!result) {\n            return (0, baseMotion_1.failedMovement)(vimState);\n        }\n        return result;\n    }\n};\nMoveToUnclosedRoundBracketBackward = __decorate([\n    base_1.RegisterAction\n], MoveToUnclosedRoundBracketBackward);\nlet MoveToUnclosedRoundBracketForward = class MoveToUnclosedRoundBracketForward extends MoveToMatchingBracket {\n    constructor() {\n        super(...arguments);\n        this.keys = [']', ')'];\n    }\n    async execAction(position, vimState) {\n        const charToMatch = '(';\n        const result = matcher_1.PairMatcher.nextPairedChar(position, charToMatch, vimState, false);\n        if (!result) {\n            return (0, baseMotion_1.failedMovement)(vimState);\n        }\n        if (vimState.recordedState.operator instanceof operator_1.ChangeOperator ||\n            vimState.recordedState.operator instanceof operator_1.DeleteOperator ||\n            vimState.recordedState.operator instanceof operator_1.YankOperator) {\n            return result.getLeftThroughLineBreaks();\n        }\n        return result;\n    }\n};\nMoveToUnclosedRoundBracketForward = __decorate([\n    base_1.RegisterAction\n], MoveToUnclosedRoundBracketForward);\nlet MoveToUnclosedCurlyBracketBackward = class MoveToUnclosedCurlyBracketBackward extends MoveToMatchingBracket {\n    constructor() {\n        super(...arguments);\n        this.keys = ['[', '{'];\n    }\n    async execAction(position, vimState) {\n        const charToMatch = '}';\n        const result = matcher_1.PairMatcher.nextPairedChar(position, charToMatch, vimState, false);\n        if (!result) {\n            return (0, baseMotion_1.failedMovement)(vimState);\n        }\n        return result;\n    }\n};\nMoveToUnclosedCurlyBracketBackward = __decorate([\n    base_1.RegisterAction\n], MoveToUnclosedCurlyBracketBackward);\nlet MoveToUnclosedCurlyBracketForward = class MoveToUnclosedCurlyBracketForward extends MoveToMatchingBracket {\n    constructor() {\n        super(...arguments);\n        this.keys = [']', '}'];\n    }\n    async execAction(position, vimState) {\n        const charToMatch = '{';\n        const result = matcher_1.PairMatcher.nextPairedChar(position, charToMatch, vimState, false);\n        if (!result) {\n            return (0, baseMotion_1.failedMovement)(vimState);\n        }\n        if (vimState.recordedState.operator instanceof operator_1.ChangeOperator ||\n            vimState.recordedState.operator instanceof operator_1.DeleteOperator ||\n            vimState.recordedState.operator instanceof operator_1.YankOperator) {\n            return result.getLeftThroughLineBreaks();\n        }\n        return result;\n    }\n};\nMoveToUnclosedCurlyBracketForward = __decorate([\n    base_1.RegisterAction\n], MoveToUnclosedCurlyBracketForward);\nclass MoveTagMatch extends ExpandingSelection {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualBlock];\n        this.includeTag = false;\n        this.isJump = true;\n    }\n    async execAction(position, vimState) {\n        const editorText = vimState.document.getText();\n        const offset = vimState.document.offsetAt(position);\n        const tagMatcher = new tagMatcher_1.TagMatcher(editorText, offset, vimState);\n        const start = tagMatcher.findOpening(this.includeTag);\n        const end = tagMatcher.findClosing(this.includeTag);\n        if (start === undefined || end === undefined) {\n            return (0, baseMotion_1.failedMovement)(vimState);\n        }\n        const startPosition = start >= 0 ? vimState.document.positionAt(start) : vimState.cursorStartPosition;\n        let endPosition = end >= 0 ? vimState.document.positionAt(end) : position;\n        if (vimState.currentMode === mode_1.Mode.Visual || vimState.currentMode === mode_1.Mode.SurroundInputMode) {\n            endPosition = endPosition.getLeftThroughLineBreaks();\n        }\n        if (position.isAfter(endPosition)) {\n            vimState.recordedState.transformer.moveCursor(endPosition.subtract(position));\n        }\n        else if (position.isBefore(startPosition)) {\n            vimState.recordedState.transformer.moveCursor(startPosition.subtract(position));\n        }\n        // if (start === end) {\n        //   if (vimState.recordedState.operator instanceof ChangeOperator) {\n        //     await vimState.setCurrentMode(ModeName.Insert);\n        //   }\n        //   return failedMovement(vimState);\n        // }\n        vimState.cursorStartPosition = startPosition;\n        return {\n            start: startPosition,\n            stop: endPosition,\n        };\n    }\n}\nlet MoveInsideTag = class MoveInsideTag extends MoveTagMatch {\n    constructor() {\n        super(...arguments);\n        this.keys = ['i', 't'];\n        this.includeTag = false;\n    }\n};\nexports.MoveInsideTag = MoveInsideTag;\nexports.MoveInsideTag = MoveInsideTag = __decorate([\n    base_1.RegisterAction\n], MoveInsideTag);\nlet MoveAroundTag = class MoveAroundTag extends MoveTagMatch {\n    constructor() {\n        super(...arguments);\n        this.keys = ['a', 't'];\n        this.includeTag = true;\n    }\n};\nexports.MoveAroundTag = MoveAroundTag;\nexports.MoveAroundTag = MoveAroundTag = __decorate([\n    base_1.RegisterAction\n], MoveAroundTag);\n\n\n//# sourceURL=webpack://vim/./src/actions/motion.ts?")},"./src/actions/operator.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar ROT13Operator_1, ActionVisualReflowParagraph_1;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ROT13Operator = exports.ChangeOperator = exports.YankOperator = exports.DeleteOperator = exports.BaseOperator = void 0;\nconst vscode = __importStar(__webpack_require__(/*! vscode */ \"vscode\"));\nconst vscode_1 = __webpack_require__(/*! vscode */ \"vscode\");\nconst statusBarTextUtils_1 = __webpack_require__(/*! ../util/statusBarTextUtils */ \"./src/util/statusBarTextUtils.ts\");\nconst util_1 = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\nconst commandLine_1 = __webpack_require__(/*! ./../cmd_line/commandLine */ \"./src/cmd_line/commandLine.ts\");\nconst cursor_1 = __webpack_require__(/*! ./../common/motion/cursor */ \"./src/common/motion/cursor.ts\");\nconst position_1 = __webpack_require__(/*! ./../common/motion/position */ \"./src/common/motion/position.ts\");\nconst configuration_1 = __webpack_require__(/*! ./../configuration/configuration */ \"./src/configuration/configuration.ts\");\nconst mode_1 = __webpack_require__(/*! ./../mode/mode */ \"./src/mode/mode.ts\");\nconst register_1 = __webpack_require__(/*! ./../register/register */ \"./src/register/register.ts\");\nconst textEditor_1 = __webpack_require__(/*! ./../textEditor */ \"./src/textEditor.ts\");\nconst base_1 = __webpack_require__(/*! ./base */ \"./src/actions/base.ts\");\nclass BaseOperator extends base_1.BaseAction {\n    constructor(multicursorIndex) {\n        super();\n        this.actionType = 'operator';\n        this.createsUndoPoint = true;\n        this.multicursorIndex = multicursorIndex;\n    }\n    doesActionApply(vimState, keysPressed) {\n        if (this.doesRepeatedOperatorApply(vimState, keysPressed)) {\n            return true;\n        }\n        if (!this.modes.includes(vimState.currentMode)) {\n            return false;\n        }\n        if (!base_1.BaseAction.CompareKeypressSequence(this.keys, keysPressed)) {\n            return false;\n        }\n        if (this instanceof BaseOperator && vimState.recordedState.operator) {\n            return false;\n        }\n        return true;\n    }\n    couldActionApply(vimState, keysPressed) {\n        if (!this.modes.includes(vimState.currentMode)) {\n            return false;\n        }\n        if (!base_1.BaseAction.CompareKeypressSequence(this.keys.slice(0, keysPressed.length), keysPressed)) {\n            return false;\n        }\n        if (this instanceof BaseOperator && vimState.recordedState.operator) {\n            return false;\n        }\n        return true;\n    }\n    doesRepeatedOperatorApply(vimState, keysPressed) {\n        const nonCountActions = vimState.recordedState.actionsRun.filter((x) => x.name !== 'cmd_num');\n        const prevAction = nonCountActions[nonCountActions.length - 1];\n        return (keysPressed.length === 1 &&\n            prevAction &&\n            this.modes.includes(vimState.currentMode) &&\n            // The previous action is the same as the one we're testing\n            prevAction.constructor === this.constructor &&\n            // The key pressed is the same as the previous action's last key.\n            base_1.BaseAction.CompareKeypressSequence(prevAction.keysPressed.slice(-1), keysPressed));\n    }\n    async runRepeat(vimState, position, count) {\n        vimState.currentRegisterMode = register_1.RegisterMode.LineWise;\n        await this.run(vimState, position.getLineBegin(), position.getDown(Math.max(0, count - 1)).getLineEnd());\n    }\n    highlightYankedRanges(vimState, ranges) {\n        if (!configuration_1.configuration.highlightedyank.enable) {\n            return;\n        }\n        const yankDecoration = vscode.window.createTextEditorDecorationType({\n            backgroundColor: configuration_1.configuration.highlightedyank.color,\n            color: configuration_1.configuration.highlightedyank.textColor,\n        });\n        vimState.editor.setDecorations(yankDecoration, ranges);\n        setTimeout(() => yankDecoration.dispose(), configuration_1.configuration.highlightedyank.duration);\n    }\n}\nexports.BaseOperator = BaseOperator;\nlet DeleteOperator = class DeleteOperator extends BaseOperator {\n    constructor() {\n        super(...arguments);\n        this.name = 'delete_op';\n        this.keys = ['d'];\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n    }\n    async run(vimState, start, end) {\n        // TODO: this is off by one when character-wise and not including last EOL\n        const numLinesDeleted = Math.abs(start.line - end.line) + 1;\n        if (vimState.currentRegisterMode === register_1.RegisterMode.LineWise) {\n            start = start.getLineBegin();\n            end = end.getLineEnd();\n        }\n        end = new vscode_1.Position(end.line, end.character + 1);\n        const isOnLastLine = end.line === vimState.document.lineCount - 1;\n        // Vim does this weird thing where it allows you to select and delete\n        // the newline character, which it places 1 past the last character\n        // in the line. Here we interpret a character position 1 past the end\n        // as selecting the newline character. Don't allow this in visual block mode\n        if (vimState.currentMode !== mode_1.Mode.VisualBlock &&\n            !isOnLastLine &&\n            end.character === vimState.document.lineAt(end).text.length + 1) {\n            end = new vscode_1.Position(end.line + 1, 0);\n        }\n        // Yank the text\n        let text = vimState.document.getText(new vscode.Range(start, end));\n        if (vimState.currentRegisterMode === register_1.RegisterMode.LineWise) {\n            // When deleting linewise, exclude final newline\n            text = text.endsWith('\\r\\n')\n                ? text.slice(0, -2)\n                : text.endsWith('\\n')\n                    ? text.slice(0, -1)\n                    : text;\n        }\n        register_1.Register.put(vimState, text, this.multicursorIndex, true);\n        // When deleting the last line linewise, we need to delete the newline\n        // character BEFORE the range because there isn't one after the range.\n        if (isOnLastLine &&\n            start.line !== 0 &&\n            vimState.currentRegisterMode === register_1.RegisterMode.LineWise) {\n            start = start.getUp().getLineEnd();\n        }\n        let diff;\n        if (vimState.currentRegisterMode === register_1.RegisterMode.LineWise) {\n            diff = position_1.PositionDiff.startOfLine();\n        }\n        else if (start.character > vimState.document.lineAt(start).text.length) {\n            diff = position_1.PositionDiff.offset({ character: -1 });\n        }\n        vimState.recordedState.transformer.addTransformation({\n            type: 'deleteRange',\n            range: new vscode.Range(start, end),\n            diff,\n        });\n        await vimState.setCurrentMode(mode_1.Mode.Normal);\n        (0, statusBarTextUtils_1.reportLinesChanged)(-numLinesDeleted, vimState);\n    }\n};\nexports.DeleteOperator = DeleteOperator;\nexports.DeleteOperator = DeleteOperator = __decorate([\n    base_1.RegisterAction\n], DeleteOperator);\nlet DeleteOperatorVisual = class DeleteOperatorVisual extends BaseOperator {\n    constructor() {\n        super(...arguments);\n        this.keys = ['D'];\n        this.modes = [mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n    }\n    async run(vimState, start, end) {\n        // ensures linewise deletion when in visual mode\n        // see special case in DeleteOperator.delete()\n        vimState.currentRegisterMode = register_1.RegisterMode.LineWise;\n        await new DeleteOperator(this.multicursorIndex).run(vimState, start, end);\n    }\n};\nDeleteOperatorVisual = __decorate([\n    base_1.RegisterAction\n], DeleteOperatorVisual);\nlet YankOperator = class YankOperator extends BaseOperator {\n    constructor() {\n        super(...arguments);\n        this.keys = ['y'];\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n        this.name = 'yank_op';\n        this.createsUndoPoint = false;\n    }\n    async run(vimState, start, end) {\n        [start, end] = (0, position_1.sorted)(start, end);\n        let extendedEnd = new vscode_1.Position(end.line, end.character + 1);\n        if (vimState.currentRegisterMode === register_1.RegisterMode.LineWise) {\n            start = start.getLineBegin();\n            extendedEnd = extendedEnd.getLineEnd();\n        }\n        const sLine = vimState.document.lineAt(start.line).text;\n        const eLine = vimState.document.lineAt(extendedEnd.line).text;\n        if (start.character !== 0 &&\n            (0, util_1.isLowSurrogate)(sLine.charCodeAt(start.character)) &&\n            (0, util_1.isHighSurrogate)(sLine.charCodeAt(start.character - 1))) {\n            start = start.getLeft();\n        }\n        if (extendedEnd.character !== 0 &&\n            (0, util_1.isLowSurrogate)(eLine.charCodeAt(extendedEnd.character)) &&\n            (0, util_1.isHighSurrogate)(eLine.charCodeAt(extendedEnd.character - 1))) {\n            extendedEnd = extendedEnd.getRight();\n        }\n        const range = new vscode.Range(start, extendedEnd);\n        let text = vimState.document.getText(range);\n        // If we selected the newline character, add it as well.\n        if (vimState.currentMode === mode_1.Mode.Visual &&\n            extendedEnd.character === vimState.document.lineAt(extendedEnd).text.length + 1) {\n            text = text + '\\n';\n        }\n        this.highlightYankedRanges(vimState, [range]);\n        register_1.Register.put(vimState, text, this.multicursorIndex, true);\n        vimState.cursorStopPosition =\n            vimState.currentMode === mode_1.Mode.Normal && vimState.currentRegisterMode === register_1.RegisterMode.LineWise\n                ? start.with({ character: vimState.cursorStopPosition.character })\n                : start;\n        await vimState.setCurrentMode(mode_1.Mode.Normal);\n        const numLinesYanked = text.split('\\n').length;\n        (0, statusBarTextUtils_1.reportLinesYanked)(numLinesYanked, vimState);\n    }\n};\nexports.YankOperator = YankOperator;\nexports.YankOperator = YankOperator = __decorate([\n    base_1.RegisterAction\n], YankOperator);\nlet FilterOperator = class FilterOperator extends BaseOperator {\n    constructor() {\n        super(...arguments);\n        this.keys = ['!'];\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n    }\n    async run(vimState, start, end) {\n        [start, end] = (0, position_1.sorted)(start, end);\n        let commandLineText;\n        if (vimState.currentMode === mode_1.Mode.Normal && start.line === end.line) {\n            commandLineText = '.!';\n        }\n        else if (vimState.currentMode === mode_1.Mode.Normal && start.line !== end.line) {\n            commandLineText = `.,.+${end.line - start.line}!`;\n        }\n        else {\n            commandLineText = \"'<,'>!\";\n        }\n        vimState.cursorStartPosition = start;\n        if (vimState.currentMode === mode_1.Mode.Normal) {\n            vimState.cursorStopPosition = start;\n        }\n        else {\n            vimState.cursors = vimState.cursorsInitialState;\n        }\n        const previousMode = vimState.currentMode;\n        await vimState.setCurrentMode(mode_1.Mode.CommandlineInProgress);\n        // TODO: Change or supplement `setCurrentMode` API so this isn't necessary\n        if (vimState.modeData.mode === mode_1.Mode.CommandlineInProgress) {\n            vimState.modeData.commandLine = new commandLine_1.ExCommandLine(commandLineText, previousMode);\n        }\n    }\n};\nFilterOperator = __decorate([\n    base_1.RegisterAction\n], FilterOperator);\nlet ShiftYankOperatorVisual = class ShiftYankOperatorVisual extends BaseOperator {\n    constructor() {\n        super(...arguments);\n        this.keys = ['Y'];\n        this.modes = [mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n    }\n    async run(vimState, start, end) {\n        vimState.currentRegisterMode = register_1.RegisterMode.LineWise;\n        await new YankOperator(this.multicursorIndex).run(vimState, start, end);\n    }\n};\nShiftYankOperatorVisual = __decorate([\n    base_1.RegisterAction\n], ShiftYankOperatorVisual);\nlet DeleteOperatorXVisual = class DeleteOperatorXVisual extends BaseOperator {\n    constructor() {\n        super(...arguments);\n        this.keys = [['x'], ['<Del>']];\n        this.modes = [mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n    }\n    async run(vimState, start, end) {\n        await new DeleteOperator(this.multicursorIndex).run(vimState, start, end);\n    }\n};\nDeleteOperatorXVisual = __decorate([\n    base_1.RegisterAction\n], DeleteOperatorXVisual);\nlet ChangeOperatorSVisual = class ChangeOperatorSVisual extends BaseOperator {\n    constructor() {\n        super(...arguments);\n        this.keys = ['s'];\n        this.modes = [mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n    }\n    // Don't clash with Sneak plugin\n    doesActionApply(vimState, keysPressed) {\n        return super.doesActionApply(vimState, keysPressed) && !configuration_1.configuration.sneak;\n    }\n    async run(vimState, start, end) {\n        await new ChangeOperator(this.multicursorIndex).run(vimState, start, end);\n    }\n};\nChangeOperatorSVisual = __decorate([\n    base_1.RegisterAction\n], ChangeOperatorSVisual);\nlet FormatOperator = class FormatOperator extends BaseOperator {\n    constructor() {\n        super(...arguments);\n        this.keys = ['='];\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n    }\n    async run(vimState, start, end) {\n        // = operates on complete lines\n        vimState.editor.selection = new vscode.Selection(start.getLineBegin(), end.getLineEnd());\n        await vscode.commands.executeCommand('editor.action.formatSelection');\n        let line = vimState.cursorStartPosition.line;\n        if (vimState.cursorStartPosition.isAfter(vimState.cursorStopPosition)) {\n            line = vimState.cursorStopPosition.line;\n        }\n        const newCursorPosition = textEditor_1.TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, line);\n        vimState.cursorStopPosition = newCursorPosition;\n        vimState.cursorStartPosition = newCursorPosition;\n        await vimState.setCurrentMode(mode_1.Mode.Normal);\n    }\n};\nFormatOperator = __decorate([\n    base_1.RegisterAction\n], FormatOperator);\nclass ChangeCaseOperator extends BaseOperator {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n    }\n    async run(vimState, startPos, endPos) {\n        if (vimState.currentMode === mode_1.Mode.VisualBlock) {\n            for (const { start, end } of textEditor_1.TextEditor.iterateLinesInBlock(vimState)) {\n                const range = new vscode.Range(start, end);\n                vimState.recordedState.transformer.replace(range, this.transformText(vimState.document.getText(range)));\n            }\n            // HACK: currently must do this nonsense to collapse all cursors into one\n            for (let i = 0; i < vimState.editor.selections.length; i++) {\n                vimState.recordedState.transformer.moveCursor(position_1.PositionDiff.exactPosition((0, position_1.earlierOf)(startPos, endPos)), i);\n            }\n        }\n        else {\n            if (vimState.currentRegisterMode === register_1.RegisterMode.LineWise) {\n                startPos = startPos.getLineBegin();\n                endPos = endPos.getLineEnd();\n            }\n            const range = new vscode.Range(startPos, new vscode_1.Position(endPos.line, endPos.character + 1));\n            vimState.recordedState.transformer.addTransformation({\n                type: 'replaceText',\n                range,\n                text: this.transformText(vimState.document.getText(range)),\n                diff: position_1.PositionDiff.exactPosition(startPos),\n            });\n        }\n        await vimState.setCurrentMode(mode_1.Mode.Normal);\n    }\n}\nlet UpperCaseOperator = class UpperCaseOperator extends ChangeCaseOperator {\n    constructor() {\n        super(...arguments);\n        this.keys = [['g', 'U'], ['U']];\n    }\n    transformText(text) {\n        return text.toUpperCase();\n    }\n};\nUpperCaseOperator = __decorate([\n    base_1.RegisterAction\n], UpperCaseOperator);\nlet UpperCaseWithMotion = class UpperCaseWithMotion extends UpperCaseOperator {\n    constructor() {\n        super(...arguments);\n        this.keys = [['g', 'U']];\n        this.modes = [mode_1.Mode.Normal];\n    }\n};\nUpperCaseWithMotion = __decorate([\n    base_1.RegisterAction\n], UpperCaseWithMotion);\nlet LowerCaseOperator = class LowerCaseOperator extends ChangeCaseOperator {\n    constructor() {\n        super(...arguments);\n        this.keys = [['g', 'u'], ['u']];\n    }\n    transformText(text) {\n        return text.toLowerCase();\n    }\n};\nLowerCaseOperator = __decorate([\n    base_1.RegisterAction\n], LowerCaseOperator);\nlet LowerCaseWithMotion = class LowerCaseWithMotion extends LowerCaseOperator {\n    constructor() {\n        super(...arguments);\n        this.keys = [['g', 'u']];\n        this.modes = [mode_1.Mode.Normal];\n    }\n};\nLowerCaseWithMotion = __decorate([\n    base_1.RegisterAction\n], LowerCaseWithMotion);\nlet ToggleCaseOperator = class ToggleCaseOperator extends ChangeCaseOperator {\n    constructor() {\n        super(...arguments);\n        this.keys = [['g', '~'], ['~']];\n    }\n    transformText(text) {\n        let newText = '';\n        for (const char of text) {\n            let toggled = char.toLocaleLowerCase();\n            if (toggled === char) {\n                toggled = char.toLocaleUpperCase();\n            }\n            newText += toggled;\n        }\n        return newText;\n    }\n};\nToggleCaseOperator = __decorate([\n    base_1.RegisterAction\n], ToggleCaseOperator);\nlet ToggleCaseWithMotion = class ToggleCaseWithMotion extends ToggleCaseOperator {\n    constructor() {\n        super(...arguments);\n        this.keys = [['g', '~']];\n        this.modes = [mode_1.Mode.Normal];\n    }\n};\nToggleCaseWithMotion = __decorate([\n    base_1.RegisterAction\n], ToggleCaseWithMotion);\nlet IndentOperator = class IndentOperator extends BaseOperator {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['>'];\n    }\n    async run(vimState, start, end) {\n        vimState.editor.selection = new vscode.Selection(start.getLineBegin(), end.getLineEnd());\n        await vscode.commands.executeCommand('editor.action.indentLines');\n        await vimState.setCurrentMode(mode_1.Mode.Normal);\n        vimState.cursorStopPosition = start.obeyStartOfLine(vimState.document);\n    }\n};\nIndentOperator = __decorate([\n    base_1.RegisterAction\n], IndentOperator);\n/**\n * `3>` to indent a line 3 times in visual mode is actually a bit of a special case.\n *\n * > is an operator, and generally speaking, you don't run operators multiple times, you run motions multiple times.\n * e.g. `d3w` runs `w` 3 times, then runs d once.\n *\n * Same with literally every other operator motion combination... until `3>`in visual mode\n * walked into my life.\n */\nlet IndentOperatorVisualAndVisualLine = class IndentOperatorVisualAndVisualLine extends BaseOperator {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n        this.keys = ['>'];\n    }\n    async run(vimState, start, end) {\n        // Repeating this command with dot should apply the indent to the previous selection\n        if (vimState.isRunningDotCommand && vimState.dotCommandPreviousVisualSelection) {\n            if (vimState.cursorStartPosition.isAfter(vimState.cursorStopPosition)) {\n                const shiftSelectionByNum = vimState.dotCommandPreviousVisualSelection.end.line -\n                    vimState.dotCommandPreviousVisualSelection.start.line;\n                start = vimState.cursorStartPosition;\n                const newEnd = vimState.cursorStartPosition.getDown(shiftSelectionByNum);\n                vimState.editor.selection = new vscode.Selection(start, newEnd);\n            }\n        }\n        for (let i = 0; i < (vimState.recordedState.count || 1); i++) {\n            await vscode.commands.executeCommand('editor.action.indentLines');\n        }\n        await vimState.setCurrentMode(mode_1.Mode.Normal);\n        vimState.cursorStopPosition = start.obeyStartOfLine(vimState.document);\n    }\n};\nIndentOperatorVisualAndVisualLine = __decorate([\n    base_1.RegisterAction\n], IndentOperatorVisualAndVisualLine);\nlet IndentOperatorVisualBlock = class IndentOperatorVisualBlock extends BaseOperator {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.VisualBlock];\n        this.keys = ['>'];\n    }\n    async run(vimState, start, end) {\n        /**\n         * Repeating this command with dot should apply the indent to the left edge of the\n         * block formed by extending the cursor start position downward by the number of lines\n         * in the previous visual block selection.\n         */\n        if (vimState.isRunningDotCommand && vimState.dotCommandPreviousVisualSelection) {\n            const shiftSelectionByNum = Math.abs(vimState.dotCommandPreviousVisualSelection.end.line -\n                vimState.dotCommandPreviousVisualSelection.start.line);\n            start = vimState.cursorStartPosition;\n            end = vimState.cursorStartPosition.getDown(shiftSelectionByNum);\n            vimState.editor.selection = new vscode.Selection(start, end);\n        }\n        for (let lineIdx = 0; lineIdx < end.line - start.line + 1; lineIdx++) {\n            const tabSize = Number(vimState.editor.options.tabSize);\n            const currentLineEnd = vimState.document.lineAt(start.line + lineIdx).range.end.character;\n            if (currentLineEnd > start.character) {\n                vimState.recordedState.transformer.addTransformation({\n                    type: 'insertText',\n                    text: ' '.repeat(tabSize).repeat(vimState.recordedState.count || 1),\n                    position: start.getDown(lineIdx),\n                    manuallySetCursorPositions: true,\n                });\n            }\n        }\n        await vimState.setCurrentMode(mode_1.Mode.Normal);\n        vimState.cursors = [new cursor_1.Cursor(start, start)];\n    }\n};\nIndentOperatorVisualBlock = __decorate([\n    base_1.RegisterAction\n], IndentOperatorVisualBlock);\nlet OutdentOperator = class OutdentOperator extends BaseOperator {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal];\n        this.keys = ['<'];\n    }\n    async run(vimState, start, end) {\n        vimState.editor.selection = new vscode.Selection(start, end.getLineEnd());\n        await vscode.commands.executeCommand('editor.action.outdentLines');\n        await vimState.setCurrentMode(mode_1.Mode.Normal);\n        vimState.cursorStopPosition = textEditor_1.TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, start.line);\n    }\n};\nOutdentOperator = __decorate([\n    base_1.RegisterAction\n], OutdentOperator);\n/**\n * See comment for IndentOperatorVisualAndVisualLine\n */\nlet OutdentOperatorVisualAndVisualLine = class OutdentOperatorVisualAndVisualLine extends BaseOperator {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n        this.keys = ['<'];\n    }\n    async run(vimState, start, end) {\n        // Repeating this command with dot should apply the indent to the previous selection\n        if (vimState.isRunningDotCommand && vimState.dotCommandPreviousVisualSelection) {\n            if (vimState.cursorStartPosition.isAfter(vimState.cursorStopPosition)) {\n                const shiftSelectionByNum = vimState.dotCommandPreviousVisualSelection.end.line -\n                    vimState.dotCommandPreviousVisualSelection.start.line;\n                start = vimState.cursorStartPosition;\n                const newEnd = vimState.cursorStartPosition.getDown(shiftSelectionByNum);\n                vimState.editor.selection = new vscode.Selection(start, newEnd);\n            }\n        }\n        for (let i = 0; i < (vimState.recordedState.count || 1); i++) {\n            await vscode.commands.executeCommand('editor.action.outdentLines');\n        }\n        await vimState.setCurrentMode(mode_1.Mode.Normal);\n        vimState.cursorStopPosition = textEditor_1.TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, start.line);\n    }\n};\nOutdentOperatorVisualAndVisualLine = __decorate([\n    base_1.RegisterAction\n], OutdentOperatorVisualAndVisualLine);\nlet OutdentOperatorVisualBlock = class OutdentOperatorVisualBlock extends BaseOperator {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.VisualBlock];\n        this.keys = ['<'];\n    }\n    async run(vimState, start, end) {\n        /**\n         * Repeating this command with dot should apply the outdent to the left edge of the\n         * block formed by extending the cursor start position downward by the number of lines\n         * in the previous visual block selection.\n         */\n        if (vimState.isRunningDotCommand && vimState.dotCommandPreviousVisualSelection) {\n            const shiftSelectionByNum = Math.abs(vimState.dotCommandPreviousVisualSelection.end.line -\n                vimState.dotCommandPreviousVisualSelection.start.line);\n            start = vimState.cursorStartPosition;\n            end = vimState.cursorStartPosition.getDown(shiftSelectionByNum);\n            vimState.editor.selection = new vscode.Selection(start, end);\n        }\n        for (let lineIdx = 0; lineIdx < end.line - start.line + 1; lineIdx++) {\n            const tabSize = Number(vimState.editor.options.tabSize);\n            const currentLine = vimState.document.lineAt(start.line + lineIdx);\n            const currentLineEnd = currentLine.range.end.character;\n            if (currentLineEnd > start.character) {\n                const currentLineFromStart = currentLine.text.slice(start.character);\n                const isFirstCharBlank = /\\s/.test(currentLineFromStart.charAt(0));\n                if (isFirstCharBlank) {\n                    const currentLinePosition = start.getDown(lineIdx);\n                    const distToNonBlankChar = currentLineFromStart.match(/\\S/)?.index ?? 0;\n                    const outdentDist = Math.min(distToNonBlankChar, tabSize * (vimState.recordedState.count || 1));\n                    vimState.recordedState.transformer.addTransformation({\n                        type: 'deleteRange',\n                        range: new vscode.Range(currentLinePosition, currentLinePosition.getRight(outdentDist)),\n                        manuallySetCursorPositions: true,\n                    });\n                }\n            }\n        }\n        await vimState.setCurrentMode(mode_1.Mode.Normal);\n        vimState.cursors = [new cursor_1.Cursor(start, start)];\n    }\n};\nOutdentOperatorVisualBlock = __decorate([\n    base_1.RegisterAction\n], OutdentOperatorVisualBlock);\nlet ChangeOperator = class ChangeOperator extends BaseOperator {\n    constructor() {\n        super(...arguments);\n        this.keys = ['c'];\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n    }\n    async run(vimState, start, end) {\n        if (vimState.currentRegisterMode === register_1.RegisterMode.LineWise) {\n            start = start.getLineBegin();\n            end = end.getLineEnd();\n        }\n        else if (vimState.currentMode === mode_1.Mode.Visual && end.isLineEnd()) {\n            end = end.getRightThroughLineBreaks();\n        }\n        else {\n            end = end.getRight();\n        }\n        const deleteRange = new vscode.Range(start, end);\n        register_1.Register.put(vimState, vimState.document.getText(deleteRange), this.multicursorIndex, true);\n        if (vimState.currentRegisterMode === register_1.RegisterMode.LineWise && configuration_1.configuration.autoindent) {\n            // Linewise is a bit of a special case - we want to preserve the first line's indentation,\n            // then let the language server adjust that indentation if it can.\n            const firstLineIndent = vimState.document.getText(new vscode.Range(deleteRange.start.getLineBegin(), deleteRange.start.getLineBeginRespectingIndent(vimState.document)));\n            vimState.recordedState.transformer.replace(deleteRange, firstLineIndent, position_1.PositionDiff.exactPosition(new vscode_1.Position(deleteRange.start.line, firstLineIndent.length)));\n            if (vimState.document.languageId !== 'plaintext') {\n                vimState.recordedState.transformer.vscodeCommand('editor.action.reindentselectedlines');\n                vimState.recordedState.transformer.moveCursor(position_1.PositionDiff.endOfLine(), this.multicursorIndex);\n            }\n        }\n        else {\n            vimState.recordedState.transformer.delete(deleteRange);\n        }\n        await vimState.setCurrentMode(mode_1.Mode.Insert);\n    }\n};\nexports.ChangeOperator = ChangeOperator;\nexports.ChangeOperator = ChangeOperator = __decorate([\n    base_1.RegisterAction\n], ChangeOperator);\nlet YankVisualBlockMode = class YankVisualBlockMode extends BaseOperator {\n    constructor() {\n        super(...arguments);\n        this.keys = ['y'];\n        this.modes = [mode_1.Mode.VisualBlock];\n        this.createsUndoPoint = false;\n    }\n    runsOnceForEveryCursor() {\n        return false;\n    }\n    async run(vimState, startPos, endPos) {\n        const ranges = [];\n        const lines = [];\n        for (const { line, start, end } of textEditor_1.TextEditor.iterateLinesInBlock(vimState)) {\n            lines.push(line);\n            ranges.push(new vscode.Range(start, end));\n        }\n        vimState.currentRegisterMode = register_1.RegisterMode.BlockWise;\n        this.highlightYankedRanges(vimState, ranges);\n        register_1.Register.put(vimState, lines.join('\\n'), this.multicursorIndex, true);\n        vimState.historyTracker.addMark(vimState.document, startPos, '<');\n        vimState.historyTracker.addMark(vimState.document, endPos, '>');\n        const numLinesYanked = lines.length;\n        (0, statusBarTextUtils_1.reportLinesYanked)(numLinesYanked, vimState);\n        await vimState.setCurrentMode(mode_1.Mode.Normal);\n        vimState.cursorStopPosition = startPos;\n    }\n};\nYankVisualBlockMode = __decorate([\n    base_1.RegisterAction\n], YankVisualBlockMode);\nlet CommentOperator = class CommentOperator extends BaseOperator {\n    constructor() {\n        super(...arguments);\n        this.keys = ['g', 'c'];\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n    }\n    async run(vimState, start, end) {\n        vimState.editor.selection = new vscode.Selection(start.getLineBegin(), end.getLineEnd());\n        await vscode.commands.executeCommand('editor.action.commentLine');\n        vimState.cursorStopPosition = new vscode_1.Position(start.line, 0);\n        await vimState.setCurrentMode(mode_1.Mode.Normal);\n    }\n};\nCommentOperator = __decorate([\n    base_1.RegisterAction\n], CommentOperator);\nlet ROT13Operator = ROT13Operator_1 = class ROT13Operator extends BaseOperator {\n    constructor() {\n        super(...arguments);\n        this.keys = ['g', '?'];\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n    }\n    async run(vimState, start, end) {\n        let selections;\n        if ((0, mode_1.isVisualMode)(vimState.currentMode)) {\n            selections = vimState.editor.selections;\n        }\n        else if (vimState.currentRegisterMode === register_1.RegisterMode.LineWise) {\n            selections = [new vscode.Selection(start.getLineBegin(), end.getLineEnd())];\n        }\n        else {\n            selections = [new vscode.Selection(start, end.getRight())];\n        }\n        for (const range of selections) {\n            const original = vimState.document.getText(range);\n            vimState.recordedState.transformer.replace(range, ROT13Operator_1.rot13(original));\n        }\n    }\n    /**\n     * https://en.wikipedia.org/wiki/ROT13\n     */\n    static rot13(str) {\n        return str\n            .split('')\n            .map((char) => {\n            let charCode = char.charCodeAt(0);\n            if (char >= 'a' && char <= 'z') {\n                const a = 'a'.charCodeAt(0);\n                charCode = ((charCode - a + 13) % 26) + a;\n            }\n            if (char >= 'A' && char <= 'Z') {\n                const A = 'A'.charCodeAt(0);\n                charCode = ((charCode - A + 13) % 26) + A;\n            }\n            return String.fromCharCode(charCode);\n        })\n            .join('');\n    }\n};\nexports.ROT13Operator = ROT13Operator;\nexports.ROT13Operator = ROT13Operator = ROT13Operator_1 = __decorate([\n    base_1.RegisterAction\n], ROT13Operator);\nlet CommentBlockOperator = class CommentBlockOperator extends BaseOperator {\n    constructor() {\n        super(...arguments);\n        this.keys = ['g', 'C'];\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n    }\n    async run(vimState, start, end) {\n        if (vimState.currentMode === mode_1.Mode.Normal) {\n            // If we're in normal mode, we need to construct a selection for the\n            // command to operate on. If we're not, we've already got it.\n            const endPosition = end.getRight();\n            vimState.editor.selection = new vscode.Selection(start, endPosition);\n        }\n        await vscode.commands.executeCommand('editor.action.blockComment');\n        vimState.cursorStopPosition = start;\n        await vimState.setCurrentMode(mode_1.Mode.Normal);\n    }\n};\nCommentBlockOperator = __decorate([\n    base_1.RegisterAction\n], CommentBlockOperator);\nlet ActionVisualReflowParagraph = ActionVisualReflowParagraph_1 = class ActionVisualReflowParagraph extends BaseOperator {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n        this.keys = ['g', 'q'];\n    }\n    getIndentation(s) {\n        // Use the indentation of the first non-whitespace line, if any such line is\n        // selected.\n        for (const line of s.split('\\n')) {\n            const result = line.match(/^\\s+/g);\n            const indent = result ? result[0] : '';\n            if (indent !== line) {\n                return indent;\n            }\n        }\n        return '';\n    }\n    reflowParagraph(s) {\n        const indent = this.getIndentation(s);\n        let indentLevel = 0;\n        for (const char of indent) {\n            indentLevel += char === '\\t' ? configuration_1.configuration.tabstop : 1;\n        }\n        const maximumLineLength = configuration_1.configuration.textwidth - indentLevel;\n        const chunksToReflow = [];\n        for (const line of s.split('\\n')) {\n            let lastChunk = chunksToReflow[chunksToReflow.length - 1];\n            const trimmedLine = line.trimStart();\n            // See what comment type they are using.\n            let commentType;\n            for (const type of ActionVisualReflowParagraph_1.CommentTypes) {\n                if (trimmedLine.startsWith(type.start)) {\n                    commentType = type;\n                    break;\n                }\n                // If they're currently in a multiline comment, see if they continued it.\n                if (lastChunk &&\n                    !lastChunk.final &&\n                    type.start === lastChunk.commentType.start &&\n                    !type.singleLine) {\n                    if (trimmedLine.startsWith(type.inner)) {\n                        commentType = type;\n                        break;\n                    }\n                    if (trimmedLine.endsWith(type.final)) {\n                        commentType = type;\n                        break;\n                    }\n                }\n            }\n            if (!commentType) {\n                break;\n            } // will never happen, just to satisfy typechecker.\n            // Did they start a new comment type?\n            if (!lastChunk || lastChunk.final || commentType.start !== lastChunk.commentType.start) {\n                const chunk = {\n                    commentType,\n                    content: `${trimmedLine.substr(commentType.start.length).trimStart()}`,\n                    indentLevelAfterComment: 0,\n                    final: false,\n                };\n                if (commentType.singleLine) {\n                    chunk.indentLevelAfterComment =\n                        trimmedLine.substr(commentType.start.length).length - chunk.content.length;\n                }\n                else if (chunk.content.endsWith(commentType.final)) {\n                    // Multiline comment started and ended on one line\n                    chunk.content = chunk.content\n                        .substr(0, chunk.content.length - commentType.final.length)\n                        .trim();\n                    chunk.final = true;\n                }\n                chunksToReflow.push(chunk);\n                continue;\n            }\n            // Parse out commenting style, gather words.\n            lastChunk = chunksToReflow[chunksToReflow.length - 1];\n            if (lastChunk.commentType.singleLine) {\n                // is it a continuation of a comment like \"//\"\n                lastChunk.content += `\\n${trimmedLine\n                    .substr(lastChunk.commentType.start.length)\n                    .trimStart()}`;\n            }\n            else if (!lastChunk.final) {\n                // are we in the middle of a multiline comment like \"/*\"\n                if (trimmedLine.endsWith(lastChunk.commentType.final)) {\n                    lastChunk.final = true;\n                    const prefix = trimmedLine.startsWith(lastChunk.commentType.inner)\n                        ? lastChunk.commentType.inner.length\n                        : 0;\n                    lastChunk.content += `\\n${trimmedLine\n                        .substr(prefix, trimmedLine.length - lastChunk.commentType.final.length - prefix)\n                        .trim()}`;\n                }\n                else if (trimmedLine.startsWith(lastChunk.commentType.inner)) {\n                    lastChunk.content += `\\n${trimmedLine\n                        .substr(lastChunk.commentType.inner.length)\n                        .trimStart()}`;\n                }\n                else if (trimmedLine.startsWith(lastChunk.commentType.start)) {\n                    lastChunk.content += `\\n${trimmedLine\n                        .substr(lastChunk.commentType.start.length)\n                        .trimStart()}`;\n                }\n            }\n        }\n        // Reflow each chunk.\n        const result = [];\n        for (const { commentType, content, indentLevelAfterComment } of chunksToReflow) {\n            const indentAfterComment = Array(indentLevelAfterComment + 1).join(' ');\n            const commentLength = commentType.start.length + indentAfterComment.length;\n            // Start with a single empty content line.\n            const lines = [``];\n            for (let line of content.split('\\n')) {\n                // Preserve blank lines in output.\n                if (line.trim() === '') {\n                    // Replace empty content line with blank line.\n                    if (lines[lines.length - 1] === '') {\n                        lines.pop();\n                    }\n                    lines.push(line);\n                    // Add new empty content line for remaining content.\n                    lines.push(``);\n                    continue;\n                }\n                // Repeatedly partition line into pieces that fit in maximumLineLength\n                while (line) {\n                    const lastLine = lines[lines.length - 1];\n                    // Determine the separator that we'd need to add to the last line\n                    // in order to join onto this line.\n                    let separator;\n                    if (!lastLine) {\n                        separator = '';\n                    }\n                    else if (configuration_1.configuration.joinspaces &&\n                        (lastLine.endsWith('.') || lastLine.endsWith('?') || lastLine.endsWith('!'))) {\n                        separator = '  ';\n                    }\n                    else if (lastLine.endsWith(' ')) {\n                        if (configuration_1.configuration.joinspaces &&\n                            (lastLine.endsWith('. ') || lastLine.endsWith('? ') || lastLine.endsWith('! '))) {\n                            separator = ' ';\n                        }\n                        else {\n                            separator = '';\n                        }\n                    }\n                    else {\n                        separator = ' ';\n                    }\n                    // Consider appending separator and part of line to last line\n                    const remaining = maximumLineLength - separator.length - lastLine.length - commentLength;\n                    const trimmedLine = line.trimStart();\n                    if (trimmedLine.length <= remaining) {\n                        // Entire line fits on last line\n                        lines[lines.length - 1] += `${separator}${trimmedLine}`;\n                        break;\n                    }\n                    else {\n                        // Find largest portion of line that fits on last line,\n                        // by searching backward for a whitespace character (space or tab).\n                        let breakpoint = Math.max(trimmedLine.lastIndexOf(' ', remaining), trimmedLine.lastIndexOf('\\t', remaining));\n                        if (breakpoint < 0) {\n                            // Next word is too long to fit on the current line.\n                            if (lastLine) {\n                                // Start a new line and try again next round.\n                                lines.push('');\n                                continue;\n                            }\n                            else {\n                                // Next word is too long to fit on a line by itself.\n                                // Break it at the next word boundary, if there is one.\n                                breakpoint = trimmedLine.search(/[ \\t]/);\n                                if (breakpoint < 0)\n                                    breakpoint = line.length;\n                            }\n                        }\n                        // Split the line into the part that fits on the last line\n                        // and the remainder.  Start a new line for the remainder.\n                        lines[lines.length - 1] += `${separator}${trimmedLine.slice(0, breakpoint).trimEnd()}`;\n                        line = line.slice(breakpoint + 1);\n                        lines.push('');\n                    }\n                }\n            }\n            // Drop final empty content line.\n            if (lines[lines.length - 1] === '') {\n                lines.pop();\n            }\n            for (let i = 0; i < lines.length; i++) {\n                if (commentType.singleLine) {\n                    lines[i] = `${indent}${commentType.start}${indentAfterComment}${lines[i]}`;\n                }\n                else {\n                    if (i === 0) {\n                        if (lines[i] === '') {\n                            lines[i] = `${indent}${commentType.start}`;\n                        }\n                        else {\n                            lines[i] = `${indent}${commentType.start} ${lines[i]}`;\n                        }\n                        if (i === lines.length - 1) {\n                            lines[i] += ` ${commentType.final}`;\n                        }\n                    }\n                    else if (i === lines.length - 1) {\n                        if (lines[i] === '') {\n                            lines[i] = `${indent} ${commentType.final}`;\n                        }\n                        else {\n                            lines[i] = `${indent} ${commentType.inner} ${lines[i]} ${commentType.final}`;\n                        }\n                    }\n                    else {\n                        if (lines[i] === '') {\n                            lines[i] = `${indent} ${commentType.inner}`;\n                        }\n                        else {\n                            lines[i] = `${indent} ${commentType.inner} ${lines[i]}`;\n                        }\n                    }\n                }\n            }\n            result.push(...lines);\n        }\n        return result.join('\\n');\n    }\n    async run(vimState, start, end) {\n        [start, end] = (0, position_1.sorted)(start, end);\n        start = start.getLineBegin();\n        end = end.getLineEnd();\n        let textToReflow = vimState.document.getText(new vscode.Range(start, end));\n        textToReflow = this.reflowParagraph(textToReflow);\n        vimState.recordedState.transformer.addTransformation({\n            type: 'replaceText',\n            text: textToReflow,\n            range: new vscode.Range(start, end),\n            // Move cursor to front of line to realign the view\n            diff: position_1.PositionDiff.exactCharacter({ character: 0 }),\n        });\n        await vimState.setCurrentMode(mode_1.Mode.Normal);\n    }\n};\nActionVisualReflowParagraph.CommentTypes = [\n    { singleLine: false, start: '/**', inner: '*', final: '*/' },\n    { singleLine: false, start: '/*', inner: '*', final: '*/' },\n    { singleLine: false, start: '{-', inner: '-', final: '-}' },\n    { singleLine: true, start: '///' },\n    { singleLine: true, start: '//!' },\n    { singleLine: true, start: '//' },\n    { singleLine: true, start: '--' },\n    { singleLine: true, start: '#' },\n    { singleLine: true, start: ';' },\n    { singleLine: true, start: '*' },\n    { singleLine: true, start: '%' },\n    // Needs to come last, since everything starts with the empty string!\n    { singleLine: true, start: '' },\n];\nActionVisualReflowParagraph = ActionVisualReflowParagraph_1 = __decorate([\n    base_1.RegisterAction\n], ActionVisualReflowParagraph);\n\n\n//# sourceURL=webpack://vim/./src/actions/operator.ts?")},"./src/actions/plugins/easymotion/easymotion.cmd.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EasyMotionLineMoveCommandBase = exports.EasyMotionWordMoveCommandBase = exports.EasyMotionCharMoveCommandBase = exports.SearchByNCharCommand = exports.SearchByCharCommand = exports.buildTriggerKeys = void 0;\nconst configuration_1 = __webpack_require__(/*! ./../../../configuration/configuration */ \"./src/configuration/configuration.ts\");\nconst mode_1 = __webpack_require__(/*! ./../../../mode/mode */ \"./src/mode/mode.ts\");\nconst base_1 = __webpack_require__(/*! ./../../base */ \"./src/actions/base.ts\");\nconst easymotion_1 = __webpack_require__(/*! ./easymotion */ \"./src/actions/plugins/easymotion/easymotion.ts\");\nconst globalState_1 = __webpack_require__(/*! ../../../state/globalState */ \"./src/state/globalState.ts\");\nconst textEditor_1 = __webpack_require__(/*! ../../../textEditor */ \"./src/textEditor.ts\");\nconst markerGenerator_1 = __webpack_require__(/*! ./markerGenerator */ \"./src/actions/plugins/easymotion/markerGenerator.ts\");\nconst vscode_1 = __webpack_require__(/*! vscode */ \"vscode\");\nfunction buildTriggerKeys(trigger) {\n    return [\n        ...Array.from({ length: trigger.leaderCount || 2 }, () => '<leader>'),\n        ...trigger.key.split(''),\n    ];\n}\nexports.buildTriggerKeys = buildTriggerKeys;\nclass BaseEasyMotionCommand extends base_1.BaseCommand {\n    constructor(baseOptions) {\n        super();\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n        this._baseOptions = baseOptions;\n    }\n    processMarkers(matches, cursorPosition, vimState) {\n        // Clear existing markers, just in case\n        vimState.easyMotion.clearMarkers();\n        let index = 0;\n        const markerGenerator = new markerGenerator_1.MarkerGenerator(matches.length);\n        for (const match of matches) {\n            const matchPosition = this.resolveMatchPosition(match);\n            // Skip if the match position equals to cursor position\n            if (!matchPosition.isEqual(cursorPosition)) {\n                const marker = markerGenerator.generateMarker(index++, matchPosition);\n                if (marker) {\n                    vimState.easyMotion.addMarker(marker);\n                }\n            }\n        }\n    }\n    searchOptions(position) {\n        switch (this._baseOptions.searchOptions) {\n            case 'min':\n                return { min: position };\n            case 'max':\n                return { max: position };\n            default:\n                return {};\n        }\n    }\n    async exec(position, vimState) {\n        // Only execute the action if the configuration is set\n        if (configuration_1.configuration.easymotion) {\n            // Search all occurences of the character pressed\n            const matches = this.getMatches(position, vimState);\n            // Stop if there are no matches\n            if (matches.length > 0) {\n                vimState.easyMotion = new easymotion_1.EasyMotion();\n                this.processMarkers(matches, position, vimState);\n                if (matches.length === 1) {\n                    // Only one found, navigate to it\n                    const marker = vimState.easyMotion.markers[0];\n                    // Set cursor position based on marker entered\n                    vimState.cursorStopPosition = marker.position;\n                    vimState.easyMotion.clearDecorations(vimState.editor);\n                }\n                else {\n                    // Store mode to return to after performing easy motion\n                    vimState.easyMotion.previousMode = vimState.currentMode;\n                    // Enter the EasyMotion mode and await further keys\n                    await vimState.setCurrentMode(mode_1.Mode.EasyMotionMode);\n                }\n            }\n        }\n    }\n}\nfunction getMatchesForString(position, vimState, searchString, options) {\n    switch (searchString) {\n        case '':\n            return [];\n        case ' ':\n            // Searching for space should only find the first space\n            return vimState.easyMotion.sortedSearch(vimState.document, position, new RegExp(' {1,}', 'g'), options);\n        default:\n            // Search all occurences of the character pressed\n            // If the input is not a letter, treating it as regex can cause issues\n            if (!/[a-zA-Z]/.test(searchString)) {\n                return vimState.easyMotion.sortedSearch(vimState.document, position, searchString, options);\n            }\n            const ignorecase = configuration_1.configuration.ignorecase && !(configuration_1.configuration.smartcase && /[A-Z]/.test(searchString));\n            const regexFlags = ignorecase ? 'gi' : 'g';\n            return vimState.easyMotion.sortedSearch(vimState.document, position, new RegExp(searchString, regexFlags), options);\n    }\n}\nclass SearchByCharCommand extends BaseEasyMotionCommand {\n    get searchCharCount() {\n        return this._options.charCount;\n    }\n    constructor(options) {\n        super(options);\n        this.keys = [];\n        this.searchString = '';\n        this._options = options;\n    }\n    getMatches(position, vimState) {\n        return getMatchesForString(position, vimState, this.searchString, this.searchOptions(position));\n    }\n    shouldFire() {\n        const charCount = this._options.charCount;\n        return charCount ? this.searchString.length >= charCount : true;\n    }\n    async fire(position, vimState) {\n        await this.exec(position, vimState);\n    }\n    resolveMatchPosition(match) {\n        const { line, character } = match.position;\n        switch (this._options.labelPosition) {\n            case 'after':\n                return new vscode_1.Position(line, character + this._options.charCount);\n            case 'before':\n                return new vscode_1.Position(line, Math.max(0, character - 1));\n            default:\n                return match.position;\n        }\n    }\n}\nexports.SearchByCharCommand = SearchByCharCommand;\nclass SearchByNCharCommand extends BaseEasyMotionCommand {\n    get searchCharCount() {\n        return -1;\n    }\n    constructor() {\n        super({});\n        this.keys = [];\n        this.searchString = '';\n    }\n    resolveMatchPosition(match) {\n        return match.position;\n    }\n    getMatches(position, vimState) {\n        return getMatchesForString(position, vimState, this.removeTrailingLineBreak(this.searchString), {});\n    }\n    removeTrailingLineBreak(s) {\n        return s.replace(new RegExp('\\n+$', 'g'), '');\n    }\n    shouldFire() {\n        // Fire when <CR> typed\n        return this.searchString.endsWith('\\n');\n    }\n    async fire(position, vimState) {\n        if (this.removeTrailingLineBreak(this.searchString) !== '') {\n            await this.exec(position, vimState);\n        }\n    }\n}\nexports.SearchByNCharCommand = SearchByNCharCommand;\nclass EasyMotionCharMoveCommandBase extends base_1.BaseCommand {\n    constructor(action) {\n        super();\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n        this._action = action;\n    }\n    async exec(position, vimState) {\n        // Only execute the action if easymotion is enabled\n        if (configuration_1.configuration.easymotion) {\n            vimState.easyMotion = new easymotion_1.EasyMotion();\n            vimState.easyMotion.previousMode = vimState.currentMode;\n            vimState.easyMotion.searchAction = this._action;\n            globalState_1.globalState.hl = true;\n            await vimState.setCurrentMode(mode_1.Mode.EasyMotionInputMode);\n        }\n    }\n}\nexports.EasyMotionCharMoveCommandBase = EasyMotionCharMoveCommandBase;\nclass EasyMotionWordMoveCommandBase extends BaseEasyMotionCommand {\n    constructor(options = {}) {\n        super(options);\n        this._options = options;\n    }\n    getMatches(position, vimState) {\n        return this.getMatchesForWord(position, vimState, this.searchOptions(position));\n    }\n    resolveMatchPosition(match) {\n        const { line, character } = match.position;\n        switch (this._options.labelPosition) {\n            case 'after':\n                return new vscode_1.Position(line, character + match.text.length - 1);\n            default:\n                return match.position;\n        }\n    }\n    getMatchesForWord(position, vimState, options) {\n        const regex = this._options.jumpToAnywhere\n            ? new RegExp(configuration_1.configuration.easymotionJumpToAnywhereRegex, 'g')\n            : new RegExp('\\\\w{1,}', 'g');\n        return vimState.easyMotion.sortedSearch(vimState.document, position, regex, options);\n    }\n}\nexports.EasyMotionWordMoveCommandBase = EasyMotionWordMoveCommandBase;\nclass EasyMotionLineMoveCommandBase extends BaseEasyMotionCommand {\n    constructor(options = {}) {\n        super(options);\n        this._options = options;\n    }\n    resolveMatchPosition(match) {\n        return match.position;\n    }\n    getMatches(position, vimState) {\n        return this.getMatchesForLineStart(position, vimState, this.searchOptions(position));\n    }\n    getMatchesForLineStart(position, vimState, options) {\n        // Search for the beginning of all non whitespace chars on each line before the cursor\n        const matches = vimState.easyMotion.sortedSearch(vimState.document, position, new RegExp('^.', 'gm'), options);\n        for (const match of matches) {\n            match.position = textEditor_1.TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, match.position.line);\n        }\n        return matches;\n    }\n}\nexports.EasyMotionLineMoveCommandBase = EasyMotionLineMoveCommandBase;\nlet EasyMotionCharInputMode = class EasyMotionCharInputMode extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.EasyMotionInputMode];\n        this.keys = ['<character>'];\n    }\n    async exec(position, vimState) {\n        const key = this.keysPressed[0];\n        const action = vimState.easyMotion.searchAction;\n        action.searchString =\n            key === '<BS>' || key === '<S-BS>'\n                ? action.searchString.slice(0, -1)\n                : action.searchString + key;\n        if (action.shouldFire()) {\n            // Skip Easymotion input mode to make sure not to back to it\n            await vimState.setCurrentMode(vimState.easyMotion.previousMode);\n            await action.fire(vimState.cursorStopPosition, vimState);\n        }\n    }\n};\nEasyMotionCharInputMode = __decorate([\n    base_1.RegisterAction\n], EasyMotionCharInputMode);\nlet CommandEscEasyMotionCharInputMode = class CommandEscEasyMotionCharInputMode extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.EasyMotionInputMode];\n        this.keys = ['<Esc>'];\n    }\n    async exec(position, vimState) {\n        await vimState.setCurrentMode(mode_1.Mode.Normal);\n    }\n};\nCommandEscEasyMotionCharInputMode = __decorate([\n    base_1.RegisterAction\n], CommandEscEasyMotionCharInputMode);\nlet MoveEasyMotion = class MoveEasyMotion extends base_1.BaseCommand {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.EasyMotionMode];\n        this.keys = ['<character>'];\n        this.isJump = true;\n    }\n    async exec(position, vimState) {\n        const key = this.keysPressed[0];\n        if (key) {\n            // \"nail\" refers to the accumulated depth keys\n            const nail = vimState.easyMotion.accumulation + key;\n            vimState.easyMotion.accumulation = nail;\n            // Find markers starting with \"nail\"\n            const markers = vimState.easyMotion.findMarkers(nail, true);\n            if (markers.length === 1) {\n                // Only one found, navigate to it\n                const marker = markers[0];\n                vimState.easyMotion.clearDecorations(vimState.editor);\n                // Restore the mode from before easy motion\n                await vimState.setCurrentMode(vimState.easyMotion.previousMode);\n                // Set cursor position based on marker entered\n                vimState.cursorStopPosition = marker.position;\n            }\n            else if (markers.length === 0) {\n                // None found, exit mode\n                vimState.easyMotion.clearDecorations(vimState.editor);\n                await vimState.setCurrentMode(vimState.easyMotion.previousMode);\n            }\n        }\n    }\n};\nMoveEasyMotion = __decorate([\n    base_1.RegisterAction\n], MoveEasyMotion);\n\n\n//# sourceURL=webpack://vim/./src/actions/plugins/easymotion/easymotion.cmd.ts?")},"./src/actions/plugins/easymotion/easymotion.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EasyMotion = void 0;\nconst vscode = __importStar(__webpack_require__(/*! vscode */ \"vscode\"));\nconst vscode_1 = __webpack_require__(/*! vscode */ \"vscode\");\nconst configuration_1 = __webpack_require__(/*! ./../../../configuration/configuration */ \"./src/configuration/configuration.ts\");\nconst textEditor_1 = __webpack_require__(/*! ./../../../textEditor */ \"./src/textEditor.ts\");\nconst types_1 = __webpack_require__(/*! ./types */ \"./src/actions/plugins/easymotion/types.ts\");\nclass EasyMotion {\n    constructor() {\n        /**\n         * Refers to the accumulated keys for depth navigation\n         */\n        this.accumulation = '';\n        this.markers = [];\n        this.visibleMarkers = [];\n        this.decorations = [];\n    }\n    /**\n     * Create and cache decoration types for different marker lengths\n     */\n    static getDecorationType(length, decorations) {\n        const cache = this.decorationTypeCache[length];\n        if (cache) {\n            return cache;\n        }\n        else {\n            const type = vscode.window.createTextEditorDecorationType(decorations || {});\n            this.decorationTypeCache[length] = type;\n            return type;\n        }\n    }\n    /**\n     * Clear all decorations\n     */\n    clearDecorations(editor) {\n        for (let i = 1; i <= this.decorations.length; i++) {\n            editor.setDecorations(EasyMotion.getDecorationType(i), []);\n        }\n        editor.setDecorations(EasyMotion.fade, []);\n        editor.setDecorations(EasyMotion.hide, []);\n    }\n    /**\n     * Clear all markers\n     */\n    clearMarkers() {\n        while (this.markers.length) {\n            this.markers.pop();\n        }\n        this.visibleMarkers = [];\n    }\n    addMarker(marker) {\n        this.markers.push(marker);\n    }\n    /**\n     * Find markers beginning with a string\n     */\n    findMarkers(nail, onlyVisible) {\n        const markers = onlyVisible ? this.visibleMarkers : this.markers;\n        return markers.filter((marker) => marker.name.startsWith(nail));\n    }\n    /**\n     * Search and sort using the index of a match compared to the index of position (usually the cursor)\n     */\n    sortedSearch(document, position, search = '', options = {}) {\n        const regex = typeof search === 'string'\n            ? new RegExp(search.replace(EasyMotion.specialCharactersRegex, '\\\\$&'), 'g')\n            : search;\n        const matches = [];\n        // Cursor index refers to the index of the marker that is on or to the right of the cursor\n        let cursorIndex = position.character;\n        let prevMatch;\n        // Calculate the min/max bounds for the search\n        const lineCount = document.lineCount;\n        const lineMin = options.min ? Math.max(options.min.line, 0) : 0;\n        const lineMax = options.max ? Math.min(options.max.line + 1, lineCount) : lineCount;\n        outer: for (let lineIdx = lineMin; lineIdx < lineMax; lineIdx++) {\n            const line = document.lineAt(lineIdx).text;\n            let result = regex.exec(line);\n            while (result) {\n                if (matches.length >= 1000) {\n                    break outer;\n                }\n                else {\n                    const pos = new vscode_1.Position(lineIdx, result.index);\n                    // Check if match is within bounds\n                    if ((options.min && pos.isBefore(options.min)) ||\n                        (options.max && pos.isAfter(options.max)) ||\n                        Math.abs(pos.line - position.line) > 100) {\n                        // Stop searching after 100 lines in both directions\n                        result = regex.exec(line);\n                    }\n                    else {\n                        // Update cursor index to the marker on the right side of the cursor\n                        if (!prevMatch || prevMatch.position.isBefore(position)) {\n                            cursorIndex = matches.length;\n                        }\n                        // Matches on the cursor position should be ignored\n                        if (pos.isEqual(position)) {\n                            result = regex.exec(line);\n                        }\n                        else {\n                            prevMatch = new types_1.Match(pos, result[0], matches.length);\n                            matches.push(prevMatch);\n                            result = regex.exec(line);\n                        }\n                    }\n                }\n            }\n        }\n        // Sort by the index distance from the cursor index\n        matches.sort((a, b) => {\n            const computeAboluteDiff = (matchIndex) => {\n                const absDiff = Math.abs(cursorIndex - matchIndex);\n                // Prioritize the matches on the right side of the cursor index\n                return matchIndex < cursorIndex ? absDiff - 0.5 : absDiff;\n            };\n            const absDiffA = computeAboluteDiff(a.index);\n            const absDiffB = computeAboluteDiff(b.index);\n            return absDiffA - absDiffB;\n        });\n        return matches;\n    }\n    getMarkerColor(customizedValue, themeColorId) {\n        if (customizedValue) {\n            return customizedValue;\n        }\n        else if (!themeColorId.startsWith('#')) {\n            return new vscode.ThemeColor(themeColorId);\n        }\n        else {\n            return themeColorId;\n        }\n    }\n    getEasymotionMarkerBackgroundColor() {\n        return this.getMarkerColor(configuration_1.configuration.easymotionMarkerBackgroundColor, '#0000');\n    }\n    getEasymotionMarkerForegroundColorOneChar() {\n        return this.getMarkerColor(configuration_1.configuration.easymotionMarkerForegroundColorOneChar, '#ff0000');\n    }\n    getEasymotionMarkerForegroundColorTwoCharFirst() {\n        return this.getMarkerColor(configuration_1.configuration.easymotionMarkerForegroundColorTwoCharFirst, '#ffb400');\n    }\n    getEasymotionMarkerForegroundColorTwoCharSecond() {\n        return this.getMarkerColor(configuration_1.configuration.easymotionMarkerForegroundColorTwoCharSecond, '#b98300');\n    }\n    getEasymotionDimColor() {\n        return this.getMarkerColor(configuration_1.configuration.easymotionDimColor, '#777777');\n    }\n    updateDecorations(editor) {\n        this.clearDecorations(editor);\n        this.visibleMarkers = [];\n        this.decorations = [];\n        // Set the decorations for all the different marker lengths\n        const dimmingZones = [];\n        const dimmingRenderOptions = {\n            // we update the color here again in case the configuration has changed\n            color: this.getEasymotionDimColor(),\n        };\n        // Why this instead of `background-color` on the marker?\n        // The easy fix would've been to let the user set the marker background to the same\n        // color as the editor so it would hide the character behind, However this would require\n        // the user to do more work, with this solution we temporarily hide the marked character\n        // so no user specific setting is needed\n        const hiddenChars = [];\n        const markers = this.markers\n            .filter((m) => m.name.startsWith(this.accumulation))\n            .sort((a, b) => (a.position.isBefore(b.position) ? -1 : 1));\n        // Ignore markers that do not start with the accumulated depth level\n        for (const marker of markers) {\n            const pos = marker.position;\n            // Get keys after the depth we're at\n            const keystroke = marker.name.substr(this.accumulation.length);\n            if (!this.decorations[keystroke.length]) {\n                this.decorations[keystroke.length] = [];\n            }\n            // #region Hack (remove once backend handles this)\n            /*\n              This hack is here because the backend for easy motion reports two adjacent\n              2 char markers resulting in a 4 char wide markers, this isn't what happens in\n              original easymotion for instance: for doom\n                  - original reports d[m][m2]m where [m] is a marker and [m2] is secondary\n                  - here it reports d[m][m][m][m]m\n              The reason this won't work with current impl is that it overflows resulting in\n              one extra hidden character, hence the check below (until backend truely mimics original)\n      \n              if two consecutive 2 char markers, we only use the first char from the current marker\n              and reduce the char substitution by 1. Once backend properly reports adjacent markers\n              all instances of `trim` can be removed\n            */\n            let trim = 0;\n            const next = markers[markers.indexOf(marker) + 1];\n            if (next &&\n                next.position.character - pos.character === 1 &&\n                next.position.line === pos.line) {\n                const nextKeystroke = next.name.substr(this.accumulation.length);\n                if (keystroke.length > 1 && nextKeystroke.length > 1) {\n                    trim = -1;\n                }\n            }\n            // #endregion\n            // First Char/One Char decoration\n            const firstCharFontColor = keystroke.length > 1\n                ? this.getEasymotionMarkerForegroundColorTwoCharFirst()\n                : this.getEasymotionMarkerForegroundColorOneChar();\n            const backgroundColor = this.getEasymotionMarkerBackgroundColor();\n            const firstCharRange = new vscode.Range(pos.line, pos.character, pos.line, pos.character);\n            const firstCharRenderOptions = {\n                before: {\n                    contentText: keystroke.substring(0, 1),\n                    backgroundColor,\n                    color: firstCharFontColor,\n                    margin: `0 -1ch 0 0;\n          position: absolute;\n          font-weight: ${configuration_1.configuration.easymotionMarkerFontWeight};`,\n                    height: '100%',\n                },\n            };\n            this.decorations[keystroke.length].push({\n                range: firstCharRange,\n                renderOptions: {\n                    dark: firstCharRenderOptions,\n                    light: firstCharRenderOptions,\n                },\n            });\n            // Second Char decoration\n            if (keystroke.length + trim > 1) {\n                const secondCharFontColor = this.getEasymotionMarkerForegroundColorTwoCharSecond();\n                const secondCharRange = new vscode.Range(pos.line, pos.character + 1, pos.line, pos.character + 1);\n                const secondCharRenderOptions = {\n                    before: {\n                        contentText: keystroke.slice(1),\n                        backgroundColor,\n                        color: secondCharFontColor,\n                        margin: `0 -1ch 0 0;\n            position: absolute;\n            font-weight: ${configuration_1.configuration.easymotionMarkerFontWeight};`,\n                        height: '100%',\n                    },\n                };\n                this.decorations[keystroke.length].push({\n                    range: secondCharRange,\n                    renderOptions: {\n                        dark: secondCharRenderOptions,\n                        light: secondCharRenderOptions,\n                    },\n                });\n            }\n            hiddenChars.push(new vscode.Range(pos.line, pos.character, pos.line, pos.character + keystroke.length + trim));\n            if (configuration_1.configuration.easymotionDimBackground) {\n                // This excludes markers from the dimming ranges by using them as anchors\n                // each marker adds the range between it and previous marker to the dimming zone\n                // except last marker after which the rest of document is dimmed\n                //\n                // example [m1] text that has multiple [m2] marks\n                // |<------    |<----------------------     ----\x3e|\n                if (dimmingZones.length === 0) {\n                    dimmingZones.push({\n                        range: new vscode.Range(0, 0, pos.line, pos.character),\n                        renderOptions: dimmingRenderOptions,\n                    });\n                }\n                else {\n                    const prevMarker = markers[markers.indexOf(marker) - 1];\n                    const prevKeystroke = prevMarker.name.substring(this.accumulation.length);\n                    const prevDimPos = prevMarker.position;\n                    const offsetPrevDimPos = prevDimPos.withColumn(prevDimPos.character + prevKeystroke.length);\n                    // Don't create dimming ranges in between consecutive markers (the 'after' is in the cases\n                    // where you have 2 char consecutive markers where the first one only shows the first char.\n                    // since we don't take that into account when creating 'offsetPrevDimPos' it will be after\n                    // the current marker position which means we are in the middle of two consecutive markers.\n                    // See the hack region above.)\n                    if (!offsetPrevDimPos.isAfterOrEqual(pos)) {\n                        dimmingZones.push({\n                            range: new vscode.Range(offsetPrevDimPos.line, offsetPrevDimPos.character, pos.line, pos.character),\n                            renderOptions: dimmingRenderOptions,\n                        });\n                    }\n                }\n            }\n            this.visibleMarkers.push(marker);\n        }\n        // for the last marker dim till document end\n        if (configuration_1.configuration.easymotionDimBackground && markers.length > 0) {\n            const prevMarker = markers[markers.length - 1];\n            const prevKeystroke = prevMarker.name.substring(this.accumulation.length);\n            const prevDimPos = dimmingZones[dimmingZones.length - 1].range.end;\n            const offsetPrevDimPos = prevDimPos.withColumn(prevDimPos.character + prevKeystroke.length);\n            // Don't create any more dimming ranges when the last marker is at document end\n            if (!offsetPrevDimPos.isEqual(textEditor_1.TextEditor.getDocumentEnd(editor.document))) {\n                dimmingZones.push({\n                    range: new vscode.Range(offsetPrevDimPos, new vscode_1.Position(editor.document.lineCount, Number.MAX_VALUE)),\n                    renderOptions: dimmingRenderOptions,\n                });\n            }\n        }\n        for (let j = 1; j < this.decorations.length; j++) {\n            if (this.decorations[j]) {\n                editor.setDecorations(EasyMotion.getDecorationType(j), this.decorations[j]);\n            }\n        }\n        editor.setDecorations(EasyMotion.hide, hiddenChars);\n        if (configuration_1.configuration.easymotionDimBackground) {\n            editor.setDecorations(EasyMotion.fade, dimmingZones);\n        }\n    }\n}\nexports.EasyMotion = EasyMotion;\nEasyMotion.fade = vscode.window.createTextEditorDecorationType({\n    color: configuration_1.configuration.easymotionDimColor,\n});\nEasyMotion.hide = vscode.window.createTextEditorDecorationType({\n    color: 'transparent',\n});\n/**\n * TODO: For future motions\n */\nEasyMotion.specialCharactersRegex = /[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g;\n/**\n * Caches for decorations\n */\nEasyMotion.decorationTypeCache = [];\n\n\n//# sourceURL=webpack://vim/./src/actions/plugins/easymotion/easymotion.ts?")},"./src/actions/plugins/easymotion/markerGenerator.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MarkerGenerator = void 0;\nconst configuration_1 = __webpack_require__(/*! ./../../../configuration/configuration */ \"./src/configuration/configuration.ts\");\nclass MarkerGenerator {\n    constructor(matchesCount) {\n        this.matchesCount = matchesCount;\n        this.keyTable = this.getKeyTable();\n        this.prefixKeyTable = this.createPrefixKeyTable();\n    }\n    generateMarker(index, markerPosition) {\n        const { keyTable, prefixKeyTable } = this;\n        if (index >= keyTable.length - prefixKeyTable.length) {\n            const remainder = index - (keyTable.length - prefixKeyTable.length);\n            const currentStep = Math.floor(remainder / keyTable.length) + 1;\n            if (currentStep > prefixKeyTable.length) {\n                return null;\n            }\n            else {\n                const prefix = prefixKeyTable[currentStep - 1];\n                const label = keyTable[remainder % keyTable.length];\n                return {\n                    name: prefix + label,\n                    position: markerPosition,\n                };\n            }\n        }\n        else {\n            return {\n                name: keyTable[index],\n                position: markerPosition,\n            };\n        }\n    }\n    createPrefixKeyTable() {\n        const totalRemainder = Math.max(this.matchesCount - this.keyTable.length, 0);\n        const totalSteps = Math.ceil(totalRemainder / this.keyTable.length);\n        const reversed = this.keyTable.slice().reverse();\n        const count = Math.min(totalSteps, reversed.length);\n        return reversed.slice(0, count);\n    }\n    /**\n     * The key sequence for marker name generation\n     */\n    getKeyTable() {\n        if (configuration_1.configuration.easymotionKeys) {\n            return configuration_1.configuration.easymotionKeys.split('');\n        }\n        else {\n            return 'hklyuiopnm,qwertzxcvbasdgjf;'.split('');\n        }\n    }\n}\nexports.MarkerGenerator = MarkerGenerator;\n\n\n//# sourceURL=webpack://vim/./src/actions/plugins/easymotion/markerGenerator.ts?")},"./src/actions/plugins/easymotion/types.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.Match = void 0;\nconst vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));\nclass Match {\n    constructor(position, text, index) {\n        this.position = position;\n        this.text = text;\n        this.index = index;\n    }\n    toRange() {\n        return new vscode.Range(this.position, this.position.translate(0, this.text.length));\n    }\n}\nexports.Match = Match;\n\n\n//# sourceURL=webpack://vim/./src/actions/plugins/easymotion/types.ts?')},"./src/actions/plugins/pluginDefaultMappings.ts":(__unused_webpack_module,exports)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PluginDefaultMappings = void 0;\nclass PluginDefaultMappings {\n    static getPluginDefaultMappings(mode, config) {\n        return this.defaultMappings\n            .filter((m) => m.mode === mode && config[m.configSwitch])\n            .map((m) => m.mapping);\n    }\n}\nexports.PluginDefaultMappings = PluginDefaultMappings;\n// plugin authers may add entries here\nPluginDefaultMappings.defaultMappings = [\n    // default maps for surround\n    {\n        mode: 'normalModeKeyBindingsNonRecursive',\n        configSwitch: 'surround',\n        mapping: { before: ['y', 's'], after: ['<plugys>'] },\n    },\n    {\n        mode: 'normalModeKeyBindingsNonRecursive',\n        configSwitch: 'surround',\n        mapping: { before: ['y', 's', 's'], after: ['<plugys>', '<plugys>'] },\n    },\n    {\n        mode: 'normalModeKeyBindingsNonRecursive',\n        configSwitch: 'surround',\n        mapping: { before: ['c', 's'], after: ['<plugcs>'] },\n    },\n    {\n        mode: 'normalModeKeyBindingsNonRecursive',\n        configSwitch: 'surround',\n        mapping: { before: ['d', 's'], after: ['<plugds>'] },\n    },\n];\n\n\n//# sourceURL=webpack://vim/./src/actions/plugins/pluginDefaultMappings.ts?")},"./src/actions/plugins/sneak.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar SneakForward_1, SneakBackward_1;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SneakBackward = exports.SneakForward = void 0;\nconst configuration_1 = __webpack_require__(/*! ./../../configuration/configuration */ \"./src/configuration/configuration.ts\");\nconst base_1 = __webpack_require__(/*! ./../base */ \"./src/actions/base.ts\");\nconst baseMotion_1 = __webpack_require__(/*! ../baseMotion */ \"./src/actions/baseMotion.ts\");\nconst vscode_1 = __webpack_require__(/*! vscode */ \"vscode\");\nlet SneakForward = SneakForward_1 = class SneakForward extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = [\n            ['s', '<character>', '<character>'],\n            ['z', '<character>', '<character>'],\n        ];\n        this.isJump = true;\n    }\n    couldActionApply(vimState, keysPressed) {\n        const startingLetter = vimState.recordedState.operator === undefined ? 's' : 'z';\n        return (configuration_1.configuration.sneak &&\n            super.couldActionApply(vimState, keysPressed) &&\n            keysPressed[0] === startingLetter);\n    }\n    async execAction(position, vimState) {\n        if (!this.isRepeat) {\n            vimState.lastSemicolonRepeatableMovement = new SneakForward_1(this.keysPressed, true);\n            vimState.lastCommaRepeatableMovement = new SneakBackward(this.keysPressed, true);\n        }\n        if (this.keysPressed[2] === '\\n') {\n            // Single key sneak\n            this.keysPressed[2] = '';\n        }\n        const searchString = this.keysPressed[1] + this.keysPressed[2];\n        const document = vimState.document;\n        const lineCount = document.lineCount;\n        for (let i = position.line; i < lineCount; ++i) {\n            const lineText = document.lineAt(i).text;\n            // Start searching after the current character so we don't find the same match twice\n            const fromIndex = i === position.line ? position.character + 1 : 0;\n            let matchIndex = -1;\n            const ignorecase = configuration_1.configuration.sneakUseIgnorecaseAndSmartcase &&\n                configuration_1.configuration.ignorecase &&\n                !(configuration_1.configuration.smartcase && /[A-Z]/.test(searchString));\n            // Check for matches\n            if (ignorecase) {\n                matchIndex = lineText\n                    .toLocaleLowerCase()\n                    .indexOf(searchString.toLocaleLowerCase(), fromIndex);\n            }\n            else {\n                matchIndex = lineText.indexOf(searchString, fromIndex);\n            }\n            if (matchIndex >= 0) {\n                return new vscode_1.Position(i, matchIndex);\n            }\n        }\n        return position;\n    }\n};\nexports.SneakForward = SneakForward;\nexports.SneakForward = SneakForward = SneakForward_1 = __decorate([\n    base_1.RegisterAction\n], SneakForward);\nlet SneakBackward = SneakBackward_1 = class SneakBackward extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.keys = [\n            ['S', '<character>', '<character>'],\n            ['Z', '<character>', '<character>'],\n        ];\n        this.isJump = true;\n    }\n    couldActionApply(vimState, keysPressed) {\n        const startingLetter = vimState.recordedState.operator === undefined ? 'S' : 'Z';\n        return (configuration_1.configuration.sneak &&\n            super.couldActionApply(vimState, keysPressed) &&\n            keysPressed[0] === startingLetter);\n    }\n    async execAction(position, vimState) {\n        if (!this.isRepeat) {\n            vimState.lastSemicolonRepeatableMovement = new SneakBackward_1(this.keysPressed, true);\n            vimState.lastCommaRepeatableMovement = new SneakForward(this.keysPressed, true);\n        }\n        if (this.keysPressed[2] === '\\n') {\n            // Single key sneak\n            this.keysPressed[2] = '';\n        }\n        const searchString = this.keysPressed[1] + this.keysPressed[2];\n        const document = vimState.document;\n        for (let i = position.line; i >= 0; --i) {\n            const lineText = document.lineAt(i).text;\n            // Start searching before the current character so we don't find the same match twice\n            const fromIndex = i === position.line ? position.character - 1 : +Infinity;\n            let matchIndex = -1;\n            const ignorecase = configuration_1.configuration.sneakUseIgnorecaseAndSmartcase &&\n                configuration_1.configuration.ignorecase &&\n                !(configuration_1.configuration.smartcase && /[A-Z]/.test(searchString));\n            // Check for matches\n            if (ignorecase) {\n                matchIndex = lineText\n                    .toLocaleLowerCase()\n                    .lastIndexOf(searchString.toLocaleLowerCase(), fromIndex);\n            }\n            else {\n                matchIndex = lineText.lastIndexOf(searchString, fromIndex);\n            }\n            if (matchIndex >= 0) {\n                return new vscode_1.Position(i, matchIndex);\n            }\n        }\n        return position;\n    }\n};\nexports.SneakBackward = SneakBackward;\nexports.SneakBackward = SneakBackward = SneakBackward_1 = __decorate([\n    base_1.RegisterAction\n], SneakBackward);\n\n\n//# sourceURL=webpack://vim/./src/actions/plugins/sneak.ts?")},"./src/actions/plugins/targets/smartQuotesMatcher.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.SmartQuoteMatcher = void 0;\nconst configuration_1 = __webpack_require__(/*! ../../../configuration/configuration */ "./src/configuration/configuration.ts");\nvar QuoteMatch;\n(function (QuoteMatch) {\n    QuoteMatch[QuoteMatch["Opening"] = 0] = "Opening";\n    QuoteMatch[QuoteMatch["Closing"] = 1] = "Closing";\n})(QuoteMatch || (QuoteMatch = {}));\n/**\n * This mapping is used to give a way to identify which action we need to take when operating on a line.\n * The keys here are, in some sense, the number of quotes in the line, in the format of `lcr`, where:\n * `l` means left of the cursor, `c` whether the cursor is on a quote, and `r` is right of the cursor.\n *\n * It is based on the ideas used in `targets.vim`. For each line & cursor position, we count the number of quotes\n * left (#L) and right (#R) of the cursor. Using those numbers and whether the cursor it on a quote, we know\n * what action to make.\n *\n * For each entry we have an example of a line & position.\n */\nconst quoteDirs = {\n    \'002\': {\n        // | "a" "b" "c"\n        search: { first: \'>\', second: \'>\', includeCurrent: false },\n        skipToLeft: 0,\n        skipToRight: 1,\n    },\n    \'012\': {\n        // |"a" "b" "c" "\n        search: { first: \'>\', second: \'>\', includeCurrent: true },\n        skipToLeft: 0,\n        skipToRight: 2,\n    },\n    \'102\': {\n        // "a" "|b" "c" "\n        search: { first: \'<\', second: \'>\', includeCurrent: false },\n        skipToLeft: 2,\n        skipToRight: 2,\n    },\n    \'112\': {\n        //  "a" "b|" "c"\n        search: { first: \'<\', second: \'<\', includeCurrent: true },\n        skipToLeft: 2,\n        skipToRight: 1,\n    },\n    \'202\': {\n        //  "a"| "b" "c"\n        search: { first: \'>\', second: \'>\', includeCurrent: false },\n        skipToLeft: 1,\n        skipToRight: 1,\n    },\n    \'211\': {\n        //  "a" |"b" "c"\n        search: { first: \'>\', second: \'>\', includeCurrent: true },\n        skipToLeft: 1,\n        skipToRight: 2,\n    },\n    \'101\': {\n        //  "a" "|b" "c"\n        search: { first: \'<\', second: \'>\', includeCurrent: false },\n        skipToLeft: 2,\n        skipToRight: 2,\n    },\n    \'011\': {\n        //  |"a" "b" "c"\n        search: { first: \'>\', second: \'>\', includeCurrent: true },\n        skipToLeft: 0,\n        skipToRight: 2,\n    },\n    \'110\': {\n        //  "a" "b" "c|"\n        search: { first: \'<\', second: \'<\', includeCurrent: true },\n        skipToLeft: 2,\n        skipToRight: 0,\n    },\n    \'212\': {\n        //  "a" |"b" "c" "\n        search: { first: \'>\', second: \'>\', includeCurrent: true },\n        skipToLeft: 1,\n        skipToRight: 2,\n    },\n    \'111\': {\n        //  "a" "b|" "c" "\n        search: { first: \'<\', second: \'<\', includeCurrent: true },\n        skipToLeft: 2,\n        skipToRight: 1,\n    },\n    \'200\': {\n        //  "a" "b" "c"|\n        search: { first: \'<\', second: \'<\', includeCurrent: false },\n        skipToLeft: 1,\n        skipToRight: 0,\n    },\n    \'201\': {\n        //  "a" "b" "c"| "\n        //  "a"| "b" "c" "\n        search: { first: \'>\', second: \'>\', includeCurrent: false },\n        skipToLeft: 1,\n        skipToRight: 1,\n    },\n    \'210\': {\n        //  "a" "b" "c" |"\n        search: undefined,\n        skipToLeft: 1,\n        skipToRight: 0,\n    },\n    \'001\': {\n        // | "a" "b" "c" "\n        search: undefined,\n        skipToLeft: 0,\n        skipToRight: 1,\n    },\n    \'010\': {\n        //  a|"b\n        search: undefined,\n        skipToLeft: 0,\n        skipToRight: 0,\n    },\n    \'100\': {\n        //  "a" "b" "c" "|\n        search: undefined,\n        skipToLeft: 2,\n        skipToRight: 0,\n    },\n    \'000\': {\n        //  |ab\n        search: undefined,\n        skipToLeft: 0,\n        skipToRight: 0,\n    },\n};\nclass SmartQuoteMatcher {\n    constructor(quote, document) {\n        this.quote = quote;\n        this.document = document;\n    }\n    buildQuoteMap(text) {\n        const quoteMap = [];\n        let openingQuote = true;\n        // Loop over text, marking quotes and respecting escape characters.\n        for (let i = 0; i < text.length; i++) {\n            if (text[i] === SmartQuoteMatcher.escapeChar) {\n                i += 1;\n                continue;\n            }\n            if ((this.quote === \'any\' && (text[i] === \'"\' || text[i] === "\'" || text[i] === \'`\')) ||\n                text[i] === this.quote) {\n                quoteMap[i] = openingQuote ? QuoteMatch.Opening : QuoteMatch.Closing;\n                openingQuote = !openingQuote;\n            }\n        }\n        return quoteMap;\n    }\n    static lineSearchAction(cursorIndex, quoteMap) {\n        // base on ideas from targets.vim\n        // cut line in left of, on and right of cursor\n        const left = Array.from(quoteMap.entries()).slice(undefined, cursorIndex);\n        const cursor = quoteMap[cursorIndex];\n        const right = Array.from(quoteMap.entries()).slice(cursorIndex + 1, undefined);\n        // how many delimiters left, on and right of cursor\n        const lc = left.filter(([_, v]) => v !== undefined).length;\n        const cc = cursor !== undefined ? 1 : 0;\n        const rc = right.filter(([_, v]) => v !== undefined).length;\n        // truncate counts\n        const lct = lc === 0 ? 0 : lc % 2 === 0 ? 2 : 1;\n        const rct = rc === 0 ? 0 : rc >= 2 ? 2 : 1;\n        const key = `${lct}${cc}${rct}`;\n        const act = quoteDirs[key];\n        return act;\n    }\n    smartSurroundingQuotes(position, which) {\n        position = this.document.validatePosition(position);\n        const cursorIndex = position.character;\n        const lineText = this.document.lineAt(position).text;\n        const quoteMap = this.buildQuoteMap(lineText);\n        const act = SmartQuoteMatcher.lineSearchAction(cursorIndex, quoteMap);\n        if (which === \'current\') {\n            if (act.search) {\n                const searchRes = this.smartSearch(cursorIndex, act.search, quoteMap);\n                return searchRes\n                    ? {\n                        start: position.with({ character: searchRes[0] }),\n                        stop: position.with({ character: searchRes[1] }),\n                        lineText,\n                    }\n                    : undefined;\n            }\n            else {\n                return undefined;\n            }\n        }\n        else if (which === \'next\') {\n            // search quote in current line\n            const right = Array.from(quoteMap.entries()).slice(cursorIndex + 1, undefined);\n            const [index, found] = right.filter(([i, v]) => v !== undefined)[act.skipToRight] ?? [\n                +Infinity,\n                undefined,\n            ];\n            // find next position for surrounding quotes, possibly breaking through lines\n            let nextPos;\n            position = position.with({ character: index });\n            if (found === undefined && configuration_1.configuration.targets.smartQuotes.breakThroughLines) {\n                // nextPos = State.evalGenerator(this.getNextQuoteThroughLineBreaks(), position);\n                nextPos = this.getNextQuoteThroughLineBreaks(position);\n            }\n            else {\n                nextPos = found !== undefined ? position : undefined;\n            }\n            // find surrounding with new position\n            if (nextPos) {\n                return this.smartSurroundingQuotes(nextPos, \'current\');\n            }\n            else {\n                return undefined;\n            }\n        }\n        else if (which === \'last\') {\n            // search quote in current line\n            const left = Array.from(quoteMap.entries()).slice(undefined, cursorIndex);\n            const [index, found] = left.reverse().filter(([i, v]) => v !== undefined)[act.skipToLeft] ?? [\n                0,\n                undefined,\n            ];\n            // find last position for surrounding quotes, possibly breaking through lines\n            let lastPos;\n            position = position.with({ character: index });\n            if (found === undefined && configuration_1.configuration.targets.smartQuotes.breakThroughLines) {\n                position = position.getLeftThroughLineBreaks();\n                lastPos = this.getLastQuoteThroughLineBreaks(position);\n            }\n            else {\n                lastPos = found !== undefined ? position : undefined;\n            }\n            // find surrounding with new position\n            if (lastPos) {\n                return this.smartSurroundingQuotes(lastPos, \'current\');\n            }\n            else {\n                return undefined;\n            }\n        }\n        else {\n            return undefined;\n        }\n    }\n    smartSearch(start, action, quoteMap) {\n        const offset = action.includeCurrent ? 1 : 0;\n        let cursorPos = start;\n        let fst;\n        let snd;\n        if (action.first === \'>\') {\n            cursorPos = fst = this.getNextQuote(cursorPos - offset, quoteMap);\n        }\n        else {\n            // dir === \'<\'\n            cursorPos = fst = this.getPrevQuote(cursorPos + offset, quoteMap);\n        }\n        if (cursorPos === undefined)\n            return undefined;\n        if (action.second === \'>\') {\n            snd = this.getNextQuote(cursorPos, quoteMap);\n        }\n        else {\n            // dir === \'<\'\n            snd = this.getPrevQuote(cursorPos, quoteMap);\n        }\n        if (fst === undefined || snd === undefined)\n            return undefined;\n        if (fst < snd)\n            return [fst, snd];\n        else\n            return [snd, fst];\n    }\n    getNextQuoteThroughLineBreaks(position) {\n        for (let line = position.line; line < this.document.lineCount; line++) {\n            position = this.document.validatePosition(position.with({ line }));\n            const text = this.document.lineAt(position).text;\n            if (this.quote === \'any\') {\n                for (let i = position.character; i < text.length; i++) {\n                    if (text[i] === \'"\' || text[i] === "\'" || text[i] === \'`\') {\n                        return position.with({ character: i });\n                    }\n                }\n            }\n            else {\n                const index = text.indexOf(this.quote, position.character);\n                if (index >= 0) {\n                    return position.with({ character: index });\n                }\n            }\n            position = position.with({ character: 0 }); // set at line begin for next iteration\n        }\n        return undefined;\n    }\n    getLastQuoteThroughLineBreaks(position) {\n        for (let line = position.line; line >= 0; line--) {\n            position = this.document.validatePosition(position.with({ line }));\n            const text = this.document.lineAt(position).text;\n            if (this.quote === \'any\') {\n                for (let i = position.character; i >= 0; i--) {\n                    if (text[i] === \'"\' || text[i] === "\'" || text[i] === \'`\') {\n                        return position.with({ character: i });\n                    }\n                }\n            }\n            else {\n                const index = text.lastIndexOf(this.quote, position.character);\n                if (index >= 0) {\n                    return position.with({ character: index });\n                }\n            }\n            position = position.with({ character: +Infinity }); // set at line end for next iteration\n        }\n        return undefined;\n    }\n    getNextQuote(start, quoteMap) {\n        for (let i = start + 1; i < quoteMap.length; i++) {\n            if (quoteMap[i] !== undefined) {\n                return i;\n            }\n        }\n        return undefined;\n    }\n    getPrevQuote(start, quoteMap) {\n        for (let i = start - 1; i >= 0; i--) {\n            if (quoteMap[i] !== undefined) {\n                return i;\n            }\n        }\n        return undefined;\n    }\n}\nexports.SmartQuoteMatcher = SmartQuoteMatcher;\nSmartQuoteMatcher.escapeChar = \'\\\\\';\n\n\n//# sourceURL=webpack://vim/./src/actions/plugins/targets/smartQuotesMatcher.ts?')},"./src/actions/plugins/targets/targetsConfig.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.bracketObjectsEnabled = exports.useSmartQuotes = void 0;\nconst configuration_1 = __webpack_require__(/*! ../../../configuration/configuration */ "./src/configuration/configuration.ts");\nfunction useSmartQuotes() {\n    return ((configuration_1.configuration.targets.enable === true && configuration_1.configuration.targets.smartQuotes.enable !== false) ||\n        (configuration_1.configuration.targets.enable === undefined &&\n            configuration_1.configuration.targets.smartQuotes.enable === true));\n}\nexports.useSmartQuotes = useSmartQuotes;\nfunction bracketObjectsEnabled() {\n    return ((configuration_1.configuration.targets.enable === true &&\n        configuration_1.configuration.targets.bracketObjects.enable !== false) ||\n        (configuration_1.configuration.targets.enable === undefined &&\n            configuration_1.configuration.targets.bracketObjects.enable === true));\n}\nexports.bracketObjectsEnabled = bracketObjectsEnabled;\n\n\n//# sourceURL=webpack://vim/./src/actions/plugins/targets/targetsConfig.ts?')},"./src/actions/wrapping.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.shouldWrapKey = void 0;\nconst configuration_1 = __webpack_require__(/*! ./../configuration/configuration */ \"./src/configuration/configuration.ts\");\nconst mode_1 = __webpack_require__(/*! ./../mode/mode */ \"./src/mode/mode.ts\");\n/**\n * See https://vimhelp.org/options.txt.html#%27whichwrap%27\n *\n * @returns true if the given key should cause the cursor to wrap around line boundary\n */\nconst shouldWrapKey = (mode, key) => {\n    let k;\n    if (key === '<left>') {\n        k = [mode_1.Mode.Insert, mode_1.Mode.Replace].includes(mode) ? '[' : '<';\n    }\n    else if (key === '<right>') {\n        k = [mode_1.Mode.Insert, mode_1.Mode.Replace].includes(mode) ? ']' : '>';\n    }\n    else if (['<BS>', '<C-BS>', '<S-BS>'].includes(key)) {\n        k = 'b';\n    }\n    else if (key === ' ') {\n        k = 's';\n    }\n    else if (['h', 'l', '~'].includes(key)) {\n        k = key;\n    }\n    else {\n        throw new Error(`shouldWrapKey called with unexpected key='${key}'`);\n    }\n    return configuration_1.configuration.whichwrap.split(',').includes(k);\n};\nexports.shouldWrapKey = shouldWrapKey;\n\n\n//# sourceURL=webpack://vim/./src/actions/wrapping.ts?")},"./src/cmd_line/commandLine.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.SearchCommandLine = exports.ExCommandLine = exports.CommandLine = void 0;\nconst vscode_1 = __webpack_require__(/*! vscode */ "vscode");\nconst configuration_1 = __webpack_require__(/*! ../configuration/configuration */ "./src/configuration/configuration.ts");\nconst error_1 = __webpack_require__(/*! ../error */ "./src/error.ts");\nconst historyFile_1 = __webpack_require__(/*! ../history/historyFile */ "./src/history/historyFile.ts");\nconst register_1 = __webpack_require__(/*! ../register/register */ "./src/register/register.ts");\nconst globalState_1 = __webpack_require__(/*! ../state/globalState */ "./src/state/globalState.ts");\nconst recordedState_1 = __webpack_require__(/*! ../state/recordedState */ "./src/state/recordedState.ts");\nconst searchState_1 = __webpack_require__(/*! ../state/searchState */ "./src/state/searchState.ts");\nconst statusBar_1 = __webpack_require__(/*! ../statusBar */ "./src/statusBar.ts");\nconst word_1 = __webpack_require__(/*! ../textobject/word */ "./src/textobject/word.ts");\nconst decorationUtils_1 = __webpack_require__(/*! ../util/decorationUtils */ "./src/util/decorationUtils.ts");\nconst logger_1 = __webpack_require__(/*! ../util/logger */ "./src/util/logger.ts");\nconst statusBarTextUtils_1 = __webpack_require__(/*! ../util/statusBarTextUtils */ "./src/util/statusBarTextUtils.ts");\nconst util_1 = __webpack_require__(/*! ../util/util */ "./src/util/util.ts");\nconst pattern_1 = __webpack_require__(/*! ../vimscript/pattern */ "./src/vimscript/pattern.ts");\nconst mode_1 = __webpack_require__(/*! ./../mode/mode */ "./src/mode/mode.ts");\nconst register_2 = __webpack_require__(/*! ./commands/register */ "./src/cmd_line/commands/register.ts");\nconst substitute_1 = __webpack_require__(/*! ./commands/substitute */ "./src/cmd_line/commands/substitute.ts");\nclass CommandLine {\n    constructor(text, previousMode) {\n        this.cursorIndex = text.length;\n        this.historyIndex = this.getHistory().get().length;\n        this.previousMode = previousMode;\n        this.savedText = text;\n    }\n    async historyBack() {\n        if (this.historyIndex === 0) {\n            return;\n        }\n        const historyEntries = this.getHistory().get();\n        if (this.historyIndex === undefined) {\n            this.historyIndex = historyEntries.length - 1;\n            this.savedText = this.text;\n        }\n        else if (this.historyIndex > 0) {\n            this.historyIndex--;\n        }\n        this.text = historyEntries[this.historyIndex];\n        this.cursorIndex = this.text.length;\n    }\n    async historyForward() {\n        if (this.historyIndex === undefined) {\n            return;\n        }\n        const historyEntries = this.getHistory().get();\n        if (this.historyIndex === historyEntries.length - 1) {\n            this.historyIndex = undefined;\n            this.text = this.savedText;\n        }\n        else if (this.historyIndex < historyEntries.length - 1) {\n            this.historyIndex++;\n            this.text = historyEntries[this.historyIndex];\n        }\n        this.cursorIndex = this.text.length;\n    }\n    /**\n     * Called when `<BS>` is pressed\n     */\n    async backspace(vimState) {\n        if (this.cursorIndex === 0) {\n            if (this.text.length === 0) {\n                await this.escape(vimState);\n            }\n            return;\n        }\n        this.text = this.text.slice(0, this.cursorIndex - 1) + this.text.slice(this.cursorIndex);\n        this.cursorIndex = Math.max(this.cursorIndex - 1, 0);\n    }\n    /**\n     * Called when `<Del>` is pressed\n     */\n    async delete(vimState) {\n        if (this.cursorIndex === this.text.length) {\n            return this.backspace(vimState);\n        }\n        this.text = this.text.slice(0, this.cursorIndex) + this.text.slice(this.cursorIndex + 1);\n    }\n    /**\n     * Called when `<Home>` is pressed\n     */\n    async home() {\n        this.cursorIndex = 0;\n    }\n    /**\n     * Called when `<End>` is pressed\n     */\n    async end() {\n        this.cursorIndex = this.text.length;\n    }\n    /**\n     * Called when `<C-Left>` is pressed\n     */\n    async wordLeft() {\n        this.cursorIndex = (0, word_1.getWordLeftInText)(this.text, this.cursorIndex, word_1.WordType.Big) ?? 0;\n    }\n    /**\n     * Called when `<C-Right>` is pressed\n     */\n    async wordRight() {\n        this.cursorIndex =\n            (0, word_1.getWordRightInText)(this.text, this.cursorIndex, word_1.WordType.Big) ?? this.text.length;\n    }\n    /**\n     * Called when `<C-BS>` is pressed\n     */\n    async deleteWord() {\n        const wordStart = (0, word_1.getWordLeftInText)(this.text, this.cursorIndex, word_1.WordType.Normal);\n        if (wordStart !== undefined) {\n            this.text = this.text.substring(0, wordStart).concat(this.text.slice(this.cursorIndex));\n            this.cursorIndex = this.cursorIndex - (this.cursorIndex - wordStart);\n        }\n    }\n    /**\n     * Called when `<C-BS>` is pressed\n     */\n    async deleteToBeginning() {\n        this.text = this.text.slice(this.cursorIndex);\n        this.cursorIndex = 0;\n    }\n    async typeCharacter(char) {\n        const modifiedString = this.text.split(\'\');\n        modifiedString.splice(this.cursorIndex, 0, char);\n        this.text = modifiedString.join(\'\');\n        this.cursorIndex += char.length;\n    }\n}\nexports.CommandLine = CommandLine;\nclass ExCommandLine extends CommandLine {\n    static async loadHistory(context) {\n        ExCommandLine.history = new historyFile_1.CommandLineHistory(context);\n        await ExCommandLine.history.load();\n    }\n    constructor(commandText, previousMode) {\n        super(commandText, previousMode);\n        // TODO: Make this stuff private?\n        this.autoCompleteIndex = 0;\n        this.autoCompleteItems = [];\n        this.preCompleteCharacterPos = 0;\n        this.preCompleteCommand = \'\';\n        this.commandText = commandText;\n        this.text = commandText;\n        this.previousMode = previousMode;\n    }\n    display(cursorChar) {\n        return (0, statusBarTextUtils_1.escapeCSSIcons)(`:${this.text.substring(0, this.cursorIndex)}${cursorChar}${this.text.substring(this.cursorIndex)}`);\n    }\n    get text() {\n        return this.commandText;\n    }\n    set text(text) {\n        this.commandText = text;\n        try {\n            // TODO: This eager parsing is costly, and if it\'s not `:s` or similar, don\'t need to parse the args at all\n            const { lineRange, command } = ExCommandLine.parser.tryParse(this.commandText);\n            this.lineRange = lineRange;\n            this.command = command;\n        }\n        catch (err) {\n            this.lineRange = undefined;\n            this.command = undefined;\n        }\n    }\n    getSearchState() {\n        return undefined;\n    }\n    getDecorations(vimState) {\n        return this.command instanceof substitute_1.SubstituteCommand &&\n            vimState.currentMode === mode_1.Mode.CommandlineInProgress\n            ? this.command.getSubstitutionDecorations(vimState, this.lineRange)\n            : undefined;\n    }\n    getHistory() {\n        return ExCommandLine.history;\n    }\n    async run(vimState) {\n        logger_1.Logger.info(`Executing :${this.text}`);\n        void ExCommandLine.history.add(this.text);\n        this.historyIndex = ExCommandLine.history.get().length;\n        if (!(this.command instanceof register_2.RegisterCommand)) {\n            // TODO(jfields): Wait...why are we saving the `:` register as a RecordedState?\n            const recState = new recordedState_1.RecordedState();\n            recState.registerName = \':\';\n            recState.commandList = this.text.split(\'\');\n            register_1.Register.setReadonlyRegister(\':\', recState);\n        }\n        try {\n            if (this.command === undefined) {\n                // TODO: A bit gross:\n                ExCommandLine.parser.tryParse(this.text);\n                throw new Error(`Expected parsing ExCommand \'${this.text}\' to fail`);\n            }\n            const useNeovim = configuration_1.configuration.enableNeovim && this.command.neovimCapable();\n            if (useNeovim && vimState.nvim) {\n                const { statusBarText, error } = await vimState.nvim.run(vimState, this.text);\n                statusBar_1.StatusBar.setText(vimState, statusBarText, error);\n            }\n            else {\n                if (this.lineRange) {\n                    await this.command.executeWithRange(vimState, this.lineRange);\n                }\n                else {\n                    await this.command.execute(vimState);\n                }\n            }\n        }\n        catch (e) {\n            if (e instanceof error_1.VimError) {\n                if (e.code === error_1.ErrorCode.NotAnEditorCommand &&\n                    configuration_1.configuration.enableNeovim &&\n                    vimState.nvim) {\n                    const { statusBarText } = await vimState.nvim.run(vimState, this.text);\n                    statusBar_1.StatusBar.setText(vimState, statusBarText, true);\n                }\n                else {\n                    statusBar_1.StatusBar.setText(vimState, e.toString(), true);\n                }\n            }\n            else {\n                logger_1.Logger.error(`Error executing cmd=${this.text}. err=${e}.`);\n            }\n        }\n        // Update state if this command is repeatable via dot command.\n        vimState.lastCommandDotRepeatable = this.command?.isRepeatableWithDot ?? false;\n    }\n    async escape(vimState) {\n        await vimState.setCurrentMode(mode_1.Mode.Normal);\n        if (this.text.length > 0) {\n            void ExCommandLine.history.add(this.text);\n        }\n    }\n    async ctrlF(vimState) {\n        void ExCommandLine.onSearch(vimState);\n    }\n}\nexports.ExCommandLine = ExCommandLine;\nclass SearchCommandLine extends CommandLine {\n    /**\n     * Shows the search history as a QuickPick (popup list)\n     *\n     * @returns The SearchState that was selected by the user, if there was one.\n     */\n    static async showSearchHistory() {\n        const items = SearchCommandLine.previousSearchStates\n            .slice()\n            .reverse()\n            .map((searchState) => {\n            return {\n                label: searchState.searchString,\n                searchState,\n            };\n        });\n        const item = await vscode_1.window.showQuickPick(items, {\n            placeHolder: \'Vim search history\',\n            ignoreFocusOut: false,\n        });\n        return item?.searchState;\n    }\n    static async loadHistory(context) {\n        SearchCommandLine.history = new historyFile_1.SearchHistory(context);\n        SearchCommandLine.history\n            .get()\n            .forEach((val) => SearchCommandLine.previousSearchStates.push(new searchState_1.SearchState(pattern_1.SearchDirection.Forward, new vscode_1.Position(0, 0), val, undefined)));\n    }\n    static async addSearchStateToHistory(searchState) {\n        const prevSearchString = SearchCommandLine.previousSearchStates.length === 0\n            ? undefined\n            : SearchCommandLine.previousSearchStates[SearchCommandLine.previousSearchStates.length - 1]\n                .searchString;\n        // Store this search if different than previous\n        if (searchState.searchString !== prevSearchString) {\n            SearchCommandLine.previousSearchStates.push(searchState);\n            if (SearchCommandLine.history !== undefined) {\n                await SearchCommandLine.history.add(searchState.searchString);\n            }\n        }\n        // Make sure search history does not exceed configuration option\n        if (SearchCommandLine.previousSearchStates.length > configuration_1.configuration.history) {\n            SearchCommandLine.previousSearchStates.splice(0, 1);\n        }\n    }\n    constructor(vimState, searchString, direction) {\n        super(searchString, vimState.currentMode);\n        /**\n         * Keeps the state of the current match, i.e. the match to which the cursor moves when the search is executed.\n         * Incremented / decremented by \\<C-g> or \\<C-t> in SearchInProgress mode.\n         * Resets to 0 if the search string becomes empty.\n         *\n         * @see {@link getCurrentMatchRelativeIndex}\n         */\n        this.currentMatchDisplacement = 0;\n        this.searchState = new searchState_1.SearchState(direction, vimState.cursorStopPosition, searchString);\n    }\n    display(cursorChar) {\n        return (0, statusBarTextUtils_1.escapeCSSIcons)(`${this.searchState.direction === pattern_1.SearchDirection.Forward ? \'/\' : \'?\'}${this.text.substring(0, this.cursorIndex)}${cursorChar}${this.text.substring(this.cursorIndex)}`);\n    }\n    get text() {\n        return this.searchState.searchString;\n    }\n    set text(text) {\n        this.searchState.searchString = text;\n        if (text === \'\') {\n            this.currentMatchDisplacement = 0;\n        }\n    }\n    getSearchState() {\n        return this.searchState;\n    }\n    getHistory() {\n        return SearchCommandLine.history;\n    }\n    /**\n     * @returns the index of the current match, relative to the next match.\n     */\n    getCurrentMatchRelativeIndex(vimState) {\n        const count = vimState.recordedState.count || 1;\n        return count - 1 + this.currentMatchDisplacement * count;\n    }\n    /**\n     * @returns The start of the current match range (after applying the search offset) and its rank in the document\'s matches\n     */\n    getCurrentMatchPosition(vimState) {\n        return this.searchState.getNextSearchMatchPosition(vimState, vimState.cursorStopPosition, pattern_1.SearchDirection.Forward, this.getCurrentMatchRelativeIndex(vimState));\n    }\n    /**\n     * @returns The current match range and its rank in the document\'s matches\n     *\n     * NOTE: This method does not take the search offset into account\n     */\n    getCurrentMatchRange(vimState) {\n        return this.searchState.getNextSearchMatchRange(vimState, vimState.cursorStopPosition, pattern_1.SearchDirection.Forward, this.getCurrentMatchRelativeIndex(vimState));\n    }\n    getDecorations(vimState) {\n        return (0, decorationUtils_1.getDecorationsForSearchMatchRanges)(this.searchState.getMatchRanges(vimState), configuration_1.configuration.incsearch && vimState.currentMode === mode_1.Mode.SearchInProgressMode\n            ? this.getCurrentMatchRange(vimState)?.index\n            : undefined);\n    }\n    async run(vimState) {\n        // Repeat the previous search if no new string is entered\n        if (this.text === \'\') {\n            if (SearchCommandLine.previousSearchStates.length > 0) {\n                this.text =\n                    SearchCommandLine.previousSearchStates[SearchCommandLine.previousSearchStates.length - 1].searchString;\n            }\n        }\n        logger_1.Logger.info(`Searching for ${this.text}`);\n        this.cursorIndex = 0;\n        register_1.Register.setReadonlyRegister(\'/\', this.text);\n        void SearchCommandLine.addSearchStateToHistory(this.searchState);\n        globalState_1.globalState.hl = true;\n        if (this.searchState.getMatchRanges(vimState).length === 0) {\n            statusBar_1.StatusBar.displayError(vimState, error_1.VimError.fromCode(error_1.ErrorCode.PatternNotFound, this.text));\n            return;\n        }\n        const currentMatch = this.getCurrentMatchPosition(vimState);\n        if (currentMatch === undefined) {\n            statusBar_1.StatusBar.displayError(vimState, error_1.VimError.fromCode(this.searchState.direction === pattern_1.SearchDirection.Backward\n                ? error_1.ErrorCode.SearchHitTop\n                : error_1.ErrorCode.SearchHitBottom, this.text));\n            return;\n        }\n        vimState.cursorStopPosition = currentMatch.pos;\n        (0, statusBarTextUtils_1.reportSearch)(currentMatch.index, this.searchState.getMatchRanges(vimState).length, vimState);\n    }\n    async escape(vimState) {\n        vimState.cursorStopPosition = this.searchState.cursorStartPosition;\n        const prevSearchList = SearchCommandLine.previousSearchStates;\n        globalState_1.globalState.searchState = prevSearchList\n            ? prevSearchList[prevSearchList.length - 1]\n            : undefined;\n        if (vimState.modeData.mode === mode_1.Mode.SearchInProgressMode) {\n            const offset = vimState.editor.visibleRanges[0].start.line -\n                vimState.modeData.firstVisibleLineBeforeSearch;\n            (0, util_1.scrollView)(vimState, offset);\n        }\n        await vimState.setCurrentMode(this.previousMode);\n        if (this.text.length > 0) {\n            void SearchCommandLine.addSearchStateToHistory(this.searchState);\n        }\n    }\n    async ctrlF(vimState) {\n        await SearchCommandLine.onSearch(vimState, this.searchState.direction);\n    }\n    /**\n     * Called when <C-g> or <C-t> is pressed during SearchInProgress mode\n     */\n    async advanceCurrentMatch(vimState, direction) {\n        // <C-g> always moves forward in the document, and <C-t> always moves back, regardless of search direction.\n        // To compensate, multiply the desired direction by the searchState\'s direction, so that\n        // effectiveDirection == direction * (searchState.direction)^2 == direction.\n        this.currentMatchDisplacement += this.searchState.direction * direction;\n        // With nowrapscan, <C-g>/<C-t> shouldn\'t do anything if it would mean advancing past the last reachable match in the buffer.\n        // We account for this by checking whether getCurrentMatchRange returns undefined once this.currentMatchDisplacement is advanced.\n        // If it does, we undo the change to this.currentMatchDisplacement before exiting, making this command a noop.\n        if (!configuration_1.configuration.wrapscan && !this.getCurrentMatchRange(vimState)) {\n            this.currentMatchDisplacement -= this.searchState.direction * direction;\n        }\n    }\n}\nexports.SearchCommandLine = SearchCommandLine;\nSearchCommandLine.previousSearchStates = [];\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commandLine.ts?')},"./src/cmd_line/commands/ascii.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.AsciiCommand = void 0;\nconst actions_1 = __webpack_require__(/*! ../../actions/commands/actions */ "./src/actions/commands/actions.ts");\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ "./src/vimscript/exCommand.ts");\nclass AsciiCommand extends exCommand_1.ExCommand {\n    async execute(vimState) {\n        await new actions_1.CommandUnicodeName().exec(vimState.cursorStopPosition, vimState);\n    }\n}\nexports.AsciiCommand = AsciiCommand;\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/ascii.ts?')},"./src/cmd_line/commands/bang.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.BangCommand = void 0;\nconst position_1 = __webpack_require__(/*! ../../common/motion/position */ "./src/common/motion/position.ts");\nconst externalCommand_1 = __webpack_require__(/*! ../../util/externalCommand */ "./src/util/externalCommand.ts");\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ "./src/vimscript/exCommand.ts");\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ "./node_modules/parsimmon/build/parsimmon.umd.min.js");\nclass BangCommand extends exCommand_1.ExCommand {\n    constructor(args) {\n        super();\n        this._arguments = args;\n    }\n    neovimCapable() {\n        return true;\n    }\n    getReplaceDiff(text) {\n        const lines = text.split(\'\\n\');\n        const numNewlines = lines.length - 1;\n        const check = lines[0].match(/^\\s*/);\n        const numWhitespace = check ? check[0].length : 0;\n        return position_1.PositionDiff.exactCharacter({\n            lineOffset: -numNewlines,\n            character: numWhitespace,\n        });\n    }\n    async execute(vimState) {\n        await externalCommand_1.externalCommand.run(this._arguments.command);\n    }\n    async executeWithRange(vimState, range) {\n        const resolvedRange = range.resolveToRange(vimState);\n        // pipe in stdin from lines in range\n        const input = vimState.document.getText(resolvedRange);\n        const output = await externalCommand_1.externalCommand.run(this._arguments.command, input);\n        // place cursor at the start of the replaced text and first non-whitespace character\n        const diff = this.getReplaceDiff(output);\n        vimState.recordedState.transformer.addTransformation({\n            type: \'replaceText\',\n            text: output,\n            range: resolvedRange,\n            diff,\n        });\n    }\n}\nexports.BangCommand = BangCommand;\nBangCommand.argParser = parsimmon_1.all.map((command) => new BangCommand({\n    command,\n}));\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/bang.ts?')},"./src/cmd_line/commands/breakpoints.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Breakpoints = void 0;\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ \"./node_modules/parsimmon/build/parsimmon.umd.min.js\");\nconst path = __importStar(__webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\"));\nconst vscode = __importStar(__webpack_require__(/*! vscode */ \"vscode\"));\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ \"./src/vimscript/exCommand.ts\");\nconst parserUtils_1 = __webpack_require__(/*! ../../vimscript/parserUtils */ \"./src/vimscript/parserUtils.ts\");\nfunction isSourceBreakpoint(b) {\n    return b.location !== undefined;\n}\nfunction isFunctionBreakpoint(b) {\n    return b.functionName !== undefined;\n}\nclass AddBreakpointCommand extends exCommand_1.ExCommand {\n    constructor(addBreakpoint) {\n        super();\n        this.isRepeatableWithDot = false;\n        this.addBreakpoint = addBreakpoint;\n    }\n    async execute(vimState) {\n        if (this.addBreakpoint.type === 'here') {\n            const location = new vscode.Location(vimState.document.uri, vimState.cursorStartPosition);\n            return vscode.debug.addBreakpoints([new vscode.SourceBreakpoint(location)]);\n        }\n        else if (this.addBreakpoint.type === 'file') {\n            let file;\n            if (this.addBreakpoint.file === '') {\n                file = vimState.document.uri;\n            }\n            else {\n                const workspaceFolder = vscode.workspace.getWorkspaceFolder(vimState.document.uri)?.uri ?? vscode.Uri.file('./');\n                file = vscode.Uri.joinPath(workspaceFolder, this.addBreakpoint.file);\n            }\n            const location = new vscode.Location(file, new vscode.Position(this.addBreakpoint.line - 1, 0));\n            return vscode.debug.addBreakpoints([new vscode.SourceBreakpoint(location)]);\n        }\n        else if (this.addBreakpoint.type === 'func') {\n            return vscode.debug.addBreakpoints([\n                new vscode.FunctionBreakpoint(this.addBreakpoint.function),\n            ]);\n        }\n        else if (this.addBreakpoint.type === 'expr') {\n            const location = new vscode.Location(vimState.document.uri, vimState.cursorStartPosition);\n            return vscode.debug.addBreakpoints([\n                new vscode.SourceBreakpoint(location, undefined, this.addBreakpoint.expr),\n            ]);\n        }\n    }\n}\nclass DeleteBreakpointCommand extends exCommand_1.ExCommand {\n    constructor(delBreakpoint) {\n        super();\n        this.isRepeatableWithDot = false;\n        this.delBreakpoint = delBreakpoint;\n    }\n    async execute(vimState) {\n        if (this.delBreakpoint.type === 'byId') {\n            return vscode.debug.removeBreakpoints(vscode.debug.breakpoints.slice(this.delBreakpoint.id - 1, 1));\n        }\n        else if (this.delBreakpoint.type === 'all') {\n            return vscode.debug.removeBreakpoints(vscode.debug.breakpoints);\n        }\n        else if (this.delBreakpoint.type === 'file') {\n            let reqUri;\n            if (this.delBreakpoint.file === '') {\n                reqUri = vimState.document.uri;\n            }\n            else {\n                const workspaceFolder = vscode.workspace.getWorkspaceFolder(vimState.document.uri)?.uri ?? vscode.Uri.file('./');\n                reqUri = vscode.Uri.joinPath(workspaceFolder, this.delBreakpoint.file);\n            }\n            const reqLine = this.delBreakpoint.line - 1;\n            const breakpoint = vscode.debug.breakpoints\n                .filter(isSourceBreakpoint)\n                .find((b) => b.location.uri.toString() === reqUri.toString() &&\n                b.location.range.start.line === reqLine);\n            if (breakpoint)\n                return vscode.debug.removeBreakpoints([breakpoint]);\n        }\n        else if (this.delBreakpoint.type === 'func') {\n            const functionName = this.delBreakpoint.function;\n            const breakpoint = vscode.debug.breakpoints\n                .filter(isFunctionBreakpoint)\n                .filter((b) => b.functionName === functionName);\n            if (breakpoint)\n                return vscode.debug.removeBreakpoints(breakpoint);\n        }\n        else if (this.delBreakpoint.type === 'here') {\n            const location = new vscode.Location(vimState.document.uri, vimState.cursorStartPosition);\n            const distFromLocationCharacter = (b) => Math.abs(b.location.range.start.character - location.range.start.character);\n            const breakpoint = vscode.debug.breakpoints\n                .filter(isSourceBreakpoint)\n                .filter((b) => b.location.uri.toString() === location.uri.toString() &&\n                b.location.range.start.line === location.range.start.line)\n                .sort((a, b) => distFromLocationCharacter(a) - distFromLocationCharacter(b))[0];\n            if (breakpoint)\n                return vscode.debug.removeBreakpoints([breakpoint]);\n        }\n    }\n}\n/**\n * List Breakpoints Command\n */\nclass ListBreakpointsCommand extends exCommand_1.ExCommand {\n    constructor() {\n        super(...arguments);\n        this.isRepeatableWithDot = false;\n    }\n    async execute(vimState) {\n        const breakpoints = vscode.debug.breakpoints;\n        const lines = breakpoints.map((b, i) => {\n            const { id, enabled, condition } = b;\n            let label = '';\n            label += `#${i + 1}\\t`;\n            label += enabled ? '$(circle-filled)\\t' : '$(circle-outline)\\t';\n            label += condition ? '$(debug-breakpoint-conditional)\\t' : '\\t';\n            if (isSourceBreakpoint(b))\n                label += `${path.basename(b.location.uri.fsPath)}:${b.location.range.start.line + 1}`;\n            if (isFunctionBreakpoint(b))\n                label += `$(debug-breakpoint-function)${b.functionName}`;\n            return {\n                label,\n                breakpointId: id,\n            };\n        });\n        await vscode.window.showQuickPick(lines).then(async (selected) => {\n            if (selected) {\n                const id = selected.breakpointId;\n                const breakpoint = breakpoints.find((b) => b.id === id);\n                if (breakpoint && isSourceBreakpoint(breakpoint)) {\n                    await vscode.window.showTextDocument(breakpoint.location.uri).then(() => {\n                        vimState.cursorStopPosition = breakpoint.location.range.start;\n                    });\n                }\n            }\n        });\n    }\n}\nclass Breakpoints {\n}\nexports.Breakpoints = Breakpoints;\nBreakpoints.argParsers = {\n    add: parsimmon_1.whitespace\n        .then((0, parsimmon_1.alt)(\n    // here\n    (0, parsimmon_1.seqObj)(['type', (0, parsimmon_1.string)('here')], parsimmon_1.optWhitespace), \n    // file\n    (0, parsimmon_1.seqObj)(['type', (0, parsimmon_1.string)('file')], ['line', parsimmon_1.optWhitespace.then(parserUtils_1.numberParser).fallback(1)], ['file', parsimmon_1.optWhitespace.then(parserUtils_1.fileNameParser).fallback('')]), \n    // func\n    (0, parsimmon_1.seqObj)(['type', (0, parsimmon_1.string)('func')], parsimmon_1.optWhitespace.then(parserUtils_1.numberParser).fallback(1), // we don't support line numbers in function names, but Vim does, so we'll allow it.\n    ['function', parsimmon_1.optWhitespace.then((0, parsimmon_1.regexp)(/\\S+/))]), \n    // expr\n    (0, parsimmon_1.seqObj)(['type', (0, parsimmon_1.string)('expr')], ['expr', parsimmon_1.optWhitespace.then(parsimmon_1.all)])))\n        .or(\n    // without arg\n    parsimmon_1.eof.result({ type: 'here' }))\n        .map((a) => new AddBreakpointCommand(a)),\n    del: parsimmon_1.whitespace\n        .then((0, parsimmon_1.alt)(\n    // here\n    (0, parsimmon_1.seqObj)(['type', (0, parsimmon_1.string)('here')], parsimmon_1.optWhitespace), \n    // file\n    (0, parsimmon_1.seqObj)(['type', (0, parsimmon_1.string)('file')], ['line', parsimmon_1.optWhitespace.then(parserUtils_1.numberParser).fallback(1)], ['file', parsimmon_1.optWhitespace.then(parserUtils_1.fileNameParser).fallback('')]), \n    // func\n    (0, parsimmon_1.seqObj)(['type', (0, parsimmon_1.string)('func')], parsimmon_1.optWhitespace.then(parserUtils_1.numberParser).fallback(1), // we don't support line numbers in function names, but Vim does, so we'll allow it.\n    ['function', parsimmon_1.optWhitespace.then((0, parsimmon_1.regexp)(/\\S+/))]), \n    // all\n    (0, parsimmon_1.string)('*').then(parsimmon_1.optWhitespace).result({ type: 'all' }), \n    // by number\n    parserUtils_1.numberParser.map((n) => ({ type: 'byId', id: n }))))\n        .or(\n    // without arg\n    parsimmon_1.eof.result({ type: 'here' }))\n        .map((a) => new DeleteBreakpointCommand(a)),\n    list: (0, parsimmon_1.succeed)(new ListBreakpointsCommand()),\n};\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/breakpoints.ts?")},"./src/cmd_line/commands/bufferDelete.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.BufferDeleteCommand = void 0;\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ "./node_modules/parsimmon/build/parsimmon.umd.min.js");\nconst vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));\nconst error = __importStar(__webpack_require__(/*! ../../error */ "./src/error.ts"));\nconst statusBar_1 = __webpack_require__(/*! ../../statusBar */ "./src/statusBar.ts");\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ "./src/vimscript/exCommand.ts");\nconst parserUtils_1 = __webpack_require__(/*! ../../vimscript/parserUtils */ "./src/vimscript/parserUtils.ts");\n//\n//  Implements :bd\n// http://vimdoc.sourceforge.net/htmldoc/windows.html#buffers\n//\nclass BufferDeleteCommand extends exCommand_1.ExCommand {\n    constructor(args) {\n        super();\n        this.arguments = args;\n    }\n    async execute(vimState) {\n        if (vimState.document.isDirty && !this.arguments.bang) {\n            throw error.VimError.fromCode(error.ErrorCode.NoWriteSinceLastChange);\n        }\n        if (this.arguments.buffers.length === 0) {\n            await vscode.commands.executeCommand(\'workbench.action.closeActiveEditor\');\n        }\n        else {\n            for (const buffer of this.arguments.buffers) {\n                if (typeof buffer === \'string\') {\n                    // TODO\n                    statusBar_1.StatusBar.setText(vimState, \':bd[elete][!] {bufname} is not yet implemented (PRs are welcome!)\', true);\n                    continue;\n                }\n                try {\n                    await vscode.commands.executeCommand(`workbench.action.openEditorAtIndex${buffer}`);\n                }\n                catch (e) {\n                    throw error.VimError.fromCode(error.ErrorCode.NoBuffersDeleted);\n                }\n                await vscode.commands.executeCommand(\'workbench.action.closeActiveEditor\');\n            }\n        }\n    }\n}\nexports.BufferDeleteCommand = BufferDeleteCommand;\nBufferDeleteCommand.argParser = (0, parsimmon_1.seq)(parserUtils_1.bangParser.skip(parsimmon_1.optWhitespace), (0, parsimmon_1.alt)(parserUtils_1.numberParser, parserUtils_1.fileNameParser).sepBy(parsimmon_1.whitespace)).map(([bang, buffers]) => new BufferDeleteCommand({ bang, buffers }));\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/bufferDelete.ts?')},"./src/cmd_line/commands/close.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.CloseCommand = void 0;\nconst vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));\nconst error = __importStar(__webpack_require__(/*! ../../error */ "./src/error.ts"));\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ "./src/vimscript/exCommand.ts");\nconst parserUtils_1 = __webpack_require__(/*! ../../vimscript/parserUtils */ "./src/vimscript/parserUtils.ts");\n//\n//  Implements :close\n//  http://vimdoc.sourceforge.net/htmldoc/windows.html#:close\n//\nclass CloseCommand extends exCommand_1.ExCommand {\n    constructor(bang) {\n        super();\n        this.bang = bang;\n    }\n    async execute(vimState) {\n        if (vimState.document.isDirty && !this.bang) {\n            throw error.VimError.fromCode(error.ErrorCode.NoWriteSinceLastChange);\n        }\n        if (vscode.window.visibleTextEditors.length === 1) {\n            throw error.VimError.fromCode(error.ErrorCode.CannotCloseLastWindow);\n        }\n        const oldViewColumn = vimState.editor.viewColumn;\n        await vscode.commands.executeCommand(\'workbench.action.closeActiveEditor\');\n        if (vscode.window.activeTextEditor !== undefined &&\n            vscode.window.activeTextEditor.viewColumn === oldViewColumn) {\n            await vscode.commands.executeCommand(\'workbench.action.previousEditor\');\n        }\n    }\n}\nexports.CloseCommand = CloseCommand;\nCloseCommand.argParser = parserUtils_1.bangParser.map((bang) => new CloseCommand(bang));\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/close.ts?')},"./src/cmd_line/commands/copy.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.CopyCommand = void 0;\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ "./node_modules/parsimmon/build/parsimmon.umd.min.js");\nconst vscode_1 = __webpack_require__(/*! vscode */ "vscode");\nconst position_1 = __webpack_require__(/*! ../../common/motion/position */ "./src/common/motion/position.ts");\nconst error_1 = __webpack_require__(/*! ../../error */ "./src/error.ts");\nconst statusBar_1 = __webpack_require__(/*! ../../statusBar */ "./src/statusBar.ts");\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ "./src/vimscript/exCommand.ts");\nconst lineRange_1 = __webpack_require__(/*! ../../vimscript/lineRange */ "./src/vimscript/lineRange.ts");\nclass CopyCommand extends exCommand_1.ExCommand {\n    constructor(address) {\n        super();\n        this.address = address;\n    }\n    neovimCapable() {\n        return true;\n    }\n    copyLines(vimState, sourceStart, sourceEnd) {\n        const dest = this.address?.resolve(vimState, \'left\', false);\n        if (dest === undefined || dest < -1 || dest > vimState.document.lineCount) {\n            statusBar_1.StatusBar.displayError(vimState, error_1.VimError.fromCode(error_1.ErrorCode.InvalidAddress));\n            return;\n        }\n        if (sourceEnd < sourceStart) {\n            [sourceStart, sourceEnd] = [sourceEnd, sourceStart];\n        }\n        const copiedText = vimState.document.getText(new vscode_1.Range(new vscode_1.Position(sourceStart, 0), new vscode_1.Position(sourceEnd, 0).getLineEnd()));\n        let text;\n        let position;\n        if (dest === -1) {\n            text = copiedText + \'\\n\';\n            position = new vscode_1.Position(0, 0);\n        }\n        else {\n            text = \'\\n\' + copiedText;\n            position = new vscode_1.Position(dest, 0).getLineEnd();\n        }\n        const lines = copiedText.split(\'\\n\');\n        const cursorPosition = new vscode_1.Position(Math.max(dest + lines.length, 0), lines[lines.length - 1].match(/\\S/)?.index ?? 0);\n        vimState.recordedState.transformer.insert(position, text, position_1.PositionDiff.exactPosition(cursorPosition));\n    }\n    async execute(vimState) {\n        const line = vimState.cursors[0].stop.line;\n        this.copyLines(vimState, line, line);\n    }\n    async executeWithRange(vimState, range) {\n        const { start, end } = range.resolve(vimState);\n        this.copyLines(vimState, start, end);\n    }\n}\nexports.CopyCommand = CopyCommand;\nCopyCommand.argParser = parsimmon_1.optWhitespace\n    .then(lineRange_1.Address.parser.fallback(undefined))\n    .map((address) => new CopyCommand(address));\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/copy.ts?')},"./src/cmd_line/commands/delete.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.DeleteCommand = void 0;\nconst vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));\n// eslint-disable-next-line id-denylist\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ "./node_modules/parsimmon/build/parsimmon.umd.min.js");\nconst vscode_1 = __webpack_require__(/*! vscode */ "vscode");\nconst register_1 = __webpack_require__(/*! ../../register/register */ "./src/register/register.ts");\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ "./src/vimscript/exCommand.ts");\nconst parserUtils_1 = __webpack_require__(/*! ../../vimscript/parserUtils */ "./src/vimscript/parserUtils.ts");\nclass DeleteCommand extends exCommand_1.ExCommand {\n    constructor(args) {\n        super();\n        this.arguments = args;\n    }\n    neovimCapable() {\n        return true;\n    }\n    /**\n     * Deletes text between `startLine` and `endLine`, inclusive.\n     * Puts the cursor at the start of the line where the deleted range was.\n     */\n    deleteRange(startLine, endLine, vimState) {\n        let start = new vscode_1.Position(startLine, 0);\n        let end = new vscode_1.Position(endLine, 0).getLineEndIncludingEOL();\n        if (endLine < vimState.document.lineCount - 1) {\n            end = end.getRightThroughLineBreaks();\n        }\n        else if (startLine > 0) {\n            start = start.getLeftThroughLineBreaks();\n        }\n        const range = new vscode.Range(start, end);\n        const text = vimState.document\n            .getText(range)\n            // Remove leading or trailing newline\n            .replace(/^\\r?\\n/, \'\')\n            .replace(/\\r?\\n$/, \'\');\n        vimState.recordedState.transformer.addTransformation({\n            type: \'deleteRange\',\n            range: new vscode.Range(start, end),\n            manuallySetCursorPositions: true,\n        });\n        vimState.cursorStopPosition = start.getLineBegin();\n        if (this.arguments.register) {\n            vimState.recordedState.registerName = this.arguments.register;\n        }\n        vimState.currentRegisterMode = register_1.RegisterMode.LineWise;\n        register_1.Register.put(vimState, text, 0, true);\n    }\n    async execute(vimState) {\n        const linesToRemove = this.arguments.count ?? 1;\n        // :d[elete][cnt] removes [cnt] lines\n        const startLine = vimState.cursorStartPosition.line;\n        const endLine = startLine + (linesToRemove - 1);\n        this.deleteRange(startLine, endLine, vimState);\n    }\n    async executeWithRange(vimState, range) {\n        /**\n         * If a [cnt] and [range] is specified (e.g. :.+2d3), :delete [cnt] is called from\n         * the end of the [range].\n         * Ex. if two lines are VisualLine highlighted, :<,>d3 will :d3\n         * from the end of the selected lines.\n         */\n        const { start, end } = range.resolve(vimState);\n        if (this.arguments.count) {\n            vimState.cursorStartPosition = new vscode_1.Position(end, 0);\n            await this.execute(vimState);\n            return;\n        }\n        this.deleteRange(start, end, vimState);\n    }\n}\nexports.DeleteCommand = DeleteCommand;\n// TODO: this is copy-pasted from `:y[ank]`\nDeleteCommand.argParser = parsimmon_1.optWhitespace.then((0, parsimmon_1.alt)(parserUtils_1.numberParser.map((count) => {\n    return { register: undefined, count };\n}), \n// eslint-disable-next-line id-denylist\n(0, parsimmon_1.seq)(parsimmon_1.any.fallback(undefined), parsimmon_1.whitespace.then(parserUtils_1.numberParser).fallback(undefined)).map(([register, count]) => {\n    return { register, count };\n})).map(({ register, count }) => new DeleteCommand({\n    register,\n    count,\n})));\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/delete.ts?')},"./src/cmd_line/commands/digraph.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.DigraphsCommand = void 0;\nconst vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));\n// eslint-disable-next-line id-denylist\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ "./node_modules/parsimmon/build/parsimmon.umd.min.js");\nconst digraphs_1 = __webpack_require__(/*! ../../actions/commands/digraphs */ "./src/actions/commands/digraphs.ts");\nconst textEditor_1 = __webpack_require__(/*! ../../textEditor */ "./src/textEditor.ts");\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ "./src/vimscript/exCommand.ts");\nconst parserUtils_1 = __webpack_require__(/*! ../../vimscript/parserUtils */ "./src/vimscript/parserUtils.ts");\nconst configuration_1 = __webpack_require__(/*! ./../../configuration/configuration */ "./src/configuration/configuration.ts");\nclass DigraphsCommand extends exCommand_1.ExCommand {\n    constructor(args) {\n        super();\n        this.arguments = args;\n    }\n    makeQuickPicks(digraphs) {\n        return digraphs.map(([shortcut, [charDesc, charCodes]]) => {\n            if (!Array.isArray(charCodes)) {\n                charCodes = [charCodes];\n            }\n            return {\n                label: shortcut,\n                description: `${charDesc} (user)`,\n                charCodes,\n            };\n        });\n    }\n    async execute(vimState) {\n        // TODO: use arguments\n        const digraphKeyAndContent = this.makeQuickPicks(Object.entries(configuration_1.configuration.digraphs)).concat(this.makeQuickPicks([...digraphs_1.DefaultDigraphs.entries()]));\n        void vscode.window.showQuickPick(digraphKeyAndContent).then(async (val) => {\n            if (val) {\n                const char = String.fromCharCode(...val.charCodes);\n                await textEditor_1.TextEditor.insert(vimState.editor, char);\n            }\n        });\n    }\n}\nexports.DigraphsCommand = DigraphsCommand;\nDigraphsCommand.argParser = (0, parsimmon_1.seq)(parserUtils_1.bangParser, parsimmon_1.whitespace.then((0, parsimmon_1.seq)(parsimmon_1.any, parsimmon_1.any, parsimmon_1.whitespace.then(parserUtils_1.numberParser))).many()).map(([bang, newDigraphs]) => new DigraphsCommand({ bang, newDigraphs }));\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/digraph.ts?')},"./src/cmd_line/commands/file.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FileCommand = exports.FilePosition = void 0;\nconst vscode = __importStar(__webpack_require__(/*! vscode */ \"vscode\"));\nconst logger_1 = __webpack_require__(/*! ../../util/logger */ \"./src/util/logger.ts\");\nconst path_1 = __webpack_require__(/*! ../../util/path */ \"./src/util/path.ts\");\nconst fs_1 = __webpack_require__(/*! platform/fs */ \"./src/platform/browser/fs.ts\");\nconst untildify = __webpack_require__(/*! untildify */ \"./node_modules/untildify/index.js\");\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ \"./src/vimscript/exCommand.ts\");\nconst parserUtils_1 = __webpack_require__(/*! ../../vimscript/parserUtils */ \"./src/vimscript/parserUtils.ts\");\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ \"./node_modules/parsimmon/build/parsimmon.umd.min.js\");\nvar FilePosition;\n(function (FilePosition) {\n    FilePosition[FilePosition[\"NewWindowVerticalSplit\"] = 0] = \"NewWindowVerticalSplit\";\n    FilePosition[FilePosition[\"NewWindowHorizontalSplit\"] = 1] = \"NewWindowHorizontalSplit\";\n})(FilePosition || (exports.FilePosition = FilePosition = {}));\nfunction getLegacyArgs(args) {\n    if (args.name === 'edit') {\n        return { file: args.file, bang: args.bang, cmd: args.cmd, createFileIfNotExists: true };\n    }\n    else if (args.name === 'enew') {\n        return { bang: args.bang, createFileIfNotExists: true };\n    }\n    else if (args.name === 'new') {\n        return {\n            file: args.file,\n            position: FilePosition.NewWindowHorizontalSplit,\n            createFileIfNotExists: true,\n        };\n    }\n    else if (args.name === 'vnew') {\n        return {\n            file: args.file,\n            position: FilePosition.NewWindowVerticalSplit,\n            createFileIfNotExists: true,\n        };\n    }\n    else if (args.name === 'split') {\n        return {\n            file: args.file,\n            position: FilePosition.NewWindowHorizontalSplit,\n            // only to create if file arg is specified\n            createFileIfNotExists: args.file !== undefined,\n        };\n    }\n    else if (args.name === 'vsplit') {\n        return {\n            file: args.file,\n            position: FilePosition.NewWindowVerticalSplit,\n            // only to create if file arg is specified\n            createFileIfNotExists: args.file !== undefined,\n        };\n    }\n    else {\n        throw new Error(`Unexpected FileCommand.arguments.name: ${args.name}`);\n    }\n}\nclass FileCommand extends exCommand_1.ExCommand {\n    constructor(args) {\n        super();\n        this.arguments = args;\n    }\n    async execute(vimState) {\n        const args = getLegacyArgs(this.arguments);\n        if (args.bang) {\n            await vscode.commands.executeCommand('workbench.action.files.revert');\n            return;\n        }\n        // Need to do this before the split since it loses the activeTextEditor\n        const editorFileUri = vscode.window.activeTextEditor.document.uri;\n        const editorFilePath = editorFileUri.fsPath;\n        // Do the split if requested\n        let split = false;\n        if (args.position === FilePosition.NewWindowVerticalSplit) {\n            await vscode.commands.executeCommand('workbench.action.splitEditorRight');\n            split = true;\n        }\n        if (args.position === FilePosition.NewWindowHorizontalSplit) {\n            await vscode.commands.executeCommand('workbench.action.splitEditorDown');\n            split = true;\n        }\n        const hidePreviousEditor = async () => {\n            if (split === true) {\n                await vscode.commands.executeCommand('workbench.action.previousEditor');\n                await vscode.commands.executeCommand('workbench.action.closeActiveEditor');\n            }\n        };\n        // No file was specified\n        if (args.file === undefined) {\n            if (args.createFileIfNotExists === true) {\n                await vscode.commands.executeCommand('workbench.action.files.newUntitledFile');\n                await hidePreviousEditor();\n            }\n            return;\n        }\n        // Only untidify when the currently open page and file completion is local\n        if (args.file && editorFileUri.scheme === 'file') {\n            args.file = untildify(args.file);\n        }\n        let fileUri = editorFileUri;\n        // Using the empty string will request to open a file\n        if (args.file === '') {\n            // No file on split is fine and just return\n            if (split === true) {\n                return;\n            }\n            const fileList = await vscode.window.showOpenDialog({});\n            if (fileList && fileList.length > 0) {\n                fileUri = fileList[0];\n            }\n        }\n        else {\n            // remove file://\n            args.file = args.file.replace(/^file:\\/\\//, '');\n            // Using a filename, open or create the file\n            const isRemote = !!vscode.env.remoteName;\n            const { fullPath, path: p } = (0, path_1.getPathDetails)(args.file, editorFileUri, isRemote);\n            // Only if the expanded path of the full path is different than\n            // the currently opened window path\n            if (fullPath !== editorFilePath) {\n                const uriPath = (0, path_1.resolveUri)(fullPath, p.sep, editorFileUri, isRemote);\n                if (uriPath === null) {\n                    // return if the path is invalid\n                    return;\n                }\n                let fileExists = await (0, fs_1.doesFileExist)(uriPath);\n                if (fileExists) {\n                    // If the file without the added ext exists\n                    fileUri = uriPath;\n                }\n                else {\n                    // if file does not exist\n                    // try to find it with the same extension as the current file\n                    const pathWithExt = fullPath + p.extname(editorFilePath);\n                    const uriPathWithExt = (0, path_1.resolveUri)(pathWithExt, p.sep, editorFileUri, isRemote);\n                    if (uriPathWithExt !== null) {\n                        fileExists = await (0, fs_1.doesFileExist)(uriPathWithExt);\n                        if (fileExists) {\n                            // if the file with the added ext exists\n                            fileUri = uriPathWithExt;\n                        }\n                    }\n                }\n                // If both with and without ext path do not exist\n                if (!fileExists) {\n                    if (args.createFileIfNotExists) {\n                        // Change the scheme to untitled to open an\n                        // untitled tab\n                        fileUri = uriPath.with({ scheme: 'untitled' });\n                    }\n                    else {\n                        logger_1.Logger.error(`${args.file} does not exist.`);\n                        return;\n                    }\n                }\n            }\n        }\n        const doc = await vscode.workspace.openTextDocument(fileUri);\n        const editor = await vscode.window.showTextDocument(doc);\n        const lineNumber = args.cmd?.type === 'line_number'\n            ? args.cmd.line\n            : args.cmd?.type === 'last_line'\n                ? vscode.window.activeTextEditor.document.lineCount - 1\n                : undefined;\n        if (lineNumber !== undefined && lineNumber >= 0) {\n            const pos = new vscode.Position(lineNumber, 0);\n            editor.selection = new vscode.Selection(pos, pos);\n            const range = new vscode.Range(pos, pos);\n            editor.revealRange(range);\n        }\n        await hidePreviousEditor();\n    }\n}\nexports.FileCommand = FileCommand;\n// TODO: There's a lot of duplication here\n// TODO: These `optWhitespace` calls should be `whitespace`\nFileCommand.argParsers = {\n    edit: (0, parsimmon_1.seq)(parserUtils_1.bangParser, parsimmon_1.optWhitespace.then(parserUtils_1.fileOptParser).fallback([]), parsimmon_1.optWhitespace.then(parserUtils_1.fileCmdParser).fallback(undefined), parsimmon_1.optWhitespace.then(parserUtils_1.fileNameParser).fallback(undefined)).map(([bang, opt, cmd, file]) => new FileCommand({ name: 'edit', bang, opt, cmd, file })),\n    enew: parserUtils_1.bangParser.map((bang) => new FileCommand({ name: 'enew', bang })),\n    new: (0, parsimmon_1.seq)(parsimmon_1.optWhitespace.then(parserUtils_1.fileOptParser).fallback([]), parsimmon_1.optWhitespace.then(parserUtils_1.fileCmdParser).fallback(undefined), parsimmon_1.optWhitespace.then(parserUtils_1.fileNameParser).fallback(undefined)).map(([opt, cmd, file]) => new FileCommand({ name: 'new', opt, cmd, file })),\n    split: (0, parsimmon_1.seq)(parsimmon_1.optWhitespace.then(parserUtils_1.fileOptParser).fallback([]), parsimmon_1.optWhitespace.then(parserUtils_1.fileCmdParser).fallback(undefined), parsimmon_1.optWhitespace.then(parserUtils_1.fileNameParser).fallback(undefined)).map(([opt, cmd, file]) => new FileCommand({ name: 'split', opt, cmd, file })),\n    vnew: (0, parsimmon_1.seq)(parsimmon_1.optWhitespace.then(parserUtils_1.fileOptParser).fallback([]), parsimmon_1.optWhitespace.then(parserUtils_1.fileCmdParser).fallback(undefined), parsimmon_1.optWhitespace.then(parserUtils_1.fileNameParser).fallback(undefined)).map(([opt, cmd, file]) => new FileCommand({ name: 'vnew', opt, cmd, file })),\n    vsplit: (0, parsimmon_1.seq)(parsimmon_1.optWhitespace.then(parserUtils_1.fileOptParser).fallback([]), parsimmon_1.optWhitespace.then(parserUtils_1.fileCmdParser).fallback(undefined), parsimmon_1.optWhitespace.then(parserUtils_1.fileNameParser).fallback(undefined)).map(([opt, cmd, file]) => new FileCommand({ name: 'vsplit', opt, cmd, file })),\n};\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/file.ts?")},"./src/cmd_line/commands/fileInfo.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.FileInfoCommand = void 0;\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ "./node_modules/parsimmon/build/parsimmon.umd.min.js");\nconst statusBarTextUtils_1 = __webpack_require__(/*! ../../util/statusBarTextUtils */ "./src/util/statusBarTextUtils.ts");\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ "./src/vimscript/exCommand.ts");\nconst parserUtils_1 = __webpack_require__(/*! ../../vimscript/parserUtils */ "./src/vimscript/parserUtils.ts");\nclass FileInfoCommand extends exCommand_1.ExCommand {\n    constructor(args) {\n        super();\n        this.args = args;\n    }\n    async execute(vimState) {\n        // TODO: Use `this.args`\n        (0, statusBarTextUtils_1.reportFileInfo)(vimState.cursors[0].start, vimState);\n    }\n}\nexports.FileInfoCommand = FileInfoCommand;\nFileInfoCommand.argParser = (0, parsimmon_1.seq)(parserUtils_1.bangParser, parsimmon_1.optWhitespace.then(parsimmon_1.all)).map(([bang, fileName]) => new FileInfoCommand({ bang, fileName }));\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/fileInfo.ts?')},"./src/cmd_line/commands/goto.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.GotoCommand = void 0;\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ "./node_modules/parsimmon/build/parsimmon.umd.min.js");\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ "./src/vimscript/exCommand.ts");\nconst parserUtils_1 = __webpack_require__(/*! ../../vimscript/parserUtils */ "./src/vimscript/parserUtils.ts");\nclass GotoCommand extends exCommand_1.ExCommand {\n    constructor(offset) {\n        super();\n        this.offset = offset;\n    }\n    gotoOffset(vimState, offset) {\n        vimState.cursorStopPosition = vimState.document.positionAt(offset);\n    }\n    async execute(vimState) {\n        this.gotoOffset(vimState, this.offset ?? 0);\n    }\n    async executeWithRange(vimState, range) {\n        if (this.offset === undefined) {\n            this.offset = range.resolve(vimState)?.end ?? 0;\n        }\n        this.gotoOffset(vimState, this.offset);\n    }\n}\nexports.GotoCommand = GotoCommand;\nGotoCommand.argParser = parsimmon_1.optWhitespace\n    .then(parserUtils_1.numberParser.fallback(undefined))\n    .map((count) => new GotoCommand(count));\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/goto.ts?')},"./src/cmd_line/commands/gotoLine.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.GotoLineCommand = void 0;\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ "./src/vimscript/exCommand.ts");\nclass GotoLineCommand extends exCommand_1.ExCommand {\n    async execute(vimState) {\n        return;\n    }\n    async executeWithRange(vimState, range) {\n        vimState.cursorStartPosition = vimState.cursorStopPosition = vimState.cursorStopPosition\n            .with({ line: range.resolve(vimState).end })\n            .obeyStartOfLine(vimState.document);\n    }\n}\nexports.GotoLineCommand = GotoLineCommand;\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/gotoLine.ts?')},"./src/cmd_line/commands/history.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HistoryCommand = exports.HistoryCommandType = void 0;\n// eslint-disable-next-line id-denylist\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ \"./node_modules/parsimmon/build/parsimmon.umd.min.js\");\nconst actions_1 = __webpack_require__(/*! ../../actions/commands/actions */ \"./src/actions/commands/actions.ts\");\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ \"./src/vimscript/exCommand.ts\");\nconst parserUtils_1 = __webpack_require__(/*! ../../vimscript/parserUtils */ \"./src/vimscript/parserUtils.ts\");\nconst pattern_1 = __webpack_require__(/*! ../../vimscript/pattern */ \"./src/vimscript/pattern.ts\");\nvar HistoryCommandType;\n(function (HistoryCommandType) {\n    HistoryCommandType[HistoryCommandType[\"Cmd\"] = 0] = \"Cmd\";\n    HistoryCommandType[HistoryCommandType[\"Search\"] = 1] = \"Search\";\n    HistoryCommandType[HistoryCommandType[\"Expr\"] = 2] = \"Expr\";\n    HistoryCommandType[HistoryCommandType[\"Input\"] = 3] = \"Input\";\n    HistoryCommandType[HistoryCommandType[\"Debug\"] = 4] = \"Debug\";\n    HistoryCommandType[HistoryCommandType[\"All\"] = 5] = \"All\";\n})(HistoryCommandType || (exports.HistoryCommandType = HistoryCommandType = {}));\nconst historyTypeParser = (0, parsimmon_1.alt)((0, parsimmon_1.alt)((0, parserUtils_1.nameAbbrevParser)('c', 'md'), (0, parsimmon_1.string)(':')).result(HistoryCommandType.Cmd), (0, parsimmon_1.alt)((0, parserUtils_1.nameAbbrevParser)('s', 'earch'), (0, parsimmon_1.string)('/')).result(HistoryCommandType.Search), (0, parsimmon_1.alt)((0, parserUtils_1.nameAbbrevParser)('e', 'xpr'), (0, parsimmon_1.string)('=')).result(HistoryCommandType.Expr), (0, parsimmon_1.alt)((0, parserUtils_1.nameAbbrevParser)('i', 'nput'), (0, parsimmon_1.string)('@')).result(HistoryCommandType.Input), (0, parsimmon_1.alt)((0, parserUtils_1.nameAbbrevParser)('d', 'ebug'), (0, parsimmon_1.string)('>')).result(HistoryCommandType.Debug), (0, parserUtils_1.nameAbbrevParser)('a', 'll').result(HistoryCommandType.All));\n// http://vimdoc.sourceforge.net/htmldoc/cmdline.html#:history\nclass HistoryCommand extends exCommand_1.ExCommand {\n    constructor(args) {\n        super();\n        this.arguments = args;\n    }\n    async execute(vimState) {\n        switch (this.arguments.type) {\n            case HistoryCommandType.Cmd:\n                await new actions_1.CommandShowCommandHistory().exec(vimState.cursorStopPosition, vimState);\n                break;\n            case HistoryCommandType.Search:\n                await new actions_1.CommandShowSearchHistory(pattern_1.SearchDirection.Forward).exec(vimState.cursorStopPosition, vimState);\n                break;\n            // TODO: Implement these\n            case HistoryCommandType.Expr:\n                throw new Error('Not implemented');\n            case HistoryCommandType.Input:\n                throw new Error('Not implemented');\n            case HistoryCommandType.Debug:\n                throw new Error('Not implemented');\n            case HistoryCommandType.All:\n                throw new Error('Not implemented');\n        }\n    }\n}\nexports.HistoryCommand = HistoryCommand;\nHistoryCommand.argParser = parsimmon_1.optWhitespace\n    .then(historyTypeParser.fallback(HistoryCommandType.Cmd))\n    .map((type) => new HistoryCommand({ type }));\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/history.ts?")},"./src/cmd_line/commands/jumps.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.ClearJumpsCommand = exports.JumpsCommand = void 0;\nconst vscode_1 = __webpack_require__(/*! vscode */ "vscode");\nconst cursor_1 = __webpack_require__(/*! ../../common/motion/cursor */ "./src/common/motion/cursor.ts");\nconst globalState_1 = __webpack_require__(/*! ../../state/globalState */ "./src/state/globalState.ts");\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ "./src/vimscript/exCommand.ts");\nclass JumpPickItem {\n    constructor(jump, idx) {\n        this.jump = jump;\n        this.label = jump.fileName;\n        this.detail = `jump ${idx} line ${jump.position.line + 1} col ${jump.position.character}`;\n        try {\n            this.description = jump.document.lineAt(jump.position).text;\n        }\n        catch (e) {\n            this.description = undefined;\n        }\n    }\n}\nclass JumpsCommand extends exCommand_1.ExCommand {\n    async execute(vimState) {\n        const jumpTracker = globalState_1.globalState.jumpTracker;\n        if (jumpTracker.hasJumps) {\n            const quickPickItems = jumpTracker.jumps.map((jump, idx) => new JumpPickItem(jump, idx));\n            const item = await vscode_1.window.showQuickPick(quickPickItems, {\n                canPickMany: false,\n            });\n            if (item && item.jump.document !== undefined) {\n                void vscode_1.window.showTextDocument(item.jump.document);\n                vimState.cursors = [new cursor_1.Cursor(item.jump.position, item.jump.position)];\n            }\n        }\n        else {\n            void vscode_1.window.showInformationMessage(\'No jumps available\');\n        }\n    }\n}\nexports.JumpsCommand = JumpsCommand;\nclass ClearJumpsCommand extends exCommand_1.ExCommand {\n    async execute(vimState) {\n        const jumpTracker = globalState_1.globalState.jumpTracker;\n        jumpTracker.clearJumps();\n    }\n}\nexports.ClearJumpsCommand = ClearJumpsCommand;\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/jumps.ts?')},"./src/cmd_line/commands/leftRightCenter.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CenterCommand = exports.RightCommand = exports.LeftCommand = void 0;\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ \"./node_modules/parsimmon/build/parsimmon.umd.min.js\");\nconst vscode_1 = __webpack_require__(/*! vscode */ \"vscode\");\nconst configuration_1 = __webpack_require__(/*! ../../configuration/configuration */ \"./src/configuration/configuration.ts\");\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ \"./src/vimscript/exCommand.ts\");\nconst lineRange_1 = __webpack_require__(/*! ../../vimscript/lineRange */ \"./src/vimscript/lineRange.ts\");\nconst parserUtils_1 = __webpack_require__(/*! ../../vimscript/parserUtils */ \"./src/vimscript/parserUtils.ts\");\nclass LeftCommand extends exCommand_1.ExCommand {\n    constructor(args) {\n        super();\n        this.args = args;\n    }\n    async execute(vimState) {\n        void this.executeWithRange(vimState, new lineRange_1.LineRange(new lineRange_1.Address({ type: 'current_line' })));\n    }\n    async executeWithRange(vimState, range) {\n        const { start, end } = range.resolve(vimState);\n        const lines = [];\n        for (let line = start; line <= end; line++) {\n            lines.push(vimState.document.lineAt(line));\n        }\n        vimState.recordedState.transformer.replace(new vscode_1.Range(lines[0].range.start, lines[lines.length - 1].range.end), lines\n            .map((line) => ' '.repeat(this.args.indent) + line.text.slice(line.firstNonWhitespaceCharacterIndex))\n            .join('\\n'));\n    }\n}\nexports.LeftCommand = LeftCommand;\nLeftCommand.argParser = parsimmon_1.optWhitespace\n    .then(parserUtils_1.numberParser.fallback(0))\n    .map((indent) => new LeftCommand({ indent }));\nclass RightCommand extends exCommand_1.ExCommand {\n    constructor(args) {\n        super();\n        this.args = args;\n    }\n    async execute(vimState) {\n        void this.executeWithRange(vimState, new lineRange_1.LineRange(new lineRange_1.Address({ type: 'current_line' })));\n    }\n    async executeWithRange(vimState, range) {\n        const { start, end } = range.resolve(vimState);\n        const lines = [];\n        for (let line = start; line <= end; line++) {\n            lines.push(vimState.document.lineAt(line));\n        }\n        vimState.recordedState.transformer.replace(new vscode_1.Range(lines[0].range.start, lines[lines.length - 1].range.end), lines\n            .map((line) => {\n            const indent = ' '.repeat(Math.max(0, this.args.width - (line.text.length - line.firstNonWhitespaceCharacterIndex)));\n            return indent + line.text.slice(line.firstNonWhitespaceCharacterIndex);\n        })\n            .join('\\n'));\n    }\n}\nexports.RightCommand = RightCommand;\nRightCommand.argParser = parsimmon_1.optWhitespace\n    .then(parserUtils_1.numberParser.fallback(undefined))\n    .map((width) => new RightCommand({ width: width ?? configuration_1.configuration.textwidth }));\nclass CenterCommand extends exCommand_1.ExCommand {\n    constructor(args) {\n        super();\n        this.args = args;\n    }\n    async execute(vimState) {\n        void this.executeWithRange(vimState, new lineRange_1.LineRange(new lineRange_1.Address({ type: 'current_line' })));\n    }\n    async executeWithRange(vimState, range) {\n        const { start, end } = range.resolve(vimState);\n        const lines = [];\n        for (let line = start; line <= end; line++) {\n            lines.push(vimState.document.lineAt(line));\n        }\n        vimState.recordedState.transformer.replace(new vscode_1.Range(lines[0].range.start, lines[lines.length - 1].range.end), lines\n            .map((line) => {\n            const indent = ' '.repeat(Math.max(0, this.args.width - (line.text.length - line.firstNonWhitespaceCharacterIndex)) / 2);\n            return indent + line.text.slice(line.firstNonWhitespaceCharacterIndex);\n        })\n            .join('\\n'));\n    }\n}\nexports.CenterCommand = CenterCommand;\nCenterCommand.argParser = parsimmon_1.optWhitespace\n    .then(parserUtils_1.numberParser.fallback(undefined))\n    .map((width) => new CenterCommand({ width: width ?? configuration_1.configuration.textwidth }));\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/leftRightCenter.ts?")},"./src/cmd_line/commands/marks.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DeleteMarksCommand = exports.MarksCommand = void 0;\nconst vscode_1 = __webpack_require__(/*! vscode */ \"vscode\");\n// eslint-disable-next-line id-denylist\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ \"./node_modules/parsimmon/build/parsimmon.umd.min.js\");\nconst cursor_1 = __webpack_require__(/*! ../../common/motion/cursor */ \"./src/common/motion/cursor.ts\");\nconst error_1 = __webpack_require__(/*! ../../error */ \"./src/error.ts\");\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ \"./src/vimscript/exCommand.ts\");\nclass MarkQuickPickItem {\n    constructor(vimState, mark) {\n        this.picked = false;\n        this.alwaysShow = false;\n        this.mark = mark;\n        this.label = mark.name;\n        if (mark.document && mark.document !== vimState.document) {\n            this.description = mark.document.fileName;\n        }\n        else {\n            this.description = vimState.document.lineAt(mark.position).text.trim();\n        }\n        this.detail = `line ${mark.position.line} col ${mark.position.character}`;\n    }\n}\nclass MarksCommand extends exCommand_1.ExCommand {\n    constructor(marksFilter) {\n        super();\n        this.marksFilter = marksFilter;\n    }\n    async execute(vimState) {\n        const quickPickItems = vimState.historyTracker\n            .getMarks()\n            .filter((mark) => {\n            return this.marksFilter.length === 0 || this.marksFilter.includes(mark.name);\n        })\n            .map((mark) => new MarkQuickPickItem(vimState, mark));\n        if (quickPickItems.length > 0) {\n            const item = await vscode_1.window.showQuickPick(quickPickItems, {\n                canPickMany: false,\n            });\n            if (item) {\n                vimState.cursors = [new cursor_1.Cursor(item.mark.position, item.mark.position)];\n            }\n        }\n        else {\n            void vscode_1.window.showInformationMessage('No marks set');\n        }\n    }\n}\nexports.MarksCommand = MarksCommand;\nMarksCommand.argParser = parsimmon_1.optWhitespace\n    .then((0, parsimmon_1.noneOf)('|'))\n    .many()\n    .map((marks) => new MarksCommand(marks));\nclass DeleteMarksCommand extends exCommand_1.ExCommand {\n    constructor(args) {\n        super();\n        this.args = args;\n    }\n    static resolveMarkList(vimState, args) {\n        const asciiRange = (start, end) => {\n            if (start > end) {\n                throw error_1.VimError.fromCode(error_1.ErrorCode.InvalidArgument);\n            }\n            const [asciiStart, asciiEnd] = [start.charCodeAt(0), end.charCodeAt(0)];\n            const chars = [];\n            for (let ascii = asciiStart; ascii <= asciiEnd; ascii++) {\n                chars.push(String.fromCharCode(ascii));\n            }\n            return chars;\n        };\n        if (args === '!') {\n            // TODO: clear change list\n            return asciiRange('a', 'z');\n        }\n        const marks = [];\n        for (const x of args) {\n            if (typeof x === 'string') {\n                marks.push(x);\n            }\n            else {\n                const range = asciiRange(x.start, x.end);\n                if (range === undefined) {\n                    throw error_1.VimError.fromCode(error_1.ErrorCode.InvalidArgument);\n                }\n                marks.push(...range.concat());\n            }\n        }\n        return marks;\n    }\n    async execute(vimState) {\n        const marks = DeleteMarksCommand.resolveMarkList(vimState, this.args);\n        vimState.historyTracker.removeMarks(marks);\n    }\n}\nexports.DeleteMarksCommand = DeleteMarksCommand;\nDeleteMarksCommand.argParser = (0, parsimmon_1.alt)((0, parsimmon_1.string)('!'), parsimmon_1.whitespace.then(parsimmon_1.optWhitespace\n    .then((0, parsimmon_1.alt)((0, parsimmon_1.seq)((0, parsimmon_1.regexp)(/[a-z]/).skip((0, parsimmon_1.string)('-')), (0, parsimmon_1.regexp)(/[a-z]/)).map(([start, end]) => {\n    return { start, end };\n}), (0, parsimmon_1.seq)((0, parsimmon_1.regexp)(/[A-Z]/).skip((0, parsimmon_1.string)('-')), (0, parsimmon_1.regexp)(/[A-Z]/)).map(([start, end]) => {\n    return { start, end };\n}), (0, parsimmon_1.seq)((0, parsimmon_1.regexp)(/[0-9]/).skip((0, parsimmon_1.string)('-')), (0, parsimmon_1.regexp)(/[0-9]/)).map(([start, end]) => {\n    return { start, end };\n}), (0, parsimmon_1.noneOf)('-')))\n    .many())).map((marks) => new DeleteMarksCommand(marks));\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/marks.ts?")},"./src/cmd_line/commands/move.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.MoveCommand = void 0;\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ "./node_modules/parsimmon/build/parsimmon.umd.min.js");\nconst vscode_1 = __webpack_require__(/*! vscode */ "vscode");\nconst position_1 = __webpack_require__(/*! ../../common/motion/position */ "./src/common/motion/position.ts");\nconst error_1 = __webpack_require__(/*! ../../error */ "./src/error.ts");\nconst statusBar_1 = __webpack_require__(/*! ../../statusBar */ "./src/statusBar.ts");\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ "./src/vimscript/exCommand.ts");\nconst lineRange_1 = __webpack_require__(/*! ../../vimscript/lineRange */ "./src/vimscript/lineRange.ts");\nclass MoveCommand extends exCommand_1.ExCommand {\n    constructor(address) {\n        super();\n        this.address = address;\n    }\n    neovimCapable() {\n        return true;\n    }\n    moveLines(vimState, sourceStart, sourceEnd) {\n        const dest = this.address?.resolve(vimState, \'left\', false);\n        if (dest === undefined || dest < -1 || dest > vimState.document.lineCount) {\n            statusBar_1.StatusBar.displayError(vimState, error_1.VimError.fromCode(error_1.ErrorCode.InvalidAddress));\n            return;\n        }\n        if (sourceEnd < sourceStart) {\n            [sourceStart, sourceEnd] = [sourceEnd, sourceStart];\n        }\n        /* make sure\n        1. not move a range to the place inside itself.\n        2. not move a range to the place right below or above itself, which leads to no change.\n        */\n        if (dest >= sourceStart && dest <= sourceEnd) {\n            statusBar_1.StatusBar.displayError(vimState, error_1.VimError.fromCode(error_1.ErrorCode.InvalidAddress));\n            return;\n        }\n        // copy\n        const copiedText = vimState.document.getText(new vscode_1.Range(new vscode_1.Position(sourceStart, 0), new vscode_1.Position(sourceEnd, 0).getLineEnd()));\n        let text;\n        let position;\n        if (dest === -1) {\n            text = copiedText + \'\\n\';\n            position = new vscode_1.Position(0, 0);\n        }\n        else {\n            text = \'\\n\' + copiedText;\n            position = new vscode_1.Position(dest, 0).getLineEnd();\n        }\n        const lines = copiedText.split(\'\\n\');\n        let cursorPosition;\n        if (dest > sourceEnd) {\n            // make the cursor position at the beginning of the endline.\n            cursorPosition = new vscode_1.Position(Math.max(dest, 0), lines[lines.length - 1].match(/\\S/)?.index ?? 0);\n        }\n        else {\n            cursorPosition = new vscode_1.Position(Math.max(dest + lines.length, 0), lines[lines.length - 1].match(/\\S/)?.index ?? 0);\n        }\n        // delete\n        let start = new vscode_1.Position(sourceStart, 0);\n        let end = new vscode_1.Position(sourceEnd, 0).getLineEndIncludingEOL();\n        if (sourceEnd < vimState.document.lineCount - 1) {\n            end = end.getRightThroughLineBreaks();\n        }\n        else if (sourceStart > 0) {\n            start = start.getLeftThroughLineBreaks();\n        }\n        vimState.recordedState.transformer.addTransformation({\n            type: \'deleteRange\',\n            range: new vscode_1.Range(start, end),\n            manuallySetCursorPositions: true,\n        });\n        // insert\n        vimState.recordedState.transformer.insert(position, text, position_1.PositionDiff.exactPosition(cursorPosition));\n    }\n    async execute(vimState) {\n        const line = vimState.cursors[0].stop.line;\n        this.moveLines(vimState, line, line);\n    }\n    async executeWithRange(vimState, range) {\n        const { start, end } = range.resolve(vimState);\n        this.moveLines(vimState, start, end);\n    }\n}\nexports.MoveCommand = MoveCommand;\nMoveCommand.argParser = parsimmon_1.optWhitespace\n    .then(lineRange_1.Address.parser.fallback(undefined))\n    .map((address) => new MoveCommand(address));\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/move.ts?')},"./src/cmd_line/commands/nohl.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.NohlCommand = void 0;\nconst globalState_1 = __webpack_require__(/*! ../../state/globalState */ "./src/state/globalState.ts");\nconst statusBar_1 = __webpack_require__(/*! ../../statusBar */ "./src/statusBar.ts");\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ "./src/vimscript/exCommand.ts");\nclass NohlCommand extends exCommand_1.ExCommand {\n    async execute(vimState) {\n        globalState_1.globalState.hl = false;\n        // Clear the `match x of y` message from status bar\n        statusBar_1.StatusBar.clear(vimState);\n    }\n}\nexports.NohlCommand = NohlCommand;\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/nohl.ts?')},"./src/cmd_line/commands/only.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.OnlyCommand = void 0;\nconst vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ "./src/vimscript/exCommand.ts");\nclass OnlyCommand extends exCommand_1.ExCommand {\n    async execute(vimState) {\n        await Promise.allSettled([\n            vscode.commands.executeCommand(\'workbench.action.closeEditorsInOtherGroups\'),\n            vscode.commands.executeCommand(\'workbench.action.maximizeEditor\'),\n            vscode.commands.executeCommand(\'workbench.action.closePanel\'),\n        ]);\n    }\n}\nexports.OnlyCommand = OnlyCommand;\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/only.ts?')},"./src/cmd_line/commands/print.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.PrintCommand = void 0;\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ "./node_modules/parsimmon/build/parsimmon.umd.min.js");\nconst statusBar_1 = __webpack_require__(/*! ../../statusBar */ "./src/statusBar.ts");\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ "./src/vimscript/exCommand.ts");\nconst lineRange_1 = __webpack_require__(/*! ../../vimscript/lineRange */ "./src/vimscript/lineRange.ts");\n// TODO: `:l[ist]` is more than an alias\n// TODO: `:z`\nclass PrintCommand extends exCommand_1.ExCommand {\n    constructor(args) {\n        super();\n        this.args = args;\n    }\n    async execute(vimState) {\n        // TODO: Wrong default for `:=`\n        void this.executeWithRange(vimState, new lineRange_1.LineRange(new lineRange_1.Address({ type: \'current_line\' })));\n    }\n    async executeWithRange(vimState, range) {\n        const { end } = range.resolve(vimState);\n        // For now, we just print the last line.\n        // TODO: Create a dynamic document if there\'s more than one line?\n        const line = vimState.document.lineAt(end);\n        let output;\n        if (this.args.printNumbers) {\n            if (this.args.printText) {\n                output = `${line.lineNumber + 1} ${line.text}`;\n            }\n            else {\n                output = `${line.lineNumber + 1}`;\n            }\n        }\n        else {\n            if (this.args.printText) {\n                output = `${line.text}`;\n            }\n            else {\n                output = \'\';\n            }\n        }\n        statusBar_1.StatusBar.setText(vimState, output);\n    }\n}\nexports.PrintCommand = PrintCommand;\n// TODO: Print {count} and [flags]\nPrintCommand.argParser = (args) => (0, parsimmon_1.succeed)(new PrintCommand(args));\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/print.ts?')},"./src/cmd_line/commands/put.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.PutExCommand = void 0;\nconst configuration_1 = __webpack_require__(/*! ../../configuration/configuration */ "./src/configuration/configuration.ts");\n// eslint-disable-next-line id-denylist\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ "./node_modules/parsimmon/build/parsimmon.umd.min.js");\nconst vscode_1 = __webpack_require__(/*! vscode */ "vscode");\nconst put_1 = __webpack_require__(/*! ../../actions/commands/put */ "./src/actions/commands/put.ts");\nconst error_1 = __webpack_require__(/*! ../../error */ "./src/error.ts");\nconst register_1 = __webpack_require__(/*! ../../register/register */ "./src/register/register.ts");\nconst statusBar_1 = __webpack_require__(/*! ../../statusBar */ "./src/statusBar.ts");\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ "./src/vimscript/exCommand.ts");\nconst parserUtils_1 = __webpack_require__(/*! ../../vimscript/parserUtils */ "./src/vimscript/parserUtils.ts");\nconst expression_1 = __webpack_require__(/*! ../expression */ "./src/cmd_line/expression.ts");\n//\n// Implements :put\n// http://vimdoc.sourceforge.net/htmldoc/change.html#:put\n//\nclass PutExCommand extends exCommand_1.ExCommand {\n    constructor(args) {\n        super();\n        this.arguments = args;\n    }\n    neovimCapable() {\n        return true;\n    }\n    async doPut(vimState, position) {\n        if (this.arguments.fromExpression && this.arguments.register) {\n            // set the register to the value of the expression\n            register_1.Register.overwriteRegister(vimState, this.arguments.register, this.arguments.fromExpression, 0);\n        }\n        const registerName = this.arguments.register || (configuration_1.configuration.useSystemClipboard ? \'*\' : \'"\');\n        if (!register_1.Register.isValidRegister(registerName)) {\n            statusBar_1.StatusBar.displayError(vimState, error_1.VimError.fromCode(error_1.ErrorCode.TrailingCharacters));\n            return;\n        }\n        vimState.recordedState.registerName = registerName;\n        const putCmd = this.arguments.bang ? new put_1.PutBeforeFromCmdLine() : new put_1.PutFromCmdLine();\n        putCmd.setInsertionLine(position.line);\n        await putCmd.exec(position, vimState);\n    }\n    async execute(vimState) {\n        await this.doPut(vimState, vimState.cursorStopPosition);\n    }\n    async executeWithRange(vimState, range) {\n        const { end } = range.resolve(vimState);\n        await this.doPut(vimState, new vscode_1.Position(end, 0).getLineEnd());\n    }\n}\nexports.PutExCommand = PutExCommand;\nPutExCommand.argParser = (0, parsimmon_1.seq)(parserUtils_1.bangParser, (0, parsimmon_1.alt)(expression_1.expressionParser, parsimmon_1.optWhitespace\n    .then(parsimmon_1.any)\n    .map((x) => ({ register: x }))\n    .fallback({ register: undefined }))).map(([bang, register]) => new PutExCommand({ bang, ...register }));\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/put.ts?')},"./src/cmd_line/commands/quit.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.QuitCommand = void 0;\nconst vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));\nconst error = __importStar(__webpack_require__(/*! ../../error */ "./src/error.ts"));\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ "./src/vimscript/exCommand.ts");\nconst parserUtils_1 = __webpack_require__(/*! ../../vimscript/parserUtils */ "./src/vimscript/parserUtils.ts");\n//\n//  Implements :quit\n//  http://vimdoc.sourceforge.net/htmldoc/editing.html#:quit\n//\nclass QuitCommand extends exCommand_1.ExCommand {\n    constructor(args) {\n        super();\n        this.isRepeatableWithDot = false;\n        this.arguments = args;\n    }\n    async execute(vimState) {\n        // NOTE: We can\'t currently get all open text editors, so this isn\'t perfect. See #3809\n        const duplicatedInSplit = vscode.window.visibleTextEditors.filter((editor) => editor.document === vimState.document)\n            .length > 1;\n        if (vimState.document.isDirty &&\n            !this.arguments.bang &&\n            (!duplicatedInSplit || this.arguments.quitAll)) {\n            throw error.VimError.fromCode(error.ErrorCode.NoWriteSinceLastChange);\n        }\n        if (this.arguments.quitAll) {\n            await vscode.commands.executeCommand(\'workbench.action.closeAllEditors\');\n        }\n        else {\n            if (!this.arguments.bang) {\n                await vscode.commands.executeCommand(\'workbench.action.closeActiveEditor\');\n            }\n            else {\n                await vscode.commands.executeCommand(\'workbench.action.revertAndCloseActiveEditor\');\n            }\n        }\n    }\n}\nexports.QuitCommand = QuitCommand;\nQuitCommand.argParser = (quitAll) => parserUtils_1.bangParser.map((bang) => new QuitCommand({\n    bang,\n    quitAll,\n}));\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/quit.ts?')},"./src/cmd_line/commands/read.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.ReadCommand = void 0;\n// eslint-disable-next-line id-denylist\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ "./node_modules/parsimmon/build/parsimmon.umd.min.js");\nconst constants_1 = __webpack_require__(/*! platform/constants */ "./src/platform/browser/constants.ts");\nconst fs_1 = __webpack_require__(/*! platform/fs */ "./src/platform/browser/fs.ts");\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ "./src/vimscript/exCommand.ts");\nconst parserUtils_1 = __webpack_require__(/*! ../../vimscript/parserUtils */ "./src/vimscript/parserUtils.ts");\n//\n//  Implements :read and :read!\n//  http://vimdoc.sourceforge.net/htmldoc/insert.html#:read\n//  http://vimdoc.sourceforge.net/htmldoc/insert.html#:read!\n//\nclass ReadCommand extends exCommand_1.ExCommand {\n    constructor(args) {\n        super();\n        this.arguments = args;\n    }\n    neovimCapable() {\n        return true;\n    }\n    async execute(vimState) {\n        const textToInsert = await this.getTextToInsert(vimState);\n        if (textToInsert) {\n            vimState.recordedState.transformer.insert(vimState.cursorStopPosition.getLineEnd(), \'\\n\' + textToInsert);\n        }\n    }\n    // TODO: executeWithRange()\n    async getTextToInsert(vimState) {\n        if (\'file\' in this.arguments) {\n            return (0, fs_1.readFileAsync)(this.arguments.file, \'utf8\');\n        }\n        else if (\'cmd\' in this.arguments) {\n            if (this.arguments.cmd.length > 0) {\n                if (constants_1.SUPPORT_READ_COMMAND) {\n                    const cmd = this.arguments.cmd;\n                    return new Promise(async (resolve, reject) => {\n                        const { exec } = await Promise.resolve().then(() => __importStar(__webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module \'child_process\'"); e.code = \'MODULE_NOT_FOUND\'; throw e; }()))));\n                        exec(cmd, (err, stdout, stderr) => {\n                            if (err) {\n                                reject(err);\n                            }\n                            else {\n                                resolve(stdout);\n                            }\n                        });\n                    });\n                }\n                else {\n                    return \'\';\n                }\n            }\n            else {\n                // TODO: error message?\n                return \'\';\n            }\n        }\n        else {\n            return vimState.document.getText();\n        }\n    }\n}\nexports.ReadCommand = ReadCommand;\nReadCommand.argParser = (0, parsimmon_1.seq)(parsimmon_1.whitespace.then(parserUtils_1.fileOptParser).fallback([]), parsimmon_1.optWhitespace\n    .then((0, parsimmon_1.alt)((0, parsimmon_1.string)(\'!\')\n    .then(parsimmon_1.all)\n    .map((cmd) => {\n    return { cmd };\n}), parserUtils_1.fileNameParser.map((file) => {\n    return { file };\n})))\n    .fallback(undefined)).map(([opt, other]) => new ReadCommand({ opt, ...other }));\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/read.ts?')},"./src/cmd_line/commands/redo.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.RedoCommand = void 0;\nconst actions_1 = __webpack_require__(/*! ../../actions/commands/actions */ "./src/actions/commands/actions.ts");\nconst vscode_1 = __webpack_require__(/*! vscode */ "vscode");\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ "./src/vimscript/exCommand.ts");\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ "./node_modules/parsimmon/build/parsimmon.umd.min.js");\nconst parserUtils_1 = __webpack_require__(/*! ../../vimscript/parserUtils */ "./src/vimscript/parserUtils.ts");\n//\n//  Implements :red[o]\n//  http://vimdoc.sourceforge.net/htmldoc/undo.html#redo\n//\nclass RedoCommand extends exCommand_1.ExCommand {\n    constructor(count) {\n        super();\n        this.count = count;\n    }\n    async execute(vimState) {\n        // TODO: Use `this.count`\n        await new actions_1.CommandRedo().exec(new vscode_1.Position(0, 0), vimState);\n    }\n}\nexports.RedoCommand = RedoCommand;\nRedoCommand.argParser = parsimmon_1.optWhitespace\n    .then(parserUtils_1.numberParser)\n    .fallback(undefined)\n    .map((count) => new RedoCommand(count));\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/redo.ts?')},"./src/cmd_line/commands/register.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RegisterCommand = void 0;\nconst vscode = __importStar(__webpack_require__(/*! vscode */ \"vscode\"));\n// eslint-disable-next-line id-denylist\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ \"./node_modules/parsimmon/build/parsimmon.umd.min.js\");\nconst error_1 = __webpack_require__(/*! ../../error */ \"./src/error.ts\");\nconst register_1 = __webpack_require__(/*! ../../register/register */ \"./src/register/register.ts\");\nconst recordedState_1 = __webpack_require__(/*! ../../state/recordedState */ \"./src/state/recordedState.ts\");\nconst statusBar_1 = __webpack_require__(/*! ../../statusBar */ \"./src/statusBar.ts\");\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ \"./src/vimscript/exCommand.ts\");\nclass RegisterCommand extends exCommand_1.ExCommand {\n    constructor(registers) {\n        super();\n        this.isRepeatableWithDot = false;\n        this.registers = registers;\n    }\n    async getRegisterDisplayValue(register) {\n        let result = (await register_1.Register.get(register))?.text;\n        if (result instanceof Array) {\n            result = result.join('\\n').substr(0, 100);\n        }\n        else if (result instanceof recordedState_1.RecordedState) {\n            result = result.actionsRun.map((x) => x.keysPressed.join('')).join('');\n        }\n        return result;\n    }\n    async displayRegisterValue(vimState, register) {\n        let result = await this.getRegisterDisplayValue(register);\n        if (result === undefined) {\n            statusBar_1.StatusBar.displayError(vimState, error_1.VimError.fromCode(error_1.ErrorCode.NothingInRegister, register));\n        }\n        else {\n            result = result.replace(/\\n/g, '\\\\n');\n            void vscode.window.showInformationMessage(`${register} ${result}`);\n        }\n    }\n    regSortOrder(register) {\n        const specials = ['-', '*', '+', '.', ':', '%', '#', '/', '='];\n        if (register === '\"') {\n            return 0;\n        }\n        else if (register >= '0' && register <= '9') {\n            return 10 + parseInt(register, 10);\n        }\n        else if (register >= 'a' && register <= 'z') {\n            return 100 + (register.charCodeAt(0) - 'a'.charCodeAt(0));\n        }\n        else if (specials.includes(register)) {\n            return 1000 + specials.indexOf(register);\n        }\n        else {\n            throw new Error(`Unexpected register ${register}`);\n        }\n    }\n    async execute(vimState) {\n        if (this.registers.length === 1) {\n            await this.displayRegisterValue(vimState, this.registers[0]);\n        }\n        else {\n            const currentRegisterKeys = register_1.Register.getKeys()\n                .filter((reg) => reg !== '_' && (this.registers.length === 0 || this.registers.includes(reg)))\n                .sort((reg1, reg2) => this.regSortOrder(reg1) - this.regSortOrder(reg2));\n            const registerKeyAndContent = new Array();\n            for (const registerKey of currentRegisterKeys) {\n                const displayValue = await this.getRegisterDisplayValue(registerKey);\n                if (typeof displayValue === 'string') {\n                    registerKeyAndContent.push({\n                        label: registerKey,\n                        description: displayValue,\n                    });\n                }\n            }\n            void vscode.window.showQuickPick(registerKeyAndContent).then(async (val) => {\n                if (val) {\n                    const result = val.description;\n                    void vscode.window.showInformationMessage(`${val.label} ${result}`);\n                }\n            });\n        }\n    }\n}\nexports.RegisterCommand = RegisterCommand;\nRegisterCommand.argParser = parsimmon_1.optWhitespace.then(\n// eslint-disable-next-line id-denylist\nparsimmon_1.any.sepBy(parsimmon_1.optWhitespace).map((registers) => new RegisterCommand(registers)));\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/register.ts?")},"./src/cmd_line/commands/retab.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RetabCommand = void 0;\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ \"./node_modules/parsimmon/build/parsimmon.umd.min.js\");\nconst vscode_1 = __webpack_require__(/*! vscode */ \"vscode\");\nconst configuration_1 = __webpack_require__(/*! ../../configuration/configuration */ \"./src/configuration/configuration.ts\");\nconst mode_1 = __webpack_require__(/*! ../../mode/mode */ \"./src/mode/mode.ts\");\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ \"./src/vimscript/exCommand.ts\");\nconst parserUtils_1 = __webpack_require__(/*! ../../vimscript/parserUtils */ \"./src/vimscript/parserUtils.ts\");\nconst set_1 = __webpack_require__(/*! ./set */ \"./src/cmd_line/commands/set.ts\");\n// :[range]ret[ab][!] [new_tabstop]\nclass RetabCommand extends exCommand_1.ExCommand {\n    constructor(args) {\n        super();\n        this.arguments = args;\n    }\n    async execute(vimState) {\n        if ((0, mode_1.isVisualMode)(vimState.currentMode)) {\n            const { start, end } = vimState.editor.selection;\n            this.retab(vimState, start.line, end.line);\n        }\n        else {\n            this.retab(vimState, 0, vimState.document.lineCount - 1);\n        }\n    }\n    async executeWithRange(vimState, range) {\n        const { start, end } = range.resolve(vimState);\n        this.retab(vimState, start, end);\n    }\n    concat(count, char) {\n        let result = '';\n        for (let i = 0; i < count; i++) {\n            result += char;\n        }\n        return result;\n    }\n    hasTabs(str) {\n        return str.indexOf('\\t') >= 0;\n    }\n    expandtab(str, start = 0, tabstop = configuration_1.configuration.tabstop) {\n        let expanded = '';\n        let i = start;\n        for (const char of str) {\n            if (char === '\\t') {\n                const spaces = tabstop - (i % tabstop) || tabstop;\n                expanded += this.concat(spaces, ' ');\n                i += spaces;\n            }\n            else {\n                expanded += char;\n                i++;\n            }\n        }\n        return expanded;\n    }\n    retabLineSegment(segment, start, tabstop = configuration_1.configuration.tabstop) {\n        const retab = this.arguments.replaceSpaces || this.hasTabs(segment);\n        if (!retab) {\n            return {\n                value: segment,\n                length: segment.length,\n            };\n        }\n        const retabTabstop = this.arguments.newTabstop || tabstop;\n        const detabbed = this.expandtab(segment, start, tabstop);\n        const spaces = Math.min((start + detabbed.length) % retabTabstop, detabbed.length);\n        const tabs = Math.ceil((detabbed.length - spaces) / retabTabstop);\n        let result = '';\n        result += this.concat(tabs, '\\t');\n        result += this.concat(spaces, ' ');\n        return {\n            value: result,\n            length: detabbed.length,\n        };\n    }\n    retabLine(line, tabstop = configuration_1.configuration.tabstop) {\n        const segments = line.split(/(\\s+)/);\n        let i = 0;\n        let retabbed = '';\n        for (const str of segments) {\n            if (!str) {\n                continue;\n            }\n            if (![' ', '\\t'].includes(str[0])) {\n                retabbed += str;\n                i += str.length;\n            }\n            else {\n                const result = this.retabLineSegment(str, i, tabstop);\n                retabbed += result.value;\n                i += result.length;\n            }\n        }\n        return retabbed;\n    }\n    retab(vimState, startLine, endLine) {\n        const originalLines = [];\n        const lastLine = Math.min(endLine, vimState.document.lineCount - 1);\n        for (let i = startLine; i <= lastLine; i++) {\n            originalLines.push(vimState.document.lineAt(i).text);\n        }\n        const replacedLines = originalLines.map((line) => {\n            return configuration_1.configuration.expandtab ? this.expandtab(line) : this.retabLine(line);\n        });\n        const replacedContent = replacedLines.join('\\n');\n        const lastLineLength = originalLines[originalLines.length - 1].length;\n        vimState.recordedState.transformer.addTransformation({\n            type: 'replaceText',\n            range: new vscode_1.Range(startLine, 0, endLine, lastLineLength),\n            text: replacedContent,\n        });\n        if (this.arguments.newTabstop) {\n            const setTabstop = new set_1.SetCommand({\n                type: 'equal',\n                option: 'tabstop',\n                value: this.arguments.newTabstop.toString(),\n            });\n            void setTabstop.execute(vimState);\n        }\n    }\n}\nexports.RetabCommand = RetabCommand;\nRetabCommand.argParser = (0, parsimmon_1.seq)(parserUtils_1.bangParser, parsimmon_1.optWhitespace.then(parserUtils_1.numberParser).fallback(undefined)).map(([replaceSpaces, newTabstop]) => new RetabCommand({\n    replaceSpaces,\n    newTabstop,\n}));\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/retab.ts?")},"./src/cmd_line/commands/set.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SetCommand = void 0;\n// eslint-disable-next-line id-denylist\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ \"./node_modules/parsimmon/build/parsimmon.umd.min.js\");\nconst configuration_1 = __webpack_require__(/*! ../../configuration/configuration */ \"./src/configuration/configuration.ts\");\nconst error_1 = __webpack_require__(/*! ../../error */ \"./src/error.ts\");\nconst statusBar_1 = __webpack_require__(/*! ../../statusBar */ \"./src/statusBar.ts\");\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ \"./src/vimscript/exCommand.ts\");\nconst optionParser = (0, parsimmon_1.regexp)(/[a-z]+/);\nconst valueParser = (0, parsimmon_1.regexp)(/\\S*/);\nconst setOperationParser = parsimmon_1.whitespace\n    .then((0, parsimmon_1.alt)((0, parsimmon_1.string)('no')\n    .then(optionParser)\n    .map((option) => {\n    return {\n        type: 'unset',\n        option,\n    };\n}), (0, parsimmon_1.string)('inv')\n    .then(optionParser)\n    .map((option) => {\n    return {\n        type: 'invert',\n        option,\n    };\n}), optionParser.skip((0, parsimmon_1.string)('!')).map((option) => {\n    return {\n        type: 'invert',\n        option,\n    };\n}), optionParser.skip((0, parsimmon_1.string)('?')).map((option) => {\n    return {\n        type: 'show',\n        option,\n    };\n}), (0, parsimmon_1.seq)(optionParser.skip((0, parsimmon_1.string)('&')), (0, parsimmon_1.alt)((0, parsimmon_1.string)('vim'), (0, parsimmon_1.string)('vi'), (0, parsimmon_1.string)(''))).map(([option, source]) => {\n    return {\n        type: 'default',\n        option,\n        source,\n    };\n}), (0, parsimmon_1.seq)(optionParser.skip((0, parsimmon_1.oneOf)('=:')), valueParser).map(([option, value]) => {\n    return {\n        type: 'equal',\n        option,\n        value,\n    };\n}), (0, parsimmon_1.seq)(optionParser.skip((0, parsimmon_1.string)('+=')), valueParser).map(([option, value]) => {\n    return {\n        type: 'add',\n        option,\n        value,\n    };\n}), (0, parsimmon_1.seq)(optionParser.skip((0, parsimmon_1.string)('^=')), valueParser).map(([option, value]) => {\n    return {\n        type: 'multiply',\n        option,\n        value,\n    };\n}), (0, parsimmon_1.seq)(optionParser.skip((0, parsimmon_1.string)('-=')), valueParser).map(([option, value]) => {\n    return {\n        type: 'subtract',\n        option,\n        value,\n    };\n}), optionParser.map((option) => {\n    return {\n        type: 'show_or_set',\n        option,\n    };\n})))\n    .fallback({ type: 'show_or_set', option: undefined });\nclass SetCommand extends exCommand_1.ExCommand {\n    constructor(operation) {\n        super();\n        this.operation = operation;\n    }\n    async execute(vimState) {\n        if (this.operation.option === undefined) {\n            // TODO: Show all options that differ from their default value\n            return;\n        }\n        const option = configuration_1.optionAliases.get(this.operation.option) ?? this.operation.option;\n        const currentValue = configuration_1.configuration[option];\n        if (currentValue === undefined) {\n            throw error_1.VimError.fromCode(error_1.ErrorCode.UnknownOption, option);\n        }\n        const type = typeof currentValue === 'boolean'\n            ? 'boolean'\n            : typeof currentValue === 'string'\n                ? 'string'\n                : 'number';\n        switch (this.operation.type) {\n            case 'show_or_set': {\n                if (this.operation.option === 'all') {\n                    // TODO: Show all options\n                }\n                else {\n                    if (type === 'boolean') {\n                        configuration_1.configuration[option] = true;\n                    }\n                    else {\n                        this.showOption(vimState, option, currentValue);\n                    }\n                }\n                break;\n            }\n            case 'show': {\n                this.showOption(vimState, option, currentValue);\n                break;\n            }\n            case 'unset': {\n                if (type === 'boolean') {\n                    configuration_1.configuration[option] = false;\n                }\n                else {\n                    throw error_1.VimError.fromCode(error_1.ErrorCode.InvalidArgument, `no${option}`);\n                }\n                break;\n            }\n            case 'invert': {\n                if (type === 'boolean') {\n                    configuration_1.configuration[option] = !currentValue;\n                }\n                else {\n                    // TODO: Could also be {option}!\n                    throw error_1.VimError.fromCode(error_1.ErrorCode.InvalidArgument, `inv${option}`);\n                }\n                break;\n            }\n            case 'default': {\n                if (this.operation.option === 'all') {\n                    // TODO: Set all options to default\n                }\n                else {\n                    // TODO: Set the option to default\n                }\n                break;\n            }\n            case 'equal': {\n                if (type === 'boolean') {\n                    // TODO: Could also be {option}:{value}\n                    throw error_1.VimError.fromCode(error_1.ErrorCode.InvalidArgument, `${option}=${this.operation.value}`);\n                }\n                else if (type === 'string') {\n                    configuration_1.configuration[option] = this.operation.value;\n                }\n                else {\n                    const value = Number.parseInt(this.operation.value, 10);\n                    if (isNaN(value)) {\n                        // TODO: Could also be {option}:{value}\n                        throw error_1.VimError.fromCode(error_1.ErrorCode.NumberRequiredAfterEqual, `${option}=${this.operation.value}`);\n                    }\n                    configuration_1.configuration[option] = value;\n                }\n                break;\n            }\n            case 'add': {\n                if (type === 'boolean') {\n                    throw error_1.VimError.fromCode(error_1.ErrorCode.InvalidArgument, `${option}+=${this.operation.value}`);\n                }\n                else if (type === 'string') {\n                    configuration_1.configuration[option] = currentValue + this.operation.value;\n                }\n                else {\n                    const value = Number.parseInt(this.operation.value, 10);\n                    if (isNaN(value)) {\n                        throw error_1.VimError.fromCode(error_1.ErrorCode.NumberRequiredAfterEqual, `${option}+=${this.operation.value}`);\n                    }\n                    configuration_1.configuration[option] = currentValue + value;\n                }\n                break;\n            }\n            case 'multiply': {\n                if (type === 'boolean') {\n                    throw error_1.VimError.fromCode(error_1.ErrorCode.InvalidArgument, `${option}^=${this.operation.value}`);\n                }\n                else if (type === 'string') {\n                    configuration_1.configuration[option] = this.operation.value + currentValue;\n                }\n                else {\n                    const value = Number.parseInt(this.operation.value, 10);\n                    if (isNaN(value)) {\n                        throw error_1.VimError.fromCode(error_1.ErrorCode.NumberRequiredAfterEqual, `${option}^=${this.operation.value}`);\n                    }\n                    configuration_1.configuration[option] = currentValue * value;\n                }\n                break;\n            }\n            case 'subtract': {\n                if (type === 'boolean') {\n                    throw error_1.VimError.fromCode(error_1.ErrorCode.InvalidArgument, `${option}-=${this.operation.value}`);\n                }\n                else if (type === 'string') {\n                    configuration_1.configuration[option] = currentValue.split(this.operation.value).join('');\n                }\n                else {\n                    const value = Number.parseInt(this.operation.value, 10);\n                    if (isNaN(value)) {\n                        throw error_1.VimError.fromCode(error_1.ErrorCode.NumberRequiredAfterEqual, `${option}-=${this.operation.value}`);\n                    }\n                    configuration_1.configuration[option] = currentValue - value;\n                }\n                break;\n            }\n            default:\n                const guard = this.operation;\n                throw new Error('Got unexpected SetOperation.type');\n        }\n    }\n    showOption(vimState, option, value) {\n        if (typeof value === 'boolean') {\n            statusBar_1.StatusBar.setText(vimState, value ? option : `no${option}`);\n        }\n        else {\n            statusBar_1.StatusBar.setText(vimState, `${option}=${value}`);\n        }\n    }\n}\nexports.SetCommand = SetCommand;\nSetCommand.argParser = setOperationParser.map((operation) => new SetCommand(operation));\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/set.ts?")},"./src/cmd_line/commands/sh.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.ShCommand = void 0;\nconst vscode_1 = __webpack_require__(/*! vscode */ "vscode");\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ "./src/vimscript/exCommand.ts");\nclass ShCommand extends exCommand_1.ExCommand {\n    async execute(vimState) {\n        vscode_1.window.createTerminal().show();\n    }\n}\nexports.ShCommand = ShCommand;\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/sh.ts?')},"./src/cmd_line/commands/shift.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.ShiftCommand = void 0;\nconst vscode_1 = __webpack_require__(/*! vscode */ "vscode");\n// eslint-disable-next-line id-denylist\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ "./node_modules/parsimmon/build/parsimmon.umd.min.js");\nconst position_1 = __webpack_require__(/*! ../../common/motion/position */ "./src/common/motion/position.ts");\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ "./src/vimscript/exCommand.ts");\nconst lineRange_1 = __webpack_require__(/*! ../../vimscript/lineRange */ "./src/vimscript/lineRange.ts");\nconst parserUtils_1 = __webpack_require__(/*! ../../vimscript/parserUtils */ "./src/vimscript/parserUtils.ts");\nclass ShiftCommand extends exCommand_1.ExCommand {\n    constructor(args) {\n        super();\n        this.args = args;\n    }\n    async execute(vimState) {\n        void this.executeWithRange(vimState, new lineRange_1.LineRange(new lineRange_1.Address({ type: \'current_line\' })));\n    }\n    async executeWithRange(vimState, range) {\n        let { start, end } = range.resolve(vimState);\n        if (this.args.numLines !== undefined) {\n            start = end;\n            end = start + this.args.numLines;\n        }\n        vimState.editor.selection = new vscode_1.Selection(new vscode_1.Position(start, 0), new vscode_1.Position(end, 0));\n        for (let i = 0; i < this.args.depth; i++) {\n            if (this.args.dir === \'>\') {\n                vimState.recordedState.transformer.vscodeCommand(\'editor.action.indentLines\');\n            }\n            else if (this.args.dir === \'<\') {\n                vimState.recordedState.transformer.vscodeCommand(\'editor.action.outdentLines\');\n            }\n        }\n        vimState.recordedState.transformer.moveCursor(position_1.PositionDiff.startOfLine());\n    }\n}\nexports.ShiftCommand = ShiftCommand;\nShiftCommand.argParser = (dir) => parsimmon_1.optWhitespace\n    .then((0, parsimmon_1.seq)(\n// `:>>>` indents 3 times `shiftwidth`\n(0, parsimmon_1.string)(dir)\n    .many()\n    .map((shifts) => shifts.length + 1)\n    .skip(parsimmon_1.optWhitespace), \n// `:> 2` indents 2 lines\nparserUtils_1.numberParser.fallback(undefined)))\n    .map(([depth, numLines]) => new ShiftCommand({ dir, depth, numLines }));\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/shift.ts?')},"./src/cmd_line/commands/smile.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.SmileCommand = void 0;\nconst vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));\nconst textEditor_1 = __webpack_require__(/*! ../../textEditor */ "./src/textEditor.ts");\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ "./src/vimscript/exCommand.ts");\nclass SmileCommand extends exCommand_1.ExCommand {\n    constructor() {\n        super();\n    }\n    async execute(vimState) {\n        await vscode.commands.executeCommand(\'workbench.action.files.newUntitledFile\');\n        await textEditor_1.TextEditor.insert(vscode.window.activeTextEditor, SmileCommand.smileText);\n    }\n}\nexports.SmileCommand = SmileCommand;\nSmileCommand.smileText = `\n                               oooo$$$$$$$$$$$$oooo\n                          oo$$$$$$$$$$$$$$$$$$$$$$$$o\n                       oo$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$o         o$   $$ o$\n     o $ oo          o$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$o       $$ $$ $$o$\n    oo $ $ "$      o$$$$$$$$$    $$$$$$$$$$$$$    $$$$$$$$$o       $$$o$$o$\n    "$$$$$$o$     o$$$$$$$$$      $$$$$$$$$$$      $$$$$$$$$$o    $$$$$$$$\n      $$$$$$$    $$$$$$$$$$$      $$$$$$$$$$$      $$$$$$$$$$$$$$$$$$$$$$$\n      $$$$$$$$$$$$$$$$$$$$$$$    $$$$$$$$$$$$$    $$$$$$$$$$$$$$  """$$$\n       "$$$""""$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$     "$$$\n        $$$   o$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$     "$$$o\n       o$$"   $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$       $$$o\n       $$$    $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$" "$$$$$$ooooo$$$$o\n      o$$$oooo$$$$$  $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$   o$$$$$$$$$$$$$$$$$\n      $$$$$$$$"$$$$   $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$     $$$$""""""""\n     """"       $$$$    "$$$$$$$$$$$$$$$$$$$$$$$$$$$$"      o$$$\n                "$$$o     """$$$$$$$$$$$$$$$$$$"$$"         $$$\n                  $$$o          "$$""$$$$$$""""           o$$$\n                   $$$$o                                o$$$"\n                    "$$$$o      o$$$$$$o"$$$$o        o$$$$\n                      "$$$$$oo     ""$$$$o$$$$$o   o$$$$""\n                         ""$$$$$oooo  "$$$o$$$$$$$$$"""\n                            ""$$$$$$$oo $$$$$$$$$$\n                                    """"$$$$$$$$$$$\n                                        $$$$$$$$$$$$\n                                         $$$$$$$$$$"\n                                          "$$$""""`;\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/smile.ts?')},"./src/cmd_line/commands/sort.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.SortCommand = void 0;\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ "./node_modules/parsimmon/build/parsimmon.umd.min.js");\nconst numericString_1 = __webpack_require__(/*! ../../common/number/numericString */ "./src/common/number/numericString.ts");\nconst vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));\nconst position_1 = __webpack_require__(/*! ../../common/motion/position */ "./src/common/motion/position.ts");\nconst mode_1 = __webpack_require__(/*! ../../mode/mode */ "./src/mode/mode.ts");\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ "./src/vimscript/exCommand.ts");\nconst parserUtils_1 = __webpack_require__(/*! ../../vimscript/parserUtils */ "./src/vimscript/parserUtils.ts");\nclass SortCommand extends exCommand_1.ExCommand {\n    constructor(args) {\n        super();\n        this.arguments = args;\n    }\n    neovimCapable() {\n        return true;\n    }\n    async execute(vimState) {\n        if ((0, mode_1.isVisualMode)(vimState.currentMode)) {\n            const { start, end } = vimState.editor.selection;\n            await this.sortLines(vimState, start.line, end.line);\n        }\n        else {\n            await this.sortLines(vimState, 0, vimState.document.lineCount - 1);\n        }\n    }\n    async sortLines(vimState, startLine, endLine) {\n        let originalLines = [];\n        for (let currentLine = startLine; currentLine <= endLine && currentLine < vimState.document.lineCount; currentLine++) {\n            originalLines.push(vimState.document.lineAt(currentLine).text);\n        }\n        const lastLineLength = originalLines[originalLines.length - 1].length;\n        if (this.arguments.unique) {\n            const seen = new Set();\n            const uniqueLines = [];\n            for (const line of originalLines) {\n                const adjustedLine = this.arguments.ignoreCase ? line.toLowerCase() : line;\n                if (!seen.has(adjustedLine)) {\n                    seen.add(adjustedLine);\n                    uniqueLines.push(line);\n                }\n            }\n            originalLines = uniqueLines;\n        }\n        let sortedLines;\n        if (this.arguments.numeric) {\n            sortedLines = originalLines.sort((a, b) => (numericString_1.NumericString.parse(a, numericString_1.NumericStringRadix.Dec)?.num.value ?? Number.MAX_VALUE) -\n                (numericString_1.NumericString.parse(b, numericString_1.NumericStringRadix.Dec)?.num.value ?? Number.MAX_VALUE));\n        }\n        else if (this.arguments.ignoreCase) {\n            sortedLines = originalLines.sort((a, b) => a.localeCompare(b));\n        }\n        else {\n            sortedLines = originalLines.sort();\n        }\n        if (this.arguments.reverse) {\n            sortedLines.reverse();\n        }\n        const sortedContent = sortedLines.join(\'\\n\');\n        vimState.recordedState.transformer.addTransformation({\n            type: \'replaceText\',\n            range: new vscode.Range(startLine, 0, endLine, lastLineLength),\n            text: sortedContent,\n            diff: position_1.PositionDiff.exactPosition(new vscode.Position(startLine, sortedLines[0].match(/\\S/)?.index ?? 0)),\n        });\n    }\n    async executeWithRange(vimState, range) {\n        const { start, end } = range.resolve(vimState);\n        await this.sortLines(vimState, start, end);\n    }\n}\nexports.SortCommand = SortCommand;\nSortCommand.argParser = (0, parsimmon_1.seq)(parserUtils_1.bangParser, parsimmon_1.optWhitespace.then((0, parsimmon_1.oneOf)(\'bfilnorux\').many())).map(([bang, flags]) => new SortCommand({\n    reverse: bang,\n    ignoreCase: flags.includes(\'i\'),\n    unique: flags.includes(\'u\'),\n    numeric: flags.includes(\'n\'),\n}));\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/sort.ts?')},"./src/cmd_line/commands/substitute.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SubstituteCommand = exports.ReplaceString = void 0;\n// eslint-disable-next-line id-denylist\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ \"./node_modules/parsimmon/build/parsimmon.umd.min.js\");\nconst vscode_1 = __webpack_require__(/*! vscode */ \"vscode\");\nconst position_1 = __webpack_require__(/*! ../../common/motion/position */ \"./src/common/motion/position.ts\");\nconst configuration_1 = __webpack_require__(/*! ../../configuration/configuration */ \"./src/configuration/configuration.ts\");\nconst decoration_1 = __webpack_require__(/*! ../../configuration/decoration */ \"./src/configuration/decoration.ts\");\nconst error_1 = __webpack_require__(/*! ../../error */ \"./src/error.ts\");\nconst jump_1 = __webpack_require__(/*! ../../jumps/jump */ \"./src/jumps/jump.ts\");\nconst globalState_1 = __webpack_require__(/*! ../../state/globalState */ \"./src/state/globalState.ts\");\nconst searchState_1 = __webpack_require__(/*! ../../state/searchState */ \"./src/state/searchState.ts\");\nconst substituteState_1 = __webpack_require__(/*! ../../state/substituteState */ \"./src/state/substituteState.ts\");\nconst statusBar_1 = __webpack_require__(/*! ../../statusBar */ \"./src/statusBar.ts\");\nconst decorationUtils_1 = __webpack_require__(/*! ../../util/decorationUtils */ \"./src/util/decorationUtils.ts\");\nconst statusBarTextUtils_1 = __webpack_require__(/*! ../../util/statusBarTextUtils */ \"./src/util/statusBarTextUtils.ts\");\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ \"./src/vimscript/exCommand.ts\");\nconst lineRange_1 = __webpack_require__(/*! ../../vimscript/lineRange */ \"./src/vimscript/lineRange.ts\");\nconst parserUtils_1 = __webpack_require__(/*! ../../vimscript/parserUtils */ \"./src/vimscript/parserUtils.ts\");\nconst pattern_1 = __webpack_require__(/*! ../../vimscript/pattern */ \"./src/vimscript/pattern.ts\");\nclass ReplaceString {\n    constructor(components) {\n        this.components = components;\n    }\n    toString() {\n        return this.components\n            .map((component) => {\n            if (component.type === 'string') {\n                return component.value;\n            }\n            else if (component.type === 'capture_group') {\n                return component.group === '&' ? '&' : `\\\\${component.group}`;\n            }\n            else if (component.type === 'prev_replace_string') {\n                return '~';\n            }\n            else if (component.type === 'change_case') {\n                if (component.case === 'upper') {\n                    return component.duration === 'char' ? '\\\\u' : '\\\\U';\n                }\n                else {\n                    return component.duration === 'char' ? '\\\\l' : '\\\\L';\n                }\n            }\n            else if (component.type === 'change_case_end') {\n                return '\\\\E';\n            }\n            else {\n                const guard = component;\n                return '';\n            }\n        })\n            .join('');\n    }\n    resolve(matches) {\n        let result = '';\n        let changeCase;\n        let changeCaseChar;\n        for (const component of this.components) {\n            let newChangeCaseChar;\n            let _result = '';\n            if (component.type === 'string') {\n                _result = component.value;\n            }\n            else if (component.type === 'capture_group') {\n                const group = component.group === '&' ? 0 : component.group;\n                _result = matches[group] ?? '';\n            }\n            else if (component.type === 'prev_replace_string') {\n                _result = globalState_1.globalState.substituteState?.replaceString.toString() ?? '';\n            }\n            else if (component.type === 'change_case') {\n                if (component.duration === 'until_end') {\n                    changeCase = component.case;\n                }\n                else {\n                    newChangeCaseChar = component.case;\n                }\n            }\n            else if (component.type === 'change_case_end') {\n                changeCase = undefined;\n            }\n            else {\n                const guard = component;\n            }\n            if (_result) {\n                if (changeCase) {\n                    _result =\n                        changeCase === 'upper' ? _result.toLocaleUpperCase() : _result.toLocaleLowerCase();\n                }\n                if (changeCaseChar) {\n                    _result =\n                        (changeCaseChar === 'upper'\n                            ? _result[0].toLocaleUpperCase()\n                            : _result[0].toLocaleLowerCase()) + _result.slice(1);\n                }\n                result += _result;\n            }\n            changeCaseChar = newChangeCaseChar;\n        }\n        return result;\n    }\n}\nexports.ReplaceString = ReplaceString;\n// TODO: `:help sub-replace-special`\n// TODO: `:help sub-replace-expression`\nconst replaceStringParser = (delimiter) => (0, parsimmon_1.alt)((0, parsimmon_1.string)('\\\\').then(\n// eslint-disable-next-line id-denylist\nparsimmon_1.any.fallback(undefined).map((escaped) => {\n    if (escaped === undefined || escaped === '\\\\') {\n        return { type: 'string', value: '\\\\' };\n    }\n    else if (escaped === '/') {\n        return { type: 'string', value: '/' };\n    }\n    else if (escaped === 'b') {\n        return { type: 'string', value: '\\b' };\n    }\n    else if (escaped === 'r') {\n        return { type: 'string', value: '\\r' };\n    }\n    else if (escaped === 'n') {\n        return { type: 'string', value: '\\n' };\n    }\n    else if (escaped === 't') {\n        return { type: 'string', value: '\\t' };\n    }\n    else if (escaped === '&') {\n        return { type: 'string', value: '&' };\n    }\n    else if (escaped === '~') {\n        return { type: 'string', value: '~' };\n    }\n    else if (/[0-9]/.test(escaped)) {\n        return { type: 'capture_group', group: Number.parseInt(escaped, 10) };\n    }\n    else if (escaped === 'u') {\n        return { type: 'change_case', case: 'upper', duration: 'char' };\n    }\n    else if (escaped === 'l') {\n        return { type: 'change_case', case: 'lower', duration: 'char' };\n    }\n    else if (escaped === 'U') {\n        return { type: 'change_case', case: 'upper', duration: 'until_end' };\n    }\n    else if (escaped === 'L') {\n        return { type: 'change_case', case: 'lower', duration: 'until_end' };\n    }\n    else if (escaped === 'e' || escaped === 'E') {\n        return { type: 'change_case_end' };\n    }\n    else {\n        return { type: 'string', value: `\\\\${escaped}` };\n    }\n})), (0, parsimmon_1.string)('&').result({ type: 'capture_group', group: '&' }), (0, parsimmon_1.string)('~').result({ type: 'prev_replace_string' }), (0, parsimmon_1.noneOf)(delimiter).map((value) => ({ type: 'string', value })))\n    .many()\n    .map((components) => new ReplaceString(components));\nconst substituteFlagsParser = (0, parsimmon_1.seq)((0, parsimmon_1.string)('&').fallback(undefined), (0, parsimmon_1.oneOf)('cegiInp#lr').many()).map(([amp, flagChars]) => {\n    const flags = {};\n    if (amp === '&') {\n        flags.keepPreviousFlags = true;\n    }\n    for (const flag of flagChars) {\n        switch (flag) {\n            case 'c':\n                flags.confirmEach = true;\n                break;\n            case 'e':\n                flags.suppressError = true;\n                break;\n            case 'g':\n                flags.replaceAll = true;\n                break;\n            case 'i':\n                flags.ignoreCase = true;\n                break;\n            case 'I':\n                flags.noIgnoreCase = true;\n                break;\n            case 'n':\n                flags.printCount = true;\n                break;\n            case 'p':\n                flags.printLastMatchedLine = true;\n                break;\n            case '#':\n                flags.printLastMatchedLineWithNumber = true;\n                break;\n            case 'l':\n                flags.printLastMatchedLineWithList = true;\n                break;\n            case 'r':\n                flags.usePreviousPattern = true;\n                break;\n        }\n    }\n    return flags;\n});\nconst countParser = parsimmon_1.optWhitespace\n    .then(parserUtils_1.numberParser)\n    .fallback(undefined);\n/**\n * vim has a distinctly different state for previous search and for previous substitute.  However, in SOME\n * cases a substitution will also update the search state along with the substitute state.\n *\n * Also, the substitute command itself will sometimes use the search state, and other times it will use the\n * substitute state.\n *\n * These are the following cases and how vim handles them:\n * 1. :s/this/that\n *   - standard search/replace\n *   - update substitution state\n *   - update search state too!\n * 2. :s or :s [flags]\n *   - use previous SUBSTITUTION state, and repeat previous substitution pattern and replace.\n *   - do not touch search state!\n *   - changing substitution state is dont-care cause we're repeating it ;)\n * 3. :s/ or :s// or :s///\n *   - use previous SEARCH state (not substitution), and DELETE the string matching the pattern (replace with nothing)\n *   - update substitution state\n *   - updating search state is dont-care cause we're repeating it ;)\n * 4. :s/this or :s/this/ or :s/this//\n *   - input is pattern - replacement is empty (delete)\n *   - update replacement state\n *   - update search state too!\n */\nclass SubstituteCommand extends exCommand_1.ExCommand {\n    constructor(args) {\n        super();\n        this.arguments = args;\n        this.abort = false;\n    }\n    neovimCapable() {\n        // We need to use VSCode's quickpick capabilities to do confirmation\n        return !this.arguments.flags.confirmEach;\n    }\n    getSubstitutionDecorations(vimState, lineRange = new lineRange_1.LineRange(new lineRange_1.Address({ type: 'current_line' }))) {\n        const substitutionAppend = [];\n        const substitutionReplace = [];\n        const searchHighlight = [];\n        const subsArr = configuration_1.configuration.inccommand === 'replace' ? substitutionReplace : substitutionAppend;\n        const { pattern, replace } = this.resolvePatterns(false);\n        const showReplacements = this.arguments.pattern?.closed && configuration_1.configuration.inccommand;\n        let matches = [];\n        if (pattern?.patternString) {\n            matches = pattern.allMatches(vimState, { lineRange });\n        }\n        const global = (configuration_1.configuration.gdefault || configuration_1.configuration.substituteGlobalFlag) !==\n            (this.arguments.flags.replaceAll ?? false);\n        const lines = new Set();\n        for (const match of matches) {\n            if (!global && lines.has(match.range.start.line)) {\n                // If not global, only replace one match per line\n                continue;\n            }\n            lines.add(match.range.start.line);\n            if (showReplacements) {\n                const contentText = (0, decorationUtils_1.formatDecorationText)(replace.resolve(match.groups), vimState.editor.options.tabSize);\n                subsArr.push({\n                    range: match.range,\n                    renderOptions: {\n                        [configuration_1.configuration.inccommand === 'append' ? 'after' : 'before']: { contentText },\n                    },\n                });\n            }\n            else {\n                searchHighlight.push((0, decorationUtils_1.ensureVisible)(match.range));\n            }\n        }\n        return { substitutionAppend, substitutionReplace, searchHighlight };\n    }\n    /**\n     * @returns If match, (# newlines added) - (# newlines removed)\n     *          Else, undefined\n     */\n    async replaceMatchRange(vimState, match) {\n        if (this.arguments.flags.printCount) {\n            return 0;\n        }\n        const replaceText = this.arguments.replace.resolve(match.groups);\n        if (this.arguments.flags.confirmEach) {\n            if (await this.confirmReplacement(vimState, match, replaceText)) {\n                vimState.recordedState.transformer.replace(match.range, replaceText);\n            }\n            else {\n                return undefined;\n            }\n        }\n        else {\n            vimState.recordedState.transformer.replace(match.range, replaceText);\n        }\n        const addedNewlines = replaceText.split('\\n').length - 1;\n        const removedNewlines = match.groups[0].split('\\n').length - 1;\n        return addedNewlines - removedNewlines;\n    }\n    async confirmReplacement(vimState, match, replaceText) {\n        const cancellationToken = new vscode_1.CancellationTokenSource();\n        const validSelections = ['y', 'n', 'a', 'q', 'l'];\n        let selection = '';\n        const prompt = (0, statusBarTextUtils_1.escapeCSSIcons)(`Replace with ${(0, decorationUtils_1.formatDecorationText)(replaceText, vimState.editor.options.tabSize, '\\\\n')} (${validSelections.join('/')})?`);\n        const newConfirmationSearchHighlights = this.cSearchHighlights?.filter((d) => !d.range.isEqual(match.range)) ?? [];\n        vimState.editor.revealRange(new vscode_1.Range(match.range.start.line, 0, match.range.start.line, 0));\n        vimState.editor.setDecorations(decoration_1.decoration.searchHighlight, newConfirmationSearchHighlights);\n        vimState.editor.setDecorations(decoration_1.decoration.searchMatch, [(0, decorationUtils_1.ensureVisible)(match.range)]);\n        vimState.editor.setDecorations(decoration_1.decoration.confirmedSubstitution, this.confirmedSubstitutions ?? []);\n        await vscode_1.window.showInputBox({\n            ignoreFocusOut: true,\n            prompt,\n            placeHolder: validSelections.join('/'),\n            validateInput: (input) => {\n                if (validSelections.includes(input)) {\n                    selection = input;\n                    cancellationToken.cancel();\n                }\n                return prompt;\n            },\n        }, cancellationToken.token);\n        if (selection === 'q' || selection === 'l' || !selection) {\n            this.abort = true;\n        }\n        else if (selection === 'a') {\n            this.arguments.flags.confirmEach = undefined;\n        }\n        if (selection === 'y' || selection === 'a' || selection === 'l') {\n            if (this.cSearchHighlights) {\n                this.cSearchHighlights = newConfirmationSearchHighlights;\n            }\n            this.confirmedSubstitutions?.push({\n                range: match.range,\n                renderOptions: {\n                    before: {\n                        contentText: (0, decorationUtils_1.formatDecorationText)(replaceText, vimState.editor.options.tabSize),\n                    },\n                },\n            });\n            return true;\n        }\n        return false;\n    }\n    /**\n     * @returns the concrete Pattern and ReplaceString to be used for this substitution.\n     * If throwErrors is true, errors will be thrown :)\n     */\n    resolvePatterns(throwErrors) {\n        let { pattern, replace } = this.arguments;\n        if (pattern === undefined) {\n            // If no pattern is entered, use previous SUBSTITUTION state and don't update search state\n            // i.e. :s\n            const prevSubstituteState = globalState_1.globalState.substituteState;\n            if (prevSubstituteState?.searchPattern === undefined ||\n                prevSubstituteState.searchPattern.patternString === '') {\n                if (throwErrors) {\n                    throw error_1.VimError.fromCode(error_1.ErrorCode.NoPreviousSubstituteRegularExpression);\n                }\n            }\n            else {\n                pattern = prevSubstituteState.searchPattern;\n                replace = prevSubstituteState.replaceString;\n            }\n        }\n        else {\n            if (pattern.patternString === '') {\n                // If an explicitly empty pattern is entered, use previous search state (including search with * and #) and update both states\n                // e.g :s/ or :s///\n                const prevSearchState = globalState_1.globalState.searchState;\n                if (prevSearchState === undefined || prevSearchState.searchString === '') {\n                    if (throwErrors) {\n                        throw error_1.VimError.fromCode(error_1.ErrorCode.NoPreviousRegularExpression);\n                    }\n                }\n                else {\n                    pattern = prevSearchState.pattern;\n                }\n            }\n        }\n        return { pattern, replace };\n    }\n    async execute(vimState) {\n        await this.executeWithRange(vimState, new lineRange_1.LineRange(new lineRange_1.Address({ type: 'current_line' })));\n    }\n    async executeWithRange(vimState, lineRange) {\n        let { start, end } = lineRange.resolve(vimState);\n        if (this.arguments.count && this.arguments.count >= 0) {\n            start = end;\n            end = end + this.arguments.count - 1;\n        }\n        // TODO: this is all a bit gross\n        const { pattern, replace } = this.resolvePatterns(true);\n        this.arguments.replace = replace;\n        // `/g` flag inverts the default behavior (from `gdefault`)\n        const global = (configuration_1.configuration.gdefault || configuration_1.configuration.substituteGlobalFlag) !==\n            (this.arguments.flags.replaceAll ?? false);\n        // TODO: `allMatches` lies for patterns with empty branches, which makes this wrong (not that anyone cares)\n        const allMatches = pattern?.allMatches(vimState, {\n            // TODO: This method should probably take start/end lines as numbers\n            lineRange: new lineRange_1.LineRange(new lineRange_1.Address({ type: 'number', num: start + 1 }), ',', new lineRange_1.Address({ type: 'number', num: end + 1 })),\n        }) ?? [];\n        let replaceableMatches;\n        if (global) {\n            // every match is replaceable\n            replaceableMatches = allMatches;\n        }\n        else {\n            // only the first match on a line is replaceable\n            const replaceableLines = new Set();\n            replaceableMatches = allMatches.filter((match) => {\n                if (replaceableLines.has(match.range.start.line)) {\n                    return false;\n                }\n                replaceableLines.add(match.range.start.line);\n                return true;\n            });\n        }\n        if (this.arguments.flags.confirmEach) {\n            vimState.editor.setDecorations(decoration_1.decoration.substitutionAppend, []);\n            vimState.editor.setDecorations(decoration_1.decoration.substitutionReplace, []);\n            if (configuration_1.configuration.inccommand) {\n                this.confirmedSubstitutions = [];\n            }\n            if (configuration_1.configuration.incsearch) {\n                this.cSearchHighlights = replaceableMatches.map((match) => (0, decorationUtils_1.ensureVisible)(match.range));\n            }\n        }\n        const substitutionLines = new Set();\n        let substitutions = 0;\n        let netNewLines = 0;\n        for (const match of replaceableMatches) {\n            if (this.abort) {\n                break;\n            }\n            const newLines = await this.replaceMatchRange(vimState, match);\n            if (newLines !== undefined) {\n                substitutions++;\n                substitutionLines.add(match.range.start.line);\n                netNewLines += newLines;\n            }\n        }\n        if (substitutions > 0) {\n            // if any substitutions were made, jump to latest one\n            const lastLine = Math.max(...substitutionLines.values()) + netNewLines;\n            const cursor = new vscode_1.Position(Math.max(0, lastLine), 0);\n            globalState_1.globalState.jumpTracker.recordJump(new jump_1.Jump({\n                document: vimState.document,\n                position: cursor,\n            }), jump_1.Jump.fromStateNow(vimState));\n            vimState.recordedState.transformer.moveCursor(position_1.PositionDiff.exactPosition(cursor), 0);\n        }\n        this.confirmedSubstitutions = undefined;\n        this.cSearchHighlights = undefined;\n        vimState.editor.setDecorations(decoration_1.decoration.confirmedSubstitution, []);\n        this.setStatusBarText(vimState, substitutions, substitutionLines.size);\n        if (this.arguments.pattern !== undefined) {\n            globalState_1.globalState.substituteState = new substituteState_1.SubstituteState(pattern, replace);\n            globalState_1.globalState.searchState = new searchState_1.SearchState(pattern_1.SearchDirection.Forward, vimState.cursorStopPosition, pattern?.patternString, {});\n        }\n    }\n    setStatusBarText(vimState, substitutions, lines) {\n        if (substitutions === 0) {\n            statusBar_1.StatusBar.displayError(vimState, error_1.VimError.fromCode(error_1.ErrorCode.PatternNotFound, this.arguments.pattern?.patternString));\n        }\n        else if (this.arguments.flags.printCount) {\n            statusBar_1.StatusBar.setText(vimState, `${substitutions} match${substitutions > 1 ? 'es' : ''} on ${lines} line${lines > 1 ? 's' : ''}`);\n        }\n        else if (substitutions > configuration_1.configuration.report) {\n            statusBar_1.StatusBar.setText(vimState, `${substitutions} substitution${substitutions > 1 ? 's' : ''} on ${lines} line${lines > 1 ? 's' : ''}`);\n        }\n    }\n}\nexports.SubstituteCommand = SubstituteCommand;\nSubstituteCommand.argParser = parsimmon_1.optWhitespace.then((0, parsimmon_1.alt)(\n// :s[ubstitute]/{pattern}/{string}/[flags] [count]\n(0, parsimmon_1.regexp)(/[^\\w\\s\\\\|\"]{1}/).chain((delimiter) => (0, parsimmon_1.seq)(pattern_1.Pattern.parser({ direction: pattern_1.SearchDirection.Forward, delimiter }), replaceStringParser(delimiter), (0, parsimmon_1.string)(delimiter).then(substituteFlagsParser).fallback({}), countParser).map(([pattern, replace, flags, count]) => new SubstituteCommand({ pattern, replace, flags, count }))), \n// :s[ubstitute] [flags] [count]\n(0, parsimmon_1.seq)(substituteFlagsParser, countParser).map(([flags, count]) => new SubstituteCommand({\n    pattern: undefined,\n    replace: new ReplaceString([]),\n    flags,\n    count,\n}))));\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/substitute.ts?")},"./src/cmd_line/commands/tab.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.TabCommand = exports.TabCommandType = void 0;\n// eslint-disable-next-line id-denylist\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ "./node_modules/parsimmon/build/parsimmon.umd.min.js");\nconst path = __importStar(__webpack_require__(/*! path */ "./node_modules/path-browserify/index.js"));\nconst vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ "./src/vimscript/exCommand.ts");\nconst parserUtils_1 = __webpack_require__(/*! ../../vimscript/parserUtils */ "./src/vimscript/parserUtils.ts");\nvar TabCommandType;\n(function (TabCommandType) {\n    TabCommandType[TabCommandType["Next"] = 0] = "Next";\n    TabCommandType[TabCommandType["Previous"] = 1] = "Previous";\n    TabCommandType[TabCommandType["First"] = 2] = "First";\n    TabCommandType[TabCommandType["Last"] = 3] = "Last";\n    TabCommandType[TabCommandType["Absolute"] = 4] = "Absolute";\n    TabCommandType[TabCommandType["New"] = 5] = "New";\n    TabCommandType[TabCommandType["Close"] = 6] = "Close";\n    TabCommandType[TabCommandType["Only"] = 7] = "Only";\n    TabCommandType[TabCommandType["Move"] = 8] = "Move";\n})(TabCommandType || (exports.TabCommandType = TabCommandType = {}));\n//\n//  Implements most buffer and tab ex commands\n//  http://vimdoc.sourceforge.net/htmldoc/tabpage.html\n//\nclass TabCommand extends exCommand_1.ExCommand {\n    constructor(args) {\n        super();\n        this.arguments = args;\n    }\n    async executeCommandWithCount(count, command) {\n        for (let i = 0; i < count; i++) {\n            await vscode.commands.executeCommand(command);\n        }\n    }\n    async execute(vimState) {\n        switch (this.arguments.type) {\n            case TabCommandType.Absolute:\n                if (this.arguments.count !== undefined && this.arguments.count >= 0) {\n                    await vscode.commands.executeCommand(\'workbench.action.openEditorAtIndex\', this.arguments.count - 1);\n                }\n                break;\n            case TabCommandType.Next:\n                if (this.arguments.count !== undefined && this.arguments.count <= 0) {\n                    break;\n                }\n                if (this.arguments.count) {\n                    const tabGroup = vscode.window.tabGroups.activeTabGroup;\n                    if (0 < this.arguments.count && this.arguments.count <= tabGroup.tabs.length) {\n                        const tab = tabGroup.tabs[this.arguments.count - 1];\n                        if (tab.input.uri !== undefined) {\n                            const uri = tab.input.uri;\n                            await vscode.commands.executeCommand(\'vscode.open\', uri);\n                        }\n                    }\n                }\n                else {\n                    await vscode.commands.executeCommand(\'workbench.action.nextEditorInGroup\');\n                }\n                break;\n            case TabCommandType.Previous:\n                if (this.arguments.count !== undefined && this.arguments.count <= 0) {\n                    break;\n                }\n                await this.executeCommandWithCount(this.arguments.count || 1, \'workbench.action.previousEditorInGroup\');\n                break;\n            case TabCommandType.First:\n                await vscode.commands.executeCommand(\'workbench.action.openEditorAtIndex1\');\n                break;\n            case TabCommandType.Last:\n                await vscode.commands.executeCommand(\'workbench.action.lastEditorInGroup\');\n                break;\n            case TabCommandType.New: {\n                const hasFile = !(this.arguments.file === undefined || this.arguments.file === \'\');\n                if (hasFile) {\n                    const isAbsolute = path.isAbsolute(this.arguments.file);\n                    const isInWorkspace = vscode.workspace.workspaceFolders !== undefined &&\n                        vscode.workspace.workspaceFolders.length > 0;\n                    const currentFilePath = vscode.window.activeTextEditor.document.uri.fsPath;\n                    let toOpenPath;\n                    if (isAbsolute) {\n                        toOpenPath = this.arguments.file;\n                    }\n                    else if (isInWorkspace) {\n                        const workspacePath = vscode.workspace.workspaceFolders[0].uri.path;\n                        toOpenPath = path.join(workspacePath, this.arguments.file);\n                    }\n                    else {\n                        toOpenPath = path.join(path.dirname(currentFilePath), this.arguments.file);\n                    }\n                    if (toOpenPath !== currentFilePath) {\n                        await vscode.commands.executeCommand(\'vscode.open\', vscode.Uri.file(toOpenPath));\n                    }\n                }\n                else {\n                    await vscode.commands.executeCommand(\'workbench.action.files.newUntitledFile\');\n                }\n                break;\n            }\n            case TabCommandType.Close:\n                // Navigate the correct position\n                if (this.arguments.count === undefined) {\n                    await vscode.commands.executeCommand(\'workbench.action.closeActiveEditor\');\n                    break;\n                }\n                if (this.arguments.count === 0) {\n                    // Wrong paramter\n                    break;\n                }\n                // TODO: Close Page {count}. Page count is one-based.\n                break;\n            case TabCommandType.Only:\n                await vscode.commands.executeCommand(\'workbench.action.closeOtherEditors\');\n                break;\n            case TabCommandType.Move: {\n                const { count, direction } = this.arguments;\n                let args;\n                if (direction !== undefined) {\n                    args = { to: direction, by: \'tab\', value: count ?? 1 };\n                }\n                else if (count === 0) {\n                    args = { to: \'first\' };\n                }\n                else if (count === undefined) {\n                    args = { to: \'last\' };\n                }\n                else {\n                    args = { to: \'position\', by: \'tab\', value: count + 1 };\n                }\n                await vscode.commands.executeCommand(\'moveActiveEditor\', args);\n                break;\n            }\n            default:\n                break;\n        }\n    }\n}\nexports.TabCommand = TabCommand;\n// TODO: `count` is parsed as a number, which is incomplete\nTabCommand.argParsers = {\n    bfirst: parsimmon_1.whitespace\n        .then(parserUtils_1.fileCmdParser)\n        .fallback(undefined)\n        .map((cmd) => {\n        return new TabCommand({ type: TabCommandType.First, cmd });\n    }),\n    blast: parsimmon_1.whitespace\n        .then(parserUtils_1.fileCmdParser)\n        .fallback(undefined)\n        .map((cmd) => {\n        return new TabCommand({ type: TabCommandType.Last, cmd });\n    }),\n    bnext: (0, parsimmon_1.seq)(parserUtils_1.bangParser, parsimmon_1.optWhitespace.then(parserUtils_1.fileCmdParser).fallback(undefined), parsimmon_1.optWhitespace.then(parserUtils_1.numberParser).fallback(undefined)).map(([bang, cmd, count]) => {\n        return new TabCommand({ type: TabCommandType.Next, bang, cmd, count });\n    }),\n    bprev: (0, parsimmon_1.seq)(parserUtils_1.bangParser, parsimmon_1.optWhitespace.then(parserUtils_1.fileCmdParser).fallback(undefined), parsimmon_1.optWhitespace.then(parserUtils_1.numberParser).fallback(undefined)).map(([bang, cmd, count]) => {\n        return new TabCommand({ type: TabCommandType.Previous, bang, cmd, count });\n    }),\n    tabclose: (0, parsimmon_1.seq)(parserUtils_1.bangParser, parsimmon_1.optWhitespace.then(parserUtils_1.numberParser).fallback(undefined)).map(([bang, count]) => {\n        return new TabCommand({ type: TabCommandType.Close, bang, count });\n    }),\n    tabonly: (0, parsimmon_1.seq)(parserUtils_1.bangParser, parsimmon_1.optWhitespace.then(parserUtils_1.numberParser).fallback(undefined)).map(([bang, count]) => {\n        return new TabCommand({ type: TabCommandType.Only, bang, count });\n    }),\n    tabnew: (0, parsimmon_1.seq)(parsimmon_1.optWhitespace.then(parserUtils_1.fileOptParser).fallback([]), parsimmon_1.optWhitespace.then(parserUtils_1.fileCmdParser).fallback(undefined), (0, parsimmon_1.regexp)(/\\S+/).fallback(undefined)).map(([opt, cmd, file]) => {\n        return new TabCommand({\n            type: TabCommandType.New,\n            opt,\n            cmd,\n            file,\n        });\n    }),\n    tabmove: parsimmon_1.optWhitespace\n        .then((0, parsimmon_1.seq)((0, parsimmon_1.alt)((0, parsimmon_1.string)(\'+\').result(\'right\'), (0, parsimmon_1.string)(\'-\').result(\'left\')).fallback(undefined), parserUtils_1.numberParser.fallback(undefined)))\n        .map(([direction, count]) => new TabCommand({ type: TabCommandType.Move, direction, count })),\n    tabAbsolute: parsimmon_1.optWhitespace\n        .then(parserUtils_1.numberParser.fallback(undefined))\n        .map((count) => new TabCommand({ type: TabCommandType.Absolute, count: count ?? 0 })),\n};\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/tab.ts?')},"./src/cmd_line/commands/terminal.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.TerminalCommand = void 0;\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ "./node_modules/parsimmon/build/parsimmon.umd.min.js");\nconst vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ "./src/vimscript/exCommand.ts");\nclass TerminalCommand extends exCommand_1.ExCommand {\n    async execute(vimState) {\n        await vscode.commands.executeCommand(\'workbench.action.createTerminalEditor\');\n    }\n}\nexports.TerminalCommand = TerminalCommand;\nTerminalCommand.argParser = (0, parsimmon_1.succeed)(new TerminalCommand());\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/terminal.ts?')},"./src/cmd_line/commands/undo.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.UndoCommand = void 0;\nconst actions_1 = __webpack_require__(/*! ../../actions/commands/actions */ "./src/actions/commands/actions.ts");\nconst vscode_1 = __webpack_require__(/*! vscode */ "vscode");\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ "./src/vimscript/exCommand.ts");\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ "./node_modules/parsimmon/build/parsimmon.umd.min.js");\nconst parserUtils_1 = __webpack_require__(/*! ../../vimscript/parserUtils */ "./src/vimscript/parserUtils.ts");\n//\n//  Implements :u[ndo]\n//  http://vimdoc.sourceforge.net/htmldoc/undo.html\n//\nclass UndoCommand extends exCommand_1.ExCommand {\n    constructor(count) {\n        super();\n        this.count = count;\n    }\n    async execute(vimState) {\n        // TODO: Use `this.count`\n        await new actions_1.CommandUndo().exec(new vscode_1.Position(0, 0), vimState);\n    }\n}\nexports.UndoCommand = UndoCommand;\nUndoCommand.argParser = parsimmon_1.optWhitespace\n    .then(parserUtils_1.numberParser)\n    .fallback(undefined)\n    .map((count) => new UndoCommand(count));\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/undo.ts?')},"./src/cmd_line/commands/vscode.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.VsCodeCommand = void 0;\nconst error_1 = __webpack_require__(/*! ../../error */ "./src/error.ts");\nconst statusBar_1 = __webpack_require__(/*! ../../statusBar */ "./src/statusBar.ts");\nconst vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ "./src/vimscript/exCommand.ts");\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ "./node_modules/parsimmon/build/parsimmon.umd.min.js");\nclass VsCodeCommand extends exCommand_1.ExCommand {\n    constructor(command) {\n        super();\n        this.command = command;\n    }\n    async execute(vimState) {\n        if (!this.command) {\n            statusBar_1.StatusBar.displayError(vimState, error_1.VimError.fromCode(error_1.ErrorCode.ArgumentRequired));\n            return;\n        }\n        await vscode.commands.executeCommand(this.command);\n    }\n}\nexports.VsCodeCommand = VsCodeCommand;\nVsCodeCommand.argParser = parsimmon_1.whitespace\n    .then(parsimmon_1.all)\n    .map((command) => new VsCodeCommand(command));\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/vscode.ts?')},"./src/cmd_line/commands/wall.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.WallCommand = void 0;\nconst vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ "./src/vimscript/exCommand.ts");\nconst parserUtils_1 = __webpack_require__(/*! ../../vimscript/parserUtils */ "./src/vimscript/parserUtils.ts");\n//\n//  Implements :wall (write all)\n//  http://vimdoc.sourceforge.net/htmldoc/editing.html#:wall\n//\nclass WallCommand extends exCommand_1.ExCommand {\n    constructor(bang) {\n        super();\n        this.bang = bang ?? false;\n    }\n    async execute(vimState) {\n        // TODO : overwrite readonly files when bang? == true\n        await vscode.workspace.saveAll(false);\n    }\n}\nexports.WallCommand = WallCommand;\nWallCommand.argParser = parserUtils_1.bangParser.map((bang) => new WallCommand(bang));\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/wall.ts?')},"./src/cmd_line/commands/write.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.WriteCommand = void 0;\n// eslint-disable-next-line id-denylist\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ "./node_modules/parsimmon/build/parsimmon.umd.min.js");\nconst path = __importStar(__webpack_require__(/*! path */ "./node_modules/path-browserify/index.js"));\nconst fs = __importStar(__webpack_require__(/*! platform/fs */ "./src/platform/browser/fs.ts"));\nconst vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));\nconst statusBar_1 = __webpack_require__(/*! ../../statusBar */ "./src/statusBar.ts");\nconst logger_1 = __webpack_require__(/*! ../../util/logger */ "./src/util/logger.ts");\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ "./src/vimscript/exCommand.ts");\nconst parserUtils_1 = __webpack_require__(/*! ../../vimscript/parserUtils */ "./src/vimscript/parserUtils.ts");\n//\n//  Implements :write\n//  http://vimdoc.sourceforge.net/htmldoc/editing.html#:write\n//\nclass WriteCommand extends exCommand_1.ExCommand {\n    constructor(args) {\n        super();\n        this.isRepeatableWithDot = false;\n        this.arguments = args;\n    }\n    async execute(vimState) {\n        // TODO: Use arguments: opt, file, cmd\n        // If the file isn\'t on disk because it\'s brand new or on a remote file system, let VS Code handle it\n        if (vimState.document.isUntitled || vimState.document.uri.scheme !== \'file\') {\n            await this.background(vscode.commands.executeCommand(\'workbench.action.files.save\'));\n            return;\n        }\n        try {\n            if (this.arguments.file) {\n                await this.saveAs(vimState, this.arguments.file);\n            }\n            else {\n                await fs.accessAsync(vimState.document.fileName, fs.constants.W_OK);\n                await this.save(vimState);\n            }\n        }\n        catch (accessErr) {\n            if (this.arguments.bang) {\n                try {\n                    const mode = await fs.getMode(vimState.document.fileName);\n                    await fs.chmodAsync(vimState.document.fileName, 0o666);\n                    // We must do a foreground write so we can await the save\n                    // and chmod the file back to its original state\n                    this.arguments.bgWrite = false;\n                    await this.save(vimState);\n                    await fs.chmodAsync(vimState.document.fileName, mode);\n                }\n                catch (e) {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access\n                    statusBar_1.StatusBar.setText(vimState, e.message);\n                }\n            }\n            else {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access\n                statusBar_1.StatusBar.setText(vimState, accessErr.message);\n            }\n        }\n    }\n    // TODO: Aparentemente foi tudo, claro que falta alguns ERRORS e bla bla bla tipo o do :w 8/ E212 mas fds o E357 sobrepoe\n    // TODO: fazer PR (#1876)\n    async saveAs(vimState, fileName) {\n        try {\n            const filePath = path.resolve(path.dirname(vimState.document.fileName), fileName);\n            const fileExists = await fs.existsAsync(filePath);\n            const uri = vscode.Uri.file(path.resolve(path.dirname(vimState.document.fileName), filePath));\n            // An extension to the file must be specified.\n            if (path.extname(filePath) === \'\') {\n                statusBar_1.StatusBar.setText(vimState, `E357: The file extension must be specified`, true);\n                return;\n            }\n            // Checks if the file exists.\n            if (fileExists) {\n                const stats = await vscode.workspace.fs.stat(uri);\n                const isDirectory = stats.type === vscode.FileType.Directory;\n                // If it\'s a directory, throw an error.\n                if (isDirectory) {\n                    statusBar_1.StatusBar.setText(vimState, `E17: "${filePath}" is a directory`, true);\n                    return;\n                }\n                // Create a pop-up asking if user wants to overwrite the file.\n                const confirmOverwrite = await vscode.window.showWarningMessage(`File "${fileName}" already exists. Do you want to overwrite it?`, { modal: true }, \'Yes\', \'No\');\n                if (confirmOverwrite === \'No\') {\n                    return;\n                }\n            }\n            // Create a new file in \'filePath\', appending the current\'s file content to it.\n            await vscode.window.showTextDocument(vimState.document, { preview: false });\n            await vscode.commands.executeCommand(\'workbench.action.files.save\', uri);\n            await vscode.workspace.fs.copy(vimState.document.uri, uri, { overwrite: true });\n            statusBar_1.StatusBar.setText(vimState, `"${fileName}" ${fileExists ? \'\' : \'[New]\'} ${vimState.document.lineCount}L ${vimState.document.getText().length}C written`);\n        }\n        catch (e) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access\n            statusBar_1.StatusBar.setText(vimState, e.message);\n        }\n    }\n    async save(vimState) {\n        await this.background(vimState.document.save().then((success) => {\n            if (success) {\n                statusBar_1.StatusBar.setText(vimState, `"${path.basename(vimState.document.fileName)}" ${vimState.document.lineCount}L ${vimState.document.getText().length}C written`);\n            }\n            else {\n                logger_1.Logger.warn(\':w failed\');\n                // TODO: What\'s the right thing to do here?\n            }\n        }));\n    }\n    async background(fn) {\n        if (!this.arguments.bgWrite) {\n            await fn;\n        }\n    }\n}\nexports.WriteCommand = WriteCommand;\nWriteCommand.argParser = (0, parsimmon_1.seq)(parserUtils_1.bangParser.skip(parsimmon_1.optWhitespace), parserUtils_1.fileOptParser.skip(parsimmon_1.optWhitespace), (0, parsimmon_1.alt)((0, parsimmon_1.string)(\'!\')\n    .then(parsimmon_1.all)\n    .map((cmd) => {\n    return { cmd };\n}), parserUtils_1.fileNameParser.map((file) => {\n    return { file };\n})).fallback({})).map(([bang, opt, other]) => new WriteCommand({ bang, opt, bgWrite: true, ...other }));\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/write.ts?')},"./src/cmd_line/commands/writequit.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.WriteQuitCommand = void 0;\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ "./node_modules/parsimmon/build/parsimmon.umd.min.js");\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ "./src/vimscript/exCommand.ts");\nconst parserUtils_1 = __webpack_require__(/*! ../../vimscript/parserUtils */ "./src/vimscript/parserUtils.ts");\nconst quit_1 = __webpack_require__(/*! ./quit */ "./src/cmd_line/commands/quit.ts");\nconst write_1 = __webpack_require__(/*! ./write */ "./src/cmd_line/commands/write.ts");\nclass WriteQuitCommand extends exCommand_1.ExCommand {\n    constructor(args) {\n        super();\n        this.isRepeatableWithDot = false;\n        this.args = args;\n    }\n    // Writing command. Taken as a basis from the "write.ts" file.\n    async execute(vimState) {\n        await new write_1.WriteCommand({ bgWrite: false, ...this.args }).execute(vimState);\n        await new quit_1.QuitCommand({\n            // wq! fails when no file name is provided\n            bang: false,\n        }).execute(vimState);\n    }\n}\nexports.WriteQuitCommand = WriteQuitCommand;\nWriteQuitCommand.argParser = (0, parsimmon_1.seq)(parserUtils_1.bangParser.skip(parsimmon_1.optWhitespace), parserUtils_1.fileOptParser.skip(parsimmon_1.optWhitespace), parserUtils_1.fileNameParser.fallback(undefined)).map(([bang, opt, file]) => new WriteQuitCommand(file ? { bang, opt, file } : { bang, opt }));\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/writequit.ts?')},"./src/cmd_line/commands/writequitall.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.WriteQuitAllCommand = void 0;\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ "./node_modules/parsimmon/build/parsimmon.umd.min.js");\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ "./src/vimscript/exCommand.ts");\nconst parserUtils_1 = __webpack_require__(/*! ../../vimscript/parserUtils */ "./src/vimscript/parserUtils.ts");\nconst wall = __importStar(__webpack_require__(/*! ../commands/wall */ "./src/cmd_line/commands/wall.ts"));\nconst quit = __importStar(__webpack_require__(/*! ./quit */ "./src/cmd_line/commands/quit.ts"));\nclass WriteQuitAllCommand extends exCommand_1.ExCommand {\n    constructor(args) {\n        super();\n        this.isRepeatableWithDot = false;\n        this.arguments = args;\n    }\n    // Writing command. Taken as a basis from the "write.ts" file.\n    async execute(vimState) {\n        const quitArgs = {\n            // wq! fails when no file name is provided\n            bang: false,\n        };\n        const wallCmd = new wall.WallCommand(this.arguments.bang);\n        await wallCmd.execute(vimState);\n        // TODO: fileOpt is not used\n        quitArgs.quitAll = true;\n        const quitCmd = new quit.QuitCommand(quitArgs);\n        await quitCmd.execute(vimState);\n    }\n}\nexports.WriteQuitAllCommand = WriteQuitAllCommand;\nWriteQuitAllCommand.argParser = (0, parsimmon_1.seq)(parserUtils_1.bangParser, parsimmon_1.whitespace.then(parserUtils_1.fileOptParser).fallback([])).map(([bang, fileOpt]) => new WriteQuitAllCommand({ bang, fileOpt }));\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/writequitall.ts?')},"./src/cmd_line/commands/yank.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.YankCommand = void 0;\n// eslint-disable-next-line id-denylist\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ "./node_modules/parsimmon/build/parsimmon.umd.min.js");\nconst vscode_1 = __webpack_require__(/*! vscode */ "vscode");\nconst operator_1 = __webpack_require__(/*! ../../actions/operator */ "./src/actions/operator.ts");\nconst register_1 = __webpack_require__(/*! ../../register/register */ "./src/register/register.ts");\nconst exCommand_1 = __webpack_require__(/*! ../../vimscript/exCommand */ "./src/vimscript/exCommand.ts");\nconst parserUtils_1 = __webpack_require__(/*! ../../vimscript/parserUtils */ "./src/vimscript/parserUtils.ts");\nclass YankCommand extends exCommand_1.ExCommand {\n    constructor(args) {\n        super();\n        this.arguments = args;\n    }\n    async yank(vimState, start, end) {\n        vimState.currentRegisterMode = register_1.RegisterMode.LineWise;\n        if (this.arguments.register) {\n            vimState.recordedState.registerName = this.arguments.register;\n        }\n        const cursorPosition = vimState.cursorStopPosition;\n        await new operator_1.YankOperator().run(vimState, start.getLineBegin(), end.getLineEnd());\n        // YankOperator moves the cursor - undo that\n        vimState.cursorStopPosition = cursorPosition;\n    }\n    async execute(vimState) {\n        const linesToYank = this.arguments.count ?? 1;\n        const startPosition = vimState.cursorStartPosition;\n        const endPosition = linesToYank\n            ? startPosition.getDown(linesToYank - 1).getLineEnd()\n            : vimState.cursorStopPosition;\n        await this.yank(vimState, startPosition, endPosition);\n    }\n    async executeWithRange(vimState, range) {\n        /**\n         * If a [cnt] and [range] is specified (e.g. :.+2y3), :yank [cnt] is called from\n         * the end of the [range].\n         * Ex. if two lines are VisualLine highlighted, :<,>y3 will :y3\n         * from the end of the selected lines.\n         */\n        const { start, end } = range.resolve(vimState);\n        if (this.arguments.count) {\n            vimState.cursorStartPosition = new vscode_1.Position(end, 0);\n            await this.execute(vimState);\n            return;\n        }\n        await this.yank(vimState, new vscode_1.Position(start, 0), new vscode_1.Position(end, 0));\n    }\n}\nexports.YankCommand = YankCommand;\nYankCommand.argParser = parsimmon_1.optWhitespace.then((0, parsimmon_1.alt)(parserUtils_1.numberParser.map((count) => {\n    return { register: undefined, count };\n}), \n// eslint-disable-next-line id-denylist\n(0, parsimmon_1.seq)(parsimmon_1.any.fallback(undefined), parsimmon_1.whitespace.then(parserUtils_1.numberParser).fallback(undefined)).map(([register, count]) => {\n    return { register, count };\n})).map(({ register, count }) => new YankCommand({\n    register,\n    count,\n})));\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/commands/yank.ts?')},"./src/cmd_line/expression.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.expressionParser = void 0;\n// eslint-disable-next-line id-denylist\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ \"./node_modules/parsimmon/build/parsimmon.umd.min.js\");\nconst error_1 = __webpack_require__(/*! ../error */ \"./src/error.ts\");\nconst parserUtils_1 = __webpack_require__(/*! ../vimscript/parserUtils */ \"./src/vimscript/parserUtils.ts\");\nfunction range(start, stop, step) {\n    return Array.from({ length: (stop - start) / step + 1 }, (_, i) => start + i * step);\n}\nconst RangeExpression = {\n    parser: (0, parsimmon_1.seqObj)((0, parsimmon_1.string)('range'), (0, parsimmon_1.string)('('), parsimmon_1.optWhitespace, ['start', parserUtils_1.integerParser], parsimmon_1.optWhitespace, (0, parsimmon_1.string)(','), parsimmon_1.optWhitespace, ['end', parserUtils_1.integerParser], parsimmon_1.optWhitespace, ['step', (0, parsimmon_1.string)(',').then(parsimmon_1.optWhitespace).then(parserUtils_1.integerParser).fallback(1)], parsimmon_1.optWhitespace, (0, parsimmon_1.string)(')')).map(({ start, end, step }) => {\n        const numbers = range(start, end, step);\n        if (numbers.length === 0) {\n            throw error_1.VimError.fromCode(error_1.ErrorCode.StartPastEnd);\n        }\n        else {\n            return numbers.join('\\n');\n        }\n    }),\n};\nconst EXPRESSION_REGISTER = (0, parsimmon_1.string)('=');\nconst altExpressions = (0, parsimmon_1.alt)(RangeExpression.parser);\nexports.expressionParser = (0, parsimmon_1.seqObj)(parsimmon_1.optWhitespace, ['register', EXPRESSION_REGISTER], parsimmon_1.optWhitespace, ['fromExpression', altExpressions]);\n\n\n//# sourceURL=webpack://vim/./src/cmd_line/expression.ts?")},"./src/common/matching/matcher.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PairMatcher = void 0;\nconst vscode_1 = __webpack_require__(/*! vscode */ \"vscode\");\nconst configuration_1 = __webpack_require__(/*! ../../configuration/configuration */ \"./src/configuration/configuration.ts\");\n/**\n * PairMatcher finds the position matching the given character, respecting nested\n * instances of the pair.\n */\nclass PairMatcher {\n    static findPairedChar(position, charToFind, charToStack, stackHeight, isNextMatchForward, vimState, allowCurrentPosition) {\n        let lineNumber = position.line;\n        const linePosition = position.character;\n        const lineCount = vimState.document.lineCount;\n        const cursorChar = vimState.document.lineAt(position).text[position.character];\n        if (allowCurrentPosition &&\n            vimState.cursorStartPosition.isEqual(vimState.cursorStopPosition) &&\n            cursorChar === charToFind) {\n            return position;\n        }\n        while (PairMatcher.keepSearching(lineNumber, lineCount, isNextMatchForward)) {\n            let lineText = vimState.document.lineAt(lineNumber).text.split('');\n            const originalLineLength = lineText.length;\n            if (lineNumber === position.line) {\n                if (isNextMatchForward) {\n                    lineText = lineText.slice(linePosition + 1, originalLineLength);\n                }\n                else {\n                    lineText = lineText.slice(0, linePosition);\n                }\n            }\n            while (true) {\n                if (lineText.length <= 0 || stackHeight <= -1) {\n                    break;\n                }\n                let nextChar;\n                if (isNextMatchForward) {\n                    nextChar = lineText.shift();\n                }\n                else {\n                    nextChar = lineText.pop();\n                }\n                if (nextChar === charToStack) {\n                    stackHeight++;\n                }\n                else if (nextChar === charToFind) {\n                    stackHeight--;\n                }\n                else {\n                    continue;\n                }\n            }\n            if (stackHeight <= -1) {\n                let pairMemberChar;\n                if (isNextMatchForward) {\n                    pairMemberChar = Math.max(0, originalLineLength - lineText.length - 1);\n                }\n                else {\n                    pairMemberChar = lineText.length;\n                }\n                return new vscode_1.Position(lineNumber, pairMemberChar);\n            }\n            if (isNextMatchForward) {\n                lineNumber++;\n            }\n            else {\n                lineNumber--;\n            }\n        }\n        return undefined;\n    }\n    static keepSearching(lineNumber, lineCount, isNextMatchForward) {\n        if (isNextMatchForward) {\n            return lineNumber <= lineCount - 1;\n        }\n        else {\n            return lineNumber >= 0;\n        }\n    }\n    static getPercentPairing(char) {\n        for (const pairing of configuration_1.configuration.matchpairs.split(',')) {\n            const components = pairing.split(':');\n            if (components.length === 2) {\n                if (components[0] === char) {\n                    return {\n                        match: components[1],\n                        isNextMatchForward: true,\n                    };\n                }\n                else if (components[1] === char) {\n                    return {\n                        match: components[0],\n                        isNextMatchForward: false,\n                    };\n                }\n            }\n        }\n        return undefined;\n    }\n    static nextPairedChar(position, charToMatch, vimState, allowCurrentPosition) {\n        /**\n         * We do a fairly basic implementation that only tracks the state of the type of\n         * character you're over and its pair (e.g. \"[\" and \"]\"). This is similar to\n         * what Vim does.\n         *\n         * It can't handle strings very well - something like \"|( ')' )\" where | is the\n         * cursor will cause it to go to the ) in the quotes, even though it should skip over it.\n         *\n         * PRs welcomed! (TODO)\n         * Though ideally VSC implements https://github.com/Microsoft/vscode/issues/7177\n         */\n        const pairing = this.pairings[charToMatch];\n        if (pairing === undefined || pairing.directionless) {\n            return undefined;\n        }\n        const stackHeight = 0;\n        const charToFind = pairing.match;\n        const charToStack = charToMatch;\n        return PairMatcher.findPairedChar(position, charToFind, charToStack, stackHeight, pairing.isNextMatchForward, vimState, allowCurrentPosition);\n    }\n}\nexports.PairMatcher = PairMatcher;\nPairMatcher.pairings = {\n    '(': { match: ')', isNextMatchForward: true },\n    '{': { match: '}', isNextMatchForward: true },\n    '[': { match: ']', isNextMatchForward: true },\n    ')': { match: '(', isNextMatchForward: false },\n    '}': { match: '{', isNextMatchForward: false },\n    ']': { match: '[', isNextMatchForward: false },\n    // These characters can't be used for \"%\"-based matching, but are still\n    // useful for text objects.\n    // matchesWithPercentageMotion can be overwritten with configuration.matchpairs\n    '<': { match: '>', isNextMatchForward: true },\n    '>': { match: '<', isNextMatchForward: false },\n    // These are useful for deleting closing and opening quotes, but don't seem to negatively\n    // affect how text objects such as `ci\"` work, which was my worry.\n    '\"': { match: '\"', isNextMatchForward: false, directionless: true },\n    \"'\": { match: \"'\", isNextMatchForward: false, directionless: true },\n    '`': { match: '`', isNextMatchForward: false, directionless: true },\n};\n\n\n//# sourceURL=webpack://vim/./src/common/matching/matcher.ts?")},"./src/common/matching/quoteMatcher.ts":(__unused_webpack_module,exports)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.QuoteMatcher = void 0;\nvar QuoteMatch;\n(function (QuoteMatch) {\n    QuoteMatch[QuoteMatch["Opening"] = 0] = "Opening";\n    QuoteMatch[QuoteMatch["Closing"] = 1] = "Closing";\n})(QuoteMatch || (QuoteMatch = {}));\n/**\n * QuoteMatcher matches quoted strings, respecting escaped quotes (\\") and friends\n */\nclass QuoteMatcher {\n    constructor(quote, corpus) {\n        this.quoteMap = [];\n        let openingQuote = true;\n        // Loop over corpus, marking quotes and respecting escape characters.\n        for (let i = 0; i < corpus.length; i++) {\n            if (corpus[i] === QuoteMatcher.escapeChar) {\n                i += 1;\n                continue;\n            }\n            if (corpus[i] === quote) {\n                this.quoteMap[i] = openingQuote ? QuoteMatch.Opening : QuoteMatch.Closing;\n                openingQuote = !openingQuote;\n            }\n        }\n    }\n    surroundingQuotes(cursorIndex) {\n        const cursorQuoteType = this.quoteMap[cursorIndex];\n        if (cursorQuoteType === QuoteMatch.Opening) {\n            const closing = this.getNextQuote(cursorIndex);\n            return closing !== undefined ? [cursorIndex, closing] : undefined;\n        }\n        else if (cursorQuoteType === QuoteMatch.Closing) {\n            return [this.getPrevQuote(cursorIndex), cursorIndex];\n        }\n        else {\n            const opening = this.getPrevQuote(cursorIndex) ?? this.getNextQuote(cursorIndex);\n            if (opening !== undefined) {\n                const closing = this.getNextQuote(opening);\n                if (closing !== undefined) {\n                    return [opening, closing];\n                }\n            }\n        }\n        return undefined;\n    }\n    getNextQuote(start) {\n        for (let i = start + 1; i < this.quoteMap.length; i++) {\n            if (this.quoteMap[i] !== undefined) {\n                return i;\n            }\n        }\n        return undefined;\n    }\n    getPrevQuote(start) {\n        for (let i = start - 1; i >= 0; i--) {\n            if (this.quoteMap[i] !== undefined) {\n                return i;\n            }\n        }\n        return undefined;\n    }\n}\nexports.QuoteMatcher = QuoteMatcher;\nQuoteMatcher.escapeChar = \'\\\\\';\n\n\n//# sourceURL=webpack://vim/./src/common/matching/quoteMatcher.ts?')},"./src/common/matching/tagMatcher.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TagMatcher = void 0;\nconst textEditor_1 = __webpack_require__(/*! ../../textEditor */ \"./src/textEditor.ts\");\nclass TagMatcher {\n    constructor(corpus, position, vimState) {\n        let match = TagMatcher.TAG_REGEX.exec(corpus);\n        const tags = [];\n        // Gather all the existing tags.\n        while (match) {\n            // Node is a self closing tag, skip.\n            if (match[TagMatcher.CLOSE_FORWARD_SLASH]) {\n                match = TagMatcher.TAG_REGEX.exec(corpus);\n                continue;\n            }\n            tags.push({\n                name: match[TagMatcher.TAG_NAME],\n                type: match[TagMatcher.OPEN_FORWARD_SLASH] ? 'close' : 'open',\n                startPos: match.index,\n                endPos: TagMatcher.TAG_REGEX.lastIndex,\n            });\n            match = TagMatcher.TAG_REGEX.exec(corpus);\n        }\n        const stack = [];\n        const matchedTags = [];\n        for (const tag of tags) {\n            // We have to push on the stack\n            // if it is an open tag.\n            if (tag.type === 'open') {\n                stack.push(tag);\n            }\n            else {\n                // We have an unmatched closing tag,\n                // so try and match it with any existing tag.\n                for (let i = stack.length - 1; i >= 0; i--) {\n                    const openNode = stack[i];\n                    if (openNode.type === 'open' && openNode.name === tag.name) {\n                        // A matching tag was found, ignore\n                        // any tags that were in between.\n                        matchedTags.push({\n                            tag: openNode.name,\n                            openingTagStart: openNode.startPos,\n                            openingTagEnd: openNode.endPos,\n                            closingTagStart: tag.startPos,\n                            closingTagEnd: tag.endPos,\n                        });\n                        stack.splice(i);\n                        break;\n                    }\n                }\n            }\n        }\n        const firstNonWhitespacePositionOnLine = textEditor_1.TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, vimState.cursorStartPosition.line);\n        /**\n         * This adjustment fixes the following situation:\n         * <foo>\n         * |  <bar>\n         *    test\n         *    </bar>\n         * </foo>\n         * Now in tag matching situations, the tag opening on the cursor line is considered as well\n         * (if there is only whitespace before the tag and the cursor is standing on these whitespaces)\n         */\n        const startPos = vimState.cursorStartPosition.character < firstNonWhitespacePositionOnLine.character\n            ? firstNonWhitespacePositionOnLine\n            : vimState.cursorStartPosition;\n        const startPosOffset = vimState.document.offsetAt(startPos);\n        const endPosOffset = position;\n        const tagsSurrounding = matchedTags.filter((n) => {\n            return startPosOffset >= n.openingTagStart && endPosOffset < n.closingTagEnd;\n        });\n        if (!tagsSurrounding.length) {\n            return;\n        }\n        const nodeSurrounding = this.determineRelevantTag(tagsSurrounding, startPosOffset, vimState.cursorStartPosition.compareTo(vimState.cursorStopPosition) !== 0);\n        if (!nodeSurrounding) {\n            return;\n        }\n        this.openStart = nodeSurrounding.openingTagStart;\n        this.closeEnd = nodeSurrounding.closingTagEnd;\n        // if the inner tag content is already selected, expand to enclose tags with 'it' as in vim\n        if (startPosOffset === nodeSurrounding.openingTagEnd &&\n            endPosOffset + 1 === nodeSurrounding.closingTagStart) {\n            this.openEnd = this.openStart;\n            this.closeStart = this.closeEnd;\n        }\n        else {\n            this.openEnd = nodeSurrounding.openingTagEnd;\n            this.closeStart = nodeSurrounding.closingTagStart;\n        }\n    }\n    /**\n     * Most of the time the relevant tag is the innermost tag, but when Visual mode is active,\n     * the rules are different.\n     * When the cursorStart is standing on the < character of the inner tag, with \"at\" we must\n     * jump to the outer tag.\n     */\n    determineRelevantTag(tagsSurrounding, adjustedStartPosOffset, selectionActive) {\n        const relevantTag = tagsSurrounding[0];\n        if (selectionActive && adjustedStartPosOffset === relevantTag.openingTagStart) {\n            // we adjusted so we have to return the outer tag\n            return tagsSurrounding[1];\n        }\n        else {\n            return relevantTag;\n        }\n    }\n    findOpening(inclusive) {\n        if (inclusive) {\n            return this.openStart;\n        }\n        return this.openEnd;\n    }\n    findClosing(inclusive) {\n        if (inclusive) {\n            return this.closeEnd;\n        }\n        return this.closeStart;\n    }\n}\nexports.TagMatcher = TagMatcher;\n// see regexr.com/3t585\nTagMatcher.TAG_REGEX = /\\<(\\/)?([^\\>\\<\\s\\/]+)(?:[^\\>\\<]*?)(\\/)?\\>/g;\nTagMatcher.OPEN_FORWARD_SLASH = 1;\nTagMatcher.TAG_NAME = 2;\nTagMatcher.CLOSE_FORWARD_SLASH = 3;\n\n\n//# sourceURL=webpack://vim/./src/common/matching/tagMatcher.ts?")},"./src/common/motion/cursor.ts":(__unused_webpack_module,exports)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.Cursor = void 0;\nclass Cursor {\n    constructor(start, stop) {\n        this.start = start;\n        this.stop = stop;\n    }\n    isValid(textEditor) {\n        return this.start.isValid(textEditor) && this.stop.isValid(textEditor);\n    }\n    /**\n     * Create a Cursor from a VSCode selection.\n     */\n    static FromVSCodeSelection(sel) {\n        return new Cursor(sel.start, sel.end);\n    }\n    equals(other) {\n        return this.start.isEqual(other.start) && this.stop.isEqual(other.stop);\n    }\n    /**\n     * Returns a new Cursor which is the same as this Cursor, but with the provided stop value.\n     */\n    withNewStop(stop) {\n        return new Cursor(this.start, stop);\n    }\n    /**\n     * Returns a new Cursor which is the same as this Cursor, but with the provided start value.\n     */\n    withNewStart(start) {\n        return new Cursor(start, this.stop);\n    }\n    toString() {\n        return `[${this.start.toString()} | ${this.stop.toString()}]`;\n    }\n}\nexports.Cursor = Cursor;\n\n\n//# sourceURL=webpack://vim/./src/common/motion/cursor.ts?')},"./src/common/motion/position.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.sorted = exports.laterOf = exports.earlierOf = exports.PositionDiff = void 0;\nconst vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));\nconst configuration_1 = __webpack_require__(/*! ./../../configuration/configuration */ "./src/configuration/configuration.ts");\nconst textEditor_1 = __webpack_require__(/*! ./../../textEditor */ "./src/textEditor.ts");\nconst util_1 = __webpack_require__(/*! ../../util/util */ "./src/util/util.ts");\nconst sentence_1 = __webpack_require__(/*! ../../textobject/sentence */ "./src/textobject/sentence.ts");\nconst word_1 = __webpack_require__(/*! ../../textobject/word */ "./src/textobject/word.ts");\nconst vscode_1 = __webpack_require__(/*! vscode */ "vscode");\n/**\n * Controls how a PositionDiff affects the Position it\'s applied to.\n */\nvar PositionDiffType;\n(function (PositionDiffType) {\n    /** Sets both the line and character exactly */\n    PositionDiffType[PositionDiffType["ExactPosition"] = 0] = "ExactPosition";\n    /** Offsets both the line and character */\n    PositionDiffType[PositionDiffType["Offset"] = 1] = "Offset";\n    /** Offsets the line and sets the column exactly */\n    PositionDiffType[PositionDiffType["ExactCharacter"] = 2] = "ExactCharacter";\n    /** Brings the Position to the beginning of the line if `vim.startofline` is true */\n    PositionDiffType[PositionDiffType["ObeyStartOfLine"] = 3] = "ObeyStartOfLine";\n    /** Brings the Position to the end of the line */\n    PositionDiffType[PositionDiffType["EndOfLine"] = 4] = "EndOfLine";\n})(PositionDiffType || (PositionDiffType = {}));\n/**\n * Represents a difference between two Positions.\n * Add it to a Position to get another Position.\n */\nclass PositionDiff {\n    constructor(type, line, character) {\n        this.type = type;\n        this.line = line;\n        this.character = character;\n    }\n    /** Has no effect */\n    static identity() {\n        return PositionDiff.offset({ line: 0, character: 0 });\n    }\n    /** Offsets both the Position\'s line and character */\n    static offset({ line = 0, character = 0 }) {\n        return new PositionDiff(PositionDiffType.Offset, line, character);\n    }\n    /** Sets the Position\'s line and character exactly */\n    static exactPosition(position) {\n        return new PositionDiff(PositionDiffType.ExactPosition, position.line, position.character);\n    }\n    /** Brings the Position to the beginning of the line if `vim.startofline` is true */\n    static startOfLine() {\n        return new PositionDiff(PositionDiffType.ObeyStartOfLine, 0, 0);\n    }\n    /** Brings the Position to the end of the line */\n    static endOfLine() {\n        return new PositionDiff(PositionDiffType.EndOfLine, 0, 0);\n    }\n    /** Offsets the Position\'s line and sets its character exactly */\n    static exactCharacter({ lineOffset, character, }) {\n        return new PositionDiff(PositionDiffType.ExactCharacter, lineOffset ?? 0, character);\n    }\n    toString() {\n        switch (this.type) {\n            case PositionDiffType.Offset:\n                return `[ Diff: Offset ${this.line} ${this.character} ]`;\n            case PositionDiffType.ExactCharacter:\n                return `[ Diff: ExactCharacter ${this.line} ${this.character} ]`;\n            case PositionDiffType.ExactPosition:\n                return `[ Diff: ExactPosition ${this.line} ${this.character} ]`;\n            case PositionDiffType.ObeyStartOfLine:\n                return `[ Diff: ObeyStartOfLine ${this.line} ]`;\n            case PositionDiffType.EndOfLine:\n                return `[ Diff: EndOfLine ${this.line} ]`;\n            default:\n                const guard = this.type;\n                throw new Error(`Unknown PositionDiffType: ${this.type}`);\n        }\n    }\n}\nexports.PositionDiff = PositionDiff;\n/**\n * @returns the Position of the 2 provided which comes earlier in the document.\n */\nfunction earlierOf(p1, p2) {\n    return p1.isBefore(p2) ? p1 : p2;\n}\nexports.earlierOf = earlierOf;\n/**\n * @returns the Position of the 2 provided which comes later in the document.\n */\nfunction laterOf(p1, p2) {\n    return p1.isBefore(p2) ? p2 : p1;\n}\nexports.laterOf = laterOf;\n/**\n * @returns the given Positions in the order they appear in the document.\n */\nfunction sorted(p1, p2) {\n    return p1.isBefore(p2) ? [p1, p2] : [p2, p1];\n}\nexports.sorted = sorted;\nvscode_1.Position.prototype.toString = function () {\n    return `[${this.line}, ${this.character}]`;\n};\nvscode_1.Position.prototype.add = function (document, diff, boundsCheck = true) {\n    if (diff.type === PositionDiffType.ExactPosition) {\n        return new vscode_1.Position(diff.line, diff.character);\n    }\n    const resultLine = (0, util_1.clamp)(this.line + diff.line, 0, document.lineCount - 1);\n    let resultChar;\n    if (diff.type === PositionDiffType.Offset) {\n        resultChar = this.character + diff.character;\n    }\n    else if (diff.type === PositionDiffType.ExactCharacter) {\n        resultChar = diff.character;\n    }\n    else if (diff.type === PositionDiffType.ObeyStartOfLine) {\n        resultChar = this.obeyStartOfLine(document).character;\n    }\n    else if (diff.type === PositionDiffType.EndOfLine) {\n        resultChar = this.getLineEnd().character;\n    }\n    else {\n        throw new Error(`Unknown PositionDiffType: ${diff.type}`);\n    }\n    const pos = new vscode_1.Position(resultLine, Math.max(resultChar, 0));\n    return boundsCheck ? document.validatePosition(pos) : pos;\n};\nvscode_1.Position.prototype.subtract = function (other) {\n    return PositionDiff.offset({\n        line: this.line - other.line,\n        character: this.character - other.character,\n    });\n};\n/**\n * @returns a new Position with the same line and the given character.\n * Does bounds-checking to make sure the result is valid.\n */\nvscode_1.Position.prototype.withColumn = function (column) {\n    column = (0, util_1.clamp)(column, 0, textEditor_1.TextEditor.getLineLength(this.line));\n    return new vscode_1.Position(this.line, column);\n};\n/**\n * @returns the Position `count` characters to the left of this Position. Does not go over line breaks.\n */\nvscode_1.Position.prototype.getLeft = function (count = 1) {\n    return new vscode_1.Position(this.line, Math.max(this.character - count, 0));\n};\n/**\n * @returns the Position `count` characters to the right of this Position. Does not go over line breaks.\n */\nvscode_1.Position.prototype.getRight = function (count = 1) {\n    return new vscode_1.Position(this.line, Math.min(this.character + count, textEditor_1.TextEditor.getLineLength(this.line)));\n};\n/**\n * @returns the Position `count` lines down from this Position\n */\nvscode_1.Position.prototype.getDown = function (count = 1) {\n    if (vscode.window.activeTextEditor) {\n        const line = Math.min(this.line + count, textEditor_1.TextEditor.getLineCount() - 1);\n        return new vscode_1.Position(line, Math.min(this.character, textEditor_1.TextEditor.getLineLength(line)));\n    }\n    else {\n        return this.translate({ lineDelta: count });\n    }\n};\n/**\n * @returns the Position `count` lines up from this Position\n */\nvscode_1.Position.prototype.getUp = function (count = 1) {\n    const line = Math.max(this.line - count, 0);\n    return new vscode_1.Position(line, Math.min(this.character, textEditor_1.TextEditor.getLineLength(line)));\n};\n/**\n * Same as getLeft, but goes up to the previous line on line breaks.\n * Equivalent to left arrow (in a non-vim editor!)\n */\nvscode_1.Position.prototype.getLeftThroughLineBreaks = function (includeEol = true) {\n    if (!this.isLineBeginning()) {\n        return this.getLeft();\n    }\n    // First char on first line, can not go left any more\n    if (this.line === 0) {\n        return this;\n    }\n    if (includeEol) {\n        return this.getUp().getLineEnd();\n    }\n    else {\n        return this.getUp().getLineEnd().getLeft();\n    }\n};\nvscode_1.Position.prototype.getRightThroughLineBreaks = function (includeEol = false) {\n    if (this.isAtDocumentEnd()) {\n        return this;\n    }\n    if (this.line < textEditor_1.TextEditor.getLineCount() - 1) {\n        const pos = includeEol ? this : this.getRight();\n        if (pos.isLineEnd()) {\n            return this.with({ character: 0 }).getDown();\n        }\n    }\n    else if (!includeEol && this.character === textEditor_1.TextEditor.getLineLength(this.line) - 1) {\n        // Last character of document, don\'t go on to non-existent EOL\n        return this;\n    }\n    return this.getRight();\n};\nvscode_1.Position.prototype.getOffsetThroughLineBreaks = function (offset) {\n    let pos = new vscode_1.Position(this.line, this.character);\n    if (offset < 0) {\n        for (let i = 0; i < -offset; i++) {\n            pos = pos.getLeftThroughLineBreaks();\n        }\n    }\n    else {\n        for (let i = 0; i < offset; i++) {\n            pos = pos.getRightThroughLineBreaks();\n        }\n    }\n    return pos;\n};\nvscode_1.Position.prototype.prevWordStart = function (document, args) {\n    return (0, word_1.prevWordStart)(document, this, args?.wordType ?? word_1.WordType.Normal, args?.inclusive ?? false);\n};\nvscode_1.Position.prototype.nextWordStart = function (document, args) {\n    return (0, word_1.nextWordStart)(document, this, args?.wordType ?? word_1.WordType.Normal, args?.inclusive ?? false);\n};\nvscode_1.Position.prototype.prevWordEnd = function (document, args) {\n    return (0, word_1.prevWordEnd)(document, this, args?.wordType ?? word_1.WordType.Normal);\n};\nvscode_1.Position.prototype.nextWordEnd = function (document, args) {\n    return (0, word_1.nextWordEnd)(document, this, args?.wordType ?? word_1.WordType.Normal, args?.inclusive ?? false);\n};\nvscode_1.Position.prototype.getSentenceBegin = function (args) {\n    return (0, sentence_1.getSentenceBegin)(this, args);\n};\nvscode_1.Position.prototype.getSentenceEnd = function () {\n    return (0, sentence_1.getSentenceEnd)(this);\n};\n/**\n * @returns a new Position at the beginning of the current line.\n */\nvscode_1.Position.prototype.getLineBegin = function () {\n    return new vscode_1.Position(this.line, 0);\n};\n/**\n * @returns the beginning of the line, excluding preceeding whitespace.\n * This respects the `autoindent` setting, and returns `getLineBegin()` if auto-indent is disabled.\n */\nvscode_1.Position.prototype.getLineBeginRespectingIndent = function (document) {\n    if (!configuration_1.configuration.autoindent) {\n        return this.getLineBegin();\n    }\n    return textEditor_1.TextEditor.getFirstNonWhitespaceCharOnLine(document, this.line);\n};\n/**\n * @returns a new Position at the end of this position\'s line.\n */\nvscode_1.Position.prototype.getLineEnd = function () {\n    return new vscode_1.Position(this.line, textEditor_1.TextEditor.getLineLength(this.line));\n};\n/**\n * @returns a new Position at the end of this Position\'s line, including the invisible newline character.\n */\nvscode_1.Position.prototype.getLineEndIncludingEOL = function () {\n    // TODO: isn\'t this one too far?\n    return new vscode_1.Position(this.line, textEditor_1.TextEditor.getLineLength(this.line) + 1);\n};\n/**\n * @returns a new Position one to the left if this Position is on the EOL. Otherwise, returns this position.\n */\nvscode_1.Position.prototype.getLeftIfEOL = function () {\n    return this.character === textEditor_1.TextEditor.getLineLength(this.line) ? this.getLeft() : this;\n};\n/**\n * @returns the position that the cursor would be at if you pasted *text* at the current position.\n */\nvscode_1.Position.prototype.advancePositionByText = function (text) {\n    const newlines = [];\n    let idx = text.indexOf(\'\\n\', 0);\n    while (idx >= 0) {\n        newlines.push(idx);\n        idx = text.indexOf(\'\\n\', idx + 1);\n    }\n    if (newlines.length === 0) {\n        return new vscode_1.Position(this.line, this.character + text.length);\n    }\n    else {\n        return new vscode_1.Position(this.line + newlines.length, text.length - (newlines[newlines.length - 1] + 1));\n    }\n};\n/**\n * Is this position at the beginning of the line?\n */\nvscode_1.Position.prototype.isLineBeginning = function () {\n    return this.character === 0;\n};\n/**\n * Is this position at the end of the line?\n */\nvscode_1.Position.prototype.isLineEnd = function () {\n    return this.character >= textEditor_1.TextEditor.getLineLength(this.line);\n};\nvscode_1.Position.prototype.isFirstWordOfLine = function (document) {\n    return (textEditor_1.TextEditor.getFirstNonWhitespaceCharOnLine(document, this.line).character === this.character);\n};\nvscode_1.Position.prototype.isAtDocumentBegin = function () {\n    return this.line === 0 && this.isLineBeginning();\n};\nvscode_1.Position.prototype.isAtDocumentEnd = function () {\n    return this.line === textEditor_1.TextEditor.getLineCount() - 1 && this.isLineEnd();\n};\n/**\n * Returns whether the current position is in the leading whitespace of a line\n * @param allowEmpty : Use true if "" is valid\n */\nvscode_1.Position.prototype.isInLeadingWhitespace = function (document) {\n    return /^\\s+$/.test(document.getText(new vscode.Range(this.getLineBegin(), this)));\n};\n/**\n * If `vim.startofline` is set, get first non-blank character\'s position.\n */\nvscode_1.Position.prototype.obeyStartOfLine = function (document) {\n    return configuration_1.configuration.startofline\n        ? textEditor_1.TextEditor.getFirstNonWhitespaceCharOnLine(document, this.line)\n        : this;\n};\nvscode_1.Position.prototype.isValid = function (textEditor) {\n    try {\n        // line\n        // TODO: this `|| 1` seems dubious...\n        const lineCount = textEditor_1.TextEditor.getLineCount(textEditor) || 1;\n        if (this.line >= lineCount) {\n            return false;\n        }\n        // char\n        const charCount = textEditor_1.TextEditor.getLineLength(this.line);\n        if (this.character > charCount + 1) {\n            return false;\n        }\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n};\n\n\n//# sourceURL=webpack://vim/./src/common/motion/position.ts?')},"./src/common/number/numericString.ts":(__unused_webpack_module,exports)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NumericString = exports.NumericStringRadix = void 0;\n/**\n *      aaaa0x111bbbbbb\n *      |-------------| => NumericString\n *      |--|            => prefix\n *          |---|       => core\n *               |----| => suffix\n *          ||          => numPrefix\n *            |-|       => num\n *\n * Greedy matching, leftmost match wins.\n * If multiple matches begin at the same position, the match with the biggest\n *   span wins.\n * If multiple matches have the same begin position and span (This usually\n *   happens on octal and decimal), following priority sequence is used:\n *   (decimal => octal => hexadecimal)\n *\n * Example:\n *                    |  core  |     What we got      |     Rather than     |\n *  ------------------|--------|----------------------|---------------------|\n *  Leftmost rule:    | 010xff |    (010)xff [octal]  |    01(0xff) [hex]   |\n *  Biggest span rule:| 0xff   |     (0xff) [hex]     |   (0)xff [decimal]  |\n *  Priority rule:    | 00007  |    (00007) [octal]   |  (00007) [decimal]  |\n *\n * Side Effect:\n *  -0xf  Will be parsed as (-0)xf rather than -(0xf), current workaround is\n *          capturing '-' in hexadecimal regex but not consider '-' as a part\n *          of the number. This is achieved by using `negative` boolean value\n *          in `NumericString`.\n */\nvar NumericStringRadix;\n(function (NumericStringRadix) {\n    NumericStringRadix[NumericStringRadix[\"Oct\"] = 8] = \"Oct\";\n    NumericStringRadix[NumericStringRadix[\"Dec\"] = 10] = \"Dec\";\n    NumericStringRadix[NumericStringRadix[\"Hex\"] = 16] = \"Hex\";\n})(NumericStringRadix || (exports.NumericStringRadix = NumericStringRadix = {}));\nclass NumericString {\n    // Return parse result and offset of suffix\n    static parse(input, targetRadix) {\n        const filteredMatchings = targetRadix !== undefined\n            ? NumericString.matchings.filter((matching) => matching.radix === targetRadix)\n            : NumericString.matchings;\n        // Find core numeric part of input\n        let coreBegin = -1;\n        let coreLength = -1;\n        let coreRadix = -1;\n        let coreSign = false;\n        for (const { regex, radix } of filteredMatchings) {\n            const match = regex.exec(input);\n            if (match != null) {\n                // Get the leftmost and largest match\n                if (coreRadix < 0 ||\n                    match.index < coreBegin ||\n                    (match.index === coreBegin && match[0].length > coreLength)) {\n                    coreBegin = match.index;\n                    coreLength = match[0].length;\n                    coreRadix = radix;\n                    coreSign = match[1] === '-';\n                }\n            }\n        }\n        if (coreRadix < 0) {\n            return undefined;\n        }\n        const coreEnd = coreBegin + coreLength;\n        const prefix = input.slice(0, coreBegin);\n        const core = input.slice(coreBegin, coreEnd);\n        const suffix = input.slice(coreEnd, input.length);\n        let value = parseInt(core, coreRadix);\n        // 0x00ff:  numLength = 4\n        // 077:     numLength = 2\n        // -0999:   numLength = 3\n        // The numLength is only useful for parsing non-decimal. Decimal with\n        // leading zero will be trimmed in `toString()`. If value is negative,\n        // remove the width of negative sign.\n        const numLength = coreLength - NumericString.numPrefix[coreRadix].length - (coreSign ? 1 : 0);\n        // According to original vim's behavior, for hex and octal, the leading\n        // '-' *should* be captured and preserved but *should not* be regarded as\n        // part of number, which means with <C-a>, `-0xf` turns into `-0x10`. So\n        // for hex and octal, we make the value absolute and set the negative\n        // sign flag.\n        let negative = false;\n        if (coreRadix !== 10 && coreSign) {\n            value = -value;\n            negative = true;\n        }\n        let isCapital = false;\n        if (coreRadix === 16) {\n            for (const c of Array.from(input).reverse()) {\n                if ('A' <= c && c <= 'F') {\n                    isCapital = true;\n                    break;\n                }\n                else if ('a' <= c && c <= 'f') {\n                    isCapital = false;\n                    break;\n                }\n            }\n        }\n        return {\n            num: new NumericString(value, coreRadix, numLength, prefix, suffix, negative, isCapital),\n            suffixOffset: coreEnd,\n        };\n    }\n    constructor(value, radix, numLength, prefix, suffix, negative, isCapital) {\n        this.value = value;\n        this.radix = radix;\n        this.numLength = numLength;\n        this.prefix = prefix;\n        this.suffix = suffix;\n        this.negative = negative;\n        this.isCapital = isCapital;\n    }\n    toString() {\n        // For decreased octal and hexadecimal\n        if (this.radix !== 10) {\n            const max = 0xffffffff;\n            while (this.value < 0) {\n                this.value = max + this.value + 1;\n            }\n        }\n        // Gen num part\n        const absValue = Math.abs(this.value);\n        let num = absValue.toString(this.radix);\n        if (this.isCapital) {\n            num = num.toUpperCase();\n        }\n        // numLength of decimal *should not* be preserved.\n        if (this.radix !== 10) {\n            const diff = this.numLength - num.length;\n            if (diff > 0) {\n                // Preserve num length if it's narrower.\n                num = '0'.repeat(diff) + num;\n            }\n        }\n        const sign = this.negative || this.value < 0 ? '-' : '';\n        const core = sign + NumericString.numPrefix[this.radix] + num;\n        return this.prefix + core + this.suffix;\n    }\n}\nexports.NumericString = NumericString;\n// Map radix to number prefix\nNumericString.numPrefix = {\n    [NumericStringRadix.Oct]: '0',\n    [NumericStringRadix.Dec]: '',\n    [NumericStringRadix.Hex]: '0x',\n};\n// Keep octal at the top of decimal to avoid regarding 0000007 as decimal.\n// '000009' matches decimal.\n// '000007' matches octal.\n// '-0xf' matches hex rather than decimal '-0'\nNumericString.matchings = [\n    { regex: /(-)?0[0-7]+/, radix: NumericStringRadix.Oct },\n    { regex: /(-)?\\d+/, radix: NumericStringRadix.Dec },\n    { regex: /(-)?0x[\\da-fA-F]+/, radix: NumericStringRadix.Hex },\n];\n\n\n//# sourceURL=webpack://vim/./src/common/number/numericString.ts?")},"./src/completion/lineCompletionProvider.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.lineCompletionProvider = exports.getCompletionsForCurrentLine = void 0;\nconst vscode = __importStar(__webpack_require__(/*! vscode */ \"vscode\"));\nconst textEditor_1 = __webpack_require__(/*! ./../textEditor */ \"./src/textEditor.ts\");\n/**\n * Return open text documents, with a given file at the top of the list.\n * @param startingFileName File that will be first in the array, typically current file\n */\nconst documentsStartingWith = (startingFileName) => {\n    return [...vscode.workspace.textDocuments].sort((a, b) => {\n        if (a.fileName === startingFileName) {\n            return -1;\n        }\n        else if (b.fileName === startingFileName) {\n            return 1;\n        }\n        return 0;\n    });\n};\n/**\n * Get lines, with leading tabs or whitespace stripped.\n * @param document Document to get lines from.\n * @param lineToStartScanFrom Where to start looking for matches first. Closest matches are sorted first.\n * @param scanAboveFirst Whether to start scan above or below cursor. Other direction is scanned last.\n * @returns\n */\nconst linesWithoutIndentation = (document, lineToStartScanFrom, scanAboveFirst) => {\n    const distanceFromStartLine = (line) => {\n        let sortPriority = scanAboveFirst ? lineToStartScanFrom - line : line - lineToStartScanFrom;\n        if (sortPriority < 0) {\n            // We prioritized any items in the main direction searched,\n            // but now find closest items in opposite direction.\n            sortPriority = lineToStartScanFrom + Math.abs(sortPriority);\n        }\n        return sortPriority;\n    };\n    return document\n        .getText()\n        .split('\\n')\n        .map((text, line) => ({\n        sortPriority: distanceFromStartLine(line),\n        text: text.replace(/^[ \\t]*/, ''),\n    }))\n        .sort((a, b) => (a.sortPriority > b.sortPriority ? 1 : -1));\n};\n/**\n * Get all completions that match given text within open documents.\n * @example\n * a1\n * a2\n * a| // <--- Perform line completion here\n * a3\n * a4\n * // Returns: ['a2', 'a1', 'a3', 'a4']\n * @param text Text to partially match. Indentation is stripped.\n * @param currentFileName Current file, which is prioritized in sorting.\n * @param currentPosition Current position, which is prioritized when sorting for current file.\n */\nconst getCompletionsForText = (text, currentFileName, currentPosition) => {\n    const matchedLines = [];\n    for (const document of documentsStartingWith(currentFileName)) {\n        let lineToStartScanFrom = 0;\n        let scanAboveFirst = false;\n        if (document.fileName === currentFileName) {\n            lineToStartScanFrom = currentPosition.line;\n            scanAboveFirst = true;\n        }\n        for (const line of linesWithoutIndentation(document, lineToStartScanFrom, scanAboveFirst)) {\n            if (!matchedLines.includes(line.text) &&\n                line.text &&\n                line.text.startsWith(text) &&\n                line.text !== text) {\n                matchedLines.push(line.text);\n            }\n        }\n    }\n    return matchedLines;\n};\n/**\n * Get all completions that match given text within open documents.\n * Results are sorted in a few ways:\n * 1) The current document is prioritized over other open documents.\n * 2) For the current document, lines above the current cursor are always prioritized over lines below it.\n * 3) For the current document, lines are also prioritized based on distance from cursor.\n * 4) For other documents, lines are prioritized based on distance from the top.\n * @example\n * a1\n * a2\n * a| // <--- Perform line completion here\n * a3\n * a4\n * // Returns: ['a2', 'a1', 'a3', 'a4']\n * @param position Position to start scan from\n * @param document Document to start scanning from, starting at the position (other open documents are scanned from top)\n */\nconst getCompletionsForCurrentLine = (position, document) => {\n    const currentLineText = document.getText(new vscode.Range(textEditor_1.TextEditor.getFirstNonWhitespaceCharOnLine(document, position.line), position));\n    return getCompletionsForText(currentLineText, document.fileName, position);\n};\nexports.getCompletionsForCurrentLine = getCompletionsForCurrentLine;\nexports.lineCompletionProvider = {\n    /**\n     * Get all completions that match given text within open documents.\n     * Results are sorted by priority.\n     * @see getCompletionsForCurrentLine\n     *\n     * Any trailing characters are stripped. Trailing characters are often\n     * from auto-close, such as when importing in JavaScript ES6 and typing a\n     * curly brace. So the trailing characters are removed on purpose.\n     *\n     * Modifies vimState, adding transformations that replaces the\n     * current line's text with the chosen completion, with proper indentation.\n     *\n     * Here we use Quick Pick, instead of registerCompletionItemProvider\n     * Originally I looked at using a standard completion dropdown using that method,\n     * but it doesn't allow you to limit completions, and it became overwhelming\n     * when e.g. trying to do a line completion when the cursor is positioned after\n     * a space character (such that it shows almost any symbol in the list).\n     * Quick Pick also allows for searching, which is a nice bonus.\n     */\n    showLineCompletionsQuickPick: async (position, vimState) => {\n        const completions = (0, exports.getCompletionsForCurrentLine)(position, vimState.document);\n        if (!completions) {\n            return;\n        }\n        const selectedCompletion = await vscode.window.showQuickPick(completions);\n        if (!selectedCompletion) {\n            return;\n        }\n        vimState.recordedState.transformer.delete(new vscode.Range(textEditor_1.TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, position.line), position.getLineEnd()));\n        vimState.recordedState.transformer.addTransformation({\n            type: 'insertTextVSCode',\n            text: selectedCompletion,\n        });\n    },\n};\n\n\n//# sourceURL=webpack://vim/./src/completion/lineCompletionProvider.ts?")},"./src/configuration/configuration.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.configuration = exports.optionAliases = exports.extensionVersion = void 0;\nconst process = __importStar(__webpack_require__(/*! process */ \"./node_modules/process/browser.js\"));\nconst vscode = __importStar(__webpack_require__(/*! vscode */ \"vscode\"));\nconst globals_1 = __webpack_require__(/*! ../globals */ \"./src/globals.ts\");\nconst vscodeContext_1 = __webpack_require__(/*! ../util/vscodeContext */ \"./src/util/vscodeContext.ts\");\nconst configurationValidator_1 = __webpack_require__(/*! ./configurationValidator */ \"./src/configuration/configurationValidator.ts\");\nconst decoration_1 = __webpack_require__(/*! ./decoration */ \"./src/configuration/decoration.ts\");\nconst notation_1 = __webpack_require__(/*! ./notation */ \"./src/configuration/notation.ts\");\nconst constants_1 = __webpack_require__(/*! platform/constants */ \"./src/platform/browser/constants.ts\");\nconst packagejson = __importStar(__webpack_require__(/*! ../../package.json */ \"./package.json\"));\nexports.extensionVersion = packagejson.version;\n/**\n * Most options supported by Vim have a short alias. They are provided here.\n * Please keep this list up to date and sorted alphabetically.\n */\nexports.optionAliases = new Map([\n    ['ai', 'autoindent'],\n    ['et', 'expandtab'],\n    ['gd', 'gdefault'],\n    ['hi', 'history'],\n    ['hls', 'hlsearch'],\n    ['ic', 'ignorecase'],\n    ['icm', 'inccommand'],\n    ['is', 'incsearch'],\n    ['isk', 'iskeyword'],\n    ['js', 'joinspaces'],\n    ['mmd', 'maxmapdepth'],\n    ['mps', 'matchpairs'],\n    ['nu', 'number'],\n    ['rnu', 'relativenumber'],\n    ['sc', 'showcmd'],\n    ['scr', 'scroll'],\n    ['so', 'scrolloff'],\n    ['scs', 'smartcase'],\n    ['smd', 'showmode'],\n    ['sol', 'startofline'],\n    ['to', 'timeout'],\n    ['ts', 'tabstop'],\n    ['tw', 'textwidth'],\n    ['ws', 'wrapscan'],\n    ['ww', 'whichwrap'],\n]);\n/**\n * Every Vim option we support should\n * 1. Be added to contribution section of `package.json`.\n * 2. Named as `vim.{optionName}`, `optionName` is the name we use in Vim.\n * 3. Define a public property in `Configuration` with the same name and a default value.\n *    Or define a private property and define customized Getter/Setter accessors for it.\n *    Always remember to decorate Getter accessor as @enumerable()\n * 4. If user doesn't set the option explicitly\n *    a. we don't have a similar setting in Code, initialize the option as default value.\n *    b. we have a similar setting in Code, use Code's setting.\n *\n * Vim option override sequence.\n * 1. `:set {option}` on the fly\n * 2. `vim.{option}`\n * 3. VS Code configuration\n * 4. VSCodeVim configuration default values\n *\n */\nclass Configuration {\n    constructor() {\n        this.leaderDefault = '\\\\';\n        this.cursorTypeMap = {\n            line: vscode.TextEditorCursorStyle.Line,\n            block: vscode.TextEditorCursorStyle.Block,\n            underline: vscode.TextEditorCursorStyle.Underline,\n            'line-thin': vscode.TextEditorCursorStyle.LineThin,\n            'block-outline': vscode.TextEditorCursorStyle.BlockOutline,\n            'underline-thin': vscode.TextEditorCursorStyle.UnderlineThin,\n        };\n        this.handleKeys = {};\n        this.useSystemClipboard = false;\n        this.shell = '';\n        this.useCtrlKeys = false;\n        this.overrideCopy = true;\n        this.hlsearch = false;\n        this.ignorecase = true;\n        this.smartcase = true;\n        this.autoindent = true;\n        this.matchpairs = '(:),{:},[:]';\n        this.joinspaces = true;\n        this.camelCaseMotion = {\n            enable: true,\n        };\n        this.replaceWithRegister = false;\n        this.smartRelativeLine = false;\n        this.sneak = false;\n        this.sneakUseIgnorecaseAndSmartcase = false;\n        this.sneakReplacesF = false;\n        this.surround = true;\n        this.argumentObjectSeparators = [','];\n        this.argumentObjectOpeningDelimiters = ['(', '['];\n        this.argumentObjectClosingDelimiters = [')', ']'];\n        this.easymotion = false;\n        this.easymotionMarkerBackgroundColor = '#0000';\n        this.easymotionMarkerForegroundColorOneChar = '#ff0000';\n        this.easymotionMarkerForegroundColorTwoCharFirst = '#ffb400';\n        this.easymotionMarkerForegroundColorTwoCharSecond = '#b98300';\n        this.easymotionIncSearchForegroundColor = '#7fbf00';\n        this.easymotionDimColor = '#777777';\n        this.easymotionDimBackground = true;\n        this.easymotionMarkerFontWeight = 'bold';\n        this.easymotionKeys = 'hklyuiopnm,qwertzxcvbasdgjf;';\n        this.easymotionJumpToAnywhereRegex = '\\\\b[A-Za-z0-9]|[A-Za-z0-9]\\\\b|_.|#.|[a-z][A-Z]';\n        this.targets = {\n            enable: false,\n            bracketObjects: {\n                enable: true,\n            },\n            smartQuotes: {\n                enable: false,\n                breakThroughLines: false,\n                aIncludesSurroundingSpaces: true,\n            },\n        };\n        this.autoSwitchInputMethod = {\n            enable: false,\n            defaultIM: '',\n            obtainIMCmd: '',\n            switchIMCmd: '',\n        };\n        this.timeout = 1000;\n        this.maxmapdepth = 1000;\n        this.showcmd = true;\n        this.showmodename = true;\n        this.leader = this.leaderDefault;\n        this.history = 50;\n        this.inccommand = '';\n        this.incsearch = true;\n        this.startInInsertMode = false;\n        this.statusBarColorControl = false;\n        this.statusBarColors = {\n            normal: ['#005f5f', '#ffffff'],\n            insert: ['#5f0000', '#ffffff'],\n            visual: ['#5f00af', '#ffffff'],\n            visualline: ['#005f87', '#ffffff'],\n            visualblock: ['#86592d', '#ffffff'],\n            replace: ['#000000', '#ffffff'],\n        };\n        this.searchHighlightColor = '';\n        this.searchHighlightTextColor = '';\n        this.searchMatchColor = '';\n        this.searchMatchTextColor = '';\n        this.substitutionColor = '#50f01080';\n        this.substitutionTextColor = '';\n        this.highlightedyank = {\n            enable: false,\n            color: 'rgba(250, 240, 170, 0.5)',\n            textColor: '',\n            duration: 200,\n        };\n        this.boundKeyCombinations = [];\n        this.visualstar = false;\n        this.mouseSelectionGoesIntoVisualMode = true;\n        this.changeWordIncludesWhitespace = false;\n        this.foldfix = false;\n        this.disableExtension = false;\n        this.enableNeovim = false;\n        this.neovimPath = '';\n        this.neovimUseConfigFile = false;\n        this.neovimConfigPath = '';\n        this.vimrc = {\n            enable: false,\n            path: '',\n        };\n        this.digraphs = {};\n        this.gdefault = false;\n        this.substituteGlobalFlag = false; // Deprecated in favor of gdefault\n        this.whichwrap = 'b,s';\n        this.startofline = true;\n        this.showMarksInGutter = false;\n        this.report = 2;\n        this.wrapscan = true;\n        this.scroll = 0;\n        this.cursorStylePerMode = {\n            normal: undefined,\n            insert: undefined,\n            visual: undefined,\n            visualline: undefined,\n            visualblock: undefined,\n            replace: undefined,\n        };\n        // remappings\n        this.insertModeKeyBindings = [];\n        this.insertModeKeyBindingsNonRecursive = [];\n        this.normalModeKeyBindings = [];\n        this.normalModeKeyBindingsNonRecursive = [];\n        this.operatorPendingModeKeyBindings = [];\n        this.operatorPendingModeKeyBindingsNonRecursive = [];\n        this.visualModeKeyBindings = [];\n        this.visualModeKeyBindingsNonRecursive = [];\n        this.commandLineModeKeyBindings = [];\n        this.commandLineModeKeyBindingsNonRecursive = [];\n        this.insertModeKeyBindingsMap = new Map();\n        this.normalModeKeyBindingsMap = new Map();\n        this.operatorPendingModeKeyBindingsMap = new Map();\n        this.visualModeKeyBindingsMap = new Map();\n        this.commandLineModeKeyBindingsMap = new Map();\n    }\n    async load() {\n        const vimConfigs = globals_1.Globals.isTesting\n            ? globals_1.Globals.mockConfiguration\n            : this.getConfiguration('vim');\n        // eslint-disable-next-line guard-for-in\n        for (const option in this) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            let val = vimConfigs[option];\n            if (val !== null && val !== undefined) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                if (val.constructor.name === Object.name) {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                    val = Configuration.unproxify(val);\n                }\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                this[option] = val;\n            }\n        }\n        if (constants_1.SUPPORT_VIMRC && this.vimrc.enable) {\n            await Promise.resolve().then(() => __importStar(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module './vimrc'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())))).then((vimrcModel) => {\n                return vimrcModel.vimrc.load(this);\n            });\n        }\n        this.leader = notation_1.Notation.NormalizeKey(this.leader, this.leaderDefault);\n        this.clearKeyBindingsMaps();\n        const validatorResults = await configurationValidator_1.configurationValidator.validate(exports.configuration);\n        // read package.json for bound keys\n        // enable/disable certain key combinations\n        this.boundKeyCombinations = [];\n        for (const keybinding of packagejson.contributes.keybindings) {\n            if (keybinding.when.includes('listFocus')) {\n                continue;\n            }\n            if (keybinding.command.startsWith('notebook')) {\n                continue;\n            }\n            let key = keybinding.key;\n            if (process.platform === 'darwin') {\n                key = keybinding.mac || key;\n            }\n            else if (process.platform === 'linux') {\n                key = keybinding.linux || key;\n            }\n            this.boundKeyCombinations.push({\n                key: notation_1.Notation.NormalizeKey(key, this.leader),\n                command: keybinding.command,\n            });\n        }\n        // decorations\n        decoration_1.decoration.load(this);\n        for (const boundKey of this.boundKeyCombinations) {\n            // By default, all key combinations are used\n            let useKey = true;\n            const handleKey = this.handleKeys[boundKey.key];\n            if (handleKey !== undefined) {\n                // enabled/disabled through `vim.handleKeys`\n                useKey = handleKey;\n            }\n            else if (!this.useCtrlKeys && boundKey.key.slice(1, 3) === 'C-') {\n                // user has disabled CtrlKeys and the current key is a CtrlKey\n                // <C-c>, still needs to be captured to overrideCopy\n                if (boundKey.key === '<C-c>' && this.overrideCopy) {\n                    useKey = true;\n                }\n                else {\n                    useKey = false;\n                }\n            }\n            void vscodeContext_1.VSCodeContext.set(`vim.use${boundKey.key}`, useKey);\n        }\n        void vscodeContext_1.VSCodeContext.set('vim.overrideCopy', this.overrideCopy);\n        void vscodeContext_1.VSCodeContext.set('vim.overrideCtrlC', this.overrideCopy || this.useCtrlKeys);\n        return validatorResults;\n    }\n    getConfiguration(section = '') {\n        const document = vscode.window.activeTextEditor?.document;\n        const resource = document ? { uri: document.uri, languageId: document.languageId } : undefined;\n        return vscode.workspace.getConfiguration(section, resource);\n    }\n    cursorStyleFromString(cursorStyle) {\n        return this.cursorTypeMap[cursorStyle];\n    }\n    clearKeyBindingsMaps() {\n        // Clear the KeyBindingsMaps so that the previous configuration maps don't leak to this one\n        this.normalModeKeyBindingsMap = new Map();\n        this.insertModeKeyBindingsMap = new Map();\n        this.visualModeKeyBindingsMap = new Map();\n        this.commandLineModeKeyBindingsMap = new Map();\n        this.operatorPendingModeKeyBindingsMap = new Map();\n    }\n    get editorCursorStyle() {\n        return this.cursorStyleFromString(this.editorCursorStyleRaw);\n    }\n    set editorCursorStyle(val) {\n        // nop\n    }\n    getScrollLines(visibleRanges) {\n        return this.scroll === 0\n            ? Math.ceil((visibleRanges[0].end.line - visibleRanges[0].start.line) / 2)\n            : this.scroll;\n    }\n    getCursorStyleForMode(modeName) {\n        // TODO: this function should take the mode directly\n        const cursorStyle = this.cursorStylePerMode[modeName.toLowerCase()];\n        if (cursorStyle) {\n            return this.cursorStyleFromString(cursorStyle);\n        }\n        return;\n    }\n    get textwidth() {\n        const textwidth = this.getConfiguration('vim').get('textwidth', 80);\n        if (typeof textwidth !== 'number') {\n            return 80;\n        }\n        return textwidth;\n    }\n    static unproxify(obj) {\n        const result = {};\n        // eslint-disable-next-line guard-for-in\n        for (const key in obj) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const val = obj[key];\n            if (val !== null && val !== undefined) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                result[key] = val;\n            }\n        }\n        return result;\n    }\n}\n__decorate([\n    overlapSetting({ settingName: 'tabSize', defaultValue: 8 })\n], Configuration.prototype, \"tabstop\", void 0);\n__decorate([\n    overlapSetting({ settingName: 'cursorStyle', defaultValue: 'line' })\n], Configuration.prototype, \"editorCursorStyleRaw\", void 0);\n__decorate([\n    overlapSetting({ settingName: 'insertSpaces', defaultValue: false })\n], Configuration.prototype, \"expandtab\", void 0);\n__decorate([\n    overlapSetting({\n        settingName: 'lineNumbers',\n        defaultValue: true,\n        map: new Map([\n            ['on', true],\n            ['off', false],\n            ['relative', false],\n            ['interval', false],\n        ]),\n    })\n    // eslint-disable-next-line id-denylist\n], Configuration.prototype, \"number\", void 0);\n__decorate([\n    overlapSetting({\n        settingName: 'lineNumbers',\n        defaultValue: false,\n        map: new Map([\n            ['on', false],\n            ['off', false],\n            ['relative', true],\n            ['interval', false],\n        ]),\n    })\n], Configuration.prototype, \"relativenumber\", void 0);\n__decorate([\n    overlapSetting({\n        settingName: 'wordSeparators',\n        defaultValue: '/\\\\()\"\\':,.;<>~!@#$%^&*|+=[]{}`?-',\n    })\n], Configuration.prototype, \"iskeyword\", void 0);\n__decorate([\n    overlapSetting({\n        settingName: 'wordWrap',\n        defaultValue: false,\n        map: new Map([\n            ['on', true],\n            ['off', false],\n            ['wordWrapColumn', true],\n            ['bounded', true],\n        ]),\n    })\n], Configuration.prototype, \"wrap\", void 0);\n__decorate([\n    overlapSetting({\n        settingName: 'cursorSurroundingLines',\n        defaultValue: 0,\n    })\n], Configuration.prototype, \"scrolloff\", void 0);\n// handle mapped settings between vscode to vim\nfunction overlapSetting(args) {\n    return (target, propertyKey) => {\n        Object.defineProperty(target, propertyKey, {\n            get() {\n                // retrieve value from vim configuration\n                // if the value is not defined or empty\n                // look at the equivalent `editor` setting\n                // if that is not defined then defer to the default value\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n                let val = this['_' + propertyKey];\n                if (val !== undefined && val !== '') {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                    return val;\n                }\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n                val = this.getConfiguration('editor').get(args.settingName, args.defaultValue);\n                if (args.map && val !== undefined) {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                    val = args.map.get(val);\n                }\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                return val;\n            },\n            set(value) {\n                // synchronize the vim setting with the `editor` equivalent\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n                this['_' + propertyKey] = value;\n                if (value === undefined || value === '' || globals_1.Globals.isTesting) {\n                    return;\n                }\n                if (args.map) {\n                    for (const [vscodeSetting, vimSetting] of args.map.entries()) {\n                        if (value === vimSetting) {\n                            value = vscodeSetting;\n                            break;\n                        }\n                    }\n                }\n                // update configuration asynchronously\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n                this.getConfiguration('editor').update(args.settingName, value, vscode.ConfigurationTarget.Global);\n            },\n            enumerable: true,\n            configurable: true,\n        });\n    };\n}\nexports.configuration = new Configuration();\n\n\n//# sourceURL=webpack://vim/./src/configuration/configuration.ts?")},"./src/configuration/configurationValidator.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.configurationValidator = void 0;\nconst iconfigurationValidator_1 = __webpack_require__(/*! ./iconfigurationValidator */ "./src/configuration/iconfigurationValidator.ts");\nclass ConfigurationValidator {\n    constructor() {\n        this.validators = [];\n    }\n    registerValidator(validator) {\n        this.validators.push(validator);\n    }\n    async validate(config) {\n        const results = new iconfigurationValidator_1.ValidatorResults();\n        for (const validator of this.validators) {\n            const validatorResults = await validator.validate(config);\n            if (validatorResults.hasError) {\n                // errors found in configuration, disable feature\n                validator.disable(config);\n            }\n            results.concat(validatorResults);\n        }\n        return results;\n    }\n}\nexports.configurationValidator = new ConfigurationValidator();\n\n\n//# sourceURL=webpack://vim/./src/configuration/configurationValidator.ts?')},"./src/configuration/decoration.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decoration = void 0;\nconst vscode = __importStar(__webpack_require__(/*! vscode */ \"vscode\"));\nclass DecorationImpl {\n    constructor() {\n        this._markDecorationCache = new Map();\n        this.confirmedSubstitution = vscode.window.createTextEditorDecorationType({\n            letterSpacing: '-9999999px',\n            opacity: '0',\n        });\n    }\n    _createMarkDecoration(name) {\n        const svg = [\n            '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 30 30\" width=\"30px\" height=\"30px\">',\n            '<style>text { font-family: sans-serif; font-size: 0.8em; }</style>',\n            '<path fill=\"rgb(3,102,214)\" d=\"M23,27l-8-7l-8,7V5c0-1.105,0.895-2,2-2h12c1.105,0,2,0.895,2,2V27z\"/>',\n            `<text x=\"50%\" y=\"40%\" fill=\"rgb(200,200,200)\" text-anchor=\"middle\" dominant-baseline=\"middle\">${name}</text>`,\n            '</svg>',\n        ].join('');\n        const uri = vscode.Uri.parse(`data:image/svg+xml;utf8,${encodeURI(svg)}`, true);\n        return vscode.window.createTextEditorDecorationType({\n            isWholeLine: false,\n            gutterIconPath: uri,\n            gutterIconSize: 'cover',\n        });\n    }\n    set default(value) {\n        if (this._default) {\n            this._default.dispose();\n        }\n        this._default = value;\n    }\n    get default() {\n        return this._default;\n    }\n    set searchHighlight(value) {\n        if (this._searchHighlight) {\n            this._searchHighlight.dispose();\n        }\n        this._searchHighlight = value;\n    }\n    get searchHighlight() {\n        return this._searchHighlight;\n    }\n    set searchMatch(value) {\n        if (this._searchMatch) {\n            this._searchMatch.dispose();\n        }\n        this._searchMatch = value;\n    }\n    get searchMatch() {\n        return this._searchMatch;\n    }\n    set substitutionAppend(value) {\n        if (this._substitutionAppend) {\n            this._substitutionAppend.dispose();\n        }\n        this._substitutionAppend = value;\n    }\n    get substitutionAppend() {\n        return this._substitutionAppend;\n    }\n    set substitutionReplace(value) {\n        if (this._substitutionReplace) {\n            this._substitutionReplace.dispose();\n        }\n        this._substitutionReplace = value;\n    }\n    get substitutionReplace() {\n        return this._substitutionReplace;\n    }\n    get easyMotionIncSearch() {\n        return this._easyMotionIncSearch;\n    }\n    set easyMotionIncSearch(value) {\n        if (this._easyMotionIncSearch) {\n            this._easyMotionIncSearch.dispose();\n        }\n        this._easyMotionIncSearch = value;\n    }\n    get easyMotionDimIncSearch() {\n        return this._easyMotionDimIncSearch;\n    }\n    set easyMotionDimIncSearch(value) {\n        if (this._easyMotionDimIncSearch) {\n            this._easyMotionDimIncSearch.dispose();\n        }\n        this._easyMotionDimIncSearch = value;\n    }\n    getOrCreateMarkDecoration(name) {\n        const decorationType = this.getMarkDecoration(name);\n        if (decorationType) {\n            return decorationType;\n        }\n        else {\n            const type = this._createMarkDecoration(name);\n            this._markDecorationCache.set(name, type);\n            return type;\n        }\n    }\n    getMarkDecoration(name) {\n        return this._markDecorationCache.get(name);\n    }\n    allMarkDecorations() {\n        return this._markDecorationCache.values();\n    }\n    set insertModeVirtualCharacter(value) {\n        if (this._insertModeVirtualCharacter) {\n            this._insertModeVirtualCharacter.dispose();\n        }\n        this._insertModeVirtualCharacter = value;\n    }\n    get insertModeVirtualCharacter() {\n        return this._insertModeVirtualCharacter;\n    }\n    set operatorPendingModeCursor(value) {\n        if (this._operatorPendingModeCursor) {\n            this._operatorPendingModeCursor.dispose();\n        }\n        this._operatorPendingModeCursor = value;\n    }\n    get operatorPendingModeCursor() {\n        return this._operatorPendingModeCursor;\n    }\n    set operatorPendingModeCursorChar(value) {\n        if (this._operatorPendingModeCursorChar) {\n            this._operatorPendingModeCursorChar.dispose();\n        }\n        this._operatorPendingModeCursorChar = value;\n    }\n    get operatorPendingModeCursorChar() {\n        return this._operatorPendingModeCursorChar;\n    }\n    load(configuration) {\n        this.default = vscode.window.createTextEditorDecorationType({\n            backgroundColor: new vscode.ThemeColor('editorCursor.foreground'),\n            borderColor: new vscode.ThemeColor('editorCursor.foreground'),\n            dark: {\n                color: 'rgb(81,80,82)',\n            },\n            light: {\n                // used for light colored themes\n                color: 'rgb(255, 255, 255)',\n            },\n            borderStyle: 'solid',\n            borderWidth: '1px',\n        });\n        const searchHighlightBackgroundColor = configuration.searchHighlightColor\n            ? configuration.searchHighlightColor\n            : new vscode.ThemeColor('editor.findMatchHighlightBackground');\n        this.searchHighlight = vscode.window.createTextEditorDecorationType({\n            backgroundColor: searchHighlightBackgroundColor,\n            color: configuration.searchHighlightTextColor,\n            overviewRulerColor: new vscode.ThemeColor('editorOverviewRuler.findMatchForeground'),\n            after: {\n                color: 'transparent',\n                backgroundColor: searchHighlightBackgroundColor,\n            },\n            border: '1px solid',\n            borderColor: new vscode.ThemeColor('editor.findMatchHighlightBorder'),\n        });\n        const searchMatchBackgroundColor = configuration.searchMatchColor\n            ? configuration.searchMatchColor\n            : new vscode.ThemeColor('editor.findMatchBackground');\n        this.searchMatch = vscode.window.createTextEditorDecorationType({\n            backgroundColor: searchMatchBackgroundColor,\n            color: configuration.searchMatchTextColor,\n            overviewRulerColor: new vscode.ThemeColor('editorOverviewRuler.findMatchForeground'),\n            after: {\n                color: 'transparent',\n                backgroundColor: searchMatchBackgroundColor,\n            },\n            border: '2px solid',\n            borderColor: new vscode.ThemeColor('editor.findMatchBorder'),\n        });\n        const substitutionBackgroundColor = configuration.substitutionColor\n            ? configuration.substitutionColor\n            : new vscode.ThemeColor('editor.findMatchBackground');\n        this.substitutionAppend = vscode.window.createTextEditorDecorationType({\n            backgroundColor: searchHighlightBackgroundColor,\n            color: configuration.searchHighlightTextColor,\n            overviewRulerColor: new vscode.ThemeColor('editorOverviewRuler.findMatchForeground'),\n            after: {\n                color: configuration.substitutionTextColor,\n                backgroundColor: substitutionBackgroundColor,\n                border: '1px solid',\n                borderColor: new vscode.ThemeColor('editor.findMatchBorder'),\n            },\n            border: '1px dashed',\n            borderColor: new vscode.ThemeColor('editor.findMatchBorder'),\n        });\n        // Use letterSpacing and opacity to hide the decorated range, so that before text gets rendered over it\n        this.substitutionReplace = vscode.window.createTextEditorDecorationType({\n            letterSpacing: '-9999999px',\n            opacity: '0',\n            overviewRulerColor: new vscode.ThemeColor('editorOverviewRuler.findMatchForeground'),\n            before: {\n                color: configuration.substitutionTextColor,\n                backgroundColor: substitutionBackgroundColor,\n                border: '1px solid',\n                borderColor: new vscode.ThemeColor('editor.findMatchBorder'),\n            },\n        });\n        this.easyMotionIncSearch = vscode.window.createTextEditorDecorationType({\n            color: configuration.easymotionIncSearchForegroundColor,\n            fontWeight: configuration.easymotionMarkerFontWeight,\n        });\n        this.easyMotionDimIncSearch = vscode.window.createTextEditorDecorationType({\n            color: configuration.easymotionDimColor,\n        });\n        this.insertModeVirtualCharacter = vscode.window.createTextEditorDecorationType({\n            color: 'transparent', // no color to hide the existing character\n            before: {\n                color: 'currentColor',\n                backgroundColor: new vscode.ThemeColor('editor.background'),\n                borderColor: new vscode.ThemeColor('editor.background'),\n                margin: '0 -1ch 0 0',\n                height: '100%',\n            },\n        });\n        // This creates the half block cursor when on operator pending mode\n        this.operatorPendingModeCursor = vscode.window.createTextEditorDecorationType({\n            before: {\n                // no color to hide the existing character. We only need the character here to make\n                // the width be the same as the existing character.\n                color: 'transparent',\n                // The '-1ch' right margin is so that it displays on top of the existing character. The amount\n                // here doesn't really matter, it could be '-1px' it just needs to be negative so that the left\n                // of this 'before' element coincides with the left of the existing character.\n                margin: `0 -1ch 0 0;\n        position: absolute;\n        bottom: 0;\n        line-height: 0;`,\n                height: '50%',\n                backgroundColor: new vscode.ThemeColor('editorCursor.foreground'),\n            },\n        });\n        // This puts a character on top of the half block cursor and on top of the existing character\n        // to create the mix-blend 'magic'\n        this.operatorPendingModeCursorChar = vscode.window.createTextEditorDecorationType({\n            // We make the existing character 'black' -> rgb(0,0,0), because when using the mix-blend-mode\n            // with 'exclusion' it subtracts the darker color from the lightest color which means we will\n            // subtract zero from our 'currentcolor' leaving us with 'currentcolor' on the part above the\n            // background of the half cursor.\n            color: 'black',\n            before: {\n                color: 'currentcolor',\n                // The '-1ch' right margin is so that it displays on top of the existing character. The amount\n                // here doesn't really matter, it could be '-1px' it just needs to be negative so that the left\n                // of this 'before' element coincides with the left of the existing character.\n                margin: `0 -1ch 0 0;\n        position: absolute;\n        mix-blend-mode: exclusion;`,\n                height: '100%',\n            },\n        });\n    }\n}\nexports.decoration = new DecorationImpl();\n\n\n//# sourceURL=webpack://vim/./src/configuration/decoration.ts?")},"./src/configuration/iconfigurationValidator.ts":(__unused_webpack_module,exports)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ValidatorResults = void 0;\nclass ValidatorResults {\n    constructor() {\n        this.errors = new Array();\n    }\n    append(validationResult) {\n        this.errors.push(validationResult);\n    }\n    concat(validationResults) {\n        this.errors = this.errors.concat(validationResults.get());\n    }\n    get() {\n        return this.errors;\n    }\n    get numErrors() {\n        return this.errors.filter((e) => e.level === 'error').length;\n    }\n    get hasError() {\n        return this.numErrors > 0;\n    }\n    get numWarnings() {\n        return this.errors.filter((e) => e.level === 'warning').length;\n    }\n    get hasWarning() {\n        return this.numWarnings > 0;\n    }\n}\nexports.ValidatorResults = ValidatorResults;\n\n\n//# sourceURL=webpack://vim/./src/configuration/iconfigurationValidator.ts?")},"./src/configuration/notation.ts":(__unused_webpack_module,exports)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Notation = void 0;\nclass Notation {\n    /**\n     * Converts keystroke like <tab> to a single control character like \\t\n     */\n    static ToControlCharacter(key) {\n        if (key === '<tab>') {\n            return '\\t';\n        }\n        return key;\n    }\n    static IsControlKey(key) {\n        key = key.toLocaleUpperCase();\n        return (this.isSurroundedByAngleBrackets(key) && key !== '<BS>' && key !== '<S-BS>' && key !== '<TAB>');\n    }\n    /**\n     * Normalizes key to AngleBracketNotation\n     * (e.g. <ctrl+x>, Ctrl+x, <c-x> normalized to <C-x>)\n     * and converts the characters to their literals\n     * (e.g. <space>, <cr>, <leader>)\n     */\n    static NormalizeKey(key, leaderKey) {\n        if (typeof key !== 'string') {\n            return key;\n        }\n        if (key.length === 1) {\n            return key;\n        }\n        key = key.toLocaleLowerCase();\n        if (!this.isSurroundedByAngleBrackets(key)) {\n            key = `<${key}>`;\n        }\n        if (key === '<leader>') {\n            return leaderKey;\n        }\n        if (['<up>', '<down>', '<left>', '<right>'].includes(key)) {\n            return key;\n        }\n        for (const [regex, standardNotation] of this.notationMap) {\n            key = key.replace(regex, standardNotation);\n        }\n        if (this.shiftedLetterRegex.test(key)) {\n            key = key[3].toUpperCase();\n        }\n        return key;\n    }\n    /**\n     * Converts a key to a form which will look nice when logged, etc.\n     */\n    static printableKey(key, leaderKey) {\n        const normalized = this.NormalizeKey(key, leaderKey);\n        return normalized === ' ' ? '<space>' : normalized === '\\n' ? '<enter>' : normalized;\n    }\n    static isSurroundedByAngleBrackets(key) {\n        return key.startsWith('<') && key.endsWith('>');\n    }\n}\nexports.Notation = Notation;\n// Mapping from a regex to the normalized string that it should be converted to.\nNotation.notationMap = [\n    [/ctrl\\+|c\\-/gi, 'C-'],\n    [/cmd\\+|d\\-/gi, 'D-'],\n    [/shift\\+|s\\-/gi, 'S-'],\n    [/escape|esc/gi, 'Esc'],\n    [/backspace|bs/gi, 'BS'],\n    [/delete|del/gi, 'Del'],\n    [/home/gi, 'Home'],\n    [/end/gi, 'End'],\n    [/insert/gi, 'Insert'],\n    [/<space>/gi, ' '],\n    [/<cr>|<enter>|<return>/gi, '\\n'],\n];\nNotation.shiftedLetterRegex = /<S-[a-zA-Z]>/;\n\n\n//# sourceURL=webpack://vim/./src/configuration/notation.ts?")},"./src/configuration/remapper.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Remapper = exports.Remappers = void 0;\nconst vscode = __importStar(__webpack_require__(/*! vscode */ \"vscode\"));\nconst configuration_1 = __webpack_require__(/*! ../configuration/configuration */ \"./src/configuration/configuration.ts\");\nconst error_1 = __webpack_require__(/*! ../error */ \"./src/error.ts\");\nconst mode_1 = __webpack_require__(/*! ../mode/mode */ \"./src/mode/mode.ts\");\nconst statusBar_1 = __webpack_require__(/*! ../statusBar */ \"./src/statusBar.ts\");\nconst logger_1 = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\");\nconst specialKeys_1 = __webpack_require__(/*! ../util/specialKeys */ \"./src/util/specialKeys.ts\");\nconst exCommandParser_1 = __webpack_require__(/*! ../vimscript/exCommandParser */ \"./src/vimscript/exCommandParser.ts\");\nclass Remappers {\n    constructor() {\n        this.remappers = [\n            new InsertModeRemapper(),\n            new NormalModeRemapper(),\n            new VisualModeRemapper(),\n            new CommandLineModeRemapper(),\n            new OperatorPendingModeRemapper(),\n        ];\n    }\n    get isPotentialRemap() {\n        return this.remappers.some((r) => r.isPotentialRemap);\n    }\n    async sendKey(keys, modeHandler) {\n        for (const remapper of this.remappers) {\n            if (await remapper.sendKey(keys, modeHandler)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nexports.Remappers = Remappers;\nclass Remapper {\n    get isPotentialRemap() {\n        return this._isPotentialRemap;\n    }\n    constructor(configKey, remappedModes) {\n        /**\n         * Checks if the current commandList is a potential remap.\n         */\n        this._isPotentialRemap = false;\n        /**\n         * If the commandList is a potential remap but has no ambiguous remap\n         * yet, we say that it has a Potential Remap.\n         *\n         * This is to distinguish the commands with ambiguous remaps and the\n         * ones without.\n         *\n         * Example 1: if 'aaaa' is mapped and so is 'aa', when the user has pressed\n         * 'aaa' we say it has an Ambiguous Remap which is 'aa', because if the\n         * user presses other key than 'a' next or waits for the timeout to finish\n         * we need to now that there was a remap to run so we first run the 'aa'\n         * remap and then handle the remaining keys.\n         *\n         * Example 2: if only 'aaaa' is mapped, when the user has pressed 'aaa'\n         * we say it has a Potential Remap, because if the user presses other key\n         * than 'a' next or waits for the timeout to finish we need to now that\n         * there was a potential remap that never came or was broken, so we can\n         * resend the keys again without allowing for a potential remap on the first\n         * key, which means we won't get to the same state because the first key\n         * will be handled as an action (in this case a 'CommandInsertAfterCursor')\n         */\n        this.hasPotentialRemap = false;\n        this.configKey = configKey;\n        this.remappedModes = remappedModes;\n    }\n    async sendKey(keys, modeHandler) {\n        const { vimState, remapState } = modeHandler;\n        this._isPotentialRemap = false;\n        const allowPotentialRemapOnFirstKey = vimState.recordedState.allowPotentialRemapOnFirstKey;\n        let remainingKeys = [];\n        /**\n         * Means that the timeout finished so we now can't allow the keys to be buffered again\n         * because the user already waited for timeout.\n         */\n        let allowBufferingKeys = true;\n        if (!this.remappedModes.includes(vimState.currentModeIncludingPseudoModes)) {\n            return false;\n        }\n        const userDefinedRemappings = configuration_1.configuration[this.configKey];\n        if (keys[keys.length - 1] === specialKeys_1.SpecialKeys.TimeoutFinished) {\n            // Timeout finished. Don't let an ambiguous or potential remap start another timeout again\n            keys = keys.slice(0, keys.length - 1);\n            allowBufferingKeys = false;\n        }\n        if (keys.length === 0) {\n            return true;\n        }\n        logger_1.Logger.trace(`trying to find matching remap. keys=${keys}. mode=${mode_1.Mode[vimState.currentMode]}. keybindings=${this.configKey}.`);\n        let remapping = this.findMatchingRemap(userDefinedRemappings, keys);\n        // Check to see if a remapping could potentially be applied when more keys are received\n        let isPotentialRemap = Remapper.hasPotentialRemap(keys, userDefinedRemappings);\n        this._isPotentialRemap =\n            isPotentialRemap && allowBufferingKeys && allowPotentialRemapOnFirstKey;\n        /**\n         * Handle a broken potential or ambiguous remap\n         * 1. If this Remapper doesn't have a remapping AND\n         * 2. (It previously had an AmbiguousRemap OR a PotentialRemap) AND\n         * 3. (It doesn't have a potential remap anymore OR timeout finished) AND\n         * 4. keys length is more than 1\n         *\n         * Points 1-3: If we no longer have a remapping but previously had one or a potential one\n         * and there is no longer potential remappings because of another pressed key or because the\n         * timeout has passed we need to handle those situations by resending the keys or handling the\n         * ambiguous remap and resending any remaining keys.\n         * Point 4: if there is only one key there is no point in resending it without allowing remaps\n         * on first key, we can let the remapper go to the end because since either there was no potential\n         * remap anymore or the timeout finished so this means that the next two checks (the 'Buffer keys\n         * and create timeout' and 'Handle remapping and remaining keys') will never be hit, so it reaches\n         * the end without doing anything which means that this key will be handled as an action as intended.\n         */\n        if (!remapping &&\n            (this.hasAmbiguousRemap || this.hasPotentialRemap) &&\n            (!isPotentialRemap || !allowBufferingKeys) &&\n            keys.length > 1) {\n            if (this.hasAmbiguousRemap) {\n                remapping = this.hasAmbiguousRemap;\n                isPotentialRemap = false;\n                this._isPotentialRemap = false;\n                // Use the commandList to get the remaining keys so that it includes any existing\n                // '<TimeoutFinished>' key\n                remainingKeys = vimState.recordedState.commandList.slice(remapping.before.length);\n                this.hasAmbiguousRemap = undefined;\n            }\n            if (!remapping) {\n                // if there is still no remapping, handle all the keys without allowing\n                // a potential remap on the first key so that we don't repeat everything\n                // again, but still allow for other ambiguous remaps after the first key.\n                //\n                // Example: if 'iiii' is mapped in normal and 'ii' is mapped in insert mode,\n                // and the user presses 'iiia' in normal mode or presses 'iii' and waits\n                // for the timeout to finish, we want the first 'i' to be handled without\n                // allowing potential remaps, which means it will go into insert mode,\n                // but then the next 'ii' should be remapped in insert mode and after the\n                // remap the 'a' should be handled.\n                if (!allowBufferingKeys) {\n                    // Timeout finished and there is no remapping, so handle the buffered\n                    // keys but resend the '<TimeoutFinished>' key as well so we don't wait\n                    // for the timeout again but can still handle potential remaps.\n                    //\n                    // Example 1: if 'ccc' is mapped in normal mode and user presses 'cc' and\n                    // waits for the timeout to finish, this will resend the 'cc<TimeoutFinished>'\n                    // keys without allowing a potential remap on first key, which makes the\n                    // first 'c' be handled as a 'ChangeOperator' and the second 'c' which has\n                    // potential remaps (the 'ccc' remap) is buffered and the timeout started\n                    // but then the '<TimeoutFinished>' key comes straight away that clears the\n                    // timeout without waiting again, and makes the second 'c' be handled normally\n                    // as another 'ChangeOperator'.\n                    //\n                    // Example 2: if 'iiii' is mapped in normal and 'ii' is mapped in insert\n                    // mode, and the user presses 'iii' in normal mode and waits for the timeout\n                    // to finish, this will resend the 'iii<TimeoutFinished>' keys without allowing\n                    // a potential remap on first key, which makes the first 'i' be handled as\n                    // an 'CommandInsertAtCursor' and goes to insert mode, next the second 'i'\n                    // is buffered, then the third 'i' finds the insert mode remapping of 'ii'\n                    // and handles that remap, after the remapping being handled the '<TimeoutFinished>'\n                    // key comes that clears the timeout and since the commandList will be empty\n                    // we return true as we finished handling this sequence of keys.\n                    keys.push(specialKeys_1.SpecialKeys.TimeoutFinished); // include the '<TimeoutFinished>' key\n                    logger_1.Logger.trace(`${this.configKey}. timeout finished, handling timed out buffer keys without allowing a new timeout.`);\n                }\n                logger_1.Logger.trace(`${this.configKey}. potential remap broken. resending keys without allowing a potential remap on first key. keys=${keys}`);\n                this.hasPotentialRemap = false;\n                vimState.recordedState.allowPotentialRemapOnFirstKey = false;\n                vimState.recordedState.resetCommandList();\n                if (remapState.wasPerformingRemapThatFinishedWaitingForTimeout) {\n                    // Some keys that broke the possible remap were typed by the user so handle them seperatly\n                    const lastRemapLength = remapState.wasPerformingRemapThatFinishedWaitingForTimeout.after.length;\n                    const keysPressedByUser = keys.slice(lastRemapLength);\n                    keys = keys.slice(0, lastRemapLength);\n                    try {\n                        remapState.isCurrentlyPerformingRecursiveRemapping = true;\n                        await modeHandler.handleMultipleKeyEvents(keys);\n                    }\n                    catch (e) {\n                        if (e instanceof error_1.ForceStopRemappingError) {\n                            logger_1.Logger.trace(`${this.configKey}. Stopped the remapping in the middle, ignoring the rest. Reason: ${e.message}`);\n                        }\n                    }\n                    finally {\n                        remapState.isCurrentlyPerformingRecursiveRemapping = false;\n                        remapState.wasPerformingRemapThatFinishedWaitingForTimeout = false;\n                        await modeHandler.handleMultipleKeyEvents(keysPressedByUser);\n                    }\n                }\n                else {\n                    logger_1.Logger.debug(`Remapping to ${keys}`);\n                    await modeHandler.handleMultipleKeyEvents(keys);\n                }\n                return true;\n            }\n        }\n        /**\n         * Buffer keys and create timeout\n         * 1. If the current keys have a potential remap AND\n         * 2. The timeout hasn't finished yet so we allow buffering keys AND\n         * 3. We allow potential remap on first key (check the note on RecordedState. TLDR: this will only\n         * be false for one key, the first one, when we resend keys that had a potential remap but no longer\n         * have it or the timeout finished)\n         *\n         * Points 1-3: If the current keys still have a potential remap and the timeout hasn't finished yet\n         * and we are not preventing a potential remap on the first key then we need to buffer this keys\n         * and wait for another key or the timeout to finish.\n         */\n        if (isPotentialRemap && allowBufferingKeys && allowPotentialRemapOnFirstKey) {\n            if (remapping) {\n                // There are other potential remaps (ambiguous remaps), wait for other key or for the timeout\n                // to finish. Also store this current ambiguous remap on '_hasAmbiguousRemap' so that if later\n                // this ambiguous remap is broken or the user waits for timeout we don't need to go looking for\n                // it again.\n                this.hasAmbiguousRemap = remapping;\n                logger_1.Logger.trace(`${this.configKey}. ambiguous match found. before=${remapping.before}. after=${remapping.after}. command=${remapping.commands}. waiting for other key or timeout to finish.`);\n            }\n            else {\n                this.hasPotentialRemap = true;\n                logger_1.Logger.trace(`${this.configKey}. potential remap found. waiting for other key or timeout to finish.`);\n            }\n            // Store BufferedKeys\n            vimState.recordedState.bufferedKeys = [...keys];\n            // Create Timeout\n            vimState.recordedState.bufferedKeysTimeoutObj = setTimeout(() => {\n                void modeHandler.handleKeyEvent(specialKeys_1.SpecialKeys.TimeoutFinished);\n            }, configuration_1.configuration.timeout);\n            return true;\n        }\n        /**\n         * Handle Remapping and any remaining keys\n         * If we get here with a remapping that means we need to handle it.\n         */\n        if (remapping) {\n            if (!allowBufferingKeys) {\n                // If the user already waited for the timeout to finish, prevent the\n                // remapping from waiting for the timeout again by making a clone of\n                // remapping and change 'after' to send the '<TimeoutFinished>' key at\n                // the end.\n                const newRemapping = { ...remapping };\n                newRemapping.after = remapping.after?.slice(0);\n                newRemapping.after?.push(specialKeys_1.SpecialKeys.TimeoutFinished);\n                remapping = newRemapping;\n            }\n            this.hasAmbiguousRemap = undefined;\n            this.hasPotentialRemap = false;\n            let skipFirstCharacter = false;\n            // If we were performing a remapping already, it means this remapping has a parent remapping\n            const hasParentRemapping = remapState.isCurrentlyPerformingRemapping;\n            if (!hasParentRemapping) {\n                remapState.mapDepth = 0;\n            }\n            if (!remapping.recursive) {\n                remapState.isCurrentlyPerformingNonRecursiveRemapping = true;\n            }\n            else {\n                remapState.isCurrentlyPerformingRecursiveRemapping = true;\n                // As per the Vim documentation: (:help recursive)\n                // If the {rhs} starts with {lhs}, the first character is not mapped\n                // again (this is Vi compatible).\n                // For example:\n                // map ab abcd\n                // will execute the \"a\" command and insert \"bcd\" in the text. The \"ab\"\n                // in the {rhs} will not be mapped again.\n                if (remapping.after?.join('').startsWith(remapping.before.join(''))) {\n                    skipFirstCharacter = true;\n                }\n            }\n            // Increase mapDepth\n            remapState.mapDepth++;\n            logger_1.Logger.trace(`${this.configKey}. match found. before=${remapping.before}. after=${remapping.after}. command=${remapping.commands}. remainingKeys=${remainingKeys}. mapDepth=${remapState.mapDepth}.`);\n            let remapFailed = false;\n            try {\n                // Check maxMapDepth\n                if (remapState.mapDepth >= configuration_1.configuration.maxmapdepth) {\n                    const vimError = error_1.VimError.fromCode(error_1.ErrorCode.RecursiveMapping);\n                    statusBar_1.StatusBar.displayError(vimState, vimError);\n                    throw error_1.ForceStopRemappingError.fromVimError(vimError);\n                }\n                // Hacky code incoming!!! If someone has a better way to do this please change it\n                if (remapState.mapDepth % 10 === 0) {\n                    // Allow the user to press <C-c> or <Esc> key when inside an infinite looping remap.\n                    // When inside an infinite looping recursive mapping it would block the editor until it reached\n                    // the maxmapdepth. This 0ms wait allows the extension to handle any key typed by the user which\n                    // means it allows the user to press <C-c> or <Esc> to force stop the looping remap.\n                    // This shouldn't impact the normal use case because we're only running this every 10 nested\n                    // remaps. Also when the logs are set to Error only, a looping recursive remap takes around 1.5s\n                    // to reach 1000 mapDepth and give back control to the user, but when logs are set to debug it\n                    // can take as long as 7 seconds.\n                    const wait = (ms) => new Promise((res) => setTimeout(res, ms));\n                    await wait(0);\n                }\n                remapState.remapUsedACharacter = false;\n                await this.handleRemapping(remapping, modeHandler, skipFirstCharacter);\n            }\n            catch (e) {\n                if (e instanceof error_1.ForceStopRemappingError) {\n                    // If a motion fails or a VimError happens during any kind of remapping or if the user presses the\n                    // force stop remapping key (<C-c> or <Esc>) during a recursive remapping it should stop handling\n                    // the remap and all its parent remaps if we are on a chain of recursive remaps.\n                    // (Vim documentation :help map-error)\n                    remapFailed = true;\n                    // keep throwing until we reach the first parent\n                    if (hasParentRemapping) {\n                        throw e;\n                    }\n                    logger_1.Logger.trace(`${this.configKey}. Stopped the remapping in the middle, ignoring the rest. Reason: ${e.message}`);\n                }\n                else {\n                    // If some other error happens during the remapping handling it should stop the remap and rethrow\n                    logger_1.Logger.trace(`${this.configKey}. error found in the middle of remapping, ignoring the rest of the remap. error: ${e}`);\n                    throw e;\n                }\n            }\n            finally {\n                // Check if we are still inside a recursive remap\n                if (!hasParentRemapping && remapState.isCurrentlyPerformingRecursiveRemapping) {\n                    // no more recursive remappings being handled\n                    if (vimState.recordedState.bufferedKeysTimeoutObj !== undefined) {\n                        // In order to be able to receive other keys and at the same time wait for timeout, we need\n                        // to create a timeout and return from the remapper so that modeHandler can be free to receive\n                        // more keys. This means that if we are inside a recursive remapping, when we return on the\n                        // last key of that remapping it will think that it is finished and set the currently\n                        // performing recursive remapping flag to false, which would result in the current bufferedKeys\n                        // not knowing they had a parent remapping. So we store that remapping here.\n                        remapState.wasPerformingRemapThatFinishedWaitingForTimeout = { ...remapping };\n                    }\n                    remapState.isCurrentlyPerformingRecursiveRemapping = false;\n                    remapState.forceStopRecursiveRemapping = false;\n                }\n                if (!hasParentRemapping) {\n                    // Last remapping finished handling. Set undo step.\n                    vimState.historyTracker.finishCurrentStep();\n                }\n                // NonRecursive remappings can't have nested remaps so after a finished remap we always set this to\n                // false, because either we were performing a non recursive remap and now we finish or we weren't\n                // performing a non recursive remapping and this was false anyway.\n                remapState.isCurrentlyPerformingNonRecursiveRemapping = false;\n                // if there were other remaining keys on the buffered keys that weren't part of the remapping\n                // handle them now, except if the remap failed and the remaining keys weren't typed by the user.\n                // (we know that if this remapping has a parent remapping then the remaining keys weren't typed\n                // by the user, but instead were sent by the parent remapping handler)\n                if (remainingKeys.length > 0 && !(remapFailed && hasParentRemapping)) {\n                    if (remapState.wasPerformingRemapThatFinishedWaitingForTimeout) {\n                        // If there was a performing remap that finished waiting for timeout then only the remaining keys\n                        // that are not part of that remap were typed by the user.\n                        let specialKey = '';\n                        if (remainingKeys[remainingKeys.length - 1] === specialKeys_1.SpecialKeys.TimeoutFinished) {\n                            specialKey = remainingKeys.pop();\n                        }\n                        const lastRemap = remapState.wasPerformingRemapThatFinishedWaitingForTimeout.after;\n                        const lastRemapWithoutAmbiguousRemap = lastRemap.slice(remapping.before.length);\n                        const keysPressedByUser = remainingKeys.slice(lastRemapWithoutAmbiguousRemap.length);\n                        remainingKeys = remainingKeys.slice(0, remainingKeys.length - keysPressedByUser.length);\n                        if (specialKey) {\n                            remainingKeys.push(specialKey);\n                            if (keysPressedByUser.length !== 0) {\n                                keysPressedByUser.push(specialKey);\n                            }\n                        }\n                        try {\n                            remapState.isCurrentlyPerformingRecursiveRemapping = true;\n                            await modeHandler.handleMultipleKeyEvents(remainingKeys);\n                        }\n                        catch (e) {\n                            logger_1.Logger.trace(\n                            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                            `${this.configKey}. Stopped the remapping in the middle, ignoring the rest. Reason: ${e.message}`);\n                        }\n                        finally {\n                            remapState.isCurrentlyPerformingRecursiveRemapping = false;\n                            remapState.wasPerformingRemapThatFinishedWaitingForTimeout = false;\n                            if (keysPressedByUser.length > 0) {\n                                await modeHandler.handleMultipleKeyEvents(keysPressedByUser);\n                            }\n                        }\n                    }\n                    else {\n                        await modeHandler.handleMultipleKeyEvents(remainingKeys);\n                    }\n                }\n            }\n            return true;\n        }\n        this.hasPotentialRemap = false;\n        this.hasAmbiguousRemap = undefined;\n        return false;\n    }\n    async handleRemapping(remapping, modeHandler, skipFirstCharacter) {\n        const { vimState, remapState } = modeHandler;\n        vimState.recordedState.resetCommandList();\n        if (remapping.after) {\n            logger_1.Logger.debug(`Remapping ${remapping.before} to ${remapping.after}`);\n            if (skipFirstCharacter) {\n                remapState.isCurrentlyPerformingNonRecursiveRemapping = true;\n                await modeHandler.handleKeyEvent(remapping.after[0]);\n                remapState.isCurrentlyPerformingNonRecursiveRemapping = false;\n                await modeHandler.handleMultipleKeyEvents(remapping.after.slice(1));\n            }\n            else {\n                await modeHandler.handleMultipleKeyEvents(remapping.after);\n            }\n        }\n        if (remapping.commands) {\n            const count = vimState.recordedState.count || 1;\n            vimState.recordedState.count = 0;\n            for (let i = 0; i < count; i++) {\n                for (const command of remapping.commands) {\n                    let commandString;\n                    let commandArgs;\n                    if (typeof command === 'string') {\n                        commandString = command;\n                        commandArgs = [];\n                    }\n                    else {\n                        commandString = command.command;\n                        commandArgs = Array.isArray(command.args)\n                            ? command.args\n                            : command.args\n                                ? [command.args]\n                                : [];\n                    }\n                    if (commandString.slice(0, 1) === ':') {\n                        // Check if this is a vim command by looking for :\n                        // TODO: Parse once & cache?\n                        const result = exCommandParser_1.exCommandParser.parse(commandString);\n                        if (result.status) {\n                            if (result.value.lineRange) {\n                                await result.value.command.executeWithRange(vimState, result.value.lineRange);\n                            }\n                            else {\n                                await result.value.command.execute(vimState);\n                            }\n                        }\n                        else {\n                            throw error_1.VimError.fromCode(error_1.ErrorCode.NotAnEditorCommand, commandString);\n                        }\n                        await modeHandler.updateView();\n                    }\n                    else {\n                        await vscode.commands.executeCommand(commandString, ...commandArgs);\n                    }\n                    // TODO add test cases (silent defined in IKeyRemapping)\n                    if (!remapping.silent) {\n                        statusBar_1.StatusBar.setText(vimState, `${commandString} ${commandArgs.join(' ')}`);\n                    }\n                }\n            }\n        }\n    }\n    findMatchingRemap(userDefinedRemappings, inputtedKeys) {\n        if (userDefinedRemappings.size === 0) {\n            return undefined;\n        }\n        const range = Remapper.getRemappedKeysLengthRange(userDefinedRemappings);\n        const startingSliceLength = inputtedKeys.length;\n        const inputtedString = inputtedKeys.join('');\n        for (let sliceLength = startingSliceLength; sliceLength >= range[0]; sliceLength--) {\n            const keySlice = inputtedKeys.slice(-sliceLength).join('');\n            logger_1.Logger.trace(`key=${inputtedKeys}. keySlice=${keySlice}.`);\n            if (userDefinedRemappings.has(keySlice)) {\n                const precedingKeys = inputtedString.slice(0, inputtedString.length - keySlice.length);\n                if (precedingKeys.length > 0 && !/^[0-9]+$/.test(precedingKeys)) {\n                    logger_1.Logger.trace(`key sequences need to match precisely. precedingKeys=${precedingKeys}.`);\n                    break;\n                }\n                return userDefinedRemappings.get(keySlice);\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Given list of remappings, returns the length of the shortest and longest remapped keys\n     * @param remappings\n     */\n    static getRemappedKeysLengthRange(remappings) {\n        if (remappings.size === 0) {\n            return [0, 0];\n        }\n        const keyLengths = Array.from(remappings.values()).map((remap) => remap.before.length);\n        return [Math.min(...keyLengths), Math.max(...keyLengths)];\n    }\n    /**\n     * Given list of keys and list of remappings, returns true if the keys are a potential remap\n     * @param keys the list of keys to be checked for potential remaps\n     * @param remappings The remappings Map\n     * @param countRemapAsPotential If the current keys are themselves a remap should they be considered a potential remap as well?\n     */\n    static hasPotentialRemap(keys, remappings, countRemapAsPotential = false) {\n        const keysAsString = keys.join('');\n        const re = /^<([^>]+)>/;\n        if (keysAsString !== '') {\n            for (const remap of remappings.keys()) {\n                if (remap.startsWith(keysAsString) && (remap !== keysAsString || countRemapAsPotential)) {\n                    // Don't confuse a key combination starting with '<' that is not a special key like '<C-a>'\n                    // with a remap that starts with a special key.\n                    if (keysAsString.startsWith('<') && !re.test(keysAsString) && re.test(remap)) {\n                        continue;\n                    }\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\nexports.Remapper = Remapper;\nfunction keyBindingsConfigKey(mode) {\n    return `${mode}ModeKeyBindingsMap`;\n}\nclass InsertModeRemapper extends Remapper {\n    constructor() {\n        super(keyBindingsConfigKey('insert'), [mode_1.Mode.Insert, mode_1.Mode.Replace]);\n    }\n}\nclass NormalModeRemapper extends Remapper {\n    constructor() {\n        super(keyBindingsConfigKey('normal'), [mode_1.Mode.Normal]);\n    }\n}\nclass OperatorPendingModeRemapper extends Remapper {\n    constructor() {\n        super(keyBindingsConfigKey('operatorPending'), [mode_1.Mode.OperatorPendingMode]);\n    }\n}\nclass VisualModeRemapper extends Remapper {\n    constructor() {\n        super(keyBindingsConfigKey('visual'), [mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock]);\n    }\n}\nclass CommandLineModeRemapper extends Remapper {\n    constructor() {\n        super(keyBindingsConfigKey('commandLine'), [\n            mode_1.Mode.CommandlineInProgress,\n            mode_1.Mode.SearchInProgressMode,\n        ]);\n    }\n}\n\n\n//# sourceURL=webpack://vim/./src/configuration/remapper.ts?")},"./src/configuration/validators/inputMethodSwitcherValidator.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InputMethodSwitcherConfigurationValidator = void 0;\nconst iconfigurationValidator_1 = __webpack_require__(/*! ../iconfigurationValidator */ \"./src/configuration/iconfigurationValidator.ts\");\nconst fs_1 = __webpack_require__(/*! platform/fs */ \"./src/platform/browser/fs.ts\");\nconst globals_1 = __webpack_require__(/*! ../../globals */ \"./src/globals.ts\");\nconst configurationValidator_1 = __webpack_require__(/*! ../configurationValidator */ \"./src/configuration/configurationValidator.ts\");\nclass InputMethodSwitcherConfigurationValidator {\n    async validate(config) {\n        const result = new iconfigurationValidator_1.ValidatorResults();\n        const inputMethodConfig = config.autoSwitchInputMethod;\n        if (!inputMethodConfig.enable || globals_1.Globals.isTesting) {\n            return Promise.resolve(result);\n        }\n        if (!inputMethodConfig.switchIMCmd.includes('{im}')) {\n            result.append({\n                level: 'error',\n                message: 'vim.autoSwitchInputMethod.switchIMCmd is incorrect, it should contain the placeholder {im}.',\n            });\n        }\n        if (inputMethodConfig.obtainIMCmd === undefined || inputMethodConfig.obtainIMCmd === '') {\n            result.append({\n                level: 'error',\n                message: 'vim.autoSwitchInputMethod.obtainIMCmd is empty.',\n            });\n        }\n        else if (!(await (0, fs_1.existsAsync)(this.getRawCmd(inputMethodConfig.obtainIMCmd)))) {\n            result.append({\n                level: 'error',\n                message: `Unable to find ${inputMethodConfig.obtainIMCmd}. Check your 'vim.autoSwitchInputMethod.obtainIMCmd' in VSCode setting.`,\n            });\n        }\n        if (inputMethodConfig.defaultIM === undefined || inputMethodConfig.defaultIM === '') {\n            result.append({\n                level: 'error',\n                message: 'vim.autoSwitchInputMethod.defaultIM is empty.',\n            });\n        }\n        else if (!(await (0, fs_1.existsAsync)(this.getRawCmd(inputMethodConfig.switchIMCmd)))) {\n            result.append({\n                level: 'error',\n                message: `Unable to find ${inputMethodConfig.switchIMCmd}. Check your 'vim.autoSwitchInputMethod.switchIMCmd' in VSCode setting.`,\n            });\n        }\n        return Promise.resolve(result);\n    }\n    disable(config) {\n        config.autoSwitchInputMethod.enable = false;\n    }\n    getRawCmd(cmd) {\n        return cmd.split(' ')[0];\n    }\n}\nexports.InputMethodSwitcherConfigurationValidator = InputMethodSwitcherConfigurationValidator;\nconfigurationValidator_1.configurationValidator.registerValidator(new InputMethodSwitcherConfigurationValidator());\n\n\n//# sourceURL=webpack://vim/./src/configuration/validators/inputMethodSwitcherValidator.ts?")},"./src/configuration/validators/remappingValidator.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RemappingValidator = void 0;\nconst vscode = __importStar(__webpack_require__(/*! vscode */ \"vscode\"));\nconst pluginDefaultMappings_1 = __webpack_require__(/*! ../../actions/plugins/pluginDefaultMappings */ \"./src/actions/plugins/pluginDefaultMappings.ts\");\nconst configurationValidator_1 = __webpack_require__(/*! ../configurationValidator */ \"./src/configuration/configurationValidator.ts\");\nconst iconfigurationValidator_1 = __webpack_require__(/*! ../iconfigurationValidator */ \"./src/configuration/iconfigurationValidator.ts\");\nconst notation_1 = __webpack_require__(/*! ../notation */ \"./src/configuration/notation.ts\");\nclass RemappingValidator {\n    async validate(config) {\n        const result = new iconfigurationValidator_1.ValidatorResults();\n        const modeKeyBindingsKeys = [\n            'insertModeKeyBindings',\n            'insertModeKeyBindingsNonRecursive',\n            'normalModeKeyBindings',\n            'normalModeKeyBindingsNonRecursive',\n            'operatorPendingModeKeyBindings',\n            'operatorPendingModeKeyBindingsNonRecursive',\n            'visualModeKeyBindings',\n            'visualModeKeyBindingsNonRecursive',\n            'commandLineModeKeyBindings',\n            'commandLineModeKeyBindingsNonRecursive',\n        ];\n        for (const modeKeyBindingsKey of modeKeyBindingsKeys) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const keybindings = config[modeKeyBindingsKey];\n            // add default mappings for activated plugins\n            // because we process keybindings backwards in next loop, user mapping will override\n            for (const pluginMapping of pluginDefaultMappings_1.PluginDefaultMappings.getPluginDefaultMappings(modeKeyBindingsKey, config)) {\n                // note concat(all mappings) does not work somehow\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n                keybindings.push(pluginMapping);\n            }\n            const isRecursive = modeKeyBindingsKey.indexOf('NonRecursive') === -1;\n            const modeMapName = modeKeyBindingsKey.replace('NonRecursive', '');\n            let modeKeyBindingsMap = config[modeMapName + 'Map'];\n            if (!modeKeyBindingsMap) {\n                modeKeyBindingsMap = new Map();\n            }\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            for (let i = keybindings.length - 1; i >= 0; i--) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                const remapping = keybindings[i];\n                // set 'recursive' of the remapping according to where it was stored\n                remapping.recursive = isRecursive;\n                // validate\n                const remappingError = await this.isRemappingValid(remapping);\n                result.concat(remappingError);\n                if (remappingError.hasError) {\n                    // errors with remapping, skip\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n                    keybindings.splice(i, 1);\n                    continue;\n                }\n                // normalize\n                if (remapping.before) {\n                    remapping.before.forEach((key, idx) => (remapping.before[idx] = notation_1.Notation.NormalizeKey(key, config.leader)));\n                }\n                if (remapping.after) {\n                    remapping.after.forEach((key, idx) => (remapping.after[idx] = notation_1.Notation.NormalizeKey(key, config.leader)));\n                }\n                // check for duplicates\n                const beforeKeys = remapping.before.join('');\n                if (modeKeyBindingsMap.has(beforeKeys)) {\n                    result.append({\n                        level: 'warning',\n                        message: `${remapping.before}. Duplicate remapped key for ${beforeKeys}.`,\n                    });\n                    continue;\n                }\n                // add to map\n                modeKeyBindingsMap.set(beforeKeys, remapping);\n            }\n            config[modeMapName + 'Map'] = modeKeyBindingsMap;\n        }\n        return result;\n    }\n    disable(config) {\n        // no-op\n    }\n    async isRemappingValid(remapping) {\n        const result = new iconfigurationValidator_1.ValidatorResults();\n        if (!remapping.after && !remapping.commands) {\n            result.append({\n                level: 'error',\n                message: `${remapping.before} missing 'after' key or 'commands'.`,\n            });\n        }\n        if (!(remapping.before instanceof Array)) {\n            result.append({\n                level: 'error',\n                message: `Remapping of '${remapping.before}' should be a string array.`,\n            });\n        }\n        if (remapping.recursive === undefined) {\n            result.append({\n                level: 'error',\n                message: `Remapping of '${remapping.before}' missing 'recursive' info.`,\n            });\n        }\n        if (remapping.after && !(remapping.after instanceof Array)) {\n            result.append({\n                level: 'error',\n                message: `Remapping of '${remapping.after}' should be a string array.`,\n            });\n        }\n        if (remapping.commands) {\n            for (const command of remapping.commands) {\n                let cmd;\n                if (typeof command === 'string') {\n                    cmd = command;\n                }\n                else if (command.command) {\n                    cmd = command.command;\n                    if (!(await this.isCommandValid(cmd))) {\n                        result.append({ level: 'warning', message: `${cmd} does not exist.` });\n                    }\n                }\n                else {\n                    result.append({\n                        level: 'error',\n                        message: `Remapping of '${remapping.before}' has wrong \"commands\" structure. Should be 'string[] | { \"command\": string, \"args\": any[] }[]'.`,\n                    });\n                }\n            }\n        }\n        return result;\n    }\n    async isCommandValid(command) {\n        if (command.startsWith(':')) {\n            return true;\n        }\n        return (await this.getCommandMap()).has(command);\n    }\n    async getCommandMap() {\n        if (this.commandMap == null) {\n            this.commandMap = new Map((await vscode.commands.getCommands(true)).map((x) => [x, true]));\n        }\n        return this.commandMap;\n    }\n}\nexports.RemappingValidator = RemappingValidator;\nconfigurationValidator_1.configurationValidator.registerValidator(new RemappingValidator());\n\n\n//# sourceURL=webpack://vim/./src/configuration/validators/remappingValidator.ts?")},"./src/error.ts":(__unused_webpack_module,exports)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.ForceStopRemappingError = exports.VimError = exports.ErrorMessage = exports.ErrorCode = void 0;\nvar ErrorCode;\n(function (ErrorCode) {\n    ErrorCode[ErrorCode["InvalidAddress"] = 14] = "InvalidAddress";\n    ErrorCode[ErrorCode["InvalidRange"] = 16] = "InvalidRange";\n    ErrorCode[ErrorCode["MarkNotSet"] = 20] = "MarkNotSet";\n    ErrorCode[ErrorCode["NoAlternateFile"] = 23] = "NoAlternateFile";\n    ErrorCode[ErrorCode["NoInsertedTextYet"] = 29] = "NoInsertedTextYet";\n    ErrorCode[ErrorCode["NoFileName"] = 32] = "NoFileName";\n    ErrorCode[ErrorCode["NoPreviousSubstituteRegularExpression"] = 33] = "NoPreviousSubstituteRegularExpression";\n    ErrorCode[ErrorCode["NoPreviousCommand"] = 34] = "NoPreviousCommand";\n    ErrorCode[ErrorCode["NoPreviousRegularExpression"] = 35] = "NoPreviousRegularExpression";\n    ErrorCode[ErrorCode["NoWriteSinceLastChange"] = 37] = "NoWriteSinceLastChange";\n    ErrorCode[ErrorCode["ErrorWritingToFile"] = 208] = "ErrorWritingToFile";\n    ErrorCode[ErrorCode["FileNoLongerAvailable"] = 211] = "FileNoLongerAvailable";\n    ErrorCode[ErrorCode["RecursiveMapping"] = 223] = "RecursiveMapping";\n    ErrorCode[ErrorCode["NoStringUnderCursor"] = 348] = "NoStringUnderCursor";\n    ErrorCode[ErrorCode["NothingInRegister"] = 353] = "NothingInRegister";\n    ErrorCode[ErrorCode["InvalidRegisterName"] = 354] = "InvalidRegisterName";\n    ErrorCode[ErrorCode["SearchHitTop"] = 384] = "SearchHitTop";\n    ErrorCode[ErrorCode["SearchHitBottom"] = 385] = "SearchHitBottom";\n    ErrorCode[ErrorCode["CannotCloseLastWindow"] = 444] = "CannotCloseLastWindow";\n    ErrorCode[ErrorCode["ArgumentRequired"] = 471] = "ArgumentRequired";\n    ErrorCode[ErrorCode["InvalidArgument"] = 474] = "InvalidArgument";\n    ErrorCode[ErrorCode["NoRangeAllowed"] = 481] = "NoRangeAllowed";\n    ErrorCode[ErrorCode["PatternNotFound"] = 486] = "PatternNotFound";\n    ErrorCode[ErrorCode["TrailingCharacters"] = 488] = "TrailingCharacters";\n    ErrorCode[ErrorCode["NotAnEditorCommand"] = 492] = "NotAnEditorCommand";\n    ErrorCode[ErrorCode["NoBuffersDeleted"] = 516] = "NoBuffersDeleted";\n    ErrorCode[ErrorCode["UnknownOption"] = 518] = "UnknownOption";\n    ErrorCode[ErrorCode["NumberRequiredAfterEqual"] = 521] = "NumberRequiredAfterEqual";\n    ErrorCode[ErrorCode["AtStartOfChangeList"] = 662] = "AtStartOfChangeList";\n    ErrorCode[ErrorCode["AtEndOfChangeList"] = 663] = "AtEndOfChangeList";\n    ErrorCode[ErrorCode["ChangeListIsEmpty"] = 664] = "ChangeListIsEmpty";\n    ErrorCode[ErrorCode["StartPastEnd"] = 727] = "StartPastEnd";\n    ErrorCode[ErrorCode["NoPreviouslyUsedRegister"] = 748] = "NoPreviouslyUsedRegister";\n})(ErrorCode || (exports.ErrorCode = ErrorCode = {}));\nexports.ErrorMessage = {\n    14: \'Invalid address\',\n    16: \'Invalid range\',\n    20: \'Mark not set\',\n    23: \'No alternate file\',\n    29: \'No inserted text yet\',\n    32: \'No file name\',\n    33: \'No previous substitute regular expression\',\n    34: \'No previous command\',\n    35: \'No previous regular expression\',\n    37: \'No write since last change (add ! to override)\',\n    208: \'Error writing to file\',\n    211: \'File no longer available\', // TODO: Should be `File "[file_name]" no longer available`\n    223: \'Recursive mapping\',\n    348: \'No string under cursor\',\n    353: \'Nothing in register\',\n    354: \'Invalid register name\',\n    384: \'Search hit TOP without match for\',\n    385: \'Search hit BOTTOM without match for\',\n    444: \'Cannot close last window\',\n    471: \'Argument required\',\n    474: \'Invalid argument\',\n    481: \'No range allowed\',\n    486: \'Pattern not found\',\n    488: \'Trailing characters\',\n    492: \'Not an editor command\',\n    516: \'No buffers were deleted\',\n    518: \'Unknown option\',\n    521: \'Number required after =\',\n    662: \'At start of changelist\',\n    663: \'At end of changelist\',\n    664: \'changelist is empty\',\n    727: \'Start past end\',\n    748: \'No previously used register\',\n};\nclass VimError extends Error {\n    constructor(code, message) {\n        super();\n        this.code = code;\n        this.message = message;\n    }\n    static fromCode(code, extraValue) {\n        if (exports.ErrorMessage[code]) {\n            if (extraValue) {\n                if (code === ErrorCode.NothingInRegister) {\n                    extraValue = ` ${extraValue}`;\n                }\n                else {\n                    extraValue = `: ${extraValue}`;\n                }\n            }\n            return new VimError(code, exports.ErrorMessage[code] + (extraValue ?? \'\'));\n        }\n        throw new Error(\'unknown error code: \' + code);\n    }\n    toString() {\n        return `E${this.code}: ${this.message}`;\n    }\n}\nexports.VimError = VimError;\n/**\n * Used to stop a remapping or a chain of nested remappings after a VimError, a failed action\n * or the force stop recursive mapping key (<C-c> or <Esc>). (Vim doc :help map-error)\n */\nclass ForceStopRemappingError extends Error {\n    constructor(reason = \'StopRemapping\') {\n        super(reason);\n    }\n    static fromVimError(vimError) {\n        return new ForceStopRemappingError(vimError.toString());\n    }\n}\nexports.ForceStopRemappingError = ForceStopRemappingError;\n\n\n//# sourceURL=webpack://vim/./src/error.ts?')},"./src/globals.ts":(__unused_webpack_module,exports)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.Globals = void 0;\n/**\n * Global variables shared throughout extension\n */\nclass Globals {\n}\nexports.Globals = Globals;\n/**\n * Used for testing.\n */\nGlobals.isTesting = false;\n\n\n//# sourceURL=webpack://vim/./src/globals.ts?')},"./src/history/historyFile.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.CommandLineHistory = exports.SearchHistory = exports.HistoryFile = void 0;\nconst configuration_1 = __webpack_require__(/*! ../configuration/configuration */ "./src/configuration/configuration.ts");\nconst globals_1 = __webpack_require__(/*! ../globals */ "./src/globals.ts");\nconst history_1 = __webpack_require__(/*! platform/history */ "./src/platform/browser/history.ts");\n// TODO(jfields): What\'s going on here? Just combine HistoryFile and HistoryBase...\nclass HistoryFile {\n    get historyFilePath() {\n        return this.base.historyKey;\n    }\n    constructor(context, historyFileName) {\n        this.base = new history_1.HistoryBase(context, historyFileName, globals_1.Globals.extensionStoragePath);\n    }\n    async add(value) {\n        return this.base.add(value, configuration_1.configuration.history);\n    }\n    get() {\n        return this.base.get(configuration_1.configuration.history);\n    }\n    clear() {\n        this.base.clear();\n    }\n    async load() {\n        await this.base.load();\n    }\n}\nexports.HistoryFile = HistoryFile;\nclass SearchHistory extends HistoryFile {\n    constructor(context) {\n        super(context, \'.search_history\');\n    }\n}\nexports.SearchHistory = SearchHistory;\nclass CommandLineHistory extends HistoryFile {\n    constructor(context) {\n        super(context, \'.cmdline_history\');\n    }\n}\nexports.CommandLineHistory = CommandLineHistory;\n\n\n//# sourceURL=webpack://vim/./src/history/historyFile.ts?')},"./src/history/historyTracker.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HistoryTracker = void 0;\n/**\n * HistoryTracker is a handrolled undo/redo tracker for VSC. We currently\n * track history as a list of \"steps\", each of which consists of 1 or more\n * \"changes\".\n *\n * A Change is something like adding or deleting a few letters.\n *\n * A Step is multiple Changes.\n *\n * Undo/Redo will advance forward or backwards through Steps.\n */\nconst DiffMatchPatch = __webpack_require__(/*! diff-match-patch */ \"./node_modules/diff-match-patch/index.js\");\nconst vscode = __importStar(__webpack_require__(/*! vscode */ \"vscode\"));\nconst textEditor_1 = __webpack_require__(/*! ./../textEditor */ \"./src/textEditor.ts\");\nconst statusBar_1 = __webpack_require__(/*! ../statusBar */ \"./src/statusBar.ts\");\nconst vscode_1 = __webpack_require__(/*! vscode */ \"vscode\");\nconst jump_1 = __webpack_require__(/*! ../jumps/jump */ \"./src/jumps/jump.ts\");\nconst globalState_1 = __webpack_require__(/*! ../state/globalState */ \"./src/state/globalState.ts\");\nconst mode_1 = __webpack_require__(/*! ../mode/mode */ \"./src/mode/mode.ts\");\nconst error_1 = __webpack_require__(/*! ../error */ \"./src/error.ts\");\nconst logger_1 = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\");\nconst position_1 = __webpack_require__(/*! ../common/motion/position */ \"./src/common/motion/position.ts\");\nconst diffEngine = new DiffMatchPatch.diff_match_patch();\ndiffEngine.Diff_Timeout = 1; // 1 second\nclass DocumentChange {\n    static insert(start, text) {\n        return new DocumentChange(start, '', text);\n    }\n    static delete(start, text) {\n        return new DocumentChange(start, text, '');\n    }\n    static replace(start, before, after) {\n        return new DocumentChange(start, before, after);\n    }\n    /**\n     * @returns A new DocumentChange that represents undoing this change\n     */\n    reversed() {\n        return DocumentChange.replace(this.start, this.after, this.before);\n    }\n    constructor(start, before, after) {\n        this.start = start;\n        this.before = before;\n        this.after = after;\n    }\n    /**\n     * Run this change.\n     */\n    async do(editor) {\n        await textEditor_1.TextEditor.replace(editor, this.beforeRange, this.after);\n    }\n    /**\n     * Run this change in reverse.\n     */\n    async undo(editor) {\n        await textEditor_1.TextEditor.replace(editor, this.afterRange, this.before);\n    }\n    /**\n     * The Range that the before text occupied\n     */\n    get beforeRange() {\n        return new vscode.Range(this.start, this.start.advancePositionByText(this.before));\n    }\n    /**\n     * The Range that the after text occupies\n     */\n    get afterRange() {\n        return new vscode.Range(this.start, this.start.advancePositionByText(this.after));\n    }\n}\n/**\n * An undo's worth of changes; generally corresponds to a single action.\n */\nclass HistoryStep {\n    constructor(init) {\n        /**\n         * Whether the user is still inserting or deleting for this history step.\n         */\n        this.isFinished = false;\n        /**\n         * The position of every mark at the start of this history step.\n         */\n        this.marks = [];\n        this.changes = init.changes ?? [];\n        this.marks = init.marks ?? [];\n        this.cameFromU = init.cameFromU ?? false;\n        // This will usually be overwritten when the HistoryStep is finished\n        this.timestamp = new Date();\n    }\n    /**\n     * Collapse individual character changes into larger blocks of changes\n     */\n    merge(document) {\n        if (this.changes.length < 2) {\n            return;\n        }\n        // merged will replace this.changes\n        const merged = [];\n        // manually reduce() this.changes with variables `current` and `next`\n        // we can't use reduce() directly because the loop can emit multiple elements\n        let current = this.changes[0];\n        for (const next of this.changes.slice(1)) {\n            if (current.before.length + current.after.length === 0) {\n                // current is eliminated, replace it with top of merged, or adopt next as current\n                // see also add+del case\n                if (merged.length > 0) {\n                    current = merged.pop();\n                }\n                else {\n                    current = next;\n                    continue;\n                }\n            }\n            const intersect = current.afterRange.intersection(next.beforeRange);\n            if (intersect) {\n                const [first, second] = current.start.isBeforeOrEqual(next.start)\n                    ? [current, next]\n                    : [next, current];\n                const intersectLength = document.offsetAt(intersect.end) - document.offsetAt(intersect.start);\n                current = DocumentChange.replace(first.start, first.before + second.before.slice(intersectLength), first.after.slice(0, first.after.length - intersectLength) + second.after);\n            }\n            else {\n                merged.push(current);\n                current = next;\n            }\n        }\n        merged.push(current);\n        this.changes = merged;\n    }\n    /**\n     * Returns, as a string, the time that has passed since this step took place.\n     */\n    howLongAgo() {\n        const now = new Date();\n        const timeDiffMillis = now.getTime() - this.timestamp.getTime();\n        const timeDiffSeconds = Math.floor(timeDiffMillis / 1000);\n        if (timeDiffSeconds === 1) {\n            return `1 second ago`;\n        }\n        else if (timeDiffSeconds >= 100) {\n            const hours = this.timestamp.getHours();\n            const minutes = this.timestamp.getMinutes().toString().padStart(2, '0');\n            const seconds = this.timestamp.getSeconds().toString().padStart(2, '0');\n            return `${hours}:${minutes}:${seconds}`;\n        }\n        else {\n            return `${timeDiffSeconds} seconds ago`;\n        }\n    }\n}\n/**\n * \"global\" marks which operate across files. (when IMark.name is uppercase)\n */\nHistoryStep.globalMarks = [];\n/**\n * A simple wrapper around a list of HistorySteps, for sanity's sake\n */\nclass UndoStack {\n    constructor() {\n        this.historySteps = [];\n        this.currentStepIndex = -1;\n        // The marks as they existed before the first HistoryStep\n        this.initialMarks = [];\n    }\n    getHistoryStepAtIndex(idx) {\n        return this.historySteps[idx];\n    }\n    getCurrentHistoryStepIndex() {\n        return this.currentStepIndex;\n    }\n    getStackDepth() {\n        return this.historySteps.length;\n    }\n    /**\n     * @returns the current HistoryStep, or undefined if nothing's been done yet\n     */\n    getCurrentHistoryStep() {\n        if (this.currentStepIndex === -1) {\n            return undefined;\n        }\n        return this.historySteps[this.currentStepIndex];\n    }\n    /**\n     * Goes forward in time (redo), if possible\n     *\n     * @returns the new current HistoryStep, or undefined if none exists\n     */\n    stepForward() {\n        if (this.currentStepIndex === this.historySteps.length - 1) {\n            return undefined;\n        }\n        this.currentStepIndex++;\n        return this.getCurrentHistoryStep();\n    }\n    /**\n     * Goes backward in time (undo), if possible\n     *\n     * @returns the old HistoryStep, or undefined if there was none\n     */\n    stepBackward() {\n        const step = this.getCurrentHistoryStep();\n        if (step) {\n            this.currentStepIndex--;\n        }\n        return step;\n    }\n    /**\n     * Adds a change to the current unfinished step if there is one, or a new step if there isn't\n     */\n    pushChange(change) {\n        let step = this.getCurrentHistoryStep();\n        if (step === undefined || step.isFinished) {\n            this.currentStepIndex++;\n            this.historySteps.splice(this.currentStepIndex);\n            step = new HistoryStep({\n                marks: step?.marks ?? this.initialMarks,\n            });\n            this.historySteps.push(step);\n        }\n        step.changes.push(change);\n    }\n    /**\n     * You probably don't want to use this.\n     * @see pushChange\n     */\n    pushHistoryStep(step) {\n        this.currentStepIndex++;\n        this.historySteps.splice(this.currentStepIndex + 1);\n        this.historySteps.push(step);\n    }\n    getCurrentMarkList() {\n        const step = this.getCurrentHistoryStep();\n        return step?.marks ?? this.initialMarks;\n    }\n    removeMarks(marks) {\n        const step = this.getCurrentHistoryStep();\n        if (marks === undefined) {\n            if (step) {\n                step.marks = [];\n            }\n            else {\n                this.initialMarks = [];\n            }\n        }\n        else {\n            if (step) {\n                step.marks = step.marks.filter((m) => !marks.includes(m.name));\n            }\n            else {\n                this.initialMarks = this.initialMarks.filter((m) => !marks.includes(m.name));\n            }\n        }\n    }\n}\nclass ChangeList {\n    constructor() {\n        this.changeLocations = [];\n    }\n    addChangePosition(position) {\n        if (this.changeLocations.length > 0 &&\n            this.changeLocations[this.changeLocations.length - 1].line === position.line) {\n            this.changeLocations[this.changeLocations.length - 1] = position;\n        }\n        else {\n            this.changeLocations.push(position);\n        }\n        this.index = undefined;\n    }\n    nextChangePosition() {\n        if (this.index === undefined) {\n            if (this.changeLocations.length === 0) {\n                return error_1.VimError.fromCode(error_1.ErrorCode.ChangeListIsEmpty);\n            }\n            this.index = this.changeLocations.length - 1;\n            return this.changeLocations[this.index];\n        }\n        else if (this.index < this.changeLocations.length - 1) {\n            this.index++;\n            return this.changeLocations[this.index];\n        }\n        else {\n            return error_1.VimError.fromCode(error_1.ErrorCode.AtEndOfChangeList);\n        }\n    }\n    prevChangePosition() {\n        if (this.index === undefined) {\n            if (this.changeLocations.length === 0) {\n                return error_1.VimError.fromCode(error_1.ErrorCode.ChangeListIsEmpty);\n            }\n            this.index = this.changeLocations.length - 1;\n            return this.changeLocations[this.index];\n        }\n        else if (this.index > 0) {\n            this.index--;\n            return this.changeLocations[this.index];\n        }\n        else {\n            return error_1.VimError.fromCode(error_1.ErrorCode.AtStartOfChangeList);\n        }\n    }\n}\nclass HistoryTracker {\n    constructor(vimState) {\n        this.vimState = vimState;\n        this.undoStack = new UndoStack();\n        this.changeList = new ChangeList();\n        this.previousDocumentState = {\n            text: this.getDocumentText(),\n            versionNumber: this.getDocumentVersion(),\n        };\n        this.currentContentChanges = [];\n    }\n    getDocumentText() {\n        // vimState.editor can be undefined in some unit tests\n        return this.vimState.editor?.document.getText() ?? '';\n    }\n    getDocumentVersion() {\n        // vimState.editor can be undefined in some unit tests\n        return this.vimState.editor?.document.version ?? -1;\n    }\n    /**\n     * Marks refer to relative locations in the document, rather than absolute ones.\n     *\n     * This big gnarly method updates our marks such that they continue to mark\n     * the same character when the user does a document edit that would move the\n     * text that was marked.\n     */\n    updateAndReturnMarks(document) {\n        const previousMarks = this.getAllMarksInDocument(document);\n        const newMarks = [];\n        // clone old marks into new marks\n        for (const mark of previousMarks) {\n            newMarks.push({ ...mark });\n        }\n        for (const change of this.undoStack.getCurrentHistoryStep()?.changes ?? []) {\n            for (const newMark of newMarks) {\n                // Run through each character added/deleted, and see if it could have\n                // affected the position of this mark.\n                let pos = change.start;\n                // Pull mark back with deleted text\n                for (const ch of change.before.replace(/\\r/g, '')) {\n                    if (pos.isBefore(newMark.position)) {\n                        if (ch === '\\n') {\n                            newMark.position = new vscode_1.Position(Math.max(newMark.position.line - 1, 0), newMark.position.character);\n                        }\n                        else if (pos.line === newMark.position.line) {\n                            newMark.position = new vscode_1.Position(newMark.position.line, Math.max(newMark.position.character - 1, 0));\n                        }\n                    }\n                    if (ch === '\\n') {\n                        // The 99999 is a bit of a hack here. It's very difficult and\n                        // completely unnecessary to get the correct position, so we\n                        // just fake it.\n                        pos = new vscode_1.Position(Math.max(pos.line - 1, 0), 99999);\n                    }\n                    else {\n                        pos = new vscode_1.Position(pos.line, Math.max(pos.character - 1, 0));\n                    }\n                }\n                pos = change.start;\n                // Push mark forward with added text\n                for (const ch of change.after.replace(/\\r/g, '')) {\n                    if (pos.isBeforeOrEqual(newMark.position)) {\n                        if (ch === '\\n') {\n                            newMark.position = new vscode_1.Position(newMark.position.line + 1, newMark.position.character);\n                        }\n                        else if (pos.line === newMark.position.line) {\n                            newMark.position = new vscode_1.Position(newMark.position.line, newMark.position.character + 1);\n                        }\n                    }\n                    if (ch === '\\n') {\n                        pos = new vscode_1.Position(pos.line + 1, 0);\n                    }\n                    else {\n                        pos = new vscode_1.Position(pos.line, pos.character + 1);\n                    }\n                }\n            }\n        }\n        // Ensure the position of every mark is within the range of the document.\n        const docEnd = textEditor_1.TextEditor.getDocumentEnd(this.vimState.document);\n        for (const mark of newMarks) {\n            if (mark.position.isAfter(docEnd)) {\n                mark.position = docEnd;\n            }\n        }\n        return newMarks;\n    }\n    /**\n     * @returns the shared static list if isFileMark is true, otherwise returns the currentHistoryStep.marks.\n     */\n    getMarkList(isFileMark) {\n        return isFileMark ? HistoryStep.globalMarks : this.undoStack.getCurrentMarkList();\n    }\n    /**\n     * @returns all local and global marks in the given editor\n     */\n    getAllMarksInDocument(document) {\n        const globalMarks = HistoryStep.globalMarks.filter((mark) => mark.document === document);\n        return [...this.getLocalMarks(), ...globalMarks];\n    }\n    /**\n     * Adds a mark.\n     */\n    addMark(document, position, markName) {\n        // Sets previous context mark (adds current position to jump list).\n        if (markName === \"'\" || markName === '`') {\n            return globalState_1.globalState.jumpTracker.recordJump(jump_1.Jump.fromStateNow(this.vimState));\n        }\n        const isUppercaseMark = markName.toUpperCase() === markName;\n        const newMark = {\n            position,\n            name: markName,\n            isUppercaseMark,\n            document: isUppercaseMark ? document : undefined,\n        };\n        this.putMarkInList(newMark);\n    }\n    /**\n     * Puts the mark into either the global or local marks array depending on mark.isUppercaseMark.\n     */\n    putMarkInList(mark) {\n        const marks = this.getMarkList(mark.isUppercaseMark);\n        const previousIndex = marks.findIndex((existingMark) => existingMark.name === mark.name);\n        if (previousIndex !== -1) {\n            marks[previousIndex] = mark;\n        }\n        else {\n            marks.push(mark);\n        }\n    }\n    /**\n     * Retrieves a mark from either the global or local array depending on mark.isUppercaseMark.\n     */\n    getMark(name) {\n        // First, handle \"special\" marks\n        let position;\n        if (name === '<') {\n            const linewise = this.vimState.lastVisualSelection?.mode === mode_1.Mode.VisualLine;\n            position = linewise\n                ? this.vimState.lastVisualSelection?.start.with({ character: 0 })\n                : this.vimState.lastVisualSelection?.start;\n        }\n        else if (name === '>') {\n            const linewise = this.vimState.lastVisualSelection?.mode === mode_1.Mode.VisualLine;\n            position = linewise\n                ? this.vimState.lastVisualSelection?.end.getLineEnd()\n                : this.vimState.lastVisualSelection?.end.getLeft();\n        }\n        else if (name === '[') {\n            position = this.getLastChangeStartPosition();\n        }\n        else if (name === ']') {\n            position = this.getLastChangeEndPosition();\n        }\n        else if (name === '.') {\n            position = this.getLastHistoryStartPosition();\n        }\n        else if (name === \"'\" || name === '`') {\n            position = globalState_1.globalState.jumpTracker.end?.position;\n        }\n        if (position) {\n            return {\n                name,\n                position,\n                isUppercaseMark: false,\n            };\n        }\n        const marks = this.getMarkList(name.toUpperCase() === name);\n        return marks.find((mark) => mark.name === name);\n    }\n    /**\n     * Removes all local marks.\n     */\n    removeLocalMarks() {\n        this.undoStack.removeMarks();\n    }\n    /**\n     * Removes all marks matching from either the global or local array.\n     */\n    removeMarks(markNames) {\n        if (markNames.length === 0) {\n            return;\n        }\n        this.undoStack.removeMarks(markNames);\n        HistoryStep.globalMarks = HistoryStep.globalMarks.filter((mark) => mark.name === '' || !markNames.includes(mark.name));\n    }\n    /**\n     * Gets all local marks.  I.e., marks that are specific for the current\n     * editor.\n     */\n    getLocalMarks() {\n        return [...this.undoStack.getCurrentMarkList()];\n    }\n    /**\n     * Gets all global marks.  I.e., marks that are shared among all editors.\n     */\n    getGlobalMarks() {\n        return [...HistoryStep.globalMarks];\n    }\n    getMarks() {\n        return [...this.getLocalMarks(), ...HistoryStep.globalMarks];\n    }\n    /**\n     * Adds an individual Change to the current Step.\n     *\n     * Determines what changed by diffing the document against what it used to look like.\n     */\n    addChange(force = false) {\n        if (this.getDocumentVersion() === this.previousDocumentState.versionNumber) {\n            return;\n        }\n        if (this.nextStepStartPosition === undefined) {\n            const cursor = this.vimState.cursorsInitialState[0];\n            this.nextStepStartPosition = (0, position_1.earlierOf)(cursor.start, cursor.stop);\n            logger_1.Logger.debug(`Set nextStepStartPosition to ${this.nextStepStartPosition}`);\n        }\n        if (!force &&\n            (this.vimState.currentMode === mode_1.Mode.Insert || this.vimState.currentMode === mode_1.Mode.Replace)) {\n            // We can ignore changes while we're in insert/replace mode, since we can't interact with them (via undo, etc.) until we're back to normal mode\n            // This allows us to avoid a little bit of work per keystroke, but more importantly, it means we'll get bigger contiguous edit chunks to merge.\n            // This is particularly impactful when there are multiple cursors, which are otherwise difficult to optimize.\n            return;\n        }\n        const newText = this.getDocumentText();\n        if (newText === this.previousDocumentState.text) {\n            return;\n        }\n        // TODO: This is actually pretty stupid! Since we already have the cursorPosition,\n        // and most diffs are just +/- a few characters, we can just do a direct comparison rather\n        // than using jsdiff.\n        // The difficulty is with a few rare commands like :%s/one/two/g that make\n        // multiple changes in different places simultaneously. For those, we could require\n        // them to call addChange manually, I guess...\n        const diffs = diffEngine.diff_main(this.previousDocumentState.text, newText);\n        diffEngine.diff_cleanupEfficiency(diffs);\n        let currentPosition = new vscode_1.Position(0, 0);\n        for (const diff of diffs) {\n            const [whatHappened, text] = diff;\n            const added = whatHappened === DiffMatchPatch.DIFF_INSERT;\n            const removed = whatHappened === DiffMatchPatch.DIFF_DELETE;\n            if (added || removed) {\n                this.undoStack.pushChange(added\n                    ? DocumentChange.insert(currentPosition, text)\n                    : DocumentChange.delete(currentPosition, text));\n            }\n            if (!removed) {\n                currentPosition = currentPosition.advancePositionByText(text);\n            }\n        }\n        this.previousDocumentState = {\n            text: newText,\n            versionNumber: this.getDocumentVersion(),\n        };\n    }\n    /**\n     * Tells the HistoryTracker that although the document has changed, we should simply\n     * ignore that change. Most often used when the change was itself triggered by\n     * the HistoryTracker.\n     */\n    ignoreChange() {\n        this.previousDocumentState = {\n            text: this.getDocumentText(),\n            versionNumber: this.getDocumentVersion(),\n        };\n    }\n    /**\n     * Until we mark it as finished, the active Step will\n     * accrue multiple changes. This function will mark it as finished,\n     * and the next time we add a change, it'll be added to a new Step.\n     */\n    finishCurrentStep() {\n        const currentHistoryStep = this.undoStack.getCurrentHistoryStep();\n        if (currentHistoryStep && !currentHistoryStep.isFinished) {\n            currentHistoryStep.isFinished = true;\n            currentHistoryStep.timestamp = new Date();\n            currentHistoryStep.cursorStart ??= this.nextStepStartPosition;\n            this.nextStepStartPosition = undefined;\n            currentHistoryStep.merge(this.vimState.document);\n            currentHistoryStep.marks = this.updateAndReturnMarks(this.vimState.document);\n            const changes = currentHistoryStep.changes;\n            if (changes) {\n                const changePos = changes[0].after ? changes[0].afterRange.end.getLeft() : changes[0].start;\n                this.changeList.addChangePosition(changePos);\n            }\n            logger_1.Logger.debug(`Finished history step with ${changes.length} change(s)`);\n        }\n    }\n    /**\n     * Undo the current HistoryStep, if there is one\n     *\n     * @returns the new cursor positions, or undefined if there are no steps to undo\n     */\n    async goBackHistoryStep() {\n        const step = this.undoStack.stepBackward();\n        if (step === undefined) {\n            return undefined;\n        }\n        for (const change of step.changes.slice(0).reverse()) {\n            await change.undo(this.vimState.editor);\n        }\n        this.ignoreChange();\n        // TODO: if there are more/fewer lines after undoing the change, it should say so\n        const changes = step.changes.length === 1 ? `1 change` : `${step.changes.length} changes`;\n        statusBar_1.StatusBar.setText(this.vimState, `${changes}; before #${this.undoStack.getCurrentHistoryStepIndex() + 1}  ${step.howLongAgo()}`);\n        return step.cursorStart;\n    }\n    /**\n     * Redo the next HistoryStep, if there is one\n     *\n     * @returns the new cursor positions, or undefined if there are no steps to redo\n     */\n    async goForwardHistoryStep() {\n        const step = this.undoStack.stepForward();\n        if (step === undefined) {\n            return undefined;\n        }\n        // TODO: do these transformations in a batch\n        for (const change of step.changes) {\n            await change.do(this.vimState.editor);\n        }\n        this.ignoreChange();\n        const changes = step.changes.length === 1 ? `1 change` : `${step.changes.length} changes`;\n        statusBar_1.StatusBar.setText(this.vimState, `${changes}; after #${this.undoStack.getCurrentHistoryStepIndex()}  ${step.howLongAgo()}`);\n        return step.cursorStart;\n    }\n    /**\n     * Logic for command U.\n     *\n     * Performs an undo action for all changes which occurred on\n     * the same line as the most recent change.\n     * Returns undefined if there's no more steps back to go.\n     * Only acts upon consecutive changes on the most-recently-changed line.\n     * U itself is a change, so all the changes are reversed and added back\n     * to the history.\n     *\n     * This method contains a significant amount of extra logic to account for\n     * the difficult scenario where a newline is embedded in a change (ex: '\\nhello'), which\n     * is created by the 'o' command. Vim behavior for the 'U' command does\n     * not undo newlines, so the change text needs to be checked & trimmed.\n     * This worst-case scenario tends to offset line values and make it harder to\n     * determine the line of the change, so this behavior is also compensated.\n     */\n    async goBackHistoryStepsOnLine() {\n        const currentHistoryStep = this.undoStack.getCurrentHistoryStep();\n        if (currentHistoryStep === undefined) {\n            return undefined;\n        }\n        let done = false;\n        const changesToUndo = [];\n        let lastChange = currentHistoryStep.changes[currentHistoryStep.changes.length - 1];\n        const undoLine = lastChange.afterRange.end.line;\n        for (let stepIdx = this.undoStack.getCurrentHistoryStepIndex(); stepIdx >= 0; stepIdx--) {\n            const step = this.undoStack.getHistoryStepAtIndex(stepIdx);\n            for (let change of [...step.changes].reverse()) {\n                /*\n                 * This conditional accounts for the behavior where the change is a newline\n                 * followed by text to undo. Note the line offset behavior that must be compensated.\n                 */\n                const newlines = [...change.after.matchAll(/\\n/g)];\n                if (newlines.length > 0 && change.start.line + newlines.length === undoLine) {\n                    // Modify & replace the change to avoid undoing the newline embedded in the change\n                    change = DocumentChange.insert(new vscode_1.Position(change.start.line + 1, 0), change.after.slice(change.after.lastIndexOf('\\n')));\n                    done = true;\n                }\n                else if (newlines.length > 0 || change.start.line !== undoLine) {\n                    done = true;\n                    break;\n                }\n                changesToUndo.push(change);\n                lastChange = change;\n                if (done) {\n                    break;\n                }\n            }\n            if (step.cameFromU) {\n                done = true;\n            }\n            if (done) {\n                break;\n            }\n        }\n        if (changesToUndo.length > 0) {\n            for (const change of changesToUndo) {\n                await change.undo(this.vimState.editor);\n            }\n            const newStep = new HistoryStep({\n                marks: this.undoStack.getCurrentMarkList(),\n                changes: changesToUndo.map((change) => change.reversed()).reverse(),\n                cameFromU: true,\n            });\n            this.nextStepStartPosition = lastChange.start;\n            this.undoStack.pushHistoryStep(newStep);\n            this.finishCurrentStep();\n        }\n        this.ignoreChange();\n        /*\n         * Unlike the goBackHistoryStep() function, this function does not trust the\n         * HistoryStep.cursorStart property. This can lead to invalid cursor position errors.\n         * Since this function reverses change-by-change, rather than step-by-step,\n         * the cursor position is based on the start of the last change that is undone.\n         */\n        return lastChange?.start;\n    }\n    /**\n     * Gets the ending cursor position of the last Change of the last Step.\n     *\n     * In practice, this sets the cursor position to the end of\n     * the most recent text change.\n     */\n    getLastChangeEndPosition() {\n        const currentHistoryStep = this.undoStack.getCurrentHistoryStep();\n        if (currentHistoryStep === undefined) {\n            return undefined;\n        }\n        const lastChangeIndex = currentHistoryStep.changes.length;\n        if (lastChangeIndex === 0) {\n            return undefined;\n        }\n        const lastChange = currentHistoryStep.changes[lastChangeIndex - 1];\n        return lastChange.afterRange.end;\n    }\n    getLastHistoryStartPosition() {\n        return this.undoStack.getCurrentHistoryStep()?.cursorStart;\n    }\n    getLastChangeStartPosition() {\n        const currentHistoryStep = this.undoStack.getCurrentHistoryStep();\n        if (currentHistoryStep === undefined) {\n            return undefined;\n        }\n        const changes = currentHistoryStep.changes;\n        if (changes.length === 0) {\n            return undefined;\n        }\n        return changes[changes.length - 1].start;\n    }\n    /**\n     * Logic for `g,` command\n     */\n    nextChangeInChangeList() {\n        return this.changeList.nextChangePosition();\n    }\n    /**\n     * Logic for `g;` command\n     */\n    prevChangeInChangeList() {\n        return this.changeList.prevChangePosition();\n    }\n}\nexports.HistoryTracker = HistoryTracker;\n\n\n//# sourceURL=webpack://vim/./src/history/historyTracker.ts?")},"./src/jumps/jump.ts":(__unused_webpack_module,exports)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Jump = void 0;\n/**\n * Represents a Jump in the JumpTracker.\n * Includes information necessary to determine jump actions,\n * and to be able to open the related file.\n */\nclass Jump {\n    /**\n     *\n     * @param options\n     * @param options.editor - The editor associated with the jump.\n     * @param options.position - The line and column number information.\n     */\n    constructor({ document, position }) {\n        this.document = document;\n        this.position = position;\n    }\n    get fileName() {\n        return this.document.fileName;\n    }\n    /**\n     * Factory method for creating a Jump from a VimState's current cursor position.\n     * @param vimState - State that contains the fileName and position for the jump\n     */\n    static fromStateNow(vimState) {\n        return new Jump({\n            document: vimState.document,\n            position: vimState.cursorStopPosition,\n        });\n    }\n    /**\n     * Factory method for creating a Jump from a VimState's cursor position,\n     * before any actions or commands were performed.\n     * @param vimState - State that contains the fileName and prior position for the jump\n     */\n    static fromStateBefore(vimState) {\n        return new Jump({\n            document: vimState.document,\n            position: vimState.cursorsInitialState[0].stop,\n        });\n    }\n    /**\n     * Determine whether another jump matches the same file path, line number, and character column.\n     * @param other - Another Jump to compare against\n     */\n    isSamePosition(other) {\n        return this.fileName === other.fileName && this.position.isEqual(other.position);\n    }\n}\nexports.Jump = Jump;\n\n\n//# sourceURL=webpack://vim/./src/jumps/jump.ts?")},"./src/jumps/jumpTracker.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.JumpTracker = void 0;\nconst vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));\nconst file_1 = __webpack_require__(/*! ./../cmd_line/commands/file */ "./src/cmd_line/commands/file.ts");\nconst jump_1 = __webpack_require__(/*! ./jump */ "./src/jumps/jump.ts");\nconst fs_1 = __webpack_require__(/*! platform/fs */ "./src/platform/browser/fs.ts");\nconst vscode_1 = __webpack_require__(/*! vscode */ "vscode");\nconst error_1 = __webpack_require__(/*! ../error */ "./src/error.ts");\nconst MAX_JUMPS = 100;\n/**\n * JumpTracker is a handrolled version of VSCode\'s TextEditorState\n * in relation to the \'workbench.action.navigateBack\' command.\n */\nclass JumpTracker {\n    constructor() {\n        this._jumps = [];\n        this._currentJumpNumber = 0;\n        /**\n         * When receiving vscode.window.onDidChangeActiveTextEditor messages,\n         * don\'t record the jump if we initiated the command.\n         *\n         * Either the jump was added, or it was traversing jump history\n         * and shouldn\'t count as a new jump.\n         */\n        this.isJumpingThroughHistory = false;\n    }\n    /**\n     * All recorded jumps, in the order of occurrence.\n     */\n    get jumps() {\n        return this._jumps;\n    }\n    /**\n     * Current position in the list of jumps.\n     * This will be past last index if not traveling through history.\n     */\n    get currentJumpNumber() {\n        return this._currentJumpNumber;\n    }\n    /**\n     * Current jump in the list of jumps.\n     */\n    get currentJump() {\n        return this._jumps[this._currentJumpNumber] || null;\n    }\n    /**\n     * Current jump in the list of jumps.\n     */\n    get hasJumps() {\n        return this._jumps.length > 0;\n    }\n    /**\n     * Last jump in list of jumps.\n     */\n    get end() {\n        return this._jumps[this._jumps.length - 1];\n    }\n    /**\n     * Record that a jump occurred.\n     *\n     * If the current position is back in history,\n     * jumps after this position will be removed.\n     *\n     * @param from - File/position jumped from\n     * @param to - File/position jumped to\n     */\n    recordJump(from, to) {\n        if (to && from.isSamePosition(to)) {\n            return;\n        }\n        this.pushJump(from, to);\n    }\n    /**\n     * Record that a jump occurred from one file to another.\n     * This is likely only needed on a handler for\n     * vscode.window.onDidChangeActiveTextEditor.\n     *\n     * File jumps have extra checks in place, keeping in mind\n     * whether this plugin initiated the jump, whether the new file is\n     * a legitimate file.\n     *\n     * @param from - File/position jumped from\n     * @param to - File/position jumped to\n     */\n    handleFileJump(from, to) {\n        if (this.isJumpingThroughHistory) {\n            this.isJumpingThroughHistory = false;\n            return;\n        }\n        if (to.document.isClosed) {\n            // Wallaby.js seemed to be adding an extra file jump, named e.g. extension-output-#4\n            // It was marked closed when jumping to it. Hopefully we can rely on checking isClosed\n            // when extensions get all weird on us.\n            return;\n        }\n        this.pushJump(from, to);\n    }\n    async performFileJump(jump, vimState) {\n        this.isJumpingThroughHistory = true;\n        if (jump.document) {\n            try {\n                // Open jump file from stored editor\n                await vscode.window.showTextDocument(jump.document);\n            }\n            catch (e) {\n                // This can happen when the document we\'d like to jump to is weird (like a search editor) or has been deleted\n                throw error_1.VimError.fromCode(error_1.ErrorCode.FileNoLongerAvailable);\n            }\n        }\n        else if (await (0, fs_1.existsAsync)(jump.fileName)) {\n            // Open jump file from disk\n            await new file_1.FileCommand({\n                name: \'edit\',\n                bang: false,\n                opt: [],\n                file: jump.fileName,\n                cmd: { type: \'line_number\', line: jump.position.line },\n                createFileIfNotExists: false,\n            }).execute(vimState);\n        }\n        else {\n            // Get jump file from visible editors\n            const editor = vscode.window.visibleTextEditors.filter((e) => e.document.fileName === jump.fileName)[0];\n            if (editor) {\n                await vscode.window.showTextDocument(editor.document, jump.position.character, false);\n            }\n        }\n    }\n    /**\n     * Jump forward, possibly resulting in a file jump\n     */\n    async jumpForward(position, vimState) {\n        await this.jumpThroughHistory(this.recordJumpForward.bind(this), position, vimState);\n    }\n    /**\n     * Jump back, possibly resulting in a file jump\n     */\n    async jumpBack(position, vimState) {\n        await this.jumpThroughHistory(this.recordJumpBack.bind(this), position, vimState);\n    }\n    async jumpThroughHistory(getJump, position, vimState) {\n        let jump = new jump_1.Jump({\n            document: vimState.document,\n            position,\n        });\n        const iterations = vimState.recordedState.count || 1;\n        for (let i = 0; i < iterations; i++) {\n            jump = getJump(jump_1.Jump.fromStateNow(vimState));\n        }\n        if (!jump) {\n            return;\n        }\n        const jumpedFiles = jump.fileName !== vimState.document.fileName;\n        if (jumpedFiles) {\n            await this.performFileJump(jump, vimState);\n        }\n        else {\n            vimState.cursorStopPosition = jump.position;\n        }\n    }\n    /**\n     * Get the previous jump in history.\n     * Continues further back if the current line is on the same line.\n     *\n     * @param from - File/position jumped from\n     */\n    recordJumpBack(from) {\n        if (!this.hasJumps) {\n            return from;\n        }\n        if (this._currentJumpNumber <= 0) {\n            return this._jumps[0];\n        }\n        const to = this._jumps[this._currentJumpNumber - 1];\n        if (this._currentJumpNumber === this._jumps.length) {\n            this.recordJump(from, to);\n            this._currentJumpNumber = this._currentJumpNumber - 2;\n        }\n        else {\n            this._currentJumpNumber = this._currentJumpNumber - 1;\n        }\n        return to;\n    }\n    /**\n     * Get the next jump in history.\n     * Continues further ahead if the current line is on the same line.\n     *\n     * @param from - File/position jumped from\n     */\n    recordJumpForward(from) {\n        if (!this.hasJumps) {\n            return from;\n        }\n        if (this._currentJumpNumber >= this._jumps.length) {\n            return from;\n        }\n        this._currentJumpNumber = Math.min(this._currentJumpNumber + 1, this._jumps.length - 1);\n        return this._jumps[this._currentJumpNumber];\n    }\n    /**\n     * Update existing jumps when lines were added to a document.\n     *\n     * @param document - Document that was changed, typically a vscode.TextDocument.\n     * @param range - Location where the text was added.\n     * @param text - Text containing one or more newline characters.\n     */\n    handleTextAdded(document, range, text) {\n        // Get distance from newlines in the text added.\n        // Unlike handleTextDeleted, the range parameter distance between start/end is generally zero,\n        // just showing where the text was added.\n        const distance = text.split(\'\').filter((c) => c === \'\\n\').length;\n        this._jumps.forEach((jump, i) => {\n            const jumpIsAfterAddedText = jump.fileName === document.fileName && jump.position.line > range.start.line;\n            if (jumpIsAfterAddedText) {\n                const newPosition = new vscode_1.Position(jump.position.line + distance, jump.position.character);\n                this.changePositionForJumpNumber(i, jump, newPosition);\n            }\n        });\n    }\n    /**\n     * Update existing jumps when lines were removed from a document.\n     *\n     * Vim doesn\'t actually remove deleted lines. Instead, it seems to shift line numbers down\n     * for any jumps after the deleted text, and preserves position for jumps on deleted lines or\n     * lines above the deleted lines. After lines are shifted, if there are multiple jumps on a line,\n     * the duplicates are removed, preserving the newest jumps (preserving latest column number).\n     *\n     * Lines are shifted based on number of lines deleted before the jump. So if e.g. the jump is on\n     * a middle line #6, where the jump above and below it were also deleted, the jump position would\n     * move down just one so it is now line #5, based on the line above it being deleted.\n     *\n     * @param document - Document that was changed, typically a vscode.TextDocument.\n     * @param range - Location where the text was removed.\n     */\n    handleTextDeleted(document, range) {\n        // Note that this is like Array.slice, such that range.end.line is one line AFTER a deleted line,\n        // so distance is expected to be at least 1.\n        const distance = range.end.line - range.start.line;\n        for (let i = this._jumps.length - 1; i >= 0; i--) {\n            const jump = this._jumps[i];\n            if (jump.fileName !== document.fileName) {\n                continue;\n            }\n            const jumpIsAfterDeletedText = jump.position.line > range.start.line;\n            if (jumpIsAfterDeletedText) {\n                const newLineShiftedUp = jump.position.line - Math.min(jump.position.line - range.start.line, distance);\n                const newPosition = new vscode_1.Position(newLineShiftedUp, jump.position.character);\n                this.changePositionForJumpNumber(i, jump, newPosition);\n            }\n        }\n        this.removeDuplicateJumps();\n    }\n    /**\n     * Clear existing jumps and reset jump position.\n     */\n    clearJumps() {\n        this._jumps.splice(0, this._jumps.length);\n        this._currentJumpNumber = 0;\n    }\n    pushJump(from, to) {\n        if (from) {\n            this.clearJumpsOnSameLine(from);\n        }\n        if (from && (!to || !from.isSamePosition(to))) {\n            if (this._jumps.length === MAX_JUMPS) {\n                this._jumps.splice(0, 1);\n            }\n            this._jumps.push(from);\n        }\n        this._currentJumpNumber = this._jumps.length;\n    }\n    changePositionForJumpNumber(index, jump, newPosition) {\n        this._jumps.splice(index, 1, new jump_1.Jump({\n            document: jump.document,\n            position: newPosition,\n        }));\n    }\n    clearJumpsOnSameLine(jump) {\n        this._jumps = this._jumps.filter((j) => j === jump || !(j.fileName === jump.fileName && j.position.line === jump.position.line));\n    }\n    removeDuplicateJumps() {\n        const linesSeenPerFile = new Map();\n        for (let i = this._jumps.length - 1; i >= 0; i--) {\n            const jump = this._jumps[i];\n            if (!linesSeenPerFile.has(jump.fileName)) {\n                linesSeenPerFile.set(jump.fileName, []);\n            }\n            const lines = linesSeenPerFile.get(jump.fileName);\n            if (lines.includes(jump.position.line)) {\n                this._jumps.splice(i, 1);\n            }\n            else {\n                lines.push(jump.position.line);\n            }\n        }\n    }\n}\nexports.JumpTracker = JumpTracker;\n\n\n//# sourceURL=webpack://vim/./src/jumps/jumpTracker.ts?')},"./src/mode/mode.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.visualBlockGetBottomRightPosition = exports.visualBlockGetTopLeftPosition = exports.getCursorStyle = exports.isStatusBarMode = exports.isVisualMode = exports.VSCodeVimCursorType = exports.Mode = void 0;\nconst vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));\nconst vscode_1 = __webpack_require__(/*! vscode */ "vscode");\nvar Mode;\n(function (Mode) {\n    Mode[Mode["Normal"] = 0] = "Normal";\n    Mode[Mode["Insert"] = 1] = "Insert";\n    Mode[Mode["Visual"] = 2] = "Visual";\n    Mode[Mode["VisualBlock"] = 3] = "VisualBlock";\n    Mode[Mode["VisualLine"] = 4] = "VisualLine";\n    Mode[Mode["SearchInProgressMode"] = 5] = "SearchInProgressMode";\n    Mode[Mode["CommandlineInProgress"] = 6] = "CommandlineInProgress";\n    Mode[Mode["Replace"] = 7] = "Replace";\n    Mode[Mode["EasyMotionMode"] = 8] = "EasyMotionMode";\n    Mode[Mode["EasyMotionInputMode"] = 9] = "EasyMotionInputMode";\n    Mode[Mode["SurroundInputMode"] = 10] = "SurroundInputMode";\n    Mode[Mode["OperatorPendingMode"] = 11] = "OperatorPendingMode";\n    Mode[Mode["Disabled"] = 12] = "Disabled";\n})(Mode || (exports.Mode = Mode = {}));\nvar VSCodeVimCursorType;\n(function (VSCodeVimCursorType) {\n    VSCodeVimCursorType[VSCodeVimCursorType["Block"] = 0] = "Block";\n    VSCodeVimCursorType[VSCodeVimCursorType["Line"] = 1] = "Line";\n    VSCodeVimCursorType[VSCodeVimCursorType["LineThin"] = 2] = "LineThin";\n    VSCodeVimCursorType[VSCodeVimCursorType["Underline"] = 3] = "Underline";\n    VSCodeVimCursorType[VSCodeVimCursorType["TextDecoration"] = 4] = "TextDecoration";\n    VSCodeVimCursorType[VSCodeVimCursorType["Native"] = 5] = "Native";\n    VSCodeVimCursorType[VSCodeVimCursorType["UnderlineThin"] = 6] = "UnderlineThin";\n})(VSCodeVimCursorType || (exports.VSCodeVimCursorType = VSCodeVimCursorType = {}));\n/**\n * Is the given mode visual, visual line, or visual block?\n */\nfunction isVisualMode(mode) {\n    return [Mode.Visual, Mode.VisualLine, Mode.VisualBlock].includes(mode);\n}\nexports.isVisualMode = isVisualMode;\n/**\n * Is the given mode one where the cursor is on the status bar?\n * This means SearchInProgess and CommandlineInProgress modes.\n */\nfunction isStatusBarMode(mode) {\n    return [Mode.SearchInProgressMode, Mode.CommandlineInProgress].includes(mode);\n}\nexports.isStatusBarMode = isStatusBarMode;\nfunction getCursorStyle(cursorType) {\n    switch (cursorType) {\n        case VSCodeVimCursorType.Block:\n            return vscode.TextEditorCursorStyle.Block;\n        case VSCodeVimCursorType.Line:\n            return vscode.TextEditorCursorStyle.Line;\n        case VSCodeVimCursorType.LineThin:\n            return vscode.TextEditorCursorStyle.LineThin;\n        case VSCodeVimCursorType.Underline:\n            return vscode.TextEditorCursorStyle.Underline;\n        case VSCodeVimCursorType.UnderlineThin:\n            return vscode.TextEditorCursorStyle.UnderlineThin;\n        case VSCodeVimCursorType.TextDecoration:\n            return vscode.TextEditorCursorStyle.LineThin;\n        case VSCodeVimCursorType.Native:\n        default:\n            return vscode.TextEditorCursorStyle.Block;\n    }\n}\nexports.getCursorStyle = getCursorStyle;\nfunction visualBlockGetTopLeftPosition(start, stop) {\n    return new vscode_1.Position(Math.min(start.line, stop.line), Math.min(start.character, stop.character));\n}\nexports.visualBlockGetTopLeftPosition = visualBlockGetTopLeftPosition;\nfunction visualBlockGetBottomRightPosition(start, stop) {\n    return new vscode_1.Position(Math.max(start.line, stop.line), Math.max(start.character, stop.character));\n}\nexports.visualBlockGetBottomRightPosition = visualBlockGetBottomRightPosition;\n\n\n//# sourceURL=webpack://vim/./src/mode/mode.ts?')},"./src/mode/modeHandler.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ModeHandler = void 0;\nconst vscode = __importStar(__webpack_require__(/*! vscode */ \"vscode\"));\nconst process = __importStar(__webpack_require__(/*! process */ \"./node_modules/process/browser.js\"));\nconst vscode_1 = __webpack_require__(/*! vscode */ \"vscode\");\nconst baseMotion_1 = __webpack_require__(/*! ../actions/baseMotion */ \"./src/actions/baseMotion.ts\");\nconst operator_1 = __webpack_require__(/*! ../actions/operator */ \"./src/actions/operator.ts\");\nconst easymotion_1 = __webpack_require__(/*! ../actions/plugins/easymotion/easymotion */ \"./src/actions/plugins/easymotion/easymotion.ts\");\nconst easymotion_cmd_1 = __webpack_require__(/*! ../actions/plugins/easymotion/easymotion.cmd */ \"./src/actions/plugins/easymotion/easymotion.cmd.ts\");\nconst cursor_1 = __webpack_require__(/*! ../common/motion/cursor */ \"./src/common/motion/cursor.ts\");\nconst configuration_1 = __webpack_require__(/*! ../configuration/configuration */ \"./src/configuration/configuration.ts\");\nconst decoration_1 = __webpack_require__(/*! ../configuration/decoration */ \"./src/configuration/decoration.ts\");\nconst notation_1 = __webpack_require__(/*! ../configuration/notation */ \"./src/configuration/notation.ts\");\nconst remapper_1 = __webpack_require__(/*! ../configuration/remapper */ \"./src/configuration/remapper.ts\");\nconst jump_1 = __webpack_require__(/*! ../jumps/jump */ \"./src/jumps/jump.ts\");\nconst globalState_1 = __webpack_require__(/*! ../state/globalState */ \"./src/state/globalState.ts\");\nconst remapState_1 = __webpack_require__(/*! ../state/remapState */ \"./src/state/remapState.ts\");\nconst statusBar_1 = __webpack_require__(/*! ../statusBar */ \"./src/statusBar.ts\");\nconst execute_1 = __webpack_require__(/*! ../transformations/execute */ \"./src/transformations/execute.ts\");\nconst transformations_1 = __webpack_require__(/*! ../transformations/transformations */ \"./src/transformations/transformations.ts\");\nconst decorationUtils_1 = __webpack_require__(/*! ../util/decorationUtils */ \"./src/util/decorationUtils.ts\");\nconst logger_1 = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\");\nconst specialKeys_1 = __webpack_require__(/*! ../util/specialKeys */ \"./src/util/specialKeys.ts\");\nconst util_1 = __webpack_require__(/*! ../util/util */ \"./src/util/util.ts\");\nconst vscodeContext_1 = __webpack_require__(/*! ../util/vscodeContext */ \"./src/util/vscodeContext.ts\");\nconst base_1 = __webpack_require__(/*! ./../actions/base */ \"./src/actions/base.ts\");\nconst actions_1 = __webpack_require__(/*! ./../actions/commands/actions */ \"./src/actions/commands/actions.ts\");\nconst insert_1 = __webpack_require__(/*! ./../actions/commands/insert */ \"./src/actions/commands/insert.ts\");\nconst matcher_1 = __webpack_require__(/*! ./../common/matching/matcher */ \"./src/common/matching/matcher.ts\");\nconst position_1 = __webpack_require__(/*! ./../common/motion/position */ \"./src/common/motion/position.ts\");\nconst error_1 = __webpack_require__(/*! ./../error */ \"./src/error.ts\");\nconst register_1 = __webpack_require__(/*! ./../register/register */ \"./src/register/register.ts\");\nconst recordedState_1 = __webpack_require__(/*! ./../state/recordedState */ \"./src/state/recordedState.ts\");\nconst vimState_1 = __webpack_require__(/*! ./../state/vimState */ \"./src/state/vimState.ts\");\nconst textEditor_1 = __webpack_require__(/*! ./../textEditor */ \"./src/textEditor.ts\");\nconst mode_1 = __webpack_require__(/*! ./mode */ \"./src/mode/mode.ts\");\n/**\n * ModeHandler is the extension's backbone. It listens to events and updates the VimState.\n * One of these exists for each editor - see ModeHandlerMap\n *\n * See:  https://github.com/VSCodeVim/Vim/blob/master/.github/CONTRIBUTING.md#the-vim-state-machine\n */\nclass ModeHandler {\n    get currentMode() {\n        return this._currentMode;\n    }\n    async setCurrentMode(mode) {\n        if (this.vimState.currentMode !== mode) {\n            await this.vimState.setCurrentMode(mode);\n        }\n        this._currentMode = mode;\n    }\n    static async create(handlerMap, textEditor) {\n        const modeHandler = new ModeHandler(handlerMap, textEditor);\n        await modeHandler.vimState.load();\n        await modeHandler.setCurrentMode(configuration_1.configuration.startInInsertMode ? mode_1.Mode.Insert : mode_1.Mode.Normal);\n        modeHandler.syncCursors();\n        return modeHandler;\n    }\n    constructor(handlerMap, textEditor) {\n        this.focusChanged = false;\n        this.disposables = [];\n        /**\n         * Used internally to ignore selection changes that were performed by us.\n         * 'ignoreIntermediateSelections': set to true when running an action, during this time\n         * all selections change events will be ignored.\n         * 'ourSelections': keeps track of our selections that will trigger a selection change event\n         * so that we can ignore them.\n         */\n        this.selectionsChanged = {\n            /**\n             * Set to true when running an action, during this time\n             * all selections change events will be ignored.\n             */\n            ignoreIntermediateSelections: false,\n            /**\n             * keeps track of our selections that will trigger a selection change event\n             * so that we can ignore them.\n             */\n            ourSelections: Array(),\n        };\n        /**\n         * Was the previous mouse click past EOL\n         */\n        this.lastClickWasPastEol = false;\n        this.handlerMap = handlerMap;\n        this.remappers = new remapper_1.Remappers();\n        this.vimState = new vimState_1.VimState(textEditor, new easymotion_1.EasyMotion());\n        this.remapState = new remapState_1.RemapState();\n        this.disposables.push(this.vimState);\n    }\n    /**\n     * Updates VSCodeVim's internal representation of cursors to match VSCode's selections.\n     * This loses some information, so it should only be done when necessary.\n     */\n    syncCursors() {\n        // TODO: getCursorsAfterSync() is basically this, but stupider\n        const { selections } = this.vimState.editor;\n        // TODO: this if block is a workaround for a problem described here https://github.com/VSCodeVim/Vim/pull/8426\n        if (selections.length === 1 &&\n            selections[0].isEqual(new vscode_1.Range(new vscode_1.Position(0, 0), new vscode_1.Position(0, 0)))) {\n            return;\n        }\n        if (!this.vimState.cursorStartPosition.isEqual(selections[0].anchor) ||\n            !this.vimState.cursorStopPosition.isEqual(selections[0].active)) {\n            this.vimState.desiredColumn = selections[0].active.character;\n        }\n        this.vimState.cursors = selections.map(({ active, anchor }) => active.isBefore(anchor) ? new cursor_1.Cursor(anchor.getLeft(), active) : new cursor_1.Cursor(anchor, active));\n    }\n    /**\n     * This is easily the worst function in VSCodeVim.\n     *\n     * We need to know when VSCode has updated our selection, so that we can sync\n     * that internally. Unfortunately, VSCode has a habit of calling this\n     * function at weird times, or or with incomplete information, so we have to\n     * do a lot of voodoo to make sure we're updating the cursors correctly.\n     *\n     * Even worse, we don't even know how to test this stuff.\n     *\n     * Anyone who wants to change the behavior of this method should make sure\n     * all selection related test cases pass. Follow this spec\n     * https://gist.github.com/rebornix/d21d1cc060c009d4430d3904030bd4c1 to\n     * perform the manual testing. Besides this testing you should still test\n     * commands like 'editor.action.smartSelect.grow' and you should test moving\n     * continuously up/down or left/right with and without remapped movement keys\n     * because sometimes vscode lags behind and calls this function with information\n     * that is not up to date with our selections yet and we need to make sure we don't\n     * change our cursors to previous information (this usally is only an issue in visual\n     * mode because of our different ways of handling selections and in those cases\n     * updating our cursors with not up to date info might result in us changing our\n     * cursor start position).\n     */\n    async handleSelectionChange(e) {\n        if (vscode.window.activeTextEditor === undefined ||\n            e.textEditor.document !== vscode.window.activeTextEditor.document) {\n            // we don't care if there is no active editor\n            // or user selection changed in a paneled window (e.g debug console/terminal)\n            // This check is made before enqueuing this selection change, but sometimes\n            // between the enqueueing and the actual calling of this function the editor\n            // might close or change to other document\n            return;\n        }\n        const selection = e.selections[0];\n        logger_1.Logger.debug(`Selection change: ${selection.anchor.toString()}, ${selection.active}, SelectionsLength: ${e.selections.length}`);\n        // If our previous cursors are not included on any of the current selections, then a snippet\n        // must have been inserted.\n        const isSnippetSelectionChange = () => {\n            return e.selections.every((s) => {\n                return this.vimState.cursors.every((c) => !s.contains(new vscode.Range(c.start, c.stop)));\n            });\n        };\n        if ((e.selections.length !== this.vimState.cursors.length || this.vimState.isMultiCursor) &&\n            this.vimState.currentMode !== mode_1.Mode.VisualBlock) {\n            const allowedModes = [mode_1.Mode.Normal];\n            if (!isSnippetSelectionChange()) {\n                allowedModes.push(mode_1.Mode.Insert, mode_1.Mode.Replace);\n            }\n            // Number of selections changed, make sure we know about all of them still\n            this.vimState.cursors = e.textEditor.selections.map((sel) => new cursor_1.Cursor(\n            // Adjust the cursor positions because cursors & selections don't match exactly\n            sel.anchor.isAfter(sel.active) ? sel.anchor.getLeft() : sel.anchor, sel.active));\n            if (e.selections.some((s) => !s.anchor.isEqual(s.active)) &&\n                allowedModes.includes(this.vimState.currentMode)) {\n                // If we got a visual selection and we are on normal, insert or replace mode, enter visual mode.\n                // We shouldn't go to visual mode on any other mode, because the other visual modes are handled\n                // very differently than vscode so only our extension will create them. And the other modes\n                // like the plugin modes shouldn't be changed or else it might mess up the plugins actions.\n                await this.setCurrentMode(mode_1.Mode.Visual);\n            }\n            return this.updateView({ drawSelection: false, revealRange: false });\n        }\n        /**\n         * We only trigger our view updating process if it's a mouse selection.\n         * Otherwise we only update our internal cursor positions accordingly.\n         */\n        if (e.kind !== vscode.TextEditorSelectionChangeKind.Mouse) {\n            if (selection) {\n                if (e.kind === vscode.TextEditorSelectionChangeKind.Command) {\n                    // This 'Command' kind is triggered when using a command like 'editor.action.smartSelect.grow'\n                    // but it is also triggered when we set the 'editor.selections' on 'updateView'.\n                    const allowedModes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n                    if (!isSnippetSelectionChange()) {\n                        // if we just inserted a snippet then don't allow insert modes to go to visual mode\n                        allowedModes.push(mode_1.Mode.Insert, mode_1.Mode.Replace);\n                    }\n                    if (allowedModes.includes(this.vimState.currentMode)) {\n                        // Since the selections weren't ignored then probably we got change of selection from\n                        // a command, so we need to update our start and stop positions. This is where commands\n                        // like 'editor.action.smartSelect.grow' are handled.\n                        if (this.vimState.currentMode === mode_1.Mode.Visual) {\n                            logger_1.Logger.trace('Updating Visual Selection!');\n                            this.vimState.cursorStopPosition = selection.active;\n                            this.vimState.cursorStartPosition = selection.anchor;\n                            await this.updateView({ drawSelection: false, revealRange: false });\n                            return;\n                        }\n                        else if (!selection.active.isEqual(selection.anchor)) {\n                            logger_1.Logger.trace('Creating Visual Selection from command!');\n                            this.vimState.cursorStopPosition = selection.active;\n                            this.vimState.cursorStartPosition = selection.anchor;\n                            await this.setCurrentMode(mode_1.Mode.Visual);\n                            await this.updateView({ drawSelection: false, revealRange: false });\n                            return;\n                        }\n                    }\n                }\n                // Here we are on the selection changed of kind 'Keyboard' or 'undefined' which is triggered\n                // when pressing movement keys that are not caught on the 'type' override but also when using\n                // commands like 'cursorMove'.\n                if ((0, mode_1.isVisualMode)(this.vimState.currentMode)) {\n                    /**\n                     * In Visual Mode, our `cursorPosition` and `cursorStartPosition` can not reflect `active`,\n                     * `start`, `end` and `anchor` information in a selection.\n                     * See `Fake block cursor with text decoration` section of `updateView` method.\n                     * Besides this, sometimes on visual modes our start position is not the same has vscode\n                     * anchor because we need to move vscode anchor one to the right of our start when our start\n                     * is after our stop in order to include the start character on vscodes selection.\n                     */\n                    return;\n                }\n                const cursorEnd = (0, position_1.laterOf)(this.vimState.cursorStartPosition, this.vimState.cursorStopPosition);\n                if (e.textEditor.document.validatePosition(cursorEnd).isBefore(cursorEnd)) {\n                    // The document changed such that our cursor position is now out of bounds, possibly by\n                    // another program. Let's just use VSCode's selection.\n                    // TODO: if this is the case, but we're in visual mode, we never get here (because of branch above)\n                }\n                else if (e.kind === vscode.TextEditorSelectionChangeKind.Keyboard &&\n                    this.vimState.cursorStopPosition.isEqual(this.vimState.cursorStartPosition) &&\n                    this.vimState.cursorStopPosition.getRight().isLineEnd() &&\n                    this.vimState.cursorStopPosition.getLineEnd().isEqual(selection.active)) {\n                    // We get here when we use a 'cursorMove' command (that is considered a selection changed\n                    // kind of 'Keyboard') that ends past the line break. But our cursors are already on last\n                    // character which is what we want. Even though our cursors will be corrected again when\n                    // checking if they are in bounds on 'runAction' there is no need to be changing them back\n                    // and forth so we check for this situation here.\n                    return;\n                }\n                // Here we allow other 'cursorMove' commands to update our cursors in case there is another\n                // extension making cursor changes that we need to catch.\n                //\n                // We still need to be careful with this because this here might be changing our cursors\n                // in ways we don't want to. So with future selection issues this is a good place to start\n                // looking.\n                logger_1.Logger.debug(`Selections: Changing Cursors from selection handler... ${selection.anchor.toString()}, ${selection.active}`);\n                this.vimState.cursorStopPosition = selection.active;\n                this.vimState.cursorStartPosition = selection.anchor;\n                this.vimState.desiredColumn = selection.active.character;\n                await this.updateView({ drawSelection: false, revealRange: false });\n            }\n            return;\n        }\n        if ((0, mode_1.isStatusBarMode)(this.vimState.currentMode)) {\n            return;\n        }\n        let toDraw = false;\n        if (selection) {\n            let newPosition = selection.active;\n            // Only check on a click, not a full selection (to prevent clicking past EOL)\n            if (newPosition.character >= newPosition.getLineEnd().character && selection.isEmpty) {\n                if (this.vimState.currentMode !== mode_1.Mode.Insert) {\n                    this.lastClickWasPastEol = true;\n                    // This prevents you from mouse clicking past the EOL\n                    newPosition = newPosition.withColumn(Math.max(newPosition.getLineEnd().character - 1, 0));\n                    // Switch back to normal mode since it was a click not a selection\n                    await this.setCurrentMode(mode_1.Mode.Normal);\n                    toDraw = true;\n                }\n            }\n            else if (selection.isEmpty) {\n                this.lastClickWasPastEol = false;\n            }\n            this.vimState.cursorStopPosition = newPosition;\n            this.vimState.cursorStartPosition = newPosition;\n            this.vimState.desiredColumn = newPosition.character;\n            // start visual mode?\n            if (selection.anchor.line === selection.active.line &&\n                selection.anchor.character >= newPosition.getLineEnd().character &&\n                selection.active.character >= newPosition.getLineEnd().character) {\n                // This prevents you from selecting EOL\n            }\n            else if (!selection.anchor.isEqual(selection.active)) {\n                let selectionStart = new vscode_1.Position(selection.anchor.line, selection.anchor.character);\n                if (selectionStart.character > selectionStart.getLineEnd().character) {\n                    selectionStart = new vscode_1.Position(selectionStart.line, selectionStart.getLineEnd().character);\n                }\n                this.vimState.cursorStartPosition = selectionStart;\n                if (selectionStart.isAfter(newPosition)) {\n                    this.vimState.cursorStartPosition = this.vimState.cursorStartPosition.getLeft();\n                }\n                // If we prevented from clicking past eol but it is part of this selection, include the last char\n                if (this.lastClickWasPastEol) {\n                    const newStart = new vscode_1.Position(selection.anchor.line, selection.anchor.character + 1);\n                    this.vimState.editor.selection = new vscode.Selection(newStart, selection.active);\n                    this.vimState.cursorStartPosition = selectionStart;\n                    this.lastClickWasPastEol = false;\n                }\n                if (configuration_1.configuration.mouseSelectionGoesIntoVisualMode &&\n                    !(0, mode_1.isVisualMode)(this.vimState.currentMode) &&\n                    this.currentMode !== mode_1.Mode.Insert) {\n                    await this.setCurrentMode(mode_1.Mode.Visual);\n                    // double click mouse selection causes an extra character to be selected so take one less character\n                }\n            }\n            else if (this.vimState.currentMode !== mode_1.Mode.Insert) {\n                await this.setCurrentMode(mode_1.Mode.Normal);\n            }\n            void this.updateView({ drawSelection: toDraw, revealRange: false });\n        }\n    }\n    async handleMultipleKeyEvents(keys) {\n        for (const key of keys) {\n            await this.handleKeyEvent(key);\n        }\n    }\n    async handleKeyEvent(key) {\n        if (this.remapState.forceStopRecursiveRemapping) {\n            return;\n        }\n        const now = Date.now();\n        const printableKey = notation_1.Notation.printableKey(key, configuration_1.configuration.leader);\n        logger_1.Logger.debug(`Handling key: ${printableKey}`);\n        if ((key === specialKeys_1.SpecialKeys.TimeoutFinished ||\n            this.vimState.recordedState.bufferedKeys.length > 0) &&\n            this.vimState.recordedState.bufferedKeysTimeoutObj) {\n            // Handle the bufferedKeys or append the new key to the previously bufferedKeys\n            clearTimeout(this.vimState.recordedState.bufferedKeysTimeoutObj);\n            this.vimState.recordedState.bufferedKeysTimeoutObj = undefined;\n            this.vimState.recordedState.commandList = [...this.vimState.recordedState.bufferedKeys];\n            this.vimState.recordedState.bufferedKeys = [];\n        }\n        // rewrite copy\n        if (configuration_1.configuration.overrideCopy) {\n            // The conditions when you trigger a \"copy\" rather than a ctrl-c are\n            // too sophisticated to be covered by the \"when\" condition in package.json\n            if (key === '<D-c>') {\n                key = '<copy>';\n            }\n            if (key === '<C-c>' && process.platform !== 'darwin') {\n                if (!configuration_1.configuration.useCtrlKeys ||\n                    this.vimState.currentMode === mode_1.Mode.Visual ||\n                    this.vimState.currentMode === mode_1.Mode.VisualBlock ||\n                    this.vimState.currentMode === mode_1.Mode.VisualLine) {\n                    key = '<copy>';\n                }\n            }\n        }\n        // <C-d> triggers \"add selection to next find match\" by default,\n        // unless users explicity make <C-d>: true\n        // TODO: Destroy this silliness\n        if (key === '<C-d>' && !(configuration_1.configuration.handleKeys['<C-d>'] === true)) {\n            key = '<D-d>';\n        }\n        this.vimState.cursorsInitialState = this.vimState.cursors;\n        this.vimState.recordedState.commandList.push(key);\n        const oldMode = this.vimState.currentMode;\n        const oldFullMode = this.vimState.currentModeIncludingPseudoModes;\n        const oldStatusBarText = statusBar_1.StatusBar.getText();\n        const oldWaitingForAnotherActionKey = this.vimState.recordedState.waitingForAnotherActionKey;\n        let handledAsRemap = false;\n        let handledAsAction = false;\n        try {\n            // Handling special case for '0'. From Vim documentation (:help :map-modes)\n            // Special case: While typing a count for a command in Normal mode, mapping zero\n            // is disabled. This makes it possible to map zero without making it impossible\n            // to type a count with a zero.\n            const preventZeroRemap = key === '0' &&\n                this.vimState.recordedState.actionsRun[this.vimState.recordedState.actionsRun.length - 1] instanceof actions_1.CommandNumber;\n            // Check for remapped keys if:\n            // 1. We are not currently performing a non-recursive remapping\n            // 2. We are not typing '0' after starting to type a count\n            // 3. We are not waiting for another action key\n            //    Example: jj should not remap the second 'j', if jj -> <Esc> in insert mode\n            //             0 should not be remapped if typed after another number, like 10\n            //             for actions with multiple keys like 'gg' or 'fx' the second character\n            //           shouldn't be mapped\n            if (!this.remapState.isCurrentlyPerformingNonRecursiveRemapping &&\n                !preventZeroRemap &&\n                !this.vimState.recordedState.waitingForAnotherActionKey) {\n                handledAsRemap = await this.remappers.sendKey(this.vimState.recordedState.commandList, this);\n            }\n            this.vimState.recordedState.allowPotentialRemapOnFirstKey = true;\n            if (!handledAsRemap) {\n                if (key === specialKeys_1.SpecialKeys.TimeoutFinished) {\n                    // Remove the <TimeoutFinished> key and get the key before that. If the <TimeoutFinished>\n                    // key was the last key, then 'key' will be undefined and won't be sent to handle action.\n                    this.vimState.recordedState.commandList.pop();\n                    key =\n                        this.vimState.recordedState.commandList[this.vimState.recordedState.commandList.length - 1];\n                }\n                if (key !== undefined) {\n                    handledAsAction = await this.handleKeyAsAnAction(key);\n                }\n            }\n        }\n        catch (e) {\n            this.selectionsChanged.ignoreIntermediateSelections = false;\n            if (e instanceof error_1.VimError) {\n                statusBar_1.StatusBar.displayError(this.vimState, e);\n                this.vimState.recordedState = new recordedState_1.RecordedState();\n                if (this.remapState.isCurrentlyPerformingRemapping) {\n                    // If we are handling a remap and we got a VimError stop handling the remap\n                    // and discard the rest of the keys. We throw an Exception here to stop any other\n                    // remapping handling steps and go straight to the 'finally' step of the remapper.\n                    throw error_1.ForceStopRemappingError.fromVimError(e);\n                }\n            }\n            else if (e instanceof error_1.ForceStopRemappingError) {\n                // If this is a ForceStopRemappingError rethrow it until it gets to the remapper\n                throw e;\n            }\n            else if (e instanceof Error) {\n                e.message = `Failed to handle key \\`${key}\\`: ${e.message}`;\n                throw e;\n            }\n            else {\n                throw new Error(`Failed to handle key \\`${key}\\` due to an unknown error.`);\n            }\n        }\n        this.remapState.lastKeyPressedTimestamp = now;\n        statusBar_1.StatusBar.updateShowCmd(this.vimState);\n        // We don't want to immediately erase any message that resulted from the action just performed\n        if (statusBar_1.StatusBar.getText() === oldStatusBarText) {\n            // Clear the status bar of high priority messages if the mode has changed, the view has scrolled\n            // or it is recording a Macro\n            const forceClearStatusBar = (this.vimState.currentMode !== oldMode && this.vimState.currentMode !== mode_1.Mode.Normal) ||\n                this.vimState.macro !== undefined;\n            statusBar_1.StatusBar.clear(this.vimState, forceClearStatusBar);\n        }\n        // We either already ran an action or we have a potential action to run but\n        // the key is already stored on 'actionKeys' in that case we don't need it\n        // anymore on commandList that is only used for the remapper and 'showCmd'\n        // and both had already been handled at this point.\n        // If we got here it means that there is no potential remap for the key\n        // either so we need to clear it from commandList so that it doesn't interfere\n        // with the next remapper check.\n        this.vimState.recordedState.resetCommandList();\n        logger_1.Logger.trace(`handleKeyEvent('${printableKey}') took ${Date.now() - now}ms`);\n        // If we are handling a remap and the last movement failed stop handling the remap\n        // and discard the rest of the keys. We throw an Exception here to stop any other\n        // remapping handling steps and go straight to the 'finally' step of the remapper.\n        if (this.remapState.isCurrentlyPerformingRemapping && this.vimState.lastMovementFailed) {\n            this.vimState.lastMovementFailed = false;\n            throw new error_1.ForceStopRemappingError('Last movement failed');\n        }\n        // Reset lastMovementFailed. Anyone who needed it has probably already handled it.\n        // And keeping it past this point would make any following remapping force stop.\n        this.vimState.lastMovementFailed = false;\n        if (!handledAsAction) {\n            // There was no action run yet but we still want to update the view to be able\n            // to show the potential remapping keys being pressed, the `\"` character when\n            // waiting on a register key or the `?` character and any following character\n            // when waiting on digraph keys. The 'oldWaitingForAnotherActionKey' is used\n            // to call the updateView after we are no longer waiting keys so that any\n            // existing overlapped key is removed.\n            if (((this.vimState.currentMode === mode_1.Mode.Insert ||\n                this.vimState.currentMode === mode_1.Mode.Replace) &&\n                (this.vimState.recordedState.bufferedKeys.length > 0 ||\n                    this.vimState.recordedState.waitingForAnotherActionKey ||\n                    this.vimState.recordedState.waitingForAnotherActionKey !==\n                        oldWaitingForAnotherActionKey)) ||\n                this.vimState.currentModeIncludingPseudoModes !== oldFullMode) {\n                // TODO: this call to updateView is only used to update the virtualCharacter and halfBlock\n                // cursor decorations, if in the future we split up the updateView function there should\n                // be no need to call all of it.\n                await this.updateView({ drawSelection: false, revealRange: false });\n            }\n        }\n    }\n    async handleKeyAsAnAction(key) {\n        if (vscode.window.activeTextEditor !== this.vimState.editor) {\n            logger_1.Logger.warn('Current window is not active');\n            return false;\n        }\n        // Catch any text change not triggered by us (example: tab completion).\n        this.vimState.historyTracker.addChange();\n        const recordedState = this.vimState.recordedState;\n        recordedState.actionKeys.push(key);\n        const action = (0, base_1.getRelevantAction)(recordedState.actionKeys, this.vimState);\n        switch (action) {\n            case base_1.KeypressState.NoPossibleMatch:\n                if (this.vimState.currentMode === mode_1.Mode.Insert) {\n                    this.vimState.recordedState.actionKeys = [];\n                }\n                else {\n                    this.vimState.recordedState = new recordedState_1.RecordedState();\n                }\n                // Since there is no possible action we are no longer waiting any action keys\n                this.vimState.recordedState.waitingForAnotherActionKey = false;\n                return false;\n            case base_1.KeypressState.WaitingOnKeys:\n                this.vimState.recordedState.waitingForAnotherActionKey = true;\n                return false;\n        }\n        if (!this.remapState.remapUsedACharacter &&\n            this.remapState.isCurrentlyPerformingRecursiveRemapping) {\n            // Used a character inside a recursive remapping so we reset the mapDepth.\n            this.remapState.remapUsedACharacter = true;\n            this.remapState.mapDepth = 0;\n        }\n        // Since we got an action we are no longer waiting any action keys\n        this.vimState.recordedState.waitingForAnotherActionKey = false;\n        // Store action pressed keys for showCmd\n        recordedState.actionsRunPressedKeys.push(...recordedState.actionKeys);\n        let actionToRecord = action;\n        if (recordedState.actionsRun.length === 0) {\n            recordedState.actionsRun.push(action);\n        }\n        else {\n            const lastAction = recordedState.actionsRun[recordedState.actionsRun.length - 1];\n            const actionCanBeMergedWithDocumentChange = action instanceof insert_1.CommandInsertInInsertMode ||\n                action instanceof insert_1.CommandBackspaceInInsertMode ||\n                action instanceof insert_1.CommandInsertPreviousText ||\n                action instanceof insert_1.InsertCharAbove ||\n                action instanceof insert_1.InsertCharBelow;\n            if (lastAction instanceof actions_1.DocumentContentChangeAction) {\n                if (!(action instanceof insert_1.CommandEscInsertMode)) {\n                    // TODO: this includes things like <BS>, which it shouldn't\n                    lastAction.keysPressed.push(key);\n                }\n                if (actionCanBeMergedWithDocumentChange) {\n                    // delay the macro recording\n                    actionToRecord = undefined;\n                }\n                else {\n                    // Push document content change to the stack\n                    lastAction.addChanges(this.vimState.historyTracker.currentContentChanges, this.vimState.cursorStopPosition);\n                    this.vimState.historyTracker.currentContentChanges = [];\n                    recordedState.actionsRun.push(action);\n                }\n            }\n            else {\n                if (actionCanBeMergedWithDocumentChange) {\n                    // This means we are already in Insert Mode but there is still not DocumentContentChangeAction in stack\n                    this.vimState.historyTracker.currentContentChanges = [];\n                    const newContentChange = new actions_1.DocumentContentChangeAction(this.vimState.cursorStopPosition);\n                    newContentChange.keysPressed.push(key);\n                    recordedState.actionsRun.push(newContentChange);\n                    actionToRecord = newContentChange;\n                }\n                else {\n                    recordedState.actionsRun.push(action);\n                }\n            }\n        }\n        if (this.vimState.macro !== undefined &&\n            actionToRecord &&\n            !(actionToRecord instanceof actions_1.CommandQuitRecordMacro)) {\n            this.vimState.macro.actionsRun.push(actionToRecord);\n        }\n        await this.runAction(recordedState, action);\n        if (this.vimState.currentMode === mode_1.Mode.Insert) {\n            recordedState.isInsertion = true;\n        }\n        // Update view\n        await this.updateView();\n        if (action.isJump) {\n            globalState_1.globalState.jumpTracker.recordJump(jump_1.Jump.fromStateBefore(this.vimState), jump_1.Jump.fromStateNow(this.vimState));\n        }\n        return true;\n    }\n    async runAction(recordedState, action) {\n        this.selectionsChanged.ignoreIntermediateSelections = true;\n        // We handle the end of selections different to VSCode. In order for VSCode to select\n        // including the last character we will at the end of 'runAction' shift our stop position\n        // to the right. So here we shift it back by one so that our actions have our correct\n        // position instead of the position sent to VSCode.\n        if (this.vimState.currentMode === mode_1.Mode.Visual) {\n            this.vimState.cursors = this.vimState.cursors.map((c) => c.start.isBefore(c.stop) ? c.withNewStop(c.stop.getLeftThroughLineBreaks(true)) : c);\n        }\n        // Make sure all cursors are within the document's bounds before running any action\n        // It's not 100% clear to me that this is the correct place to do this, but it should solve a lot of issues\n        this.vimState.cursors = this.vimState.cursors.map((c) => new cursor_1.Cursor(this.vimState.document.validatePosition(c.start), this.vimState.document.validatePosition(c.stop)));\n        let ranRepeatableAction = false;\n        let ranAction = false;\n        if (action instanceof baseMotion_1.BaseMovement) {\n            recordedState = await this.executeMovement(action);\n            ranAction = true;\n        }\n        else if (action instanceof base_1.BaseCommand) {\n            await action.execCount(this.vimState.cursorStopPosition, this.vimState);\n            const transformer = this.vimState.recordedState.transformer;\n            await (0, execute_1.executeTransformations)(this, transformer.transformations);\n            if (action.isCompleteAction) {\n                ranAction = true;\n            }\n            if (action.createsUndoPoint) {\n                ranRepeatableAction = true;\n            }\n        }\n        else if (action instanceof operator_1.BaseOperator) {\n            recordedState.operatorCount = recordedState.count;\n        }\n        else {\n            throw new Error('Unknown action type');\n        }\n        // Update mode (note the ordering allows you to go into search mode,\n        // then return and have the motion immediately applied to an operator).\n        const prevMode = this.currentMode;\n        if (this.vimState.currentMode !== this.currentMode) {\n            await this.setCurrentMode(this.vimState.currentMode);\n            // We don't want to mark any searches as a repeatable action\n            if (this.vimState.currentMode === mode_1.Mode.Normal &&\n                prevMode !== mode_1.Mode.SearchInProgressMode &&\n                prevMode !== mode_1.Mode.EasyMotionInputMode &&\n                prevMode !== mode_1.Mode.EasyMotionMode) {\n                ranRepeatableAction = true;\n            }\n        }\n        // If there's an operator pending and we have a motion or visual selection, run the operator\n        if (recordedState.getOperatorState(this.vimState.currentMode) === 'ready') {\n            const operator = this.vimState.recordedState.operator;\n            if (operator) {\n                await this.executeOperator();\n                this.vimState.recordedState.hasRunOperator = true;\n                ranRepeatableAction = operator.createsUndoPoint;\n                ranAction = true;\n            }\n        }\n        // And then we have to do it again because an operator could\n        // have changed it as well. (TODO: do you even decomposition bro)\n        if (this.vimState.currentMode !== this.currentMode) {\n            await this.setCurrentMode(this.vimState.currentMode);\n            if (this.vimState.currentMode === mode_1.Mode.Normal) {\n                ranRepeatableAction = true;\n            }\n        }\n        ranRepeatableAction =\n            (ranRepeatableAction && this.vimState.currentMode === mode_1.Mode.Normal) ||\n                this.createUndoPointForBrackets();\n        // We don't want to record a repeatable action when exiting from these modes\n        // by pressing <Esc>\n        if ((prevMode === mode_1.Mode.Visual ||\n            prevMode === mode_1.Mode.VisualBlock ||\n            prevMode === mode_1.Mode.VisualLine ||\n            prevMode === mode_1.Mode.CommandlineInProgress) &&\n            action.keysPressed[0] === '<Esc>') {\n            ranRepeatableAction = false;\n        }\n        // Record down previous action and flush temporary state\n        if (ranRepeatableAction && this.vimState.lastCommandDotRepeatable) {\n            globalState_1.globalState.previousFullAction = this.vimState.recordedState;\n            if (recordedState.isInsertion) {\n                register_1.Register.setReadonlyRegister('.', recordedState);\n            }\n        }\n        this.vimState.lastCommandDotRepeatable = true;\n        // Update desiredColumn\n        const preservesDesiredColumn = action instanceof operator_1.BaseOperator && !ranAction ? true : action.preservesDesiredColumn;\n        if (!preservesDesiredColumn) {\n            if (action instanceof baseMotion_1.BaseMovement) {\n                // We check !operator here because e.g. d$ should NOT set the desired column to EOL.\n                if (action.setsDesiredColumnToEOL && !recordedState.operator) {\n                    this.vimState.desiredColumn = Number.POSITIVE_INFINITY;\n                }\n                else {\n                    this.vimState.desiredColumn = this.vimState.cursorStopPosition.character;\n                }\n            }\n            else if (this.vimState.currentMode !== mode_1.Mode.VisualBlock) {\n                // TODO: explain why not VisualBlock\n                this.vimState.desiredColumn = this.vimState.cursorStopPosition.character;\n            }\n        }\n        // Like previously stated we handle the end of selections different to VSCode. In order\n        // for VSCode to select including the last character we shift our stop position to the\n        // right now that all steps that need that position have already run. On the next action\n        // we will shift it back again on the start of 'runAction'.\n        if (this.vimState.currentMode === mode_1.Mode.Visual) {\n            this.vimState.cursors = this.vimState.cursors.map((c) => c.start.isBeforeOrEqual(c.stop)\n                ? c.withNewStop(c.stop.isLineEnd() ? c.stop.getRightThroughLineBreaks() : c.stop.getRight())\n                : c);\n        }\n        // We've run a complete action sequence - wipe the slate clean with a new RecordedState\n        if (ranAction && this.vimState.currentMode === mode_1.Mode.Normal) {\n            this.vimState.recordedState = new recordedState_1.RecordedState();\n            // Return to insert mode after 1 command in this case for <C-o>\n            if (this.vimState.returnToInsertAfterCommand) {\n                if (this.vimState.actionCount > 0) {\n                    await this.setCurrentMode(mode_1.Mode.Insert);\n                }\n                else {\n                    this.vimState.actionCount++;\n                }\n            }\n        }\n        // track undo history\n        if (!this.focusChanged) {\n            // important to ensure that focus didn't change, otherwise\n            // we'll grab the text of the incorrect active window and assume the\n            // whole document changed!\n            this.vimState.historyTracker.addChange();\n        }\n        // Don't record an undo point for every action of a macro, only at the very end\n        if (ranRepeatableAction &&\n            !this.vimState.isReplayingMacro &&\n            !this.remapState.isCurrentlyPerformingRemapping) {\n            this.vimState.historyTracker.finishCurrentStep();\n        }\n        recordedState.actionKeys = [];\n        this.vimState.currentRegisterMode = undefined;\n        // If we're in Normal mode, collapse each cursor down to one character\n        if (this.currentMode === mode_1.Mode.Normal) {\n            this.vimState.cursors = this.vimState.cursors.map((cursor) => new cursor_1.Cursor(cursor.stop, cursor.stop));\n        }\n        // Ensure cursors are within bounds\n        if (!this.vimState.document.isClosed &&\n            this.vimState.editor === vscode.window.activeTextEditor) {\n            const documentEndPosition = textEditor_1.TextEditor.getDocumentEnd(this.vimState.document);\n            const documentLineCount = this.vimState.document.lineCount;\n            this.vimState.cursors = this.vimState.cursors.map((cursor) => {\n                // adjust start/stop\n                if (cursor.start.line >= documentLineCount) {\n                    cursor = cursor.withNewStart(documentEndPosition);\n                }\n                if (cursor.stop.line >= documentLineCount) {\n                    cursor = cursor.withNewStop(documentEndPosition);\n                }\n                // adjust column\n                if (this.vimState.currentMode === mode_1.Mode.Normal || (0, mode_1.isVisualMode)(this.vimState.currentMode)) {\n                    const currentLineLength = textEditor_1.TextEditor.getLineLength(cursor.stop.line);\n                    const currentStartLineLength = textEditor_1.TextEditor.getLineLength(cursor.start.line);\n                    // When in visual mode you can move the cursor past the last character in order\n                    // to select that character. We use this offset to allow for that, otherwise\n                    // we would consider the position invalid and change it to the left of the last\n                    // character.\n                    const offsetAllowed = (0, mode_1.isVisualMode)(this.vimState.currentMode) && currentLineLength > 0 ? 1 : 0;\n                    if (cursor.start.character >= currentStartLineLength) {\n                        cursor = cursor.withNewStart(cursor.start.withColumn(Math.max(currentStartLineLength - 1, 0)));\n                    }\n                    if (cursor.stop.character >= currentLineLength + offsetAllowed) {\n                        cursor = cursor.withNewStop(cursor.stop.withColumn(Math.max(currentLineLength - 1, 0)));\n                    }\n                }\n                return cursor;\n            });\n        }\n        if ((0, mode_1.isVisualMode)(this.vimState.currentMode) && !this.vimState.isRunningDotCommand) {\n            // Store selection for commands like gv\n            this.vimState.lastVisualSelection = {\n                mode: this.vimState.currentMode,\n                start: this.vimState.cursorStartPosition,\n                end: this.vimState.cursorStopPosition,\n            };\n        }\n        this.selectionsChanged.ignoreIntermediateSelections = false;\n    }\n    async executeMovement(movement) {\n        this.vimState.lastMovementFailed = false;\n        const recordedState = this.vimState.recordedState;\n        const cursorsToRemove = [];\n        for (let i = 0; i < this.vimState.cursors.length; i++) {\n            /**\n             * Essentially what we're doing here is pretending like the\n             * current VimState only has one cursor (the cursor that we just\n             * iterated to).\n             *\n             * We set the cursor position to be equal to the iterated one,\n             * and then set it back immediately after we're done.\n             *\n             * The slightly more complicated logic here allows us to write\n             * Action definitions without having to think about multiple\n             * cursors in almost all cases.\n             */\n            const oldCursorPositionStart = this.vimState.cursorStartPosition;\n            const oldCursorPositionStop = this.vimState.cursorStopPosition;\n            movement.multicursorIndex = i;\n            this.vimState.cursorStartPosition = this.vimState.cursors[i].start;\n            const cursorPosition = this.vimState.cursors[i].stop;\n            this.vimState.cursorStopPosition = cursorPosition;\n            const result = await movement.execActionWithCount(cursorPosition, this.vimState, recordedState.count);\n            // We also need to update the specific cursor, in case the cursor position was modified inside\n            // the handling functions (e.g. 'it')\n            this.vimState.cursors[i] = new cursor_1.Cursor(this.vimState.cursorStartPosition, this.vimState.cursorStopPosition);\n            this.vimState.cursorStartPosition = oldCursorPositionStart;\n            this.vimState.cursorStopPosition = oldCursorPositionStop;\n            if (result instanceof vscode_1.Position) {\n                this.vimState.cursors[i] = this.vimState.cursors[i].withNewStop(result);\n                if (!(0, mode_1.isVisualMode)(this.currentMode) && !this.vimState.recordedState.operator) {\n                    this.vimState.cursors[i] = this.vimState.cursors[i].withNewStart(result);\n                }\n            }\n            else {\n                if (result.failed) {\n                    this.vimState.recordedState = new recordedState_1.RecordedState();\n                    this.vimState.lastMovementFailed = true;\n                }\n                if (result.removed) {\n                    cursorsToRemove.push(i);\n                }\n                else {\n                    this.vimState.cursors[i] = new cursor_1.Cursor(result.start, result.stop);\n                }\n            }\n        }\n        if (cursorsToRemove.length > 0) {\n            // Remove the cursors that no longer exist. Remove from the end to the start\n            // so that the index values don't change.\n            for (let i = cursorsToRemove.length - 1; i >= 0; i--) {\n                const idx = cursorsToRemove[i];\n                if (idx !== 0) {\n                    // We should never remove the main selection! This shouldn't happen, but just\n                    // in case it does, lets protect against it. Remember kids, always use protection!\n                    this.vimState.cursors.splice(idx, 1);\n                }\n            }\n        }\n        this.vimState.recordedState.count = 0;\n        // Keep the cursor within bounds\n        if (this.vimState.currentMode !== mode_1.Mode.Normal || recordedState.operator) {\n            const stop = this.vimState.cursorStopPosition;\n            // Vim does this weird thing where it allows you to select and delete\n            // the newline character, which it places 1 past the last character\n            // in the line. This is why we use > instead of >=.\n            if (stop.character > textEditor_1.TextEditor.getLineLength(stop.line)) {\n                this.vimState.cursorStopPosition = stop.getLineEnd();\n            }\n        }\n        return recordedState;\n    }\n    async executeOperator() {\n        const recordedState = this.vimState.recordedState;\n        const operator = recordedState.operator;\n        // TODO - if actions were more pure, this would be unnecessary.\n        const startingMode = this.vimState.currentMode;\n        const startingRegisterMode = this.vimState.currentRegisterMode;\n        const resultingCursors = [];\n        for (let [i, { start, stop }] of this.vimState.cursors.entries()) {\n            operator.multicursorIndex = i;\n            if (start.isAfter(stop)) {\n                [start, stop] = [stop, start];\n            }\n            if (!(0, mode_1.isVisualMode)(startingMode) && startingRegisterMode !== register_1.RegisterMode.LineWise) {\n                stop = stop.getLeftThroughLineBreaks(true);\n            }\n            if (this.currentMode === mode_1.Mode.VisualLine) {\n                start = start.getLineBegin();\n                stop = stop.getLineEnd();\n                this.vimState.currentRegisterMode = register_1.RegisterMode.LineWise;\n            }\n            await this.vimState.setCurrentMode(startingMode);\n            // We run the repeat version of an operator if the last 2 operators are the same.\n            if (recordedState.operators.length > 1 &&\n                recordedState.operators.reverse()[0].constructor ===\n                    recordedState.operators.reverse()[1].constructor) {\n                await operator.runRepeat(this.vimState, start, recordedState.count);\n            }\n            else {\n                await operator.run(this.vimState, start, stop);\n            }\n            for (const transformation of this.vimState.recordedState.transformer.transformations) {\n                if ((0, transformations_1.isTextTransformation)(transformation) && transformation.cursorIndex === undefined) {\n                    transformation.cursorIndex = operator.multicursorIndex;\n                }\n            }\n            const resultingCursor = new cursor_1.Cursor(this.vimState.cursorStartPosition, this.vimState.cursorStopPosition);\n            resultingCursors.push(resultingCursor);\n        }\n        if (this.vimState.recordedState.transformer.transformations.length > 0) {\n            const transformer = this.vimState.recordedState.transformer;\n            await (0, execute_1.executeTransformations)(this, transformer.transformations);\n        }\n        else {\n            // Keep track of all cursors (in the case of multi-cursor).\n            this.vimState.cursors = resultingCursors;\n        }\n    }\n    async rerunRecordedState(recordedState) {\n        const actions = [...recordedState.actionsRun];\n        this.vimState.isRunningDotCommand = true;\n        // If a previous visual selection exists, store it for use in replay of some commands\n        if (this.vimState.lastVisualSelection) {\n            this.vimState.dotCommandPreviousVisualSelection = new vscode.Selection(this.vimState.lastVisualSelection.start, this.vimState.lastVisualSelection.end);\n        }\n        recordedState = new recordedState_1.RecordedState();\n        this.vimState.recordedState = recordedState;\n        for (const [i, action] of actions.entries()) {\n            recordedState.actionsRun = actions.slice(0, i + 1);\n            await this.runAction(recordedState, action);\n            if (this.vimState.lastMovementFailed) {\n                // TODO: Shouldn't this be `break`? Can't this leave us in a very bad state?\n                return;\n            }\n            await this.updateView();\n        }\n        recordedState.actionsRun = actions;\n        this.vimState.isRunningDotCommand = false;\n    }\n    async runMacro(recordedMacro) {\n        let recordedState = new recordedState_1.RecordedState();\n        this.vimState.recordedState = recordedState;\n        this.vimState.isRunningDotCommand = true;\n        for (const action of recordedMacro.actionsRun) {\n            const originalLocation = jump_1.Jump.fromStateNow(this.vimState);\n            this.vimState.cursorsInitialState = this.vimState.cursors;\n            recordedState.actionsRun.push(action);\n            await this.runAction(recordedState, action);\n            // We just finished a full action; let's clear out our current state.\n            if (this.vimState.recordedState.actionsRun.length === 0) {\n                recordedState = new recordedState_1.RecordedState();\n                this.vimState.recordedState = recordedState;\n            }\n            if (this.vimState.lastMovementFailed) {\n                break;\n            }\n            await this.updateView();\n            if (action.isJump) {\n                globalState_1.globalState.jumpTracker.recordJump(originalLocation, jump_1.Jump.fromStateNow(this.vimState));\n            }\n        }\n        this.vimState.isRunningDotCommand = false;\n        this.vimState.cursorsInitialState = this.vimState.cursors;\n    }\n    updateSearchHighlights(showHighlights) {\n        const cacheKey = this.searchDecorationCacheKey;\n        this.searchDecorationCacheKey = undefined;\n        let decorations;\n        if (showHighlights) {\n            if (this.vimState.modeData.mode === mode_1.Mode.CommandlineInProgress ||\n                this.vimState.modeData.mode === mode_1.Mode.SearchInProgressMode) {\n                decorations = this.vimState.modeData.commandLine.getDecorations(this.vimState);\n            }\n            else if (globalState_1.globalState.searchState) {\n                if (cacheKey &&\n                    cacheKey.searchString === globalState_1.globalState.searchState.searchString &&\n                    cacheKey.documentVersion === this.vimState.document.version) {\n                    // The decorations are fine as-is, don't waste time re-calculating\n                    this.searchDecorationCacheKey = cacheKey;\n                    return;\n                }\n                // If there are no decorations from the command line, get decorations for previous SearchState\n                decorations = (0, decorationUtils_1.getDecorationsForSearchMatchRanges)(globalState_1.globalState.searchState.getMatchRanges(this.vimState));\n                this.searchDecorationCacheKey = {\n                    searchString: globalState_1.globalState.searchState.searchString,\n                    documentVersion: this.vimState.document.version,\n                };\n            }\n        }\n        this.vimState.editor.setDecorations(decoration_1.decoration.searchHighlight, decorations?.searchHighlight ?? []);\n        this.vimState.editor.setDecorations(decoration_1.decoration.searchMatch, decorations?.searchMatch ?? []);\n        this.vimState.editor.setDecorations(decoration_1.decoration.substitutionAppend, decorations?.substitutionAppend ?? []);\n        this.vimState.editor.setDecorations(decoration_1.decoration.substitutionReplace, decorations?.substitutionReplace ?? []);\n    }\n    async updateView(args = {\n        drawSelection: true,\n        revealRange: true,\n    }) {\n        // Draw selection (or cursor)\n        if (args.drawSelection) {\n            let selectionMode = this.vimState.currentMode;\n            if (this.vimState.modeData.mode === mode_1.Mode.SearchInProgressMode) {\n                selectionMode = this.vimState.modeData.commandLine.previousMode;\n            }\n            else if (this.vimState.modeData.mode === mode_1.Mode.CommandlineInProgress) {\n                selectionMode = this.vimState.modeData.commandLine.previousMode;\n            }\n            else if (this.vimState.modeData.mode === mode_1.Mode.SurroundInputMode) {\n                selectionMode = this.vimState.surround.previousMode;\n            }\n            let selections = [];\n            for (const cursor of this.vimState.cursors) {\n                let { start, stop } = cursor;\n                switch (selectionMode) {\n                    case mode_1.Mode.Visual:\n                        /**\n                         * Always select the letter that we started visual mode on, no matter\n                         * if we are in front or behind it. Imagine that we started visual mode\n                         * with some text like this:\n                         *\n                         *   abc|def\n                         *\n                         * (The | represents the cursor.) If we now press w, we'll select def,\n                         * but if we hit b we expect to select abcd, so we need to getRight() on the\n                         * start of the selection when it precedes where we started visual mode.\n                         */\n                        if (start.isAfterOrEqual(stop)) {\n                            start = start.getRight();\n                        }\n                        selections.push(new vscode.Selection(start, stop));\n                        break;\n                    case mode_1.Mode.VisualLine:\n                        if (start.isBeforeOrEqual(stop)) {\n                            selections.push(new vscode.Selection(start.getLineBegin(), stop.getLineEnd()));\n                        }\n                        else {\n                            selections.push(new vscode.Selection(start.getLineEnd(), stop.getLineBegin()));\n                        }\n                        break;\n                    case mode_1.Mode.VisualBlock:\n                        for (const line of textEditor_1.TextEditor.iterateLinesInBlock(this.vimState, cursor)) {\n                            selections.push(new vscode.Selection(this.vimState.document.validatePosition(line.start), this.vimState.document.validatePosition(line.end)));\n                        }\n                        break;\n                    case mode_1.Mode.Insert:\n                        // Don't collapse existing selections in insert mode\n                        selections.push(new vscode.Selection(start, stop));\n                        break;\n                    default:\n                        // Note that this collapses the selection onto one position\n                        selections.push(new vscode.Selection(stop, stop));\n                        break;\n                }\n            }\n            /**\n             * Combine instersected selections - When we have multiple cursors\n             * sometimes those cursors selections intersect and combine, we need\n             * to check that here so that we know if our currents cursors will\n             * trigger a selectionChangeEvent or not. If we didn't check for this\n             * vscode might already have the resulting combined selection selected\n             * but since that wouldn't be the same as our selections we would think\n             * there would be a selectionChangeEvent when there wouldn't be any.\n             */\n            const getSelectionsCombined = (sel) => {\n                const combinedSelections = [];\n                sel.forEach((s, i) => {\n                    if (i > 0) {\n                        const previousSelection = combinedSelections[combinedSelections.length - 1];\n                        const overlap = s.intersection(previousSelection);\n                        if (overlap) {\n                            combinedSelections[combinedSelections.length - 1] = s.anchor.isBeforeOrEqual(s.active)\n                                ? // Forwards Selection\n                                    new vscode.Selection((0, position_1.earlierOf)(s.anchor, previousSelection.anchor), (0, position_1.laterOf)(s.active, previousSelection.active))\n                                : // Backwards Selection\n                                    new vscode.Selection((0, position_1.laterOf)(s.anchor, previousSelection.anchor), (0, position_1.earlierOf)(s.active, previousSelection.active));\n                        }\n                        else {\n                            combinedSelections.push(s);\n                        }\n                    }\n                    else {\n                        combinedSelections.push(s);\n                    }\n                });\n                return combinedSelections;\n            };\n            selections = getSelectionsCombined(selections);\n            // Check if the selection we are going to set is different than the current one.\n            // If they are the same vscode won't trigger a selectionChangeEvent so we don't\n            // have to add it to the ignore selections.\n            const willTriggerChange = selections.length !== this.vimState.editor.selections.length ||\n                selections.some((s, i) => !s.anchor.isEqual(this.vimState.editor.selections[i].anchor) ||\n                    !s.active.isEqual(this.vimState.editor.selections[i].active));\n            if (willTriggerChange) {\n                const selectionsHash = selections.reduce((hash, s) => hash +\n                    `[${s.anchor.line}, ${s.anchor.character}; ${s.active.line}, ${s.active.character}]`, '');\n                this.selectionsChanged.ourSelections.push(selectionsHash);\n                logger_1.Logger.trace(`Adding selection change to be ignored! (total: ${this.selectionsChanged.ourSelections.length}) Hash: ${selectionsHash}, Selections: ${selections[0].anchor.toString()}, ${selections[0].active.toString()}`);\n            }\n            this.vimState.editor.selections = selections;\n        }\n        // cursor style\n        let cursorStyle = configuration_1.configuration.getCursorStyleForMode(mode_1.Mode[this.currentMode]);\n        if (!cursorStyle) {\n            const cursorType = getCursorType(this.vimState, this.vimState.currentModeIncludingPseudoModes);\n            cursorStyle = (0, mode_1.getCursorStyle)(cursorType);\n            if (cursorType === mode_1.VSCodeVimCursorType.Native &&\n                configuration_1.configuration.editorCursorStyle !== undefined) {\n                cursorStyle = configuration_1.configuration.editorCursorStyle;\n            }\n        }\n        this.vimState.editor.options.cursorStyle = cursorStyle;\n        // Scroll to position of cursor\n        // (This needs to run after cursor style as setting editor.options recomputes the scroll position and breaks when smooth scrolling is enabled: #8254)\n        if (this.vimState.editor.visibleRanges.length > 0 &&\n            !this.vimState.postponedCodeViewChanges.some((change) => change.command === 'editorScroll')) {\n            /**\n             * This variable decides to which cursor we scroll the view.\n             * It is meant as a patch to #880.\n             * Extend this condition if it is the desired behaviour for other actions as well.\n             */\n            const isLastCursorTracked = this.vimState.recordedState.actionsRun[this.vimState.recordedState.actionsRun.length - 1] instanceof actions_1.ActionOverrideCmdD;\n            let cursorToTrack;\n            if (isLastCursorTracked) {\n                cursorToTrack = this.vimState.cursors[this.vimState.cursors.length - 1];\n            }\n            else {\n                cursorToTrack = this.vimState.cursors[0];\n            }\n            const isCursorAboveRange = (visibleRange) => visibleRange.start.line - cursorToTrack.stop.line >= 15;\n            const isCursorBelowRange = (visibleRange) => cursorToTrack.stop.line - visibleRange.end.line >= 15;\n            const { visibleRanges } = this.vimState.editor;\n            const centerViewportAroundCursor = visibleRanges.every(isCursorAboveRange) || visibleRanges.every(isCursorBelowRange);\n            const revealType = centerViewportAroundCursor\n                ? vscode.TextEditorRevealType.InCenter\n                : vscode.TextEditorRevealType.Default;\n            if (this.vimState.modeData.mode === mode_1.Mode.SearchInProgressMode && configuration_1.configuration.incsearch) {\n                const currentMatch = this.vimState.modeData.commandLine.getCurrentMatchRange(this.vimState);\n                if (currentMatch) {\n                    this.vimState.editor.revealRange(currentMatch.range, revealType);\n                }\n                else if (this.vimState.modeData.mode === mode_1.Mode.SearchInProgressMode) {\n                    const offset = this.vimState.editor.visibleRanges[0].start.line -\n                        this.vimState.modeData.firstVisibleLineBeforeSearch;\n                    (0, util_1.scrollView)(this.vimState, offset);\n                }\n            }\n            else if (args.revealRange) {\n                if (!isLastCursorTracked ||\n                    this.vimState.cursorsInitialState.length !== this.vimState.cursors.length) {\n                    /**\n                     * We scroll the view if either:\n                     * 1. the cursor we want to keep in view is the main one (this is the \"standard\"\n                     * (before this commit) situation)\n                     * 2. if we track the last cursor, but no additional cursor was created in this step\n                     * (in the Cmd+D situation this means that no other matches were found)\n                     */\n                    this.vimState.editor.revealRange(new vscode.Range(cursorToTrack.stop, cursorToTrack.stop), revealType);\n                }\n            }\n        }\n        // cursor block\n        const cursorRange = [];\n        if (getCursorType(this.vimState, this.currentMode) === mode_1.VSCodeVimCursorType.TextDecoration &&\n            this.currentMode !== mode_1.Mode.Insert) {\n            // Fake block cursor with text decoration. Unfortunately we can't have a cursor\n            // in the middle of a selection natively, which is what we need for Visual Mode.\n            if (this.currentMode === mode_1.Mode.Visual) {\n                for (const { start: cursorStart, stop: cursorStop } of this.vimState.cursors) {\n                    if (cursorStart.isBefore(cursorStop)) {\n                        cursorRange.push(new vscode.Range(cursorStop.getLeft(), cursorStop));\n                    }\n                    else {\n                        cursorRange.push(new vscode.Range(cursorStop, cursorStop.getRight()));\n                    }\n                }\n            }\n            else {\n                for (const { stop: cursorStop } of this.vimState.cursors) {\n                    cursorRange.push(new vscode.Range(cursorStop, cursorStop.getRight()));\n                }\n            }\n        }\n        this.vimState.editor.setDecorations(decoration_1.decoration.default, cursorRange);\n        // Insert Mode virtual characters: used to temporarily show the remapping pressed keys on\n        // insert mode, to show the `\"` character after pressing `<C-r>`, and to show `?` and the\n        // first character when inserting digraphs with `<C-k>`.\n        const iModeVirtualCharDecorationOptions = [];\n        if (this.vimState.currentMode === mode_1.Mode.Insert || this.vimState.currentMode === mode_1.Mode.Replace) {\n            let virtualKey;\n            if (this.vimState.recordedState.bufferedKeys.length > 0) {\n                virtualKey =\n                    this.vimState.recordedState.bufferedKeys[this.vimState.recordedState.bufferedKeys.length - 1];\n            }\n            else if (this.vimState.recordedState.waitingForAnotherActionKey) {\n                virtualKey =\n                    this.vimState.recordedState.actionKeys[this.vimState.recordedState.actionKeys.length - 1];\n                if (virtualKey === '<C-r>') {\n                    virtualKey = '\"';\n                }\n                else if (virtualKey === '<C-k>') {\n                    virtualKey = '?';\n                }\n            }\n            // Don't show keys with `<` like `<C-x>` but show everything else\n            virtualKey = virtualKey && /<[^>]+>/.test(virtualKey) ? undefined : virtualKey;\n            if (virtualKey) {\n                // Normal Render Options with the key to overlap on the next character\n                const renderOptions = {\n                    before: {\n                        contentText: virtualKey,\n                    },\n                };\n                /**\n                 * EOL Render Options:\n                 * Some times when at the end of line the `currentColor` won't work, or it might be\n                 * transparent, so we set the color to 'editor.foreground' when at EOL to avoid the\n                 * virtualKey character not showing up.\n                 */\n                const eolRenderOptions = {\n                    before: {\n                        contentText: virtualKey,\n                        color: new vscode.ThemeColor('editor.foreground'),\n                    },\n                };\n                for (const { stop: cursorStop } of this.vimState.cursors) {\n                    if (cursorStop.isLineEnd()) {\n                        iModeVirtualCharDecorationOptions.push({\n                            range: new vscode.Range(cursorStop, cursorStop.getLineEndIncludingEOL()),\n                            renderOptions: eolRenderOptions,\n                        });\n                    }\n                    else {\n                        iModeVirtualCharDecorationOptions.push({\n                            range: new vscode.Range(cursorStop, cursorStop.getRightThroughLineBreaks(true)),\n                            renderOptions,\n                        });\n                    }\n                }\n            }\n        }\n        this.vimState.editor.setDecorations(decoration_1.decoration.insertModeVirtualCharacter, iModeVirtualCharDecorationOptions);\n        // OperatorPendingMode half block cursor\n        const opCursorDecorations = [];\n        const opCursorCharDecorations = [];\n        if (this.vimState.currentModeIncludingPseudoModes === mode_1.Mode.OperatorPendingMode) {\n            for (const { stop: cursorStop } of this.vimState.cursors) {\n                let text = textEditor_1.TextEditor.getCharAt(this.vimState.document, cursorStop);\n                // the ' ' (<space>) needs to be changed to '&nbsp;'\n                text = text === ' ' ? '\\u00a0' : text;\n                const decorationOptions = {\n                    range: new vscode.Range(cursorStop, cursorStop.getRight()),\n                    renderOptions: {\n                        before: {\n                            contentText: text,\n                        },\n                    },\n                };\n                opCursorDecorations.push(decorationOptions);\n                opCursorCharDecorations.push(decorationOptions);\n            }\n        }\n        this.vimState.editor.setDecorations(decoration_1.decoration.operatorPendingModeCursor, opCursorDecorations);\n        this.vimState.editor.setDecorations(decoration_1.decoration.operatorPendingModeCursorChar, opCursorCharDecorations);\n        for (const markDecoration of decoration_1.decoration.allMarkDecorations()) {\n            this.vimState.editor.setDecorations(markDecoration, []);\n        }\n        if (configuration_1.configuration.showMarksInGutter) {\n            for (const mark of this.vimState.historyTracker.getMarks()) {\n                if (mark.isUppercaseMark && mark.document !== this.vimState.document) {\n                    continue;\n                }\n                const markDecoration = decoration_1.decoration.getOrCreateMarkDecoration(mark.name);\n                const markLine = mark.position.getLineBegin();\n                const markRange = new vscode.Range(markLine, markLine);\n                this.vimState.editor.setDecorations(markDecoration, [markRange]);\n            }\n        }\n        const showHighlights = (configuration_1.configuration.incsearch &&\n            (this.currentMode === mode_1.Mode.SearchInProgressMode ||\n                this.currentMode === mode_1.Mode.CommandlineInProgress)) ||\n            (configuration_1.configuration.inccommand && this.currentMode === mode_1.Mode.CommandlineInProgress) ||\n            (configuration_1.configuration.hlsearch && globalState_1.globalState.hl);\n        for (const editor of vscode.window.visibleTextEditors) {\n            const mh = this.handlerMap.get(editor.document.uri);\n            if (mh) {\n                mh.updateSearchHighlights(showHighlights);\n            }\n        }\n        const easyMotionDimRanges = this.currentMode === mode_1.Mode.EasyMotionInputMode &&\n            configuration_1.configuration.easymotionDimBackground &&\n            this.vimState.easyMotion.searchAction instanceof easymotion_cmd_1.SearchByNCharCommand\n            ? [\n                new vscode.Range(textEditor_1.TextEditor.getDocumentBegin(), textEditor_1.TextEditor.getDocumentEnd(this.vimState.document)),\n            ]\n            : [];\n        const easyMotionHighlightRanges = this.currentMode === mode_1.Mode.EasyMotionInputMode &&\n            this.vimState.easyMotion.searchAction instanceof easymotion_cmd_1.SearchByNCharCommand\n            ? this.vimState.easyMotion.searchAction\n                .getMatches(this.vimState.cursorStopPosition, this.vimState)\n                .map((match) => match.toRange())\n            : [];\n        this.vimState.editor.setDecorations(decoration_1.decoration.easyMotionDimIncSearch, easyMotionDimRanges);\n        this.vimState.editor.setDecorations(decoration_1.decoration.easyMotionIncSearch, easyMotionHighlightRanges);\n        for (const viewChange of this.vimState.postponedCodeViewChanges) {\n            void vscode.commands.executeCommand(viewChange.command, viewChange.args);\n        }\n        this.vimState.postponedCodeViewChanges = [];\n        if (this.currentMode === mode_1.Mode.EasyMotionMode) {\n            // Update all EasyMotion decorations\n            this.vimState.easyMotion.updateDecorations(this.vimState.editor);\n        }\n        statusBar_1.StatusBar.clear(this.vimState, false);\n        // NOTE: this is not being awaited to save the 15-20ms block - I think this is fine\n        void vscodeContext_1.VSCodeContext.set('vim.mode', mode_1.Mode[this.vimState.currentMode]);\n        // Tell VSCode that the cursor position changed, so it updates its highlights for `editor.occurrencesHighlight`.\n        const range = new vscode.Range(this.vimState.cursorStartPosition, this.vimState.cursorStopPosition);\n        if (!/\\s+/.test(this.vimState.document.getText(range))) {\n            void vscode.commands.executeCommand('editor.action.wordHighlight.trigger');\n        }\n    }\n    // Return true if a new undo point should be created based on brackets and parentheses\n    createUndoPointForBrackets() {\n        // }])> keys all start a new undo state when directly next to an {[(< opening character\n        const key = this.vimState.recordedState.actionKeys[this.vimState.recordedState.actionKeys.length - 1];\n        if (key === undefined) {\n            return false;\n        }\n        if (this.vimState.currentMode === mode_1.Mode.Insert) {\n            // Check if the keypress is a closing bracket to a corresponding opening bracket right next to it\n            let result = matcher_1.PairMatcher.nextPairedChar(this.vimState.cursorStopPosition, key, this.vimState, false);\n            if (result !== undefined) {\n                if (this.vimState.cursorStopPosition.isEqual(result)) {\n                    return true;\n                }\n            }\n            result = matcher_1.PairMatcher.nextPairedChar(this.vimState.cursorStopPosition.getLeft(), key, this.vimState, false);\n            if (result !== undefined) {\n                if (this.vimState.cursorStopPosition.getLeft(2).isEqual(result)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    dispose() {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        this.disposables.map((d) => d.dispose());\n    }\n}\nexports.ModeHandler = ModeHandler;\nfunction getCursorType(vimState, mode) {\n    switch (mode) {\n        case mode_1.Mode.Normal:\n            return mode_1.VSCodeVimCursorType.Block;\n        case mode_1.Mode.Insert:\n            return mode_1.VSCodeVimCursorType.Native;\n        case mode_1.Mode.Visual:\n            return mode_1.VSCodeVimCursorType.TextDecoration;\n        case mode_1.Mode.VisualBlock:\n            return mode_1.VSCodeVimCursorType.TextDecoration;\n        case mode_1.Mode.VisualLine:\n            return mode_1.VSCodeVimCursorType.TextDecoration;\n        case mode_1.Mode.SearchInProgressMode:\n            return mode_1.VSCodeVimCursorType.UnderlineThin;\n        case mode_1.Mode.CommandlineInProgress:\n            return mode_1.VSCodeVimCursorType.UnderlineThin;\n        case mode_1.Mode.Replace:\n            return mode_1.VSCodeVimCursorType.Underline;\n        case mode_1.Mode.EasyMotionMode:\n            return mode_1.VSCodeVimCursorType.Block;\n        case mode_1.Mode.EasyMotionInputMode:\n            return mode_1.VSCodeVimCursorType.Block;\n        case mode_1.Mode.SurroundInputMode:\n            return getCursorType(vimState, vimState.surround.previousMode);\n        case mode_1.Mode.OperatorPendingMode:\n            return mode_1.VSCodeVimCursorType.UnderlineThin;\n        case mode_1.Mode.Disabled:\n        default:\n            return mode_1.VSCodeVimCursorType.Line;\n    }\n}\n\n\n//# sourceURL=webpack://vim/./src/mode/modeHandler.ts?")},"./src/mode/modeHandlerMap.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.ModeHandlerMap = void 0;\nconst modeHandler_1 = __webpack_require__(/*! ./modeHandler */ "./src/mode/modeHandler.ts");\n/**\n * Stores one ModeHandler (and therefore VimState) per TextDocument.\n */\nclass ModeHandlerMapImpl {\n    constructor() {\n        this.modeHandlerMap = new Map();\n    }\n    async getOrCreate(editor) {\n        const editorId = editor.document.uri;\n        let isNew = false;\n        let modeHandler = this.get(editorId);\n        if (!modeHandler) {\n            isNew = true;\n            modeHandler = await modeHandler_1.ModeHandler.create(this, editor);\n            this.modeHandlerMap.set(editorId, modeHandler);\n        }\n        return [modeHandler, isNew];\n    }\n    get(uri) {\n        return this.modeHandlerMap.get(uri);\n    }\n    entries() {\n        return this.modeHandlerMap.entries();\n    }\n    delete(editorId) {\n        const modeHandler = this.modeHandlerMap.get(editorId);\n        if (modeHandler) {\n            modeHandler.dispose();\n            this.modeHandlerMap.delete(editorId);\n        }\n    }\n    clear() {\n        for (const key of this.modeHandlerMap.keys()) {\n            this.delete(key);\n        }\n    }\n}\nexports.ModeHandlerMap = new ModeHandlerMapImpl();\n\n\n//# sourceURL=webpack://vim/./src/mode/modeHandlerMap.ts?')},"./src/platform/browser/constants.ts":(__unused_webpack_module,exports)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.SUPPORT_READ_COMMAND = exports.SUPPORT_IME_SWITCHER = exports.SUPPORT_NVIM = exports.SUPPORT_VIMRC = void 0;\nexports.SUPPORT_VIMRC = false;\nexports.SUPPORT_NVIM = false;\nexports.SUPPORT_IME_SWITCHER = false;\nexports.SUPPORT_READ_COMMAND = false;\n\n\n//# sourceURL=webpack://vim/./src/platform/browser/constants.ts?')},"./src/platform/browser/fs.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.unlinkSync = exports.chmodAsync = exports.accessAsync = exports.writeFileAsync = exports.mkdirAsync = exports.readFileAsync = exports.unlink = exports.existsAsync = exports.doesFileExist = exports.constants = void 0;\nconst vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));\nexports.constants = {\n    UV_FS_SYMLINK_DIR: 1,\n    UV_FS_SYMLINK_JUNCTION: 2,\n    O_RDONLY: 0,\n    O_WRONLY: 1,\n    O_RDWR: 2,\n    UV_DIRENT_UNKNOWN: 0,\n    UV_DIRENT_FILE: 1,\n    UV_DIRENT_DIR: 2,\n    UV_DIRENT_LINK: 3,\n    UV_DIRENT_FIFO: 4,\n    UV_DIRENT_SOCKET: 5,\n    UV_DIRENT_CHAR: 6,\n    UV_DIRENT_BLOCK: 7,\n    S_IFMT: 61440,\n    S_IFREG: 32768,\n    S_IFDIR: 16384,\n    S_IFCHR: 8192,\n    S_IFBLK: 24576,\n    S_IFIFO: 4096,\n    S_IFLNK: 40960,\n    S_IFSOCK: 49152,\n    O_CREAT: 512,\n    O_EXCL: 2048,\n    UV_FS_O_FILEMAP: 0,\n    O_NOCTTY: 131072,\n    O_TRUNC: 1024,\n    O_APPEND: 8,\n    O_DIRECTORY: 1048576,\n    O_NOFOLLOW: 256,\n    O_SYNC: 128,\n    O_DSYNC: 4194304,\n    O_SYMLINK: 2097152,\n    O_NONBLOCK: 4,\n    S_IRWXU: 448,\n    S_IRUSR: 256,\n    S_IWUSR: 128,\n    S_IXUSR: 64,\n    S_IRWXG: 56,\n    S_IRGRP: 32,\n    S_IWGRP: 16,\n    S_IXGRP: 8,\n    S_IRWXO: 7,\n    S_IROTH: 4,\n    S_IWOTH: 2,\n    S_IXOTH: 1,\n    F_OK: 0,\n    R_OK: 4,\n    W_OK: 2,\n    X_OK: 1,\n    UV_FS_COPYFILE_EXCL: 1,\n    COPYFILE_EXCL: 1,\n    UV_FS_COPYFILE_FICLONE: 2,\n    COPYFILE_FICLONE: 2,\n    UV_FS_COPYFILE_FICLONE_FORCE: 4,\n    COPYFILE_FICLONE_FORCE: 4,\n};\nasync function doesFileExist(fileUri) {\n    try {\n        await vscode.workspace.fs.stat(fileUri);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nexports.doesFileExist = doesFileExist;\nasync function existsAsync(path) {\n    try {\n        await vscode.workspace.fs.stat(vscode.Uri.parse(path));\n        return true;\n    }\n    catch (_e) {\n        return false;\n    }\n}\nexports.existsAsync = existsAsync;\nasync function unlink(path) {\n    await vscode.workspace.fs.delete(vscode.Uri.parse(path));\n}\nexports.unlink = unlink;\nasync function readFileAsync(path, encoding) {\n    const ret = await vscode.workspace.fs.readFile(vscode.Uri.parse(path));\n    return ret.toString();\n}\nexports.readFileAsync = readFileAsync;\nasync function mkdirAsync(path, options) {\n    return vscode.workspace.fs.createDirectory(vscode.Uri.parse(path));\n}\nexports.mkdirAsync = mkdirAsync;\nasync function writeFileAsync(path, content, encoding) {\n    return vscode.workspace.fs.writeFile(vscode.Uri.parse(path), Buffer.from(content));\n}\nexports.writeFileAsync = writeFileAsync;\nasync function accessAsync(path, mode) {\n    // no op in nodeless\n}\nexports.accessAsync = accessAsync;\nasync function chmodAsync(path, mode) {\n    // no op in nodeless\n}\nexports.chmodAsync = chmodAsync;\nfunction unlinkSync(path) {\n    // no op in nodeless\n}\nexports.unlinkSync = unlinkSync;\n\n\n//# sourceURL=webpack://vim/./src/platform/browser/fs.ts?')},"./src/platform/browser/history.ts":(__unused_webpack_module,exports)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HistoryBase = void 0;\nclass HistoryBase {\n    get historyKey() {\n        return `vim.${this.historyFileName}`;\n    }\n    constructor(context, historyFileName, extensionStoragePath) {\n        this.history = [];\n        this.context = context;\n        this.historyFileName = historyFileName;\n    }\n    async add(value, history) {\n        if (!value || value.length === 0) {\n            return;\n        }\n        // remove duplicates\n        const index = this.history.indexOf(value);\n        if (index !== -1) {\n            this.history.splice(index, 1);\n        }\n        // append to the end\n        this.history.push(value);\n        // resize array if necessary\n        if (this.history.length > history) {\n            this.history = this.history.slice(this.history.length - history);\n        }\n        return this.save();\n    }\n    get(history) {\n        // resize array if necessary\n        if (this.history.length > history) {\n            this.history = this.history.slice(this.history.length - history);\n        }\n        return this.history;\n    }\n    async clear() {\n        void this.context.workspaceState.update(this.historyKey, undefined);\n        this.history = [];\n    }\n    async load() {\n        const data = this.context.workspaceState.get(this.historyKey) || '';\n        if (data.length === 0) {\n            return;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        const parsedData = JSON.parse(data);\n        if (!Array.isArray(parsedData)) {\n            throw Error('Unexpected format in history. Expected JSON.');\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this.history = parsedData;\n    }\n    async save() {\n        void this.context.workspaceState.update(this.historyKey, JSON.stringify(this.history));\n    }\n}\nexports.HistoryBase = HistoryBase;\n\n\n//# sourceURL=webpack://vim/./src/platform/browser/history.ts?")},"./src/register/register.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Register = exports.RegisterMode = void 0;\nconst fs_1 = __webpack_require__(/*! platform/fs */ \"./src/platform/browser/fs.ts\");\nconst globals_1 = __webpack_require__(/*! ../globals */ \"./src/globals.ts\");\nconst recordedState_1 = __webpack_require__(/*! ./../state/recordedState */ \"./src/state/recordedState.ts\");\nconst clipboard_1 = __webpack_require__(/*! ./../util/clipboard */ \"./src/util/clipboard.ts\");\n/**\n * This is included in the register file.\n * Whenever the format saved to disk changes, so should this.\n */\nconst REGISTER_FORMAT_VERSION = '1.0';\n/**\n * There are two different modes of copy/paste in Vim - copy by character\n * and copy by line. Copy by line typically happens in Visual Line mode, but\n * also shows up in some other actions that work over lines (most notably dd,\n * yy).\n */\nvar RegisterMode;\n(function (RegisterMode) {\n    RegisterMode[RegisterMode[\"CharacterWise\"] = 0] = \"CharacterWise\";\n    RegisterMode[RegisterMode[\"LineWise\"] = 1] = \"LineWise\";\n    RegisterMode[RegisterMode[\"BlockWise\"] = 2] = \"BlockWise\";\n})(RegisterMode || (exports.RegisterMode = RegisterMode = {}));\nclass Register {\n    /**\n     * Puts given content in the currently selected register, using the current RegisterMode.\n     *\n     * @param copyToUnnamed: If true, set the unnamed register (\") as well\n     */\n    static put(vimState, content, multicursorIndex, copyToUnnamed) {\n        const register = vimState.recordedState.registerName;\n        if (!Register.isValidRegister(register)) {\n            throw new Error(`Invalid register ${register}`);\n        }\n        if (Register.isBlackHoleRegister(register) || Register.isReadOnlyRegister(register)) {\n            return;\n        }\n        if (Register.isValidUppercaseRegister(register)) {\n            Register.appendToRegister(vimState, register.toLowerCase(), content, multicursorIndex ?? 0);\n        }\n        else {\n            Register.overwriteRegister(vimState, register, content, multicursorIndex ?? 0);\n        }\n        if (copyToUnnamed && register !== '\"') {\n            Register.registers.set('\"', Register.registers.get(register));\n        }\n    }\n    static isValidRegister(register) {\n        return (Register.isValidLowercaseRegister(register) ||\n            Register.isValidUppercaseRegister(register) ||\n            /^[0-9]$/.test(register) ||\n            this.specialRegisters.includes(register));\n    }\n    static isValidRegisterForMacro(register) {\n        return /^[a-zA-Z0-9:]$/.test(register);\n    }\n    static isBlackHoleRegister(registerName) {\n        return registerName === '_';\n    }\n    static isClipboardRegister(registerName) {\n        return registerName === '*' || registerName === '+';\n    }\n    static isReadOnlyRegister(registerName) {\n        return ['.', '%', ':', '#', '/'].includes(registerName);\n    }\n    static isValidLowercaseRegister(register) {\n        return /^[a-z]$/.test(register);\n    }\n    static isValidUppercaseRegister(register) {\n        return /^[A-Z]$/.test(register);\n    }\n    /**\n     * Puts the content at the specified index of the multicursor Register.\n     * If multicursorIndex === 0, the register will be completely overwritten. Otherwise, just that index will be.\n     */\n    static overwriteRegister(vimState, register, content, multicursorIndex) {\n        if (multicursorIndex === 0 || !Register.registers.has(register)) {\n            Register.registers.set(register, []);\n        }\n        Register.registers.get(register)[multicursorIndex] = {\n            registerMode: vimState.currentRegisterMode,\n            text: content,\n        };\n        if (multicursorIndex === 0 &&\n            this.isClipboardRegister(register) &&\n            !(content instanceof recordedState_1.RecordedState)) {\n            void clipboard_1.Clipboard.Copy(content);\n        }\n        this.processNumberedRegisters(vimState, content);\n    }\n    /**\n     * Appends the content at the specified index of the multicursor Register.\n     */\n    static appendToRegister(vimState, register, content, multicursorIndex) {\n        if (!Register.registers.has(register)) {\n            Register.registers.set(register, []);\n        }\n        const contentByCursor = Register.registers.get(register);\n        const oldContent = contentByCursor[multicursorIndex];\n        if (oldContent === undefined) {\n            contentByCursor[multicursorIndex] = {\n                registerMode: vimState.currentRegisterMode,\n                text: content,\n            };\n        }\n        else {\n            // Line-wise trumps other RegisterModes\n            const registerMode = vimState.currentRegisterMode === RegisterMode.LineWise\n                ? RegisterMode.LineWise\n                : oldContent.registerMode;\n            let newText;\n            if (oldContent.text instanceof recordedState_1.RecordedState || content instanceof recordedState_1.RecordedState) {\n                newText = oldContent.text;\n            }\n            else {\n                newText = oldContent.text + (registerMode === RegisterMode.LineWise ? '\\n' : '') + content;\n            }\n            contentByCursor[multicursorIndex] = {\n                registerMode,\n                text: newText,\n            };\n        }\n        if (multicursorIndex === 0 && this.isClipboardRegister(register)) {\n            const newContent = contentByCursor[multicursorIndex].text;\n            if (!(newContent instanceof recordedState_1.RecordedState)) {\n                void clipboard_1.Clipboard.Copy(newContent);\n            }\n        }\n    }\n    /**\n     * Updates a readonly register's content. This is the only way to do so.\n     */\n    static setReadonlyRegister(register, content) {\n        Register.registers.set(register, [\n            {\n                text: content,\n                registerMode: RegisterMode.CharacterWise,\n            },\n        ]);\n    }\n    /**\n     * Handles special cases for Yank- and DeleteOperator.\n     */\n    static processNumberedRegisters(vimState, content) {\n        // Find the BaseOperator of the current actions\n        const baseOperator = vimState.recordedState.operator || vimState.recordedState.command;\n        if (!baseOperator) {\n            return;\n        }\n        if (baseOperator.name === 'yank_op' || baseOperator.name === 'yank_full_line') {\n            // 'yank' to 0 only if no register was specified\n            const registerCommand = vimState.recordedState.actionsRun.find((value) => {\n                return value.name === 'cmd_register';\n            });\n            if (!registerCommand) {\n                Register.registers.set('0', [\n                    {\n                        text: content,\n                        registerMode: vimState.currentRegisterMode,\n                    },\n                ]);\n            }\n        }\n        else if ((baseOperator.name === 'delete_op' ||\n            baseOperator.name === 'delete_char' ||\n            baseOperator.name === 'delete_last_char' ||\n            baseOperator.name === 'delete_char_visual_line_mode' ||\n            baseOperator.name === 'delete_char_with_del') &&\n            !(vimState.macro !== undefined || vimState.isReplayingMacro)) {\n            if (!content.toString().match(/\\n/g) &&\n                vimState.currentRegisterMode !== RegisterMode.LineWise) {\n                Register.registers.set('-', [\n                    {\n                        text: content,\n                        registerMode: RegisterMode.CharacterWise,\n                    },\n                ]);\n            }\n            else {\n                // shift 'delete-history' register\n                for (let index = 9; index > 1; index--) {\n                    const previous = Register.registers.get(String(index - 1));\n                    if (previous) {\n                        Register.registers.set(String(index), { ...previous });\n                    }\n                }\n                // Paste last delete into register '1'\n                Register.registers.set('1', [\n                    {\n                        text: content,\n                        registerMode: vimState.currentRegisterMode,\n                    },\n                ]);\n            }\n        }\n    }\n    /**\n     * Gets content from a register. If no register is specified, uses `vimState.recordedState.registerName`.\n     */\n    static async get(register, multicursorIndex = 0) {\n        if (!Register.isValidRegister(register)) {\n            throw new Error(`Invalid register ${register}`);\n        }\n        register = register.toLowerCase();\n        const contentByCursor = Register.registers.get(register);\n        if (Register.isClipboardRegister(register)) {\n            const clipboardContent = (await clipboard_1.Clipboard.Paste()).replace(/\\r\\n/g, '\\n');\n            const currentRegisterContent = contentByCursor?.[0]?.text?.replace(/\\r\\n/g, '\\n');\n            if (currentRegisterContent !== clipboardContent) {\n                // System clipboard seems to have changed\n                const registerContent = {\n                    text: clipboardContent,\n                    registerMode: RegisterMode.CharacterWise,\n                };\n                Register.registers.set(register, [registerContent]);\n                return registerContent;\n            }\n        }\n        // Default to the first cursor.\n        if (contentByCursor?.[multicursorIndex] === undefined) {\n            // If multicursorIndex is too high, try the first cursor\n            multicursorIndex = 0;\n        }\n        return contentByCursor?.[multicursorIndex];\n    }\n    static has(register) {\n        return Register.registers.has(register);\n    }\n    static getKeys() {\n        return [...Register.registers.keys()];\n    }\n    static clearAllRegisters() {\n        Register.registers.clear();\n    }\n    static async saveToDisk(supportNode) {\n        if (supportNode) {\n            const serializableRegisters = new Array();\n            for (const [key, contentByCursor] of Register.registers) {\n                if (!contentByCursor.some((content) => content instanceof recordedState_1.RecordedState)) {\n                    serializableRegisters.push([key, contentByCursor]);\n                }\n            }\n            return Promise.resolve().then(() => __importStar(__webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\"))).then((path) => {\n                return (0, fs_1.writeFileAsync)(path.join(globals_1.Globals.extensionStoragePath, '.registers'), JSON.stringify({\n                    version: REGISTER_FORMAT_VERSION,\n                    registers: serializableRegisters,\n                }), 'utf8');\n            });\n        }\n    }\n    static loadFromDisk(supportNode) {\n        if (supportNode) {\n            Register.registers = new Map();\n            void Promise.resolve().then(() => __importStar(__webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\"))).then((path) => {\n                void (0, fs_1.readFileAsync)(path.join(globals_1.Globals.extensionStoragePath, '.registers'), 'utf8').then((savedRegisters) => {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                    const parsed = JSON.parse(savedRegisters);\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                    if (parsed.version === REGISTER_FORMAT_VERSION) {\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access\n                        Register.registers = new Map(parsed.registers);\n                    }\n                });\n            });\n        }\n        else {\n            Register.registers = new Map();\n        }\n    }\n}\nexports.Register = Register;\nRegister.specialRegisters = [\n    '\"', // Unnamed (default)\n    '*', // Clipboard\n    '+', // Clipboard\n    '.', // Last inserted text\n    '-', // Last deleted text less than a line\n    '/', // Most recently executed search\n    ':', // Most recently executed command\n    '%', // Current file path (relative to workspace root)\n    '#', // Previous file path (relative to workspace root)\n    '_', // Black hole (always empty)\n    '=', // Expression register\n];\n\n\n//# sourceURL=webpack://vim/./src/register/register.ts?")},"./src/state/compositionState.ts":(__unused_webpack_module,exports)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CompositionState = void 0;\nclass CompositionState {\n    constructor() {\n        this.isInComposition = false;\n        this.insertedText = false;\n        this.composingText = '';\n    }\n    reset() {\n        this.isInComposition = false;\n        this.insertedText = false;\n        this.composingText = '';\n    }\n}\nexports.CompositionState = CompositionState;\n\n\n//# sourceURL=webpack://vim/./src/state/compositionState.ts?")},"./src/state/globalState.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.globalState = void 0;\nconst jumpTracker_1 = __webpack_require__(/*! ../jumps/jumpTracker */ "./src/jumps/jumpTracker.ts");\n/**\n * State which stores global state (across editors)\n */\nclass GlobalState {\n    constructor() {\n        /**\n         * Track jumps, and traverse jump history\n         */\n        this.jumpTracker = new jumpTracker_1.JumpTracker();\n        /**\n         * The keystroke sequence that made up our last complete action (that can be\n         * repeated with \'.\').\n         */\n        this.previousFullAction = undefined;\n        this.lastInvokedMacro = undefined;\n        /**\n         * Last substitute state for running :s by itself\n         */\n        this.substituteState = undefined;\n        /**\n         * The most recently active SearchState\n         * This is used for things like `n` and `hlsearch`\n         */\n        this.searchState = undefined;\n        /**\n         * Used internally for nohl.\n         */\n        this.hl = true;\n    }\n}\nexports.globalState = new GlobalState();\n\n\n//# sourceURL=webpack://vim/./src/state/globalState.ts?')},"./src/state/recordedState.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RecordedState = void 0;\nconst configuration_1 = __webpack_require__(/*! ../configuration/configuration */ \"./src/configuration/configuration.ts\");\nconst mode_1 = __webpack_require__(/*! ../mode/mode */ \"./src/mode/mode.ts\");\nconst transformer_1 = __webpack_require__(/*! ./../transformations/transformer */ \"./src/transformations/transformer.ts\");\nconst specialKeys_1 = __webpack_require__(/*! ../util/specialKeys */ \"./src/util/specialKeys.ts\");\nconst ESCAPE_REGEX = new RegExp(/[|\\\\{}()[\\]^$+*?.]/, 'g');\nconst BUFFERED_KEYS_REGEX = new RegExp(specialKeys_1.SpecialKeys.TimeoutFinished, 'g');\n/**\n * Much of Vim's power comes from the composition of individual actions.\n *\n * RecordedState holds the state associated with a sequence of actions,\n * generally beginning and ending in Normal mode.\n *\n * For example, each of these action sequences would be combined into a single RecordedState:\n *   - 5\"xyw      (yank 5 words into the 'x' register)\n *   - Axyz<Esc>  (append 'xyz' to end of line)\n *   - Vjj~       (reverse case of next 3 lines)\n *\n * The last action (for dot-repeating), macros, and a few other things are RecordedStates.\n */\nclass RecordedState {\n    constructor() {\n        /**\n         * The keys the user has pressed that have not caused an action to be executed\n         * yet and have not been stored on action keys. Used for command remapping.\n         */\n        this.commandList = [];\n        /**\n         * Keeps track of keys pressed for the next action. Comes in handy when parsing\n         * multiple length movements, e.g. gg.\n         */\n        this.actionKeys = [];\n        /**\n         * Waiting for another key for a potential action.\n         *\n         * Used to prevent the remapping of keys after a potential action key\n         * like @zZtTfF[]rm'`\"gq<C-r><C-w>. This is done to be able to use all\n         * the named registers and marks, even when the command with the same\n         * name has been mapped.\n         *\n         * Vim Documentation: (:help map-error)\n         * \"Note that the second character (argument) of the commands @zZtTfF[]rm'`\"v\n         * and CTRL-X is not mapped. This was done to be able to use all the named\n         * registers and marks, even when the command with the same name has been\n         * mapped.\"\n         *\n         * The documentation only specifies some keys, but from testing pretty much\n         * every key has this condition (keys like 'g', 'q', '<C-r>' and '<C-w>' all\n         * behave the same) so here we use 'waitingForAnotherActionKey' to prevent\n         * remapping on next keys. In the case of the 'v' key specified in the vim\n         * documentation, I don't really understand what they mean with that because\n         * it doesn't make much sense. The 'v' key puts you in Visual mode, it doesn't\n         * accept any character argument.\n         */\n        this.waitingForAnotherActionKey = false;\n        /**\n         * Every action that has been run.\n         */\n        this.actionsRun = [];\n        /**\n         * Keeps track of keys pressed by the actionsRun. Used for the showCmd. If an action\n         * changes previous actions pressed keys it should change this list, like the <Del>\n         * key after a number key.\n         */\n        this.actionsRunPressedKeys = [];\n        /**\n         * Every key that was buffered to wait for a new key or the timeout to finish\n         * in order to get another potential remap or to solve an ambiguous remap.\n         */\n        this.bufferedKeys = [];\n        this.bufferedKeysTimeoutObj = undefined;\n        /**\n         * This is used when the remappers are resending the keys after a potential\n         * remap without an ambiguous remap is broken, either by a new key or by the\n         * timeout finishing.\n         *\n         * It will make it so the first key sent will not be considered as a potential\n         * remap by any of the remappers, even though it is, to prevent the remappers\n         * of doing the same thing again. This way the first key will be handled as an\n         * action but the next keys can still be remapped.\n         *\n         * Example: if you map `iiii -> i<C-A><Esc>` in normal mode and map `ii -> <Esc>`\n         * in insert mode, after pressing `iii` you want the first `i` to put you in\n         * insert mode and the next `ii` to escape to normal mode.\n         */\n        this.allowPotentialRemapOnFirstKey = true;\n        this.hasRunOperator = false;\n        this.isInsertion = false;\n        /**\n         * The text transformations that we want to run. They will all be run after the action has been processed.\n         *\n         * Running an individual action will generally queue up to one of these, but if you're in\n         * multi-cursor mode, you'll queue one per cursor, or more.\n         *\n         * Note that the text transformations are run in parallel. This is useful in most cases,\n         * but will get you in trouble in others.\n         */\n        this.transformer = new transformer_1.Transformer();\n        /**\n         * The number of times the user wants to repeat this action.\n         */\n        this.count = 0;\n        /**\n         * The number of times the user wants to repeat the operator. If after the operator the user\n         * uses a motion with count that count will be multiplied by this count.\n         *\n         * Example: if user presses 2d3w it deletes 6 words.\n         */\n        this.operatorCount = 0;\n        /**\n         * The key used to access the register with `registerName`\n         * Example: if 'q5' then key=5 and name=5\n         * Or:      if 'qA' then key=A and name=a\n         */\n        this.registerKey = '';\n        this.registerName = configuration_1.configuration.useSystemClipboard ? '*' : '\"';\n    }\n    /**\n     * String representation of the exact keys that the user entered.\n     */\n    get commandString() {\n        let result = '';\n        if (this.actionsRun.length > 0) {\n            result = this.actionsRunPressedKeys.join('');\n        }\n        if (this.actionKeys.length > 0) {\n            // if there are any actionKeys waiting for other key append them\n            result += this.actionKeys.join('');\n        }\n        if (this.bufferedKeys.length > 0) {\n            // if there are any bufferedKeys waiting for other key append them\n            result += this.bufferedKeys.join('');\n        }\n        if (this.actionsRun.length === 0 &&\n            this.actionKeys.length === 0 &&\n            this.bufferedKeys.length === 0 &&\n            this.commandList.length > 0) {\n            // Used for the registers and macros that only record on commandList\n            result = this.commandList.join('');\n        }\n        return result\n            .replace(new RegExp(configuration_1.configuration.leader.replace(ESCAPE_REGEX, '\\\\$&'), 'g'), '<leader>')\n            .replace(BUFFERED_KEYS_REGEX, '');\n    }\n    /**\n     * String representation of the pending keys that the user entered.\n     */\n    get pendingCommandString() {\n        let result = '';\n        if (this.actionKeys.length > 0) {\n            // if there are any actionKeys waiting for other key append them\n            result += this.actionKeys.join('');\n        }\n        if (this.bufferedKeys.length > 0) {\n            // if there are any bufferedKeys waiting for other key append them\n            result += this.bufferedKeys.join('');\n        }\n        return result\n            .replace(new RegExp(configuration_1.configuration.leader.replace(ESCAPE_REGEX, '\\\\$&'), 'g'), '<leader>')\n            .replace(BUFFERED_KEYS_REGEX, '');\n    }\n    /**\n     * Reset the command list.\n     */\n    resetCommandList() {\n        this.commandList = [];\n    }\n    /**\n     * The operator (e.g. d, y, >) the user wants to run, if there is one.\n     */\n    get operator() {\n        const operators = this.operators;\n        return operators.length > 0 ? operators[0] : undefined;\n    }\n    get operators() {\n        return this.actionsRun.filter((a) => a.actionType === 'operator').reverse();\n    }\n    /**\n     * The command (e.g. i, ., R, /) the user wants to run, if there is one.\n     */\n    get command() {\n        // TODO: this is probably wrong\n        const list = this.actionsRun\n            .filter((a) => a.actionType === 'command')\n            .reverse();\n        // TODO - disregard <Esc>, then assert this is of length 1.\n        return list[0];\n    }\n    clone() {\n        const res = new RecordedState();\n        // TODO: Actual clone.\n        res.actionKeys = this.actionKeys.slice(0);\n        res.actionsRun = this.actionsRun.slice(0);\n        res.hasRunOperator = this.hasRunOperator;\n        return res;\n    }\n    getOperatorState(mode) {\n        // Do we have an operator that hasn't been run yet?\n        if (this.operator === undefined ||\n            this.hasRunOperator ||\n            // TODO: Is this mode check necessary?\n            mode === mode_1.Mode.SearchInProgressMode ||\n            mode === mode_1.Mode.CommandlineInProgress) {\n            return undefined;\n        }\n        // We've got an operator - do we also have a motion or visual selection to operate on?\n        if (this.actionsRun.some((a) => a.actionType === 'motion') || (0, mode_1.isVisualMode)(mode)) {\n            return 'ready';\n        }\n        // TODO: I don't think reversing is necessary - can't there only ever be two operators?\n        // This case is for a \"repeated\" operator (such as `dd` or `yy`)\n        if (this.operators.length > 1 &&\n            this.operators.reverse()[0].constructor === this.operators.reverse()[1].constructor) {\n            return 'ready';\n        }\n        return 'pending';\n    }\n}\nexports.RecordedState = RecordedState;\n\n\n//# sourceURL=webpack://vim/./src/state/recordedState.ts?")},"./src/state/remapState.ts":(__unused_webpack_module,exports)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RemapState = void 0;\n/**\n * State related to key remapping. Held by ModeHandler.\n */\nclass RemapState {\n    constructor() {\n        /**\n         * For timing out remapped keys like jj to esc.\n         */\n        this.lastKeyPressedTimestamp = 0;\n        /**\n         * Used to indicate that a non-recursive remap is being handled.\n         * This is used to prevent non-recursive remappings from looping.\n         */\n        this.isCurrentlyPerformingNonRecursiveRemapping = false;\n        /**\n         * Used to indicate that a recursive remap is being handled. This is used to prevent recursive remappings\n         * from looping farther then maxMapDepth and to stop recursive remappings when an action fails.\n         */\n        this.isCurrentlyPerformingRecursiveRemapping = false;\n        /**\n         * When performing a recursive remapping that has no parent remappings and that finishes while\n         * still waiting for timeout or another key to come we store that remapping here. This is used\n         * to be able to handle those buffered keys and any other key that the user might press to brake\n         * the timeout seperatly. Because if an error happens in the middle of a remap, the remaining\n         * remap keys shouldn't be handled but the user pressed ones should, but if an error happens on\n         * a user typed key, the following typed keys will still be handled.\n         *\n         * Example: having the following remapings:\n         * * `nmap <leader>lf Lfill`\n         * * `nmap Lfillc 4I<space><esc>`\n         * * `nmap Lfillp 2I<space><esc>`\n         * When user presses `<leader>lf` it remaps that to `Lfill` but because that is an ambiguous remap\n         * it creates the timeout and returns from remapper setting the performing remapping flag to false.\n         * This allows the user to then press `c` or `p` and the corresponding remap would run. But if the\n         * user presses another key or the timeout finishes we need to handle the `Lfill` keys and they\n         * need to know they were sent by a remap and not by the user so that in case the find 'i' in\n         * `Lfill` fails the last two `l` shouldn't be executed and any keys typed by the user after the\n         * remap that brake the timeout need to be handled seperatly from `Lfill`.\n         * (Check the tests for this example to understand better).\n         *\n         * To prevent this, we stored the remapping that finished waiting for timeout so that, if the\n         * timeout finishes or the user presses some keys that brake the potential remap, we will know\n         * what was the remapping waiting for timeout. So in case the timeout finishes we set the\n         * currently performing recursive remapping flag to true manually, send the <TimeoutFinished> key\n         * and in the end we set the flag back to false again and clear the stored remapping. In case\n         * the user presses one or more keys that brake the potential timeout we set the flag to true\n         * manually, handle the keys from the remapping and then set the flag back to false, clear the\n         * stored remapping and handle the keys pressed by the user seperatly.\n         * We do this because any VimError or ForceStopRemappingError are thrown only when performing a\n         * remapping.\n         */\n        this.wasPerformingRemapThatFinishedWaitingForTimeout = false;\n        /**\n         * Holds the current map depth count (number of nested remaps without using a character). In recursive remaps\n         * every time we map a key when already performing a remapping this number increases by one. When a remapping\n         * handling uses a character this number resets to 0.\n         *\n         * When it reaches the maxMapDepth it throws the VimError E223.\n         * (check vim documentation :help maxmapdepth)\n         */\n        this.mapDepth = 0;\n        /**\n         * Used to reset the mapDepth on nested recursive remaps. Is set to false every time we get a remapping and is set to\n         * true when a character is used. We consider a character as being used when we get an action.\n         * (check vim documentation :help maxmapdepth).\n         *\n         * Example 1: if we remap `x -> y` and `y -> x` if we press any of those keys we will continuously find a new\n         * remap and increase the mapDepth without ever using an action until we hit maxMapDepth and we get E223 stopping\n         * it all.\n         *\n         * Example 2: if we map `a -> x`, `x -> y`, `y -> b` and `b -> w` and we set maxMapDepth to 4 we get 'E223 Recursive\n         * Mapping', because we get to the fourth remap without ever executing an action, but if we change the 'y' map to\n         * `y -> wb`, now the max mapDepth we hit is 3 and then we execute the action 'w' that resets the mapDepth and then\n         * call another remap of `b -> w` that executes another 'w', meaning that after pressing 'a' the result would be 'ww'.\n         * Another option would be to increase the maxMapDepth to 5 or more and then we could use the initial remaps that would\n         * turn the pressing of 'a' into a single 'w'.\n         *\n         * Example 3 (possible use case): if we remap `<leader>cb -> 0i//<Space><Esc>j<leader>cb` that recursively calls itself,\n         * every time the`0` key is sent we set remapUsedACharacter to true and reset mapDepth to 0 on all nested remaps so even\n         * if it calls itself more than 1000 times (on a file with more than 1000 lines) the mapDepth will always be reset to 0,\n         * which allows the remap to keep calling itself to comment all the lines until either we get to the last line and the 'j'\n         * action fails stopping the entire remap chain or the user presses `<C-c>` or `<Esc>` to forcelly stop the recursive remaps.\n         *\n         * P.S. This behavior is weird, because we should reduce the mapDepth by one when the remapping finished handling\n         * or if it failed. But this is the way Vim does it. This allows the user to create infinite looping remaps\n         * that call themselves and only stop after an error or the user pressing a key (usually <C-c> but we also\n         * allow <Esc> because the user might not allow the use of ctrl keys).\n         *\n         * P.S.2 This is a complicated explanation for a seemingly simple feature, but I wrote this because when I first read the\n         * Vim documentation it wasn't very clear to me how this worked, I first thought that mapDepth was like a map count but that\n         * is not the case because we can have thousands of nested remaps without ever hitting maxMapDepth like in Example 3, and I\n         * only started to understand it better when I tried Example 2 in Vim and some variations of it.\n         */\n        this.remapUsedACharacter = false;\n        /**\n         * This will force Stop a recursive remapping. Used by <C-c> or <Esc> key when there is a recursive remapping\n         */\n        this.forceStopRecursiveRemapping = false;\n    }\n    /**\n     * Used to indicate that a remap is being handled and the keys sent to modeHandler were not typed\n     * by the user.\n     */\n    get isCurrentlyPerformingRemapping() {\n        return (this.isCurrentlyPerformingNonRecursiveRemapping ||\n            this.isCurrentlyPerformingRecursiveRemapping);\n    }\n}\nexports.RemapState = RemapState;\n\n\n//# sourceURL=webpack://vim/./src/state/remapState.ts?")},"./src/state/replaceState.ts":(__unused_webpack_module,exports)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.ReplaceState = void 0;\n/**\n * State involved with entering Replace mode (R).\n */\nclass ReplaceState {\n    getChanges(cursorIdx) {\n        if (this._changes[cursorIdx] === undefined) {\n            this._changes[cursorIdx] = [];\n        }\n        return this._changes[cursorIdx];\n    }\n    resetChanges(cursorIdx) {\n        this._changes[cursorIdx] = [];\n    }\n    constructor(startPositions, timesToRepeat = 1) {\n        this.timesToRepeat = timesToRepeat;\n        this._changes = startPositions.map((pos) => []);\n    }\n}\nexports.ReplaceState = ReplaceState;\n\n\n//# sourceURL=webpack://vim/./src/state/replaceState.ts?')},"./src/state/searchState.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SearchState = void 0;\nconst configuration_1 = __webpack_require__(/*! ../configuration/configuration */ \"./src/configuration/configuration.ts\");\nconst pattern_1 = __webpack_require__(/*! ../vimscript/pattern */ \"./src/vimscript/pattern.ts\");\n/**\n * @returns the least residue of n mod m in the range [0, m) if m > 0, or (m, 0] if m < 0\n */\nfunction mod(n, m) {\n    return (m + (n % m)) % m;\n}\n/**\n * State involved with beginning a search (/).\n */\nclass SearchState {\n    constructor(direction, startPosition, searchString = '', { ignoreSmartcase = false } = {}) {\n        this.matchRanges = new Map();\n        this._searchString = searchString;\n        const result = (0, pattern_1.searchStringParser)({ direction, ignoreSmartcase }).parse(this._searchString);\n        const { pattern, offset } = result.status\n            ? result.value\n            : { pattern: undefined, offset: undefined };\n        this.pattern = pattern;\n        this.offset = offset;\n        this.cursorStartPosition = startPosition;\n        this.ignoreSmartcase = ignoreSmartcase;\n    }\n    get searchString() {\n        return this._searchString;\n    }\n    set searchString(str) {\n        this._searchString = str;\n        const result = (0, pattern_1.searchStringParser)({\n            direction: this.direction,\n            ignoreSmartcase: this.ignoreSmartcase,\n        }).parse(str);\n        const { pattern, offset } = result.status\n            ? result.value\n            : { pattern: undefined, offset: undefined };\n        if (pattern?.patternString !== this.pattern?.patternString) {\n            this.pattern = pattern;\n            this.matchRanges.clear();\n        }\n        this.offset = offset;\n    }\n    get direction() {\n        // TODO: Defaulting to forward is wrong - I think storing the direction in the pattern is a mistake\n        return this.pattern?.direction ?? pattern_1.SearchDirection.Forward;\n    }\n    /**\n     * Every range in the document that matches the search string.\n     *\n     * This might not be 100% complete - @see Pattern::MAX_SEARCH_RANGES\n     */\n    getMatchRanges(vimState) {\n        return this.recalculateSearchRanges(vimState);\n    }\n    recalculateSearchRanges(vimState) {\n        if (this.searchString === '' || this.pattern === undefined) {\n            return [];\n        }\n        const document = vimState.document;\n        const cached = this.matchRanges.get(document.fileName);\n        if (cached?.version === document.version) {\n            return cached.ranges;\n        }\n        // TODO: It's weird to use the active selection for this...\n        const matchRanges = this.pattern\n            .allMatches(vimState, { fromPosition: vimState.editor.selection.active })\n            .map((match) => match.range);\n        this.matchRanges.set(document.fileName, {\n            version: document.version,\n            ranges: matchRanges,\n        });\n        return matchRanges;\n    }\n    /**\n     * @returns The start of the next match range, after applying the search offset\n     *\n     * @see getNextSearchMatchRange for parameters\n     */\n    getNextSearchMatchPosition(vimState, startPosition, direction = pattern_1.SearchDirection.Forward, relativeIndex = 0) {\n        const nextMatch = this.getNextSearchMatchRange(vimState, startPosition, direction, relativeIndex);\n        if (nextMatch === undefined) {\n            return undefined;\n        }\n        const { range, index } = nextMatch;\n        return { pos: this.offset ? this.offset.apply(range) : range.start, index };\n    }\n    /**\n     * @returns The next match range from the given position and its rank in the document's matches, or undefined if none exists.\n     * An optional index can be provided to target other matches relative to the next.\n     *\n     * @param direction If `SearchDirection.Backward`, this will search in the opposite of the pattern's direction\n     *\n     * @param relativeIndex Which match to return, relative to the next match. 0 (default) corresponds to the next match,\n     * 1 corresponds to the match after next (in the given direction), -1 corresponds to the match before next, etc.\n     *\n     * NOTE: This method does not take the search offset into account\n     */\n    getNextSearchMatchRange(vimState, fromPosition, direction = pattern_1.SearchDirection.Forward, relativeIndex = 0) {\n        const matchRanges = this.recalculateSearchRanges(vimState);\n        if (matchRanges.length === 0) {\n            return undefined;\n        }\n        const effectiveDirection = (direction * this.direction);\n        let index;\n        if (effectiveDirection === pattern_1.SearchDirection.Forward) {\n            for (let i = 0; i < matchRanges.length; i++) {\n                if ((this.offset?.apply(matchRanges[i]) ?? matchRanges[i].start).compareTo(fromPosition) > 0) {\n                    index = i;\n                    break;\n                }\n            }\n        }\n        else {\n            for (let i = matchRanges.length - 1; i >= 0; i--) {\n                if ((this.offset?.apply(matchRanges[i]) ?? matchRanges[i].start).compareTo(fromPosition) < 0) {\n                    index = i;\n                    break;\n                }\n            }\n        }\n        if (index === undefined) {\n            // We've hit the top/bottom of the file. Wrap around if configured to do so, or return undefined.\n            if (configuration_1.configuration.wrapscan) {\n                index = effectiveDirection === pattern_1.SearchDirection.Forward ? 0 : matchRanges.length - 1;\n            }\n            else {\n                return undefined;\n            }\n        }\n        // index of the first match now stored in variable index.\n        // Offsetting it by relativeIndex in the appropriate direction gets the index of the desired match.\n        index += effectiveDirection * relativeIndex;\n        if (0 <= index && index < matchRanges.length) {\n            return { index, range: matchRanges[index] };\n        }\n        // We've hit the top/bottom of the file. Wrap around (possibly many times) if configured to do so, or return undefined\n        if (configuration_1.configuration.wrapscan) {\n            index = mod(index, matchRanges.length);\n            return { index, range: matchRanges[index] };\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * @returns the match range which contains the given Position, or undefined if none exists\n     */\n    findContainingMatchRange(vimState, pos) {\n        const matchRanges = this.recalculateSearchRanges(vimState);\n        if (matchRanges.length === 0) {\n            return undefined;\n        }\n        for (const [index, range] of matchRanges.entries()) {\n            if (range.start.isBeforeOrEqual(pos) && range.end.isAfter(pos)) {\n                return {\n                    range,\n                    index,\n                };\n            }\n        }\n        return undefined;\n    }\n}\nexports.SearchState = SearchState;\n\n\n//# sourceURL=webpack://vim/./src/state/searchState.ts?")},"./src/state/substituteState.ts":(__unused_webpack_module,exports)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.SubstituteState = void 0;\n/**\n * State involved with Substitution commands (:s).\n */\nclass SubstituteState {\n    constructor(searchPattern, replaceString) {\n        this.searchPattern = searchPattern;\n        this.replaceString = replaceString;\n    }\n}\nexports.SubstituteState = SubstituteState;\n\n\n//# sourceURL=webpack://vim/./src/state/substituteState.ts?')},"./src/state/vimState.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.VimState = void 0;\nconst vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));\nconst configuration_1 = __webpack_require__(/*! ../configuration/configuration */ "./src/configuration/configuration.ts");\nconst historyTracker_1 = __webpack_require__(/*! ./../history/historyTracker */ "./src/history/historyTracker.ts");\nconst logger_1 = __webpack_require__(/*! ../util/logger */ "./src/util/logger.ts");\nconst mode_1 = __webpack_require__(/*! ../mode/mode */ "./src/mode/mode.ts");\nconst cursor_1 = __webpack_require__(/*! ../common/motion/cursor */ "./src/common/motion/cursor.ts");\nconst recordedState_1 = __webpack_require__(/*! ./recordedState */ "./src/state/recordedState.ts");\nconst register_1 = __webpack_require__(/*! ./../register/register */ "./src/register/register.ts");\nconst replaceState_1 = __webpack_require__(/*! ./../state/replaceState */ "./src/state/replaceState.ts");\nconst constants_1 = __webpack_require__(/*! platform/constants */ "./src/platform/browser/constants.ts");\nconst vscode_1 = __webpack_require__(/*! vscode */ "vscode");\nconst commandLine_1 = __webpack_require__(/*! ../cmd_line/commandLine */ "./src/cmd_line/commandLine.ts");\nconst pattern_1 = __webpack_require__(/*! ../vimscript/pattern */ "./src/vimscript/pattern.ts");\nconst globalState_1 = __webpack_require__(/*! ./globalState */ "./src/state/globalState.ts");\n/**\n * The VimState class holds permanent state that carries over from action\n * to action.\n *\n * Actions defined in actions.ts are only allowed to mutate a VimState in order to\n * indicate what they want to do.\n *\n * Each ModeHandler holds a VimState, so there is one for each open editor.\n */\nclass VimState {\n    get document() {\n        return this.editor.document;\n    }\n    /**\n     * Are multiple cursors currently present?\n     */\n    get isMultiCursor() {\n        return this._cursors.length > 1;\n    }\n    /**\n     * The cursor position (start, stop) when this action finishes.\n     */\n    get cursorStartPosition() {\n        return this.cursors[0].start;\n    }\n    set cursorStartPosition(value) {\n        if (!value.isValid(this.editor)) {\n            logger_1.Logger.warn(`invalid cursor start position. ${value.toString()}.`);\n        }\n        this.cursors[0] = this.cursors[0].withNewStart(value);\n    }\n    get cursorStopPosition() {\n        return this.cursors[0].stop;\n    }\n    set cursorStopPosition(value) {\n        if (!value.isValid(this.editor)) {\n            logger_1.Logger.warn(`invalid cursor stop position. ${value.toString()}.`);\n        }\n        this.cursors[0] = this.cursors[0].withNewStop(value);\n    }\n    get cursors() {\n        return this._cursors;\n    }\n    set cursors(value) {\n        if (value.length === 0) {\n            logger_1.Logger.warn(\'Tried to set VimState.cursors to an empty array\');\n            return;\n        }\n        const map = new Map();\n        for (const cursor of value) {\n            if (!cursor.isValid(this.editor)) {\n                logger_1.Logger.warn(`invalid cursor position. ${cursor.toString()}.`);\n            }\n            // use a map to ensure no two cursors are at the same location.\n            map.set(cursor.toString(), cursor);\n        }\n        this._cursors = [...map.values()];\n    }\n    get cursorsInitialState() {\n        return this._cursorsInitialState;\n    }\n    set cursorsInitialState(cursors) {\n        this._cursorsInitialState = [...cursors];\n    }\n    get currentMode() {\n        return this.modeData.mode;\n    }\n    /**\n     * The mode Vim is currently including pseudo-modes like OperatorPendingMode\n     * This is to be used only by the Remappers when getting the remappings so don\'t\n     * use it anywhere else.\n     */\n    get currentModeIncludingPseudoModes() {\n        return this.recordedState.getOperatorState(this.currentMode) === \'pending\'\n            ? mode_1.Mode.OperatorPendingMode\n            : this.currentMode;\n    }\n    async setModeData(modeData) {\n        if (modeData === undefined) {\n            // TODO: remove this once we\'re sure this is no longer an issue (#6500, #6464)\n            throw new Error(\'Tried setting modeData to undefined\');\n        }\n        await this.inputMethodSwitcher?.switchInputMethod(this.currentMode, modeData.mode);\n        if (this.returnToInsertAfterCommand && modeData.mode === mode_1.Mode.Insert) {\n            this.returnToInsertAfterCommand = false;\n        }\n        if (modeData.mode === mode_1.Mode.SearchInProgressMode) {\n            globalState_1.globalState.searchState = modeData.commandLine.getSearchState();\n        }\n        if (configuration_1.configuration.smartRelativeLine) {\n            this.editor.options.lineNumbers =\n                modeData.mode === mode_1.Mode.Insert\n                    ? vscode.TextEditorLineNumbersStyle.On\n                    : vscode.TextEditorLineNumbersStyle.Relative;\n        }\n        this.modeData = modeData;\n    }\n    async setCurrentMode(mode) {\n        if (mode === undefined) {\n            // TODO: remove this once we\'re sure this is no longer an issue (#6500, #6464)\n            throw new Error(\'Tried setting currentMode to undefined\');\n        }\n        await this.setModeData(mode === mode_1.Mode.Replace\n            ? {\n                mode,\n                replaceState: new replaceState_1.ReplaceState(this.cursors.map((cursor) => cursor.stop), this.recordedState.count),\n            }\n            : mode === mode_1.Mode.CommandlineInProgress\n                ? {\n                    mode,\n                    commandLine: new commandLine_1.ExCommandLine(\'\', this.modeData.mode),\n                }\n                : mode === mode_1.Mode.SearchInProgressMode\n                    ? {\n                        mode,\n                        commandLine: new commandLine_1.SearchCommandLine(this, \'\', pattern_1.SearchDirection.Forward),\n                        firstVisibleLineBeforeSearch: this.editor.visibleRanges[0].start.line,\n                    }\n                    : mode === mode_1.Mode.Insert\n                        ? {\n                            mode,\n                            highSurrogate: undefined,\n                        }\n                        : { mode });\n    }\n    /**\n     * The currently active `RegisterMode`.\n     *\n     * When setting, `undefined` means "default for current `Mode`".\n     */\n    set currentRegisterMode(registerMode) {\n        this._currentRegisterMode = registerMode;\n    }\n    get currentRegisterMode() {\n        if (this._currentRegisterMode) {\n            return this._currentRegisterMode;\n        }\n        switch (this.currentMode) {\n            case mode_1.Mode.VisualLine:\n                return register_1.RegisterMode.LineWise;\n            case mode_1.Mode.VisualBlock:\n                return register_1.RegisterMode.BlockWise;\n            default:\n                return register_1.RegisterMode.CharacterWise;\n        }\n    }\n    constructor(editor, easyMotion) {\n        /**\n         * The column the cursor wants to be at, or Number.POSITIVE_INFINITY if it should always\n         * be the rightmost column.\n         *\n         * Example: If you go to the end of a 20 character column, this value\n         * will be 20, even if you press j and the next column is only 5 characters.\n         * This is because if the third column is 25 characters, the cursor will go\n         * back to the 20th column.\n         */\n        this.desiredColumn = 0;\n        /**\n         * Is the multicursor something like visual block "multicursor", where\n         * natively in vim there would only be one cursor whose changes were applied\n         * to all lines after edit.\n         */\n        this.isFakeMultiCursor = false;\n        /**\n         * Tracks movements that can be repeated with ; (e.g. t, T, f, and F).\n         */\n        this.lastSemicolonRepeatableMovement = undefined;\n        /**\n         * Tracks movements that can be repeated with , (e.g. t, T, f, and F).\n         */\n        this.lastCommaRepeatableMovement = undefined;\n        // TODO: move into ModeHandler\n        this.lastMovementFailed = false;\n        /**\n         * Keep track of whether the last command that ran is able to be repeated\n         * with the dot command.\n         */\n        this.lastCommandDotRepeatable = true;\n        this.isRunningDotCommand = false;\n        this.isReplayingMacro = false;\n        /**\n         * The last visual selection before running the dot command\n         */\n        this.dotCommandPreviousVisualSelection = undefined;\n        this.surround = undefined;\n        /**\n         * Used for `<C-o>` in insert mode, which allows you run one normal mode\n         * command, then go back to insert mode.\n         */\n        this.returnToInsertAfterCommand = false;\n        this.actionCount = 0;\n        /**\n         * Every time we invoke a VSCode command which might trigger a view update.\n         * We should postpone its view updating phase to avoid conflicting with our internal view updating mechanism.\n         * This array is used to cache every VSCode view updating event and they will be triggered once we run the inhouse `viewUpdate`.\n         */\n        this.postponedCodeViewChanges = [];\n        /**\n         * The position of every cursor. Will never be empty.\n         */\n        this._cursors = [new cursor_1.Cursor(new vscode_1.Position(0, 0), new vscode_1.Position(0, 0))];\n        /**\n         * Stores last visual mode as well as what was selected for `gv`\n         */\n        this.lastVisualSelection = undefined;\n        /**\n         * The current mode and its associated state.\n         */\n        this.modeData = { mode: mode_1.Mode.Normal };\n        this.recordedState = new recordedState_1.RecordedState();\n        this.editor = editor;\n        this.documentUri = editor?.document.uri ?? vscode.Uri.file(\'\'); // TODO: this is needed for some badly written tests\n        this.historyTracker = new historyTracker_1.HistoryTracker(this);\n        this.easyMotion = easyMotion;\n    }\n    async load() {\n        if (constants_1.SUPPORT_NVIM) {\n            const m = await Promise.resolve().then(() => __importStar(__webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module \'../neovim/neovim\'"); e.code = \'MODULE_NOT_FOUND\'; throw e; }()))));\n            this.nvim = new m.NeovimWrapper();\n        }\n        if (constants_1.SUPPORT_IME_SWITCHER) {\n            const ime = await Promise.resolve().then(() => __importStar(__webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module \'../actions/plugins/imswitcher\'"); e.code = \'MODULE_NOT_FOUND\'; throw e; }()))));\n            this.inputMethodSwitcher = new ime.InputMethodSwitcher();\n        }\n    }\n    dispose() {\n        this.nvim?.dispose();\n    }\n}\nexports.VimState = VimState;\n\n\n//# sourceURL=webpack://vim/./src/state/vimState.ts?')},"./src/statusBar.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.statusBarCommandText = exports.statusBarText = exports.StatusBar = void 0;\nconst vscode = __importStar(__webpack_require__(/*! vscode */ \"vscode\"));\nconst configuration_1 = __webpack_require__(/*! ./configuration/configuration */ \"./src/configuration/configuration.ts\");\nconst mode_1 = __webpack_require__(/*! ./mode/mode */ \"./src/mode/mode.ts\");\nconst logger_1 = __webpack_require__(/*! ./util/logger */ \"./src/util/logger.ts\");\nclass StatusBarImpl {\n    constructor() {\n        this.previousMode = undefined;\n        this.showingDefaultMessage = true;\n        this.statusBarItem = vscode.window.createStatusBarItem('primary', vscode.StatusBarAlignment.Left, Number.MIN_SAFE_INTEGER);\n        this.statusBarItem.name = 'Vim Command Line';\n        this.statusBarItem.show();\n        this.recordedStateStatusBarItem = vscode.window.createStatusBarItem('showcmd', vscode.StatusBarAlignment.Right, Number.MAX_SAFE_INTEGER);\n        this.recordedStateStatusBarItem.name = 'Vim Pending Command Keys';\n        this.recordedStateStatusBarItem.show();\n    }\n    dispose() {\n        this.statusBarItem.dispose();\n        this.recordedStateStatusBarItem.dispose();\n    }\n    updateShowCmd(vimState) {\n        this.recordedStateStatusBarItem.text = configuration_1.configuration.showcmd\n            ? statusBarCommandText(vimState)\n            : '';\n    }\n    /**\n     * Updates the status bar text\n     * @param isError If true, text rendered in red\n     */\n    setText(vimState, text, isError = false) {\n        // Text\n        text = text.replace(/\\n/g, '^M');\n        if (this.statusBarItem.text !== text) {\n            this.statusBarItem.text = text;\n            logger_1.Logger.debug(`Status bar: ${text}`);\n        }\n        // StatusBarItem color\n        if (!configuration_1.configuration.statusBarColorControl) {\n            this.statusBarItem.color = isError\n                ? new vscode.ThemeColor('statusBarItem.errorForeground')\n                : undefined;\n            this.statusBarItem.backgroundColor = isError\n                ? new vscode.ThemeColor('statusBarItem.errorBackground')\n                : undefined;\n        }\n        // StatusBar color\n        const shouldUpdateColor = configuration_1.configuration.statusBarColorControl && vimState.currentMode !== this.previousMode;\n        if (shouldUpdateColor) {\n            this.updateColor(vimState.currentMode);\n        }\n        this.previousMode = vimState.currentMode;\n        this.showingDefaultMessage = false;\n        this.lastMessageTime = new Date();\n    }\n    displayError(vimState, error) {\n        exports.StatusBar.setText(vimState, error.toString(), true);\n    }\n    getText() {\n        return this.statusBarItem.text.replace(/\\^M/g, '\\n');\n    }\n    /**\n     * Clears any messages from the status bar, leaving the default info, such as\n     * the current mode and macro being recorded.\n     * @param force If true, will clear even high priority messages like errors.\n     */\n    clear(vimState, force = true) {\n        if (!this.showingDefaultMessage && !force) {\n            return;\n        }\n        const text = [];\n        if (configuration_1.configuration.showmodename ||\n            vimState.currentMode === mode_1.Mode.CommandlineInProgress ||\n            vimState.currentMode === mode_1.Mode.SearchInProgressMode) {\n            text.push(statusBarText(vimState));\n            if (vimState.isMultiCursor) {\n                text.push(' MULTI CURSOR ');\n            }\n        }\n        if (vimState.macro) {\n            const macroText = 'Recording @' + vimState.macro.registerName;\n            text.push(macroText);\n        }\n        exports.StatusBar.setText(vimState, text.join(' '));\n        this.showingDefaultMessage = true;\n    }\n    updateColor(mode) {\n        let foreground;\n        let background;\n        const colorToSet = configuration_1.configuration.statusBarColors[mode_1.Mode[mode].toLowerCase()];\n        if (colorToSet !== undefined) {\n            if (typeof colorToSet === 'string') {\n                background = colorToSet;\n            }\n            else {\n                [background, foreground] = colorToSet;\n            }\n        }\n        const workbenchConfiguration = configuration_1.configuration.getConfiguration('workbench');\n        const currentColorCustomizations = workbenchConfiguration.get('colorCustomizations') ?? {};\n        const colorCustomizations = { ...currentColorCustomizations };\n        // If colors are undefined, return to VSCode defaults\n        if (background !== undefined) {\n            colorCustomizations['statusBar.background'] = background;\n            colorCustomizations['statusBar.noFolderBackground'] = background;\n            colorCustomizations['statusBar.debuggingBackground'] = background;\n        }\n        if (foreground !== undefined) {\n            colorCustomizations['statusBar.foreground'] = foreground;\n            colorCustomizations['statusBar.debuggingForeground'] = foreground;\n        }\n        if (currentColorCustomizations !== colorCustomizations) {\n            void workbenchConfiguration.update('colorCustomizations', colorCustomizations, true);\n        }\n    }\n}\nexports.StatusBar = new StatusBarImpl();\nfunction statusBarText(vimState) {\n    const cursorChar = vimState.recordedState.actionKeys[vimState.recordedState.actionKeys.length - 1] === '<C-r>'\n        ? '\"'\n        : '|';\n    switch (vimState.modeData.mode) {\n        case mode_1.Mode.Normal:\n            return '-- NORMAL --';\n        case mode_1.Mode.Insert:\n            return '-- INSERT --';\n        case mode_1.Mode.Visual:\n            return '-- VISUAL --';\n        case mode_1.Mode.VisualBlock:\n            return '-- VISUAL BLOCK --';\n        case mode_1.Mode.VisualLine:\n            return '-- VISUAL LINE --';\n        case mode_1.Mode.Replace:\n            return '-- REPLACE --';\n        case mode_1.Mode.EasyMotionMode:\n            return '-- EASYMOTION --';\n        case mode_1.Mode.EasyMotionInputMode:\n            return '-- EASYMOTION INPUT --';\n        case mode_1.Mode.SurroundInputMode:\n            return '-- SURROUND INPUT --';\n        case mode_1.Mode.Disabled:\n            return '-- VIM: DISABLED --';\n        case mode_1.Mode.SearchInProgressMode:\n            return vimState.modeData.commandLine.display(cursorChar);\n        case mode_1.Mode.CommandlineInProgress:\n            return vimState.modeData.commandLine.display(cursorChar);\n        default:\n            return '';\n    }\n}\nexports.statusBarText = statusBarText;\nfunction statusBarCommandText(vimState) {\n    switch (vimState.currentMode) {\n        case mode_1.Mode.SurroundInputMode:\n            return vimState.surround && vimState.surround.replacement\n                ? vimState.surround.replacement\n                : '';\n        case mode_1.Mode.EasyMotionMode:\n            return `Target key: ${vimState.easyMotion.accumulation}`;\n        case mode_1.Mode.EasyMotionInputMode:\n            if (!vimState.easyMotion) {\n                return '';\n            }\n            const searchCharCount = vimState.easyMotion.searchAction.searchCharCount;\n            const message = searchCharCount > 0\n                ? `Search for ${searchCharCount} character(s): `\n                : 'Search for characters: ';\n            return message + vimState.easyMotion.searchAction.searchString;\n        case mode_1.Mode.Visual: {\n            // TODO: holy shit, this is SO much more complicated than it should be because\n            // our representation of a visual selection is so weird and inconsistent\n            let [start, end] = [vimState.cursorStartPosition, vimState.cursorStopPosition];\n            let wentOverEOL = false;\n            if (start.isAfter(end)) {\n                start = start.getRightThroughLineBreaks();\n                [start, end] = [end, start];\n            }\n            else if (end.isAfter(start) && end.character === 0) {\n                end = end.getLeftThroughLineBreaks(true);\n                wentOverEOL = true;\n            }\n            const lines = end.line - start.line + 1;\n            if (lines > 1) {\n                return `${lines} ${vimState.recordedState.pendingCommandString}`;\n            }\n            else {\n                const chars = Math.max(end.character - start.character, 1) + (wentOverEOL ? 1 : 0);\n                return `${chars} ${vimState.recordedState.pendingCommandString}`;\n            }\n        }\n        case mode_1.Mode.VisualLine:\n            return `${Math.abs(vimState.cursorStopPosition.line - vimState.cursorStartPosition.line) + 1} ${vimState.recordedState.pendingCommandString}`;\n        case mode_1.Mode.VisualBlock: {\n            const lines = Math.abs(vimState.cursorStopPosition.line - vimState.cursorStartPosition.line) + 1;\n            const chars = Math.abs(vimState.cursorStopPosition.character - vimState.cursorStartPosition.character) +\n                1;\n            return `${lines}x${chars} ${vimState.recordedState.pendingCommandString}`;\n        }\n        case mode_1.Mode.Insert:\n        case mode_1.Mode.Replace:\n            return vimState.recordedState.pendingCommandString;\n        case mode_1.Mode.Normal:\n        case mode_1.Mode.Disabled:\n            return vimState.recordedState.commandString;\n        default:\n            return '';\n    }\n}\nexports.statusBarCommandText = statusBarCommandText;\n\n\n//# sourceURL=webpack://vim/./src/statusBar.ts?")},"./src/taskQueue.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.taskQueue = void 0;\nconst queue_1 = __importDefault(__webpack_require__(/*! queue */ "./node_modules/queue/index.js"));\nconst logger_1 = __webpack_require__(/*! ./util/logger */ "./src/util/logger.ts");\nclass TaskQueue {\n    constructor() {\n        this.taskQueue = new queue_1.default({ autostart: true, concurrency: 1 });\n        this.taskQueue.addListener(\'error\', (err, task) => {\n            // TODO: Report via telemetry API?\n            logger_1.Logger.error(`Error running task: ${err}`);\n        });\n    }\n    /**\n     * Adds a task to the task queue.\n     */\n    enqueueTask(task) {\n        this.taskQueue.push(task);\n    }\n}\nexports.taskQueue = new TaskQueue();\n\n\n//# sourceURL=webpack://vim/./src/taskQueue.ts?')},"./src/textEditor.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.TextEditor = void 0;\nconst vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));\nconst configuration_1 = __webpack_require__(/*! ./configuration/configuration */ "./src/configuration/configuration.ts");\nconst mode_1 = __webpack_require__(/*! ./mode/mode */ "./src/mode/mode.ts");\nconst vscode_1 = __webpack_require__(/*! vscode */ "vscode");\nconst logger_1 = __webpack_require__(/*! ./util/logger */ "./src/util/logger.ts");\nconst util_1 = __webpack_require__(/*! ./util/util */ "./src/util/util.ts");\n/**\n * Collection of helper functions around vscode.window.activeTextEditor\n */\nclass TextEditor {\n    /**\n     * @deprecated Use InsertTextTransformation (or InsertTextVSCodeTransformation) instead.\n     */\n    static async insert(editor, text, at, letVSCodeHandleKeystrokes) {\n        // If we insert "blah(" with default:type, VSCode will insert the closing ).\n        // We *probably* don\'t want that to happen if we\'re inserting a lot of text.\n        letVSCodeHandleKeystrokes ??= text.length === 1;\n        if (!letVSCodeHandleKeystrokes) {\n            await editor.edit((editBuilder) => {\n                if (!at) {\n                    at = editor.selection.active;\n                }\n                editBuilder.insert(at, text);\n            });\n        }\n        else {\n            await vscode.commands.executeCommand(\'default:type\', { text });\n        }\n    }\n    /**\n     * @deprecated. Use ReplaceTextTransformation instead.\n     */\n    static async replace(editor, range, text) {\n        return editor.edit((editBuilder) => {\n            editBuilder.replace(range, text);\n        });\n    }\n    /** @deprecated Use vimState.document.lineCount */\n    static getLineCount(textEditor) {\n        textEditor ??= vscode.window.activeTextEditor;\n        return textEditor?.document.lineCount ?? -1;\n    }\n    static getLineLength(line) {\n        if (line < 0 || line >= TextEditor.getLineCount()) {\n            logger_1.Logger.warn(`getLineLength() called with out-of-bounds line ${line}`);\n            return 0;\n        }\n        return vscode.window.activeTextEditor.document.lineAt(line).text.length;\n    }\n    /** @deprecated Use `vimState.document.lineAt()` directly */\n    static getLine(lineNumber) {\n        return vscode.window.activeTextEditor.document.lineAt(lineNumber);\n    }\n    static getCharAt(document, position) {\n        position = document.validatePosition(position);\n        return document.lineAt(position).text[position.character];\n    }\n    /**\n     * Retrieves the word at the given position.\n     *\n     * Respects `iskeyword`:\n     *    - Will go right (but not over line boundaries) until it finds a "real" word\n     *    - Will settle for a "fake" word only if it hits the line end\n     */\n    static getWord(document, position) {\n        const line = document.lineAt(position).text;\n        // Skip over whitespace\n        let firstNonBlank = position.character;\n        while (this.whitespaceRegExp.test(line[firstNonBlank])) {\n            firstNonBlank++;\n            if (firstNonBlank === line.length) {\n                // Hit end of line without finding a non-whitespace character\n                return undefined;\n            }\n        }\n        // Now skip over word separators and whitespace to find a "real" word\n        let start = firstNonBlank;\n        while (configuration_1.configuration.iskeyword.includes(line[start]) ||\n            this.whitespaceRegExp.test(line[start])) {\n            start++;\n            if (start === line.length) {\n                // No keyword found - just settle for the word we\'re on\n                start = firstNonBlank;\n                break;\n            }\n        }\n        const foundRealWord = !configuration_1.configuration.iskeyword.includes(line[start]);\n        const includeInWord = (char) => !this.whitespaceRegExp.test(char) && configuration_1.configuration.iskeyword.includes(char) !== foundRealWord;\n        // Expand left and right to find the whole word\n        let end = start;\n        while (start > 0 && includeInWord(line[start - 1])) {\n            start--;\n        }\n        while (end < line.length && includeInWord(line[end + 1])) {\n            end++;\n        }\n        return line.substring(start, end + 1);\n    }\n    static getTabCharacter(editor) {\n        if (editor.options.insertSpaces) {\n            // This will always be a number when we\'re getting it from the options\n            const tabSize = editor.options.tabSize;\n            return \' \'.repeat(tabSize);\n        }\n        return \'\\t\';\n    }\n    /**\n     * @returns the number of visible columns that the given line begins with\n     */\n    static getIndentationLevel(line, tabSize) {\n        let visibleColumn = 0;\n        for (const char of line) {\n            switch (char) {\n                case \'\\t\':\n                    visibleColumn += tabSize;\n                    break;\n                case \' \':\n                    visibleColumn += 1;\n                    break;\n                default:\n                    return visibleColumn;\n            }\n        }\n        return visibleColumn;\n    }\n    /**\n     * @returns `line` with its indentation replaced with `screenCharacters` visible columns of whitespace\n     */\n    static setIndentationLevel(line, screenCharacters, expandtab) {\n        const tabSize = configuration_1.configuration.tabstop;\n        if (screenCharacters < 0) {\n            screenCharacters = 0;\n        }\n        const indentString = expandtab\n            ? \' \'.repeat(screenCharacters)\n            : \'\\t\'.repeat(screenCharacters / tabSize) + \' \'.repeat(screenCharacters % tabSize);\n        return line.replace(/^\\s*/, indentString);\n    }\n    static getDocumentBegin() {\n        return new vscode_1.Position(0, 0);\n    }\n    static getDocumentEnd(document) {\n        const line = Math.max(document.lineCount, 1) - 1;\n        return document.lineAt(line).range.end;\n    }\n    /**\n     * @returns the Position of the first character on the given line which is not whitespace.\n     * If it\'s all whitespace, will return the Position of the EOL character.\n     */\n    static getFirstNonWhitespaceCharOnLine(document, line) {\n        line = (0, util_1.clamp)(line, 0, document.lineCount - 1);\n        return new vscode_1.Position(line, document.lineAt(line).firstNonWhitespaceCharacterIndex);\n    }\n    /**\n     * Iterate over every line in the block defined by the two positions (Range) passed in.\n     * If no range is given, the primary cursor will be used as the block.\n     *\n     * This is intended for visual block mode.\n     */\n    static *iterateLinesInBlock(vimState, cursor, options = { reverse: false }) {\n        const { reverse } = options;\n        cursor ??= vimState.cursors[0];\n        const topLeft = (0, mode_1.visualBlockGetTopLeftPosition)(cursor.start, cursor.stop);\n        const bottomRight = (0, mode_1.visualBlockGetBottomRightPosition)(cursor.start, cursor.stop);\n        const [itrStart, itrEnd] = reverse\n            ? [bottomRight.line, topLeft.line]\n            : [topLeft.line, bottomRight.line];\n        const runToLineEnd = vimState.desiredColumn === Number.POSITIVE_INFINITY;\n        for (let lineIndex = itrStart; reverse ? lineIndex >= itrEnd : lineIndex <= itrEnd; reverse ? lineIndex-- : lineIndex++) {\n            const line = vimState.document.lineAt(lineIndex).text;\n            const endCharacter = runToLineEnd\n                ? line.length + 1\n                : Math.min(line.length, bottomRight.character + 1);\n            yield {\n                line: line.substring(topLeft.character, endCharacter),\n                start: new vscode_1.Position(lineIndex, topLeft.character),\n                end: new vscode_1.Position(lineIndex, endCharacter),\n            };\n        }\n    }\n    /**\n     * Iterates through words on the same line, starting from the current position.\n     */\n    static *iterateWords(document, start) {\n        const text = document.lineAt(start).text;\n        if (/\\s/.test(text[start.character])) {\n            start = start.nextWordStart(document);\n        }\n        let wordEnd = start.nextWordEnd(document, { inclusive: true });\n        do {\n            const word = text.substring(start.character, wordEnd.character + 1);\n            yield {\n                start,\n                end: wordEnd,\n                word,\n            };\n            if (wordEnd.getRight().isLineEnd()) {\n                return;\n            }\n            start = start.nextWordStart(document);\n            wordEnd = start.nextWordEnd(document, { inclusive: true });\n        } while (true);\n    }\n}\nexports.TextEditor = TextEditor;\nTextEditor.whitespaceRegExp = new RegExp(\'\\\\s+\');\n\n\n//# sourceURL=webpack://vim/./src/textEditor.ts?')},"./src/textobject/paragraph.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getCurrentParagraphBeginning = exports.getCurrentParagraphEnd = void 0;\nconst vscode_1 = __webpack_require__(/*! vscode */ \"vscode\");\nconst textEditor_1 = __webpack_require__(/*! ../textEditor */ \"./src/textEditor.ts\");\n/**\n * Get the end of the current paragraph.\n */\nfunction getCurrentParagraphEnd(pos, trimWhite = false) {\n    const lastLine = textEditor_1.TextEditor.getLineCount() - 1;\n    let line = pos.line;\n    // If we're not in a paragraph yet, go down until we are.\n    while (line < lastLine && isLineBlank(line, trimWhite)) {\n        line++;\n    }\n    // Go until we're outside of the paragraph, or at the end of the document.\n    while (line < lastLine && !isLineBlank(line, trimWhite)) {\n        line++;\n    }\n    return pos.with({ line }).getLineEnd();\n}\nexports.getCurrentParagraphEnd = getCurrentParagraphEnd;\n/**\n * Get the beginning of the current paragraph.\n */\nfunction getCurrentParagraphBeginning(pos, trimWhite = false) {\n    let line = pos.line;\n    // If we're not in a paragraph yet, go up until we are.\n    while (line > 0 && isLineBlank(line, trimWhite)) {\n        line--;\n    }\n    // Go until we're outside of the paragraph, or at the beginning of the document.\n    while (line > 0 && !isLineBlank(line, trimWhite)) {\n        line--;\n    }\n    return new vscode_1.Position(line, 0);\n}\nexports.getCurrentParagraphBeginning = getCurrentParagraphBeginning;\nfunction isLineBlank(line, trimWhite = false) {\n    const text = textEditor_1.TextEditor.getLine(line).text;\n    return (trimWhite ? text.trim() : text) === '';\n}\n\n\n//# sourceURL=webpack://vim/./src/textobject/paragraph.ts?")},"./src/textobject/sentence.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.getSentenceEnd = exports.getSentenceBegin = void 0;\nconst vscode_1 = __webpack_require__(/*! vscode */ "vscode");\nconst textEditor_1 = __webpack_require__(/*! ../textEditor */ "./src/textEditor.ts");\nconst paragraph_1 = __webpack_require__(/*! ./paragraph */ "./src/textobject/paragraph.ts");\nconst util_1 = __webpack_require__(/*! ./util */ "./src/textobject/util.ts");\nconst sentenceEndRegex = /[\\.!\\?]["\')\\]]*?([ \\n\\t]+|$)/g;\nfunction getSentenceBegin(position, args) {\n    if (args.forward) {\n        return getNextSentenceBegin(position);\n    }\n    else {\n        return getPreviousSentenceBegin(position);\n    }\n}\nexports.getSentenceBegin = getSentenceBegin;\nfunction getSentenceEnd(pos) {\n    const paragraphEnd = (0, paragraph_1.getCurrentParagraphEnd)(pos);\n    for (let currentLine = pos.line; currentLine <= paragraphEnd.line; currentLine++) {\n        const allPositions = (0, util_1.getAllPositions)(textEditor_1.TextEditor.getLine(currentLine).text, sentenceEndRegex);\n        const newCharacter = allPositions.find((index) => index > pos.character || currentLine !== pos.line);\n        if (newCharacter !== undefined) {\n            return new vscode_1.Position(currentLine, newCharacter);\n        }\n    }\n    return getFirstNonWhitespaceInParagraph(pos, paragraphEnd, false);\n}\nexports.getSentenceEnd = getSentenceEnd;\nfunction getPreviousSentenceBegin(pos) {\n    const paragraphBegin = (0, paragraph_1.getCurrentParagraphBeginning)(pos);\n    for (let currentLine = pos.line; currentLine >= paragraphBegin.line; currentLine--) {\n        const endPositions = (0, util_1.getAllEndPositions)(textEditor_1.TextEditor.getLine(currentLine).text, sentenceEndRegex);\n        const newCharacter = endPositions.reverse().find((index) => {\n            const newPositionBeforeThis = new vscode_1.Position(currentLine, index)\n                .getRightThroughLineBreaks()\n                .compareTo(pos);\n            return newPositionBeforeThis && (index < pos.character || currentLine < pos.line);\n        });\n        if (newCharacter !== undefined) {\n            return new vscode_1.Position(currentLine, newCharacter).getRightThroughLineBreaks();\n        }\n    }\n    if (paragraphBegin.line + 1 === pos.line || paragraphBegin.line === pos.line) {\n        return paragraphBegin;\n    }\n    else {\n        return new vscode_1.Position(paragraphBegin.line + 1, 0);\n    }\n}\nfunction getNextSentenceBegin(pos) {\n    // A paragraph and section boundary is also a sentence boundary.\n    const paragraphEnd = (0, paragraph_1.getCurrentParagraphEnd)(pos);\n    for (let currentLine = pos.line; currentLine <= paragraphEnd.line; currentLine++) {\n        const endPositions = (0, util_1.getAllEndPositions)(textEditor_1.TextEditor.getLine(currentLine).text, sentenceEndRegex);\n        const newCharacter = endPositions.find((index) => index > pos.character || currentLine !== pos.line);\n        if (newCharacter !== undefined) {\n            return new vscode_1.Position(currentLine, newCharacter).getRightThroughLineBreaks();\n        }\n    }\n    return getFirstNonWhitespaceInParagraph(pos, paragraphEnd, false);\n}\nfunction getFirstNonWhitespaceInParagraph(pos, paragraphEnd, inclusive) {\n    // If the cursor is at an empty line, it\'s the end of a paragraph and the begin of another paragraph\n    // Find the first non-whitespace character.\n    if (textEditor_1.TextEditor.getLine(pos.line).text) {\n        return paragraphEnd;\n    }\n    else {\n        for (let currentLine = pos.line; currentLine <= paragraphEnd.line; currentLine++) {\n            const nonWhitePositions = (0, util_1.getAllPositions)(textEditor_1.TextEditor.getLine(currentLine).text, /\\S/g);\n            const newCharacter = nonWhitePositions.find((index) => (index > pos.character && !inclusive) ||\n                (index >= pos.character && inclusive) ||\n                currentLine !== pos.line);\n            if (newCharacter !== undefined) {\n                return new vscode_1.Position(currentLine, newCharacter);\n            }\n        }\n    }\n    // Only happens at end of document\n    return pos;\n}\n\n\n//# sourceURL=webpack://vim/./src/textobject/sentence.ts?')},"./src/textobject/textobject.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SelectAroundArgument = exports.SelectInnerArgument = exports.SelectEntireIgnoringLeadingTrailing = exports.SelectEntire = exports.SelectInnerParagraph = exports.SelectParagraph = exports.SelectInnerSentence = exports.SelectSentence = exports.SelectInnerBigWord = exports.SelectInnerWord = exports.SelectAnExpandingBlock = exports.SelectABigWord = exports.SelectWord = exports.TextObject = void 0;\nconst cursor_1 = __webpack_require__(/*! ../common/motion/cursor */ \"./src/common/motion/cursor.ts\");\nconst mode_1 = __webpack_require__(/*! ../mode/mode */ \"./src/mode/mode.ts\");\nconst register_1 = __webpack_require__(/*! ../register/register */ \"./src/register/register.ts\");\nconst textEditor_1 = __webpack_require__(/*! ../textEditor */ \"./src/textEditor.ts\");\nconst base_1 = __webpack_require__(/*! ../actions/base */ \"./src/actions/base.ts\");\nconst baseMotion_1 = __webpack_require__(/*! ../actions/baseMotion */ \"./src/actions/baseMotion.ts\");\nconst motion_1 = __webpack_require__(/*! ../actions/motion */ \"./src/actions/motion.ts\");\nconst operator_1 = __webpack_require__(/*! ../actions/operator */ \"./src/actions/operator.ts\");\nconst configuration_1 = __webpack_require__(/*! ../configuration/configuration */ \"./src/configuration/configuration.ts\");\nconst paragraph_1 = __webpack_require__(/*! ./paragraph */ \"./src/textobject/paragraph.ts\");\nconst vscode_1 = __webpack_require__(/*! vscode */ \"vscode\");\nconst word_1 = __webpack_require__(/*! ./word */ \"./src/textobject/word.ts\");\nclass TextObject extends baseMotion_1.BaseMovement {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualBlock];\n    }\n    async execActionForOperator(position, vimState) {\n        const res = await this.execAction(position, vimState);\n        // Since we need to handle leading spaces, we cannot use MoveWordBegin.execActionForOperator\n        // In normal mode, the character on the stop position will be the first character after the operator executed\n        // and we do left-shifting in operator-pre-execution phase, here we need to right-shift the stop position accordingly.\n        res.stop = new vscode_1.Position(res.stop.line, res.stop.character + 1);\n        return res;\n    }\n}\nexports.TextObject = TextObject;\nlet SelectWord = class SelectWord extends TextObject {\n    constructor() {\n        super(...arguments);\n        this.keys = ['a', 'w'];\n    }\n    async execAction(position, vimState) {\n        let start;\n        let stop;\n        const currentChar = textEditor_1.TextEditor.getCharAt(vimState.document, position);\n        if (currentChar === undefined) {\n            start = position;\n            stop = position.nextWordEnd(vimState.document);\n        }\n        else if (/\\s/.test(currentChar)) {\n            start = position.prevWordEnd(vimState.document).getRight();\n            stop = position.nextWordEnd(vimState.document);\n        }\n        else {\n            stop = position.nextWordStart(vimState.document);\n            // If the next word is not at the beginning of the next line, we want to pretend it is.\n            // This is because 'aw' has two fundamentally different behaviors distinguished by whether\n            // the next word is directly after the current word, as described in the following comment.\n            // The only case that's not true is in cases like #1350.\n            if (stop.isEqual(textEditor_1.TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, stop.line))) {\n                stop = stop.getLineBegin();\n            }\n            stop = stop.getLeftThroughLineBreaks().getLeftIfEOL();\n            // If we aren't separated from the next word by whitespace(like in \"horse ca|t,dog\" or at the end of the line)\n            // then we delete the spaces to the left of the current word. Otherwise, we delete to the right.\n            // Also, if the current word is the leftmost word, we only delete from the start of the word to the end.\n            if (stop.isEqual(position.nextWordEnd(vimState.document, { inclusive: true })) &&\n                !position\n                    .prevWordStart(vimState.document, { inclusive: true })\n                    .isEqual(textEditor_1.TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, stop.line)) &&\n                vimState.recordedState.count === 0) {\n                start = position.prevWordEnd(vimState.document).getRight();\n            }\n            else {\n                start = position.prevWordStart(vimState.document, { inclusive: true });\n            }\n        }\n        if (vimState.currentMode === mode_1.Mode.Visual &&\n            !vimState.cursorStopPosition.isEqual(vimState.cursorStartPosition)) {\n            start = vimState.cursorStartPosition;\n            if (vimState.cursorStopPosition.isBefore(vimState.cursorStartPosition)) {\n                // If current cursor position is before cursor start position, we are selecting words in reverser order.\n                if (/\\s/.test(currentChar)) {\n                    stop = position.prevWordStart(vimState.document, { inclusive: true });\n                }\n                else {\n                    stop = position.prevWordEnd(vimState.document).getRight();\n                }\n            }\n        }\n        return {\n            start,\n            stop,\n        };\n    }\n};\nexports.SelectWord = SelectWord;\nexports.SelectWord = SelectWord = __decorate([\n    base_1.RegisterAction\n], SelectWord);\nlet SelectABigWord = class SelectABigWord extends TextObject {\n    constructor() {\n        super(...arguments);\n        this.keys = ['a', 'W'];\n    }\n    async execAction(position, vimState) {\n        let start;\n        let stop;\n        const currentChar = vimState.document.lineAt(position).text[position.character];\n        if (currentChar === undefined) {\n            start = position;\n            stop = position.nextWordEnd(vimState.document);\n        }\n        else if (/\\s/.test(currentChar)) {\n            start = position.prevWordEnd(vimState.document, { wordType: word_1.WordType.Big }).getRight();\n            stop = position.nextWordEnd(vimState.document, { wordType: word_1.WordType.Big });\n        }\n        else {\n            // Check 'aw' code for much of the reasoning behind this logic.\n            const nextWord = position.nextWordStart(vimState.document, { wordType: word_1.WordType.Big });\n            if ((nextWord.line > position.line || nextWord.isAtDocumentEnd()) &&\n                vimState.recordedState.count === 0) {\n                if (position.prevWordEnd(vimState.document, { wordType: word_1.WordType.Big }).isLineBeginning()) {\n                    start = position.prevWordEnd(vimState.document, { wordType: word_1.WordType.Big });\n                }\n                else {\n                    start = position.prevWordEnd(vimState.document, { wordType: word_1.WordType.Big }).getRight();\n                }\n                stop = position.getLineEnd();\n            }\n            else if ((nextWord.isEqual(textEditor_1.TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, nextWord.line)) ||\n                nextWord.isLineEnd()) &&\n                vimState.recordedState.count === 0) {\n                start = position.prevWordEnd(vimState.document).getRight();\n                stop = position.getLineEnd();\n            }\n            else {\n                start = position.prevWordStart(vimState.document, {\n                    wordType: word_1.WordType.Big,\n                    inclusive: true,\n                });\n                stop = position.nextWordStart(vimState.document, { wordType: word_1.WordType.Big }).getLeft();\n            }\n        }\n        if (vimState.currentMode === mode_1.Mode.Visual &&\n            !vimState.cursorStopPosition.isEqual(vimState.cursorStartPosition)) {\n            start = vimState.cursorStartPosition;\n            if (vimState.cursorStopPosition.isBefore(vimState.cursorStartPosition)) {\n                // If current cursor postion is before cursor start position, we are selecting words in reverser order.\n                if (/\\s/.test(currentChar)) {\n                    stop = position.prevWordStart(vimState.document, { wordType: word_1.WordType.Big });\n                }\n                else {\n                    stop = position.prevWordEnd(vimState.document, { wordType: word_1.WordType.Big }).getRight();\n                }\n            }\n        }\n        return {\n            start,\n            stop,\n        };\n    }\n};\nexports.SelectABigWord = SelectABigWord;\nexports.SelectABigWord = SelectABigWord = __decorate([\n    base_1.RegisterAction\n], SelectABigWord);\n/**\n * This is a custom action that I (johnfn) added. It selects procedurally\n * larger blocks. e.g. if you had \"blah (foo [bar 'ba|z'])\" then it would\n * select 'baz' first. If you pressed af again, it'd then select [bar 'baz'],\n * and if you did it a third time it would select \"(foo [bar 'baz'])\".\n *\n * Very similar is the now built-in `editor.action.smartSelect.expand`\n */\nlet SelectAnExpandingBlock = class SelectAnExpandingBlock extends motion_1.ExpandingSelection {\n    constructor() {\n        super(...arguments);\n        this.keys = ['a', 'f'];\n        this.modes = [mode_1.Mode.Visual, mode_1.Mode.VisualLine];\n    }\n    async execAction(position, vimState, firstIteration, lastIteration) {\n        const blocks = [\n            new motion_1.MoveAroundDoubleQuotes(),\n            new motion_1.MoveAroundSingleQuotes(),\n            new motion_1.MoveAroundBacktick(),\n            new motion_1.MoveAroundCurlyBrace(),\n            new motion_1.MoveAroundParentheses(),\n            new motion_1.MoveAroundSquareBracket(),\n            new motion_1.MoveAroundTag(),\n        ];\n        // ideally no state would change as we test each of the possible expansions\n        // a deep copy of vimState could work here but may be expensive\n        let ranges = [];\n        for (const block of blocks) {\n            const cursorPos = new vscode_1.Position(position.line, position.character);\n            const cursorStartPos = new vscode_1.Position(vimState.cursorStartPosition.line, vimState.cursorStartPosition.character);\n            ranges.push(await block.execAction(cursorPos, vimState, firstIteration, lastIteration));\n            vimState.cursorStartPosition = cursorStartPos;\n        }\n        ranges = ranges.filter((range) => {\n            return !range.failed;\n        });\n        let smallestRange;\n        for (const iMotion of ranges) {\n            const currentSelectedRange = new cursor_1.Cursor(vimState.cursorStartPosition, vimState.cursorStopPosition);\n            if (iMotion.failed) {\n                continue;\n            }\n            const range = new cursor_1.Cursor(iMotion.start, iMotion.stop);\n            let contender;\n            if (range.start.isBefore(currentSelectedRange.start) &&\n                range.stop.isAfter(currentSelectedRange.stop)) {\n                if (!smallestRange) {\n                    contender = range;\n                }\n                else {\n                    if (range.start.isAfter(smallestRange.start) && range.stop.isBefore(smallestRange.stop)) {\n                        contender = range;\n                    }\n                }\n            }\n            if (contender) {\n                const areTheyEqual = contender.equals(new cursor_1.Cursor(vimState.cursorStartPosition, vimState.cursorStopPosition)) ||\n                    (vimState.currentMode === mode_1.Mode.VisualLine &&\n                        contender.start.line === vimState.cursorStartPosition.line &&\n                        contender.stop.line === vimState.cursorStopPosition.line);\n                if (!areTheyEqual) {\n                    smallestRange = contender;\n                }\n            }\n        }\n        if (!smallestRange) {\n            return {\n                start: vimState.cursorStartPosition,\n                stop: vimState.cursorStopPosition,\n            };\n        }\n        else {\n            // revert relevant state changes\n            vimState.cursorStartPosition = new vscode_1.Position(smallestRange.start.line, smallestRange.start.character);\n            vimState.cursorStopPosition = new vscode_1.Position(smallestRange.stop.line, smallestRange.stop.character);\n            vimState.recordedState.operatorPositionDiff = undefined;\n            return {\n                start: smallestRange.start,\n                stop: smallestRange.stop,\n            };\n        }\n    }\n};\nexports.SelectAnExpandingBlock = SelectAnExpandingBlock;\nexports.SelectAnExpandingBlock = SelectAnExpandingBlock = __decorate([\n    base_1.RegisterAction\n], SelectAnExpandingBlock);\nlet SelectInnerWord = class SelectInnerWord extends TextObject {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual];\n        this.keys = ['i', 'w'];\n    }\n    async execAction(position, vimState) {\n        let start;\n        let stop;\n        const currentChar = vimState.document.lineAt(position).text[position.character];\n        if (currentChar === undefined) {\n            start = position;\n            stop = position.nextWordStart(vimState.document).getLeftThroughLineBreaks();\n        }\n        else if (/\\s/.test(currentChar)) {\n            start = position.prevWordEnd(vimState.document).getRight();\n            stop = position.nextWordStart(vimState.document).getLeftThroughLineBreaks();\n        }\n        else {\n            start = position.prevWordStart(vimState.document, { inclusive: true });\n            stop = position.nextWordEnd(vimState.document, { inclusive: true });\n        }\n        if (vimState.currentMode === mode_1.Mode.Visual &&\n            !vimState.cursorStopPosition.isEqual(vimState.cursorStartPosition)) {\n            start = vimState.cursorStartPosition;\n            if (vimState.cursorStopPosition.isBefore(vimState.cursorStartPosition)) {\n                // If current cursor postion is before cursor start position, we are selecting words in reverser order.\n                if (/\\s/.test(currentChar)) {\n                    stop = position.prevWordEnd(vimState.document).getRight();\n                }\n                else {\n                    stop = position.prevWordStart(vimState.document, { inclusive: true });\n                }\n            }\n        }\n        return {\n            start,\n            stop,\n        };\n    }\n};\nexports.SelectInnerWord = SelectInnerWord;\nexports.SelectInnerWord = SelectInnerWord = __decorate([\n    base_1.RegisterAction\n], SelectInnerWord);\nlet SelectInnerBigWord = class SelectInnerBigWord extends TextObject {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual];\n        this.keys = ['i', 'W'];\n    }\n    async execAction(position, vimState) {\n        let start;\n        let stop;\n        const currentChar = vimState.document.lineAt(position).text[position.character];\n        if (currentChar === undefined) {\n            start = position;\n            stop = position.nextWordStart(vimState.document).getLeftThroughLineBreaks();\n        }\n        else if (/\\s/.test(currentChar)) {\n            start = position.prevWordEnd(vimState.document, { wordType: word_1.WordType.Big }).getRight();\n            stop = position.nextWordStart(vimState.document, { wordType: word_1.WordType.Big }).getLeft();\n        }\n        else {\n            start = position.prevWordStart(vimState.document, {\n                wordType: word_1.WordType.Big,\n                inclusive: true,\n            });\n            stop = position.nextWordEnd(vimState.document, {\n                wordType: word_1.WordType.Big,\n                inclusive: true,\n            });\n        }\n        if (vimState.currentMode === mode_1.Mode.Visual &&\n            !vimState.cursorStopPosition.isEqual(vimState.cursorStartPosition)) {\n            start = vimState.cursorStartPosition;\n            if (vimState.cursorStopPosition.isBefore(vimState.cursorStartPosition)) {\n                // If current cursor postion is before cursor start position, we are selecting words in reverser order.\n                if (/\\s/.test(currentChar)) {\n                    stop = position.prevWordEnd(vimState.document, { wordType: word_1.WordType.Big }).getRight();\n                }\n                else {\n                    stop = position.prevWordStart(vimState.document, { wordType: word_1.WordType.Big });\n                }\n            }\n        }\n        return {\n            start,\n            stop,\n        };\n    }\n};\nexports.SelectInnerBigWord = SelectInnerBigWord;\nexports.SelectInnerBigWord = SelectInnerBigWord = __decorate([\n    base_1.RegisterAction\n], SelectInnerBigWord);\nlet SelectSentence = class SelectSentence extends TextObject {\n    constructor() {\n        super(...arguments);\n        this.keys = ['a', 's'];\n    }\n    async execAction(position, vimState) {\n        let start;\n        let stop;\n        const currentSentenceBegin = position.getSentenceBegin({ forward: false });\n        const currentSentenceNonWhitespaceEnd = currentSentenceBegin.getSentenceEnd();\n        if (currentSentenceNonWhitespaceEnd.isBefore(position)) {\n            // The cursor is on a trailing white space.\n            start = currentSentenceNonWhitespaceEnd.getRight();\n            stop = currentSentenceBegin.getSentenceBegin({ forward: true }).getSentenceEnd();\n        }\n        else {\n            const nextSentenceBegin = currentSentenceBegin.getSentenceBegin({ forward: true });\n            // If the sentence has no trailing white spaces, `as` should include its leading white spaces.\n            if (nextSentenceBegin.isEqual(currentSentenceBegin.getSentenceEnd())) {\n                start = currentSentenceBegin\n                    .getSentenceBegin({ forward: false })\n                    .getSentenceEnd()\n                    .getRight();\n                stop = nextSentenceBegin;\n            }\n            else {\n                start = currentSentenceBegin;\n                stop = nextSentenceBegin.getLeft();\n            }\n        }\n        if (vimState.currentMode === mode_1.Mode.Visual &&\n            !vimState.cursorStopPosition.isEqual(vimState.cursorStartPosition)) {\n            start = vimState.cursorStartPosition;\n            if (vimState.cursorStopPosition.isBefore(vimState.cursorStartPosition)) {\n                // If current cursor postion is before cursor start position, we are selecting sentences in reverser order.\n                if (currentSentenceNonWhitespaceEnd.isAfter(vimState.cursorStopPosition)) {\n                    stop = currentSentenceBegin\n                        .getSentenceBegin({ forward: false })\n                        .getSentenceEnd()\n                        .getRight();\n                }\n                else {\n                    stop = currentSentenceBegin;\n                }\n            }\n        }\n        return {\n            start,\n            stop,\n        };\n    }\n};\nexports.SelectSentence = SelectSentence;\nexports.SelectSentence = SelectSentence = __decorate([\n    base_1.RegisterAction\n], SelectSentence);\nlet SelectInnerSentence = class SelectInnerSentence extends TextObject {\n    constructor() {\n        super(...arguments);\n        this.keys = ['i', 's'];\n    }\n    async execAction(position, vimState) {\n        let start;\n        let stop;\n        const currentSentenceBegin = position.getSentenceBegin({ forward: false });\n        const currentSentenceNonWhitespaceEnd = currentSentenceBegin.getSentenceEnd();\n        if (currentSentenceNonWhitespaceEnd.isBefore(position)) {\n            // The cursor is on a trailing white space.\n            start = currentSentenceNonWhitespaceEnd.getRight();\n            stop = currentSentenceBegin.getSentenceBegin({ forward: true }).getLeft();\n        }\n        else {\n            start = currentSentenceBegin;\n            stop = currentSentenceNonWhitespaceEnd;\n        }\n        if (vimState.currentMode === mode_1.Mode.Visual &&\n            !vimState.cursorStopPosition.isEqual(vimState.cursorStartPosition)) {\n            start = vimState.cursorStartPosition;\n            if (vimState.cursorStopPosition.isBefore(vimState.cursorStartPosition)) {\n                // If current cursor postion is before cursor start position, we are selecting sentences in reverser order.\n                if (currentSentenceNonWhitespaceEnd.isAfter(vimState.cursorStopPosition)) {\n                    stop = currentSentenceBegin;\n                }\n                else {\n                    stop = currentSentenceNonWhitespaceEnd.getRight();\n                }\n            }\n        }\n        return {\n            start,\n            stop,\n        };\n    }\n};\nexports.SelectInnerSentence = SelectInnerSentence;\nexports.SelectInnerSentence = SelectInnerSentence = __decorate([\n    base_1.RegisterAction\n], SelectInnerSentence);\nlet SelectParagraph = class SelectParagraph extends TextObject {\n    constructor() {\n        super(...arguments);\n        this.keys = ['a', 'p'];\n    }\n    async execAction(position, vimState) {\n        vimState.currentRegisterMode = register_1.RegisterMode.LineWise;\n        let start;\n        const currentParagraphBegin = (0, paragraph_1.getCurrentParagraphBeginning)(position, true);\n        if (vimState.document.lineAt(position).isEmptyOrWhitespace) {\n            // The cursor is at an empty line, it can be both the start of next paragraph and the end of previous paragraph\n            start = (0, paragraph_1.getCurrentParagraphEnd)((0, paragraph_1.getCurrentParagraphBeginning)(position, true), true);\n        }\n        else {\n            if (currentParagraphBegin.isLineBeginning() && currentParagraphBegin.isLineEnd()) {\n                start = currentParagraphBegin.getRightThroughLineBreaks();\n            }\n            else {\n                start = currentParagraphBegin;\n            }\n        }\n        // Include additional blank lines.\n        let stop = (0, paragraph_1.getCurrentParagraphEnd)(position, true);\n        while (stop.line < vimState.document.lineCount - 1 &&\n            vimState.document.lineAt(stop.getDown()).isEmptyOrWhitespace) {\n            stop = stop.with({ character: 0 }).getDown();\n        }\n        return {\n            start,\n            stop,\n        };\n    }\n};\nexports.SelectParagraph = SelectParagraph;\nexports.SelectParagraph = SelectParagraph = __decorate([\n    base_1.RegisterAction\n], SelectParagraph);\nlet SelectInnerParagraph = class SelectInnerParagraph extends TextObject {\n    constructor() {\n        super(...arguments);\n        this.keys = ['i', 'p'];\n    }\n    async execAction(position, vimState) {\n        vimState.currentRegisterMode = register_1.RegisterMode.LineWise;\n        let start;\n        let stop;\n        if (vimState.document.lineAt(position).isEmptyOrWhitespace) {\n            // The cursor is at an empty line, so white lines are the paragraph.\n            start = position.getLineBegin();\n            stop = position.getLineEnd();\n            while (start.line > 0 && vimState.document.lineAt(start.getUp()).isEmptyOrWhitespace) {\n                start = start.getUp();\n            }\n            while (stop.line < vimState.document.lineCount - 1 &&\n                vimState.document.lineAt(stop.getDown()).isEmptyOrWhitespace) {\n                stop = stop.with({ character: 0 }).getDown();\n            }\n        }\n        else {\n            const currentParagraphBegin = (0, paragraph_1.getCurrentParagraphBeginning)(position, true);\n            stop = (0, paragraph_1.getCurrentParagraphEnd)(position, true);\n            if (vimState.document.lineAt(currentParagraphBegin).isEmptyOrWhitespace) {\n                start = currentParagraphBegin.getRightThroughLineBreaks();\n            }\n            else {\n                start = currentParagraphBegin;\n            }\n            // Exclude additional blank lines.\n            while (stop.line > 0 && vimState.document.lineAt(stop).isEmptyOrWhitespace) {\n                stop = stop.getUp().getLineEnd();\n            }\n        }\n        return {\n            start,\n            stop,\n        };\n    }\n};\nexports.SelectInnerParagraph = SelectInnerParagraph;\nexports.SelectInnerParagraph = SelectInnerParagraph = __decorate([\n    base_1.RegisterAction\n], SelectInnerParagraph);\nlet SelectEntire = class SelectEntire extends TextObject {\n    constructor() {\n        super(...arguments);\n        this.keys = ['a', 'e'];\n    }\n    async execAction(position, vimState) {\n        return {\n            start: textEditor_1.TextEditor.getDocumentBegin(),\n            stop: textEditor_1.TextEditor.getDocumentEnd(vimState.document),\n        };\n    }\n};\nexports.SelectEntire = SelectEntire;\nexports.SelectEntire = SelectEntire = __decorate([\n    base_1.RegisterAction\n], SelectEntire);\nlet SelectEntireIgnoringLeadingTrailing = class SelectEntireIgnoringLeadingTrailing extends TextObject {\n    constructor() {\n        super(...arguments);\n        this.keys = ['i', 'e'];\n    }\n    async execAction(position, vimState) {\n        let start = textEditor_1.TextEditor.getDocumentBegin();\n        let stop = textEditor_1.TextEditor.getDocumentEnd(vimState.document);\n        while (start.line < stop.line && vimState.document.lineAt(start).isEmptyOrWhitespace) {\n            start = start.getDown();\n        }\n        while (stop.line > start.line && vimState.document.lineAt(stop).isEmptyOrWhitespace) {\n            stop = stop.getUp();\n        }\n        stop = stop.getLineEnd();\n        return {\n            start,\n            stop,\n        };\n    }\n};\nexports.SelectEntireIgnoringLeadingTrailing = SelectEntireIgnoringLeadingTrailing;\nexports.SelectEntireIgnoringLeadingTrailing = SelectEntireIgnoringLeadingTrailing = __decorate([\n    base_1.RegisterAction\n], SelectEntireIgnoringLeadingTrailing);\nclass IndentObjectMatch extends TextObject {\n    constructor() {\n        super(...arguments);\n        this.setsDesiredColumnToEOL = true;\n        this.includeLineAbove = false;\n        this.includeLineBelow = false;\n    }\n    async execAction(position, vimState) {\n        const isChangeOperator = vimState.recordedState.operator instanceof operator_1.ChangeOperator;\n        const firstValidLineNumber = IndentObjectMatch.findFirstValidLine(vimState.document, position);\n        const firstValidLine = vimState.document.lineAt(firstValidLineNumber);\n        const cursorIndent = firstValidLine.firstNonWhitespaceCharacterIndex;\n        let startLineNumber = IndentObjectMatch.findRangeStartOrEnd(vimState.document, firstValidLineNumber, cursorIndent, -1);\n        let endLineNumber = IndentObjectMatch.findRangeStartOrEnd(vimState.document, firstValidLineNumber, cursorIndent, 1);\n        // Adjust the start line as needed.\n        if (this.includeLineAbove) {\n            startLineNumber -= 1;\n        }\n        // Check for OOB.\n        if (startLineNumber < 0) {\n            startLineNumber = 0;\n        }\n        // Adjust the end line as needed.\n        if (this.includeLineBelow) {\n            endLineNumber += 1;\n        }\n        // Check for OOB.\n        if (endLineNumber > vimState.document.lineCount - 1) {\n            endLineNumber = vimState.document.lineCount - 1;\n        }\n        // If initiated by a change operation, adjust the cursor to the indent level\n        // of the block.\n        let startCharacter = 0;\n        if (isChangeOperator) {\n            startCharacter = vimState.document.lineAt(startLineNumber).firstNonWhitespaceCharacterIndex;\n        }\n        // TextEditor.getLineMaxColumn throws when given line 0, which we don't\n        // care about here since it just means this text object wouldn't work on a\n        // single-line document.\n        let endCharacter;\n        if (endLineNumber === vimState.document.lineCount - 1 ||\n            vimState.currentMode === mode_1.Mode.Visual ||\n            vimState.currentMode === mode_1.Mode.VisualLine) {\n            endCharacter = textEditor_1.TextEditor.getLineLength(endLineNumber);\n        }\n        else {\n            endCharacter = 0;\n            endLineNumber++;\n        }\n        return {\n            start: new vscode_1.Position(startLineNumber, startCharacter),\n            stop: new vscode_1.Position(endLineNumber, endCharacter),\n        };\n    }\n    async execActionForOperator(position, vimState) {\n        return this.execAction(position, vimState);\n    }\n    /**\n     * Searches up from the cursor for the first non-empty line.\n     */\n    static findFirstValidLine(document, cursorPosition) {\n        for (let i = cursorPosition.line; i >= 0; i--) {\n            if (!document.lineAt(i).isEmptyOrWhitespace) {\n                return i;\n            }\n        }\n        return cursorPosition.line;\n    }\n    /**\n     * Searches up or down from a line finding the first with a lower indent level.\n     */\n    static findRangeStartOrEnd(document, startIndex, cursorIndent, step) {\n        let i = startIndex;\n        let ret = startIndex;\n        const end = step === 1 ? document.lineCount : -1;\n        for (; i !== end; i += step) {\n            const line = document.lineAt(i);\n            if (line.firstNonWhitespaceCharacterIndex < cursorIndent && !line.isEmptyOrWhitespace) {\n                break;\n            }\n            ret = i;\n        }\n        return ret;\n    }\n}\nlet InsideIndentObject = class InsideIndentObject extends IndentObjectMatch {\n    constructor() {\n        super(...arguments);\n        this.keys = ['i', 'i'];\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n    }\n};\nInsideIndentObject = __decorate([\n    base_1.RegisterAction\n], InsideIndentObject);\nlet InsideIndentObjectAbove = class InsideIndentObjectAbove extends IndentObjectMatch {\n    constructor() {\n        super(...arguments);\n        this.keys = ['a', 'i'];\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n        this.includeLineAbove = true;\n    }\n};\nInsideIndentObjectAbove = __decorate([\n    base_1.RegisterAction\n], InsideIndentObjectAbove);\nlet InsideIndentObjectBoth = class InsideIndentObjectBoth extends IndentObjectMatch {\n    constructor() {\n        super(...arguments);\n        this.keys = ['a', 'I'];\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual, mode_1.Mode.VisualLine, mode_1.Mode.VisualBlock];\n        this.includeLineAbove = true;\n        this.includeLineBelow = true;\n    }\n};\nInsideIndentObjectBoth = __decorate([\n    base_1.RegisterAction\n], InsideIndentObjectBoth);\nclass SelectArgument extends TextObject {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual];\n        // SelectArgument supports two select types: inner and around.\n        //\n        // Inner will adjust start/stop positions, so that they are inside\n        // the delimiters (excluding the delimiters themselves).\n        // Around will adjust start/stop positions, so that ONE of them includes\n        // a separator character (optionally including extra whitespace).\n        this.selectAround = false;\n    }\n    static openingDelimiterCharacters() {\n        return configuration_1.configuration.argumentObjectOpeningDelimiters;\n    }\n    static closingDelimiterCharacters() {\n        return configuration_1.configuration.argumentObjectClosingDelimiters;\n    }\n    static separatorCharacters() {\n        return configuration_1.configuration.argumentObjectSeparators;\n    }\n    // Requirement is that below example still works as expected, i.e.\n    // when we have nested pairs of parens\n    //\n    //        ( a, b, (void*) | c(void*, void*), a)\n    //\n    // Warning: For now, mismatched opening and closing delimiters, e.g.\n    // in (foo] will still be matched by this movement.\n    //\n    // Procedure:\n    //\n    // 1   Find boundaries left/right (i.e. where the argument starts/ends)\n    // 1.1 Walk left until we find a comma or an opening paren, that does not\n    //     have a matching closed one. This way we can ignore pairs\n    //     of parentheses which are part of the current argument.\n    // 1.2 Vice versa for walking right.\n    // 2   Depending on our mode (inner or around), improve the start/stop\n    //     locations for most consistent behaviour, especially in case of\n    //     multi-line statements.\n    async execAction(position, vimState) {\n        const failure = (0, baseMotion_1.failedMovement)(vimState);\n        let leftSearchStartPosition = position;\n        let rightSearchStartPosition = position;\n        const charAtPos = textEditor_1.TextEditor.getCharAt(vimState.document, position);\n        // When the cursor is on a delimiter already, pre-advance the cursor,\n        // so that our search actually spans a range. We will advance to the next argument,\n        // in case of opening delimiters or separators, and advance to the\n        // previous on closing delimiters.\n        if (SelectArgument.separatorCharacters().includes(charAtPos) ||\n            SelectArgument.openingDelimiterCharacters().includes(charAtPos)) {\n            rightSearchStartPosition = position.getRightThroughLineBreaks(true);\n        }\n        else if (SelectArgument.closingDelimiterCharacters().includes(charAtPos)) {\n            leftSearchStartPosition = position.getLeftThroughLineBreaks(true);\n        }\n        // Early abort, if no delimiters (i.e. (), [], etc.) surround us.\n        // This prevents applying the movement to surrounding separators across the buffer.\n        if (SelectInnerArgument.findLeftArgumentBoundary(vimState.document, leftSearchStartPosition, true) === undefined ||\n            SelectInnerArgument.findRightArgumentBoundary(vimState.document, rightSearchStartPosition, true) === undefined) {\n            return failure;\n        }\n        const leftArgumentBoundary = SelectInnerArgument.findLeftArgumentBoundary(vimState.document, leftSearchStartPosition);\n        if (leftArgumentBoundary === undefined) {\n            return failure;\n        }\n        const rightArgumentBoundary = SelectInnerArgument.findRightArgumentBoundary(vimState.document, rightSearchStartPosition);\n        if (rightArgumentBoundary === undefined) {\n            return failure;\n        }\n        let start;\n        let stop;\n        if (this.selectAround) {\n            const isLeftOnOpening = SelectArgument.openingDelimiterCharacters().includes(textEditor_1.TextEditor.getCharAt(vimState.document, leftArgumentBoundary));\n            const isRightOnClosing = SelectArgument.closingDelimiterCharacters().includes(textEditor_1.TextEditor.getCharAt(vimState.document, rightArgumentBoundary));\n            // Edge-case:\n            // Ensure we do not select anything if we have an empty argument list, e.g. \"()\"\n            const isEmptyArgumentList = leftArgumentBoundary.getRight().isEqual(rightArgumentBoundary) &&\n                isLeftOnOpening &&\n                isRightOnClosing;\n            if (isEmptyArgumentList) {\n                return failure;\n            }\n            // Only when we are in the first argument we outset the right boundary\n            // until the first non-whitespace, so we do not end up with whitespace\n            // at the beginning of the parens.\n            const isInFirstArgument = isLeftOnOpening && !isRightOnClosing;\n            if (isInFirstArgument) {\n                stop = rightArgumentBoundary.getRight();\n                // Walk right until non-whitespace\n                while (/\\s/.test(textEditor_1.TextEditor.getCharAt(vimState.document, stop.getRight()))) {\n                    stop = stop.getRight();\n                }\n            }\n            else {\n                // In any other case, we inset\n                stop = rightArgumentBoundary.getLeftThroughLineBreaks(true);\n            }\n            // In case the left boundary is on a opening delimiter, move that position inwards\n            if (isLeftOnOpening) {\n                start = leftArgumentBoundary.getRightThroughLineBreaks(true);\n            }\n            else {\n                start = leftArgumentBoundary;\n            }\n        }\n        else {\n            // Inset the start once to get off the boundary and then keep\n            // going until the first non whitespace.\n            // This ensures that indented argument-lists keep the indentation.\n            start = leftArgumentBoundary.getRightThroughLineBreaks(false);\n            while (/\\s/.test(textEditor_1.TextEditor.getCharAt(vimState.document, start))) {\n                start = start.getRightThroughLineBreaks(false);\n            }\n            // Same procedure for stop.\n            stop = rightArgumentBoundary.getLeftThroughLineBreaks(false);\n            while (/\\s/.test(textEditor_1.TextEditor.getCharAt(vimState.document, stop))) {\n                stop = stop.getLeftThroughLineBreaks(false);\n            }\n            // Edge-case: Seems there is only whitespace in this argument.\n            // Omit any weird handling and just clear all whitespace.\n            if (stop.isBeforeOrEqual(start)) {\n                start = leftArgumentBoundary.getRightThroughLineBreaks(true);\n                stop = rightArgumentBoundary.getLeftThroughLineBreaks(true);\n            }\n        }\n        // Handle case when cursor is not inside the anticipated movement range\n        if (position.isBefore(start)) {\n            vimState.recordedState.operatorPositionDiff = start.subtract(position);\n        }\n        vimState.cursorStartPosition = start;\n        return {\n            start,\n            stop,\n        };\n    }\n    static findLeftArgumentBoundary(document, position, ignoreSeparators = false) {\n        let delimiterPosition;\n        let walkingPosition = position;\n        let closedParensCount = 0;\n        while (true) {\n            const char = textEditor_1.TextEditor.getCharAt(document, walkingPosition);\n            if (closedParensCount === 0) {\n                let isOnBoundary = SelectArgument.openingDelimiterCharacters().includes(char);\n                if (!ignoreSeparators) {\n                    isOnBoundary ||= SelectArgument.separatorCharacters().includes(char);\n                }\n                if (isOnBoundary) {\n                    // We have found the left most delimiter or the first proper delimiter\n                    // in our cursor's list 'depth' and thus can abort.\n                    delimiterPosition = walkingPosition;\n                    break;\n                }\n            }\n            if (SelectArgument.closingDelimiterCharacters().includes(char)) {\n                closedParensCount++;\n            }\n            if (SelectArgument.openingDelimiterCharacters().includes(char)) {\n                closedParensCount--;\n            }\n            if (walkingPosition.isAtDocumentBegin()) {\n                break;\n            }\n            walkingPosition = walkingPosition.getLeftThroughLineBreaks(true);\n        }\n        return delimiterPosition;\n    }\n    static findRightArgumentBoundary(document, position, ignoreSeparators = false) {\n        let delimiterPosition;\n        let walkingPosition = position;\n        let openedParensCount = 0;\n        while (true) {\n            const char = textEditor_1.TextEditor.getCharAt(document, walkingPosition);\n            if (openedParensCount === 0) {\n                let isOnBoundary = SelectArgument.closingDelimiterCharacters().includes(char);\n                if (!ignoreSeparators) {\n                    isOnBoundary ||= SelectArgument.separatorCharacters().includes(char);\n                }\n                if (isOnBoundary) {\n                    delimiterPosition = walkingPosition;\n                    break;\n                }\n            }\n            if (SelectArgument.openingDelimiterCharacters().includes(char)) {\n                openedParensCount++;\n            }\n            if (SelectArgument.closingDelimiterCharacters().includes(char)) {\n                openedParensCount--;\n            }\n            if (walkingPosition.isAtDocumentEnd()) {\n                break;\n            }\n            // We need to include the EOL so that isAtDocumentEnd actually\n            // becomes true.\n            walkingPosition = walkingPosition.getRightThroughLineBreaks(true);\n        }\n        return delimiterPosition;\n    }\n}\nlet SelectInnerArgument = class SelectInnerArgument extends SelectArgument {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual];\n        this.keys = ['i', 'a'];\n    }\n};\nexports.SelectInnerArgument = SelectInnerArgument;\nexports.SelectInnerArgument = SelectInnerArgument = __decorate([\n    base_1.RegisterAction\n], SelectInnerArgument);\nlet SelectAroundArgument = class SelectAroundArgument extends SelectArgument {\n    constructor() {\n        super(...arguments);\n        this.modes = [mode_1.Mode.Normal, mode_1.Mode.Visual];\n        this.keys = ['a', 'a'];\n        this.selectAround = true;\n    }\n};\nexports.SelectAroundArgument = SelectAroundArgument;\nexports.SelectAroundArgument = SelectAroundArgument = __decorate([\n    base_1.RegisterAction\n], SelectAroundArgument);\n\n\n//# sourceURL=webpack://vim/./src/textobject/textobject.ts?")},"./src/textobject/util.ts":(__unused_webpack_module,exports)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.getAllEndPositions = exports.getAllPositions = void 0;\nfunction getAllPositions(line, regex) {\n    const positions = [];\n    let result = regex.exec(line);\n    while (result) {\n        positions.push(result.index);\n        // Handles the case where an empty string match causes lastIndex not to advance,\n        // which gets us in an infinite loop.\n        if (result.index === regex.lastIndex) {\n            regex.lastIndex++;\n        }\n        result = regex.exec(line);\n    }\n    return positions;\n}\nexports.getAllPositions = getAllPositions;\nfunction getAllEndPositions(line, regex) {\n    const positions = [];\n    let result = regex.exec(line);\n    while (result) {\n        if (result[0].length) {\n            positions.push(result.index + result[0].length - 1);\n        }\n        // Handles the case where an empty string match causes lastIndex not to advance,\n        // which gets us in an infinite loop.\n        if (result.index === regex.lastIndex) {\n            regex.lastIndex++;\n        }\n        result = regex.exec(line);\n    }\n    return positions;\n}\nexports.getAllEndPositions = getAllEndPositions;\n\n\n//# sourceURL=webpack://vim/./src/textobject/util.ts?')},"./src/textobject/word.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.prevWordEnd = exports.nextWordEnd = exports.nextWordStart = exports.prevWordStart = exports.getWordRightInText = exports.getWordLeftInText = exports.WordType = void 0;\nconst _ = __importStar(__webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js"));\nconst vscode_1 = __webpack_require__(/*! vscode */ "vscode");\nconst configuration_1 = __webpack_require__(/*! ../configuration/configuration */ "./src/configuration/configuration.ts");\nconst util_1 = __webpack_require__(/*! ./util */ "./src/textobject/util.ts");\nvar WordType;\n(function (WordType) {\n    WordType[WordType["Normal"] = 0] = "Normal";\n    WordType[WordType["Big"] = 1] = "Big";\n    WordType[WordType["CamelCase"] = 2] = "CamelCase";\n    WordType[WordType["FileName"] = 3] = "FileName";\n})(WordType || (exports.WordType = WordType = {}));\nconst nonBigWordCharRegex = makeWordRegex(\'\');\nconst nonFileNameRegex = makeWordRegex(\'"\\\'`;<>{}[]()\');\nfunction regexForWordType(wordType) {\n    switch (wordType) {\n        case WordType.Normal:\n            return makeUnicodeWordRegex(configuration_1.configuration.iskeyword);\n        case WordType.Big:\n            return nonBigWordCharRegex;\n        case WordType.CamelCase:\n            return makeCamelCaseWordRegex(configuration_1.configuration.iskeyword);\n        case WordType.FileName:\n            return nonFileNameRegex;\n    }\n}\n/**\n * Get the position of the word counting from the position specified.\n * @param text The string to search from.\n * @param pos The position of text to search from.\n * @returns The character position of the word to the left relative to the text and the pos.\n *          undefined if there is no word to the left of the postion.\n */\nfunction getWordLeftInText(text, pos, wordType) {\n    return getWordLeftOnLine(text, pos, wordType);\n}\nexports.getWordLeftInText = getWordLeftInText;\nfunction getWordRightInText(text, pos, wordType) {\n    return (0, util_1.getAllPositions)(text, regexForWordType(wordType)).find((index) => index > pos);\n}\nexports.getWordRightInText = getWordRightInText;\nfunction prevWordStart(document, pos, wordType, inclusive = false) {\n    for (let currentLine = pos.line; currentLine >= 0; currentLine--) {\n        const newCharacter = getWordLeftOnLine(document.lineAt(currentLine).text, pos.character, wordType, currentLine !== pos.line, inclusive);\n        if (newCharacter !== undefined) {\n            return new vscode_1.Position(currentLine, newCharacter);\n        }\n    }\n    return new vscode_1.Position(0, 0);\n}\nexports.prevWordStart = prevWordStart;\nfunction getWordLeftOnLine(text, pos, wordType, forceFirst = false, inclusive = false) {\n    return (0, util_1.getAllPositions)(text, regexForWordType(wordType))\n        .reverse()\n        .find((index) => (index < pos && !inclusive) || (index <= pos && inclusive) || forceFirst);\n}\nfunction nextWordStart(document, pos, wordType, inclusive = false) {\n    for (let currentLine = pos.line; currentLine < document.lineCount; currentLine++) {\n        const positions = (0, util_1.getAllPositions)(document.lineAt(currentLine).text, regexForWordType(wordType));\n        const newCharacter = positions.find((index) => (index > pos.character && !inclusive) ||\n            (index >= pos.character && inclusive) ||\n            currentLine !== pos.line);\n        if (newCharacter !== undefined) {\n            return new vscode_1.Position(currentLine, newCharacter);\n        }\n    }\n    return new vscode_1.Position(document.lineCount - 1, 0).getLineEnd();\n}\nexports.nextWordStart = nextWordStart;\nfunction nextWordEnd(document, pos, wordType, inclusive = false) {\n    for (let currentLine = pos.line; currentLine < document.lineCount; currentLine++) {\n        const positions = (0, util_1.getAllEndPositions)(document.lineAt(currentLine).text, regexForWordType(wordType));\n        const newCharacter = positions.find((index) => (index > pos.character && !inclusive) ||\n            (index >= pos.character && inclusive) ||\n            currentLine !== pos.line);\n        if (newCharacter !== undefined) {\n            return new vscode_1.Position(currentLine, newCharacter);\n        }\n    }\n    return new vscode_1.Position(document.lineCount - 1, 0).getLineEnd();\n}\nexports.nextWordEnd = nextWordEnd;\nfunction prevWordEnd(document, pos, wordType) {\n    for (let currentLine = pos.line; currentLine > -1; currentLine--) {\n        let positions = (0, util_1.getAllEndPositions)(document.lineAt(currentLine).text, regexForWordType(wordType));\n        // if one line is empty, use the 0 position as the default value\n        if (positions.length === 0) {\n            positions.push(0);\n        }\n        // reverse the list to find the biggest element smaller than pos.character\n        positions = positions.reverse();\n        const index = positions.findIndex((i) => i < pos.character || currentLine !== pos.line);\n        let newCharacter = 0;\n        if (index === -1) {\n            if (currentLine > -1) {\n                continue;\n            }\n            newCharacter = positions[positions.length - 1];\n        }\n        else {\n            newCharacter = positions[index];\n        }\n        if (newCharacter !== undefined) {\n            return new vscode_1.Position(currentLine, newCharacter);\n        }\n    }\n    return new vscode_1.Position(0, 0);\n}\nexports.prevWordEnd = prevWordEnd;\nfunction makeWordRegex(characterSet) {\n    const escaped = characterSet && _.escapeRegExp(characterSet).replace(/-/g, \'\\\\-\');\n    const segments = [`([^\\\\s${escaped}]+)`, `[${escaped}]+`, `$^`];\n    return new RegExp(segments.join(\'|\'), \'g\');\n}\nfunction makeCamelCaseWordRegex(characterSet) {\n    const escaped = characterSet && _.escapeRegExp(characterSet).replace(/-/g, \'\\\\-\');\n    const segments = [];\n    // Older browsers don\'t support lookbehind - in this case, use an inferior regex rather than crashing\n    let supportsLookbehind = true;\n    try {\n        new RegExp(\'(?<=x)\');\n    }\n    catch {\n        supportsLookbehind = false;\n    }\n    // prettier-ignore\n    const firstSegment = \'(\' + // OPEN: group for matching camel case words\n        `[^\\\\s${escaped}_]` + //   words can start with any non-keyword non-underscore character\n        \'(?:\' + //   OPEN: group for characters after initial char\n        `(?:${supportsLookbehind ? \'(?<=[A-Z_])\' : \'\'}` + //     If first char was a capital\n        `[A-Z](?=[\\\\sA-Z0-9${escaped}_]))+` + //       the word can continue with all caps\n        \'|\' + //     OR\n        `(?:${supportsLookbehind ? \'(?<=[0-9_])\' : \'\'}` + //     If first char was a digit\n        `[0-9](?=[\\\\sA-Z0-9${escaped}_]))+` + //       the word can continue with all digits\n        \'|\' + //     OR\n        `(?:${supportsLookbehind ? \'(?<=[_])\' : \'\'}` + //     If first char was an underscore\n        `[_](?=[\\\\s${escaped}_]))+` + //       the word can continue with all underscores\n        \'|\' + //     OR\n        `[^\\\\sA-Z0-9${escaped}_]*` + //     Continue with regular characters\n        \')\' + //   END: group for characters after initial char\n        \')\' + // END: group for matching camel case words\n        \'\';\n    segments.push(firstSegment);\n    segments.push(`[${escaped}]+`);\n    segments.push(`$^`);\n    // it can be difficult to grok the behavior of the above regex\n    // feel free to check out https://regex101.com/r/mkVeiH/1 as a live example\n    return new RegExp(segments.join(\'|\'), \'g\');\n}\nfunction makeUnicodeWordRegex(keywordChars) {\n    // Distinct categories of characters\n    let CharKind;\n    (function (CharKind) {\n        CharKind[CharKind["Punctuation"] = 0] = "Punctuation";\n        CharKind[CharKind["Superscript"] = 1] = "Superscript";\n        CharKind[CharKind["Subscript"] = 2] = "Subscript";\n        CharKind[CharKind["Braille"] = 3] = "Braille";\n        CharKind[CharKind["Ideograph"] = 4] = "Ideograph";\n        CharKind[CharKind["Hiragana"] = 5] = "Hiragana";\n        CharKind[CharKind["Katakana"] = 6] = "Katakana";\n        CharKind[CharKind["Hangul"] = 7] = "Hangul";\n    })(CharKind || (CharKind = {}));\n    // List of printable characters (code point intervals) and their character kinds.\n    // Latin alphabets (e.g., ASCII alphabets and numbers,  Latin-1 Supplement, European Latin) are excluded.\n    // Imported from utf_class_buf in src/mbyte.c of Vim.\n    const symbolTable = [\n        [[0x00a1, 0x00bf], CharKind.Punctuation], // Latin-1 punctuation\n        [[0x037e, 0x037e], CharKind.Punctuation], // Greek question mark\n        [[0x0387, 0x0387], CharKind.Punctuation], // Greek ano teleia\n        [[0x055a, 0x055f], CharKind.Punctuation], // Armenian punctuation\n        [[0x0589, 0x0589], CharKind.Punctuation], // Armenian full stop\n        [[0x05be, 0x05be], CharKind.Punctuation],\n        [[0x05c0, 0x05c0], CharKind.Punctuation],\n        [[0x05c3, 0x05c3], CharKind.Punctuation],\n        [[0x05f3, 0x05f4], CharKind.Punctuation],\n        [[0x060c, 0x060c], CharKind.Punctuation],\n        [[0x061b, 0x061b], CharKind.Punctuation],\n        [[0x061f, 0x061f], CharKind.Punctuation],\n        [[0x066a, 0x066d], CharKind.Punctuation],\n        [[0x06d4, 0x06d4], CharKind.Punctuation],\n        [[0x0700, 0x070d], CharKind.Punctuation], // Syriac punctuation\n        [[0x0964, 0x0965], CharKind.Punctuation],\n        [[0x0970, 0x0970], CharKind.Punctuation],\n        [[0x0df4, 0x0df4], CharKind.Punctuation],\n        [[0x0e4f, 0x0e4f], CharKind.Punctuation],\n        [[0x0e5a, 0x0e5b], CharKind.Punctuation],\n        [[0x0f04, 0x0f12], CharKind.Punctuation],\n        [[0x0f3a, 0x0f3d], CharKind.Punctuation],\n        [[0x0f85, 0x0f85], CharKind.Punctuation],\n        [[0x104a, 0x104f], CharKind.Punctuation], // Myanmar punctuation\n        [[0x10fb, 0x10fb], CharKind.Punctuation], // Georgian punctuation\n        [[0x1361, 0x1368], CharKind.Punctuation], // Ethiopic punctuation\n        [[0x166d, 0x166e], CharKind.Punctuation], // Canadian Syl. punctuation\n        [[0x169b, 0x169c], CharKind.Punctuation],\n        [[0x16eb, 0x16ed], CharKind.Punctuation],\n        [[0x1735, 0x1736], CharKind.Punctuation],\n        [[0x17d4, 0x17dc], CharKind.Punctuation], // Khmer punctuation\n        [[0x1800, 0x180a], CharKind.Punctuation], // Mongolian punctuation\n        [[0x200c, 0x2027], CharKind.Punctuation], // punctuation and symbols\n        [[0x202a, 0x202e], CharKind.Punctuation], // punctuation and symbols\n        [[0x2030, 0x205e], CharKind.Punctuation], // punctuation and symbols\n        [[0x2060, 0x27ff], CharKind.Punctuation], // punctuation and symbols\n        [[0x2070, 0x207f], CharKind.Superscript], // superscript\n        [[0x2080, 0x2094], CharKind.Subscript], // subscript\n        [[0x20a0, 0x27ff], CharKind.Punctuation], // all kinds of symbols\n        [[0x2800, 0x28ff], CharKind.Braille], // braille\n        [[0x2900, 0x2998], CharKind.Punctuation], // arrows, brackets, etc.\n        [[0x29d8, 0x29db], CharKind.Punctuation],\n        [[0x29fc, 0x29fd], CharKind.Punctuation],\n        [[0x2e00, 0x2e7f], CharKind.Punctuation], // supplemental punctuation\n        [[0x3001, 0x3020], CharKind.Punctuation], // ideographic punctuation\n        [[0x3030, 0x3030], CharKind.Punctuation],\n        [[0x303d, 0x303d], CharKind.Punctuation],\n        [[0x3040, 0x309f], CharKind.Hiragana], // Hiragana\n        [[0x30a0, 0x30ff], CharKind.Katakana], // Katakana\n        [[0x3300, 0x9fff], CharKind.Ideograph], // CJK Ideographs\n        [[0xac00, 0xd7a3], CharKind.Hangul], // Hangul Syllables\n        [[0xf900, 0xfaff], CharKind.Ideograph], // CJK Ideographs\n        [[0xfd3e, 0xfd3f], CharKind.Punctuation],\n        [[0xfe30, 0xfe6b], CharKind.Punctuation], // punctuation forms\n        [[0xff00, 0xff0f], CharKind.Punctuation], // half/fullwidth ASCII\n        [[0xff1a, 0xff20], CharKind.Punctuation], // half/fullwidth ASCII\n        [[0xff3b, 0xff40], CharKind.Punctuation], // half/fullwidth ASCII\n        [[0xff5b, 0xff65], CharKind.Punctuation], // half/fullwidth ASCII\n        [[0x20000, 0x2a6df], CharKind.Ideograph], // CJK Ideographs\n        [[0x2a700, 0x2b73f], CharKind.Ideograph], // CJK Ideographs\n        [[0x2b740, 0x2b81f], CharKind.Ideograph], // CJK Ideographs\n        [[0x2f800, 0x2fa1f], CharKind.Ideograph], // CJK Ideographs\n    ];\n    const codePointRangePatterns = [];\n    for (const kind in CharKind) {\n        if (!isNaN(Number(kind))) {\n            codePointRangePatterns[kind] = [];\n        }\n    }\n    for (const [[first, last], kind] of symbolTable) {\n        if (first === last) {\n            // \'\\u{hhhh}\'\n            codePointRangePatterns[kind].push(`\\\\u{${first.toString(16)}}`);\n        }\n        else {\n            // \'\\u{hhhh}-\\u{hhhh}\'\n            codePointRangePatterns[kind].push(`\\\\u{${first.toString(16)}}-\\\\u{${last.toString(16)}}`);\n        }\n    }\n    // Symbols in vim.iskeyword or editor.wordSeparators\n    // are treated as CharKind.Punctuation\n    const escapedKeywordChars = _.escapeRegExp(keywordChars).replace(/-/g, \'\\\\-\');\n    codePointRangePatterns[Number(CharKind.Punctuation)].push(escapedKeywordChars);\n    const codePointRanges = codePointRangePatterns.map((patterns) => patterns.join(\'\'));\n    const symbolSegments = codePointRanges.map((range) => `([${range}]+)`);\n    // wordSegment matches word characters.\n    // A word character is a symbol which is neither\n    // - space\n    // - a symbol listed in the table\n    // - a keyword (vim.iskeyword)\n    const wordSegment = `([^\\\\s${codePointRanges.join(\'\')}]+)`;\n    // https://regex101.com/r/X1agK6/2\n    const segments = symbolSegments.concat(wordSegment, \'$^\');\n    return new RegExp(segments.join(\'|\'), \'ug\');\n}\n\n\n//# sourceURL=webpack://vim/./src/textobject/word.ts?')},"./src/transformations/execute.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.executeTransformations = void 0;\nconst vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));\nconst commandLine_1 = __webpack_require__(/*! ../cmd_line/commandLine */ "./src/cmd_line/commandLine.ts");\nconst cursor_1 = __webpack_require__(/*! ../common/motion/cursor */ "./src/common/motion/cursor.ts");\nconst globals_1 = __webpack_require__(/*! ../globals */ "./src/globals.ts");\nconst mode_1 = __webpack_require__(/*! ../mode/mode */ "./src/mode/mode.ts");\nconst register_1 = __webpack_require__(/*! ../register/register */ "./src/register/register.ts");\nconst globalState_1 = __webpack_require__(/*! ../state/globalState */ "./src/state/globalState.ts");\nconst recordedState_1 = __webpack_require__(/*! ../state/recordedState */ "./src/state/recordedState.ts");\nconst textEditor_1 = __webpack_require__(/*! ../textEditor */ "./src/textEditor.ts");\nconst logger_1 = __webpack_require__(/*! ../util/logger */ "./src/util/logger.ts");\nconst expression_1 = __webpack_require__(/*! ../vimscript/expression */ "./src/vimscript/expression.ts");\nconst transformations_1 = __webpack_require__(/*! ./transformations */ "./src/transformations/transformations.ts");\nconst transformer_1 = __webpack_require__(/*! ./transformer */ "./src/transformations/transformer.ts");\nasync function executeTransformations(modeHandler, transformations) {\n    if (transformations.length === 0) {\n        return;\n    }\n    const vimState = modeHandler.vimState;\n    const textTransformations = transformations.filter((x) => (0, transformations_1.isTextTransformation)(x));\n    const multicursorTextTransformations = transformations.filter((x) => (0, transformations_1.isMultiCursorTextTransformation)(x));\n    const otherTransformations = transformations.filter((x) => !(0, transformations_1.isTextTransformation)(x) && !(0, transformations_1.isMultiCursorTextTransformation)(x));\n    const accumulatedPositionDifferences = {};\n    const doTextEditorEdit = (command, edit) => {\n        switch (command.type) {\n            case \'insertText\':\n                edit.insert(command.position, command.text);\n                break;\n            case \'replaceText\':\n                edit.replace(command.range, command.text);\n                break;\n            case \'deleteRange\':\n                edit.delete(command.range);\n                break;\n            case \'moveCursor\':\n                break;\n            default:\n                logger_1.Logger.warn(`Unhandled text transformation type: ${command.type}.`);\n                break;\n        }\n        if (command.diff) {\n            if (command.cursorIndex === undefined) {\n                throw new Error(\'No cursor index - this should never ever happen!\');\n            }\n            if (!accumulatedPositionDifferences[command.cursorIndex]) {\n                accumulatedPositionDifferences[command.cursorIndex] = [];\n            }\n            accumulatedPositionDifferences[command.cursorIndex].push(command.diff);\n        }\n    };\n    if (textTransformations.length > 0) {\n        const overlapping = (0, transformations_1.overlappingTransformations)(textTransformations);\n        if (overlapping !== undefined) {\n            const msg = `Transformations overlapping: ${JSON.stringify(overlapping)}`;\n            logger_1.Logger.warn(msg);\n            if (globals_1.Globals.isTesting) {\n                throw new Error(msg);\n            }\n            // TODO: Select one transformation for every cursor and run them all\n            // in parallel. Repeat till there are no more transformations.\n            for (const transformation of textTransformations) {\n                await vimState.editor.edit((edit) => doTextEditorEdit(transformation, edit));\n            }\n        }\n        else {\n            // This is the common case!\n            /**\n             * batch all text operations together as a single operation\n             * (this is primarily necessary for multi-cursor mode, since most\n             * actions will trigger at most one text operation).\n             */\n            try {\n                await vimState.editor.edit((edit) => {\n                    for (const command of textTransformations) {\n                        doTextEditorEdit(command, edit);\n                    }\n                });\n            }\n            catch (e) {\n                // Messages like "TextEditor(vs.editor.ICodeEditor:1,$model8) has been disposed" can be ignored.\n                // They occur when the user switches to a new tab while an action is running.\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                if (e.name !== \'DISPOSED\') {\n                    throw e;\n                }\n            }\n        }\n    }\n    if (multicursorTextTransformations.length > 0) {\n        if ((0, transformations_1.areAllSameTransformation)(multicursorTextTransformations)) {\n            /**\n             * Apply the transformation only once instead of to each cursor\n             * if they are all the same.\n             *\n             * This lets VSCode do multicursor snippets, auto braces and\n             * all the usual jazz VSCode does on text insertion.\n             */\n            const { text } = multicursorTextTransformations[0];\n            // await vscode.commands.executeCommand(\'default:type\', { text });\n            await textEditor_1.TextEditor.insert(vimState.editor, text);\n        }\n        else {\n            logger_1.Logger.warn(`Unhandled multicursor transformations. Not all transformations are the same!`);\n        }\n    }\n    for (const transformation of otherTransformations) {\n        switch (transformation.type) {\n            case \'insertTextVSCode\':\n                await textEditor_1.TextEditor.insert(vimState.editor, transformation.text);\n                vimState.cursors[0] = cursor_1.Cursor.FromVSCodeSelection(vimState.editor.selection);\n                break;\n            case \'replayRecordedState\':\n                await modeHandler.rerunRecordedState(transformation.recordedState.clone());\n                break;\n            case \'macro\':\n                const recordedMacro = (await register_1.Register.get(transformation.register))?.text;\n                if (!recordedMacro) {\n                    return;\n                }\n                else if (typeof recordedMacro === \'string\') {\n                    // A string was set to the register. We need to execute the characters as if they were typed (in normal mode).\n                    const keystrokes = expression_1.keystrokesExpressionParser.parse(recordedMacro);\n                    if (!keystrokes.status) {\n                        throw new Error(`Failed to execute macro: ${recordedMacro}`);\n                    }\n                    vimState.isReplayingMacro = true;\n                    vimState.recordedState = new recordedState_1.RecordedState();\n                    await modeHandler.handleMultipleKeyEvents(keystrokes.value);\n                    // Set the executed register as the registerName, otherwise the last action register is used.\n                    vimState.recordedState.registerName = transformation.register;\n                    globalState_1.globalState.lastInvokedMacro = vimState.recordedState;\n                    vimState.isReplayingMacro = false;\n                    if (vimState.lastMovementFailed) {\n                        // movement in last invoked macro failed then we should stop all following repeating macros.\n                        // Besides, we should reset `lastMovementFailed`.\n                        vimState.lastMovementFailed = false;\n                        return;\n                    }\n                }\n                else {\n                    vimState.isReplayingMacro = true;\n                    vimState.recordedState = new recordedState_1.RecordedState();\n                    if (transformation.register === \':\') {\n                        await new commandLine_1.ExCommandLine(recordedMacro.commandString, vimState.currentMode).run(vimState);\n                    }\n                    else if (transformation.replay === \'contentChange\') {\n                        await modeHandler.runMacro(recordedMacro);\n                    }\n                    else {\n                        let keyStrokes = [];\n                        for (const action of recordedMacro.actionsRun) {\n                            keyStrokes = keyStrokes.concat(action.keysPressed);\n                        }\n                        await modeHandler.handleMultipleKeyEvents(keyStrokes);\n                    }\n                    // TODO: Copied from `BaseAction.execCount`. This is all terrible.\n                    for (const t of vimState.recordedState.transformer.transformations) {\n                        if ((0, transformations_1.isTextTransformation)(t) && t.cursorIndex === undefined) {\n                            t.cursorIndex = 0;\n                        }\n                    }\n                    await executeTransformations(modeHandler, vimState.recordedState.transformer.transformations);\n                    globalState_1.globalState.lastInvokedMacro = recordedMacro;\n                    vimState.isReplayingMacro = false;\n                    if (vimState.lastMovementFailed) {\n                        // movement in last invoked macro failed then we should stop all following repeating macros.\n                        // Besides, we should reset `lastMovementFailed`.\n                        vimState.lastMovementFailed = false;\n                        return;\n                    }\n                }\n                break;\n            case \'contentChange\':\n                for (const change of transformation.changes) {\n                    await textEditor_1.TextEditor.insert(vimState.editor, change.text);\n                    vimState.cursorStopPosition = vimState.editor.selection.start;\n                }\n                const newPos = vimState.cursorStopPosition.add(vimState.document, transformation.diff);\n                vimState.editor.selection = new vscode.Selection(newPos, newPos);\n                break;\n            case \'vscodeCommand\':\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                await vscode.commands.executeCommand(transformation.command, ...transformation.args);\n                break;\n            default:\n                logger_1.Logger.warn(`Unhandled text transformation type: ${transformation.type}.`);\n                break;\n        }\n    }\n    let selections;\n    if (vimState.currentMode === mode_1.Mode.Insert) {\n        // Insert mode selections do not need to be modified\n        selections = vimState.editor.selections;\n    }\n    else {\n        selections = vimState.editor.selections.map((sel) => {\n            let range = cursor_1.Cursor.FromVSCodeSelection(sel);\n            if (range.start.isBefore(range.stop)) {\n                range = range.withNewStop(range.stop.getLeftThroughLineBreaks(true));\n            }\n            return new vscode.Selection(range.start, range.stop);\n        });\n    }\n    const firstTransformation = transformations[0];\n    const manuallySetCursorPositions = (firstTransformation.type === \'deleteRange\' ||\n        firstTransformation.type === \'replaceText\' ||\n        firstTransformation.type === \'insertText\') &&\n        firstTransformation.manuallySetCursorPositions;\n    // We handle multiple cursors in a different way in visual block mode, unfortunately.\n    // TODO - refactor that out!\n    if (vimState.currentMode !== mode_1.Mode.VisualBlock && !manuallySetCursorPositions) {\n        vimState.cursors = selections.map((sel, idx) => {\n            const diffs = accumulatedPositionDifferences[idx] ?? [];\n            if (vimState.recordedState.operatorPositionDiff) {\n                diffs.push(vimState.recordedState.operatorPositionDiff);\n            }\n            return diffs.reduce((cursor, diff) => new cursor_1.Cursor(cursor.start.add(vimState.document, diff), cursor.stop.add(vimState.document, diff)), cursor_1.Cursor.FromVSCodeSelection(sel));\n        });\n        vimState.recordedState.operatorPositionDiff = undefined;\n    }\n    else if (accumulatedPositionDifferences[0]?.length > 0) {\n        const diff = accumulatedPositionDifferences[0][0];\n        vimState.cursorStopPosition = vimState.cursorStopPosition.add(vimState.document, diff);\n        vimState.cursorStartPosition = vimState.cursorStartPosition.add(vimState.document, diff);\n    }\n    vimState.recordedState.transformer = new transformer_1.Transformer();\n}\nexports.executeTransformations = executeTransformations;\n\n\n//# sourceURL=webpack://vim/./src/transformations/execute.ts?')},"./src/transformations/transformations.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.stringify = exports.areAllSameTransformation = exports.overlappingTransformations = exports.isMultiCursorTextTransformation = exports.isTextTransformation = void 0;\nconst vscode_1 = __webpack_require__(/*! vscode */ \"vscode\");\nconst isTextTransformation = (x) => {\n    return (x.type === 'insertText' ||\n        x.type === 'replaceText' ||\n        x.type === 'deleteRange' ||\n        x.type === 'moveCursor');\n};\nexports.isTextTransformation = isTextTransformation;\nconst isMultiCursorTextTransformation = (x) => {\n    return (x.type === 'insertTextVSCode' && x.isMultiCursor) ?? false;\n};\nexports.isMultiCursorTextTransformation = isMultiCursorTextTransformation;\nconst getRangeFromTextTransformation = (transformation) => {\n    switch (transformation.type) {\n        case 'insertText':\n            return new vscode_1.Range(transformation.position, transformation.position.advancePositionByText(transformation.text));\n        case 'replaceText':\n            // TODO: Do we need to do the same sort of thing here as for insertText?\n            return transformation.range;\n        case 'deleteRange':\n            return transformation.range;\n        case 'moveCursor':\n            return undefined;\n    }\n    // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n    throw new Error('Unhandled text transformation: ' + transformation);\n};\nfunction overlappingTransformations(transformations) {\n    for (let i = 0; i < transformations.length; i++) {\n        for (let j = i + 1; j < transformations.length; j++) {\n            const first = transformations[i];\n            const second = transformations[j];\n            const firstRange = getRangeFromTextTransformation(first);\n            const secondRange = getRangeFromTextTransformation(second);\n            if (!firstRange || !secondRange) {\n                continue;\n            }\n            const intersection = firstRange.intersection(secondRange);\n            if (intersection && !intersection.start.isEqual(intersection.end)) {\n                return [first, second];\n            }\n        }\n    }\n    return undefined;\n}\nexports.overlappingTransformations = overlappingTransformations;\nconst areAllSameTransformation = (transformations) => {\n    const firstTransformation = transformations[0];\n    return transformations.every((t) => {\n        return Object.entries(t).every(([key, value]) => {\n            // TODO: this is all quite janky\n            return firstTransformation[key] === value;\n        });\n    });\n};\nexports.areAllSameTransformation = areAllSameTransformation;\nfunction stringify(transformation) {\n    if (transformation.type === 'replayRecordedState') {\n        return `Replay: ${transformation.recordedState.actionsRun\n            .map((x) => x.keysPressed.join(''))\n            .join('')}`;\n    }\n    else {\n        return JSON.stringify(transformation);\n    }\n}\nexports.stringify = stringify;\n\n\n//# sourceURL=webpack://vim/./src/transformations/transformations.ts?")},"./src/transformations/transformer.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Transformer = void 0;\nconst logger_1 = __webpack_require__(/*! ../util/logger */ \"./src/util/logger.ts\");\nconst transformations_1 = __webpack_require__(/*! ./transformations */ \"./src/transformations/transformations.ts\");\n/**\n * This class is (ideally) responsible for managing all changes made to document state, via @see Transformation.\n * Currently, changes are queued up within Actions and then executed (more or less) all at once.\n *\n * NOTE: This whole system is heavily WIP as I work through a large piecemeal refactor.\n */\nclass Transformer {\n    constructor() {\n        this.transformations = [];\n    }\n    addTransformation(transformation) {\n        logger_1.Logger.debug(`Adding Transformation ${(0, transformations_1.stringify)(transformation)}`);\n        this.transformations.push(transformation);\n    }\n    insert(position, text, diff) {\n        this.addTransformation({ type: 'insertText', position, text, diff });\n    }\n    delete(range, diff) {\n        this.addTransformation({ type: 'deleteRange', range, diff });\n    }\n    replace(range, text, diff) {\n        this.addTransformation({ type: 'replaceText', range, text, diff });\n    }\n    moveCursor(diff, cursorIndex) {\n        this.addTransformation({ type: 'moveCursor', diff, cursorIndex });\n    }\n    vscodeCommand(command, ...args) {\n        this.addTransformation({ type: 'vscodeCommand', command, args });\n    }\n}\nexports.Transformer = Transformer;\n\n\n//# sourceURL=webpack://vim/./src/transformations/transformer.ts?")},"./src/util/clipboard.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.Clipboard = void 0;\nconst vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));\nconst logger_1 = __webpack_require__(/*! ./logger */ "./src/util/logger.ts");\n/**\n * A thin wrapper around `vscode.env.clipboard`\n */\nclass Clipboard {\n    static async Copy(text) {\n        try {\n            await vscode.env.clipboard.writeText(text);\n        }\n        catch (e) {\n            logger_1.Logger.error(`Error copying to clipboard. err=${e}`);\n        }\n    }\n    static async Paste() {\n        return vscode.env.clipboard.readText();\n    }\n}\nexports.Clipboard = Clipboard;\n\n\n//# sourceURL=webpack://vim/./src/util/clipboard.ts?')},"./src/util/decorationUtils.ts":(__unused_webpack_module,exports)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getDecorationsForSearchMatchRanges = exports.formatDecorationText = exports.ensureVisible = void 0;\n/**\n * @returns a DecorationOptions object representing the given range. If the\n * given range is empty, the range of the returned object will be extended one\n * character to the right. If the given range cannot be extended right, or\n * represents the end of a line (possibly containing EOL characters), the\n * returned object will specify an after element with the width of a single\n * character.\n */\nfunction ensureVisible(range) {\n    return (range.isEmpty || range.end.isLineBeginning()) && range.start.isLineEnd()\n        ? {\n            // range is at EOL, possibly containing EOL char(s).\n            range: range.with(undefined, range.start),\n            renderOptions: {\n                after: {\n                    color: 'transparent',\n                    contentText: '$', // non-whitespace character to set width.\n                },\n            },\n        }\n        : range.isEmpty\n            ? { range: range.with(undefined, range.end.translate(0, 1)) } // extend range one character right\n            : { range };\n}\nexports.ensureVisible = ensureVisible;\n/**\n * @returns a version of the input string suitable for use as the contentText of a decoration's before or after element\n */\nfunction formatDecorationText(text, tabsize, newlineReplacement = '\\u23ce') {\n    // surround with zero-width space to prevent trimming\n    return `\\u200b${text\n        // vscode collapses whitespace in decorations; modify text to prevent this.\n        .replace(/ /g, '\\u00a0') // \" \" NO-BREAK SPACE\n        .replace(/\\t/g, '\\u00a0'.repeat(tabsize))\n        // Decorations can't change the apparent # of lines in the editor, so we must settle for a single-line version of our text\n        .replace(/\\r\\n|[\\r\\n]/g, newlineReplacement)}\\u200b`;\n}\nexports.formatDecorationText = formatDecorationText;\n/**\n * @returns search decorations for the given ranges, taking into account the current match\n */\nfunction getDecorationsForSearchMatchRanges(ranges, currentMatchIndex) {\n    const searchHighlight = [];\n    const searchMatch = [];\n    for (let i = 0; i < ranges.length; i++) {\n        (i === currentMatchIndex ? searchMatch : searchHighlight).push(ensureVisible(ranges[i]));\n    }\n    return { searchHighlight, searchMatch };\n}\nexports.getDecorationsForSearchMatchRanges = getDecorationsForSearchMatchRanges;\n\n\n//# sourceURL=webpack://vim/./src/util/decorationUtils.ts?")},"./src/util/externalCommand.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.externalCommand = void 0;\nconst configuration_1 = __webpack_require__(/*! ../configuration/configuration */ \"./src/configuration/configuration.ts\");\nconst error_1 = __webpack_require__(/*! ../error */ \"./src/error.ts\");\nclass ExternalCommand {\n    /**\n     * Expands the given command by replacing any '!' with the previous external\n     * command. The '!' can be escaped if there is a backslash preceeding the\n     * '!', then the backslash is removed and the '!' is kept.\n     *\n     * If a '!' is present but there is no previous external command, then a\n     * VimError is thrown.\n     * @param command the command to expand\n     */\n    expandCommand(command) {\n        const result = [];\n        for (let i = 0; i < command.length; i++) {\n            if (command[i] === '!') {\n                if (i > 0 && command[i - 1] === '\\\\') {\n                    // escape the '!' and keep it\n                    result.pop();\n                    result.push('!');\n                }\n                else if (!this.previousExternalCommand) {\n                    // no previous command available to substitute\n                    throw error_1.VimError.fromCode(error_1.ErrorCode.NoPreviousCommand);\n                }\n                else {\n                    result.push(this.previousExternalCommand);\n                }\n            }\n            else {\n                result.push(command[i]);\n            }\n        }\n        return result.join('');\n    }\n    /**\n     * Executes `command` and returns the output.\n     * @param command the command to run\n     * @param stdin string to pipe into stdin\n     */\n    async execute(command, stdin) {\n        const output = [];\n        const options = {\n            shell: configuration_1.configuration.shell || undefined,\n        };\n        try {\n            const exec = (await Promise.resolve().then(() => __importStar(__webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module '../util/child_process'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))))).exec;\n            const promise = exec(command, options);\n            const process = promise.child;\n            if (process.stdin !== null) {\n                process.stdin.on('error', () => {\n                    // Make write EPIPE errors silent (e.g. when writing to program not expecting stdin)\n                });\n                process.stdin.write(stdin);\n                process.stdin.end();\n            }\n            if (process.stdout !== null) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                process.stdout.on('data', (chunk) => output.push(chunk));\n            }\n            if (process.stderr !== null) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                process.stderr.on('data', (chunk) => output.push(chunk));\n            }\n            await promise;\n        }\n        catch (e) {\n            // exec throws an error if exit code != 0\n            // keep going and read the output anyway (just like vim)\n        }\n        return output.join('');\n    }\n    /**\n     * Runs the given command and returns the output (stdout and stderr).\n     * Optionally, `stdin` can be piped into stdin during execution.\n     *\n     * @param command the command to run\n     * @param stdin string to pipe into stdin, by default the empty string\n     */\n    async run(command, stdin = '') {\n        command = this.expandCommand(command);\n        this.previousExternalCommand = command;\n        // combines stdout and stderr (compatible for all platforms)\n        command += ' 2>&1';\n        let output = await this.execute(command, stdin);\n        // vim behavior, trim newlines\n        if (output.endsWith('\\r\\n')) {\n            output = output.slice(0, -2);\n        }\n        else if (output.endsWith('\\n')) {\n            output = output.slice(0, -1);\n        }\n        return output;\n    }\n}\nexports.externalCommand = new ExternalCommand();\n\n\n//# sourceURL=webpack://vim/./src/util/externalCommand.ts?")},"./src/util/logger.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.Logger = void 0;\nconst vscode_1 = __webpack_require__(/*! vscode */ "vscode");\nclass Logger {\n    static init() {\n        Logger.output = vscode_1.window.createOutputChannel(\'Vim\', { log: true });\n    }\n    static error(msg) {\n        Logger.output.error(msg);\n    }\n    static warn(msg) {\n        Logger.output.warn(msg);\n    }\n    static info(msg) {\n        Logger.output.info(msg);\n    }\n    static debug(msg) {\n        Logger.output.debug(msg);\n    }\n    static trace(msg) {\n        Logger.output.trace(msg);\n    }\n}\nexports.Logger = Logger;\n\n\n//# sourceURL=webpack://vim/./src/util/logger.ts?')},"./src/util/path.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.join = exports.readDirectory = exports.resolveUri = exports.getPathDetails = exports.separatePath = void 0;\nconst vscode = __importStar(__webpack_require__(/*! vscode */ \"vscode\"));\nconst path = __importStar(__webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\"));\nconst untildify = __webpack_require__(/*! untildify */ \"./node_modules/untildify/index.js\");\n/**\n * Separate a partial path or full path into dirname and the basename.\n * @param searchPath The path to separate.\n * @param sep The separator of the searchPath.\n * @return A two-element array where the first element is the dirname and the second\n * is the basename.\n */\nfunction separatePath(searchPath, sep) {\n    // Special handle for UNC path on windows\n    if (sep === path.win32.sep) {\n        if (searchPath[0] === sep && searchPath[1] === sep) {\n            const idx = searchPath.indexOf(sep, 2);\n            if (idx === -1) {\n                // If there isn't a complete UNC path,\n                // return the incomplete UNC as baseName\n                // e.g. \\\\test-server is an incomplete path\n                // and \\\\test-server\\ is a complete path\n                return [searchPath, ''];\n            }\n        }\n    }\n    const baseNameIndex = searchPath.lastIndexOf(sep) + 1;\n    const baseName = searchPath.slice(baseNameIndex);\n    const dirName = searchPath.slice(0, baseNameIndex);\n    return [dirName, baseName];\n}\nexports.separatePath = separatePath;\n/**\n * Get path detail.\n *\n * If the currently active document is an untitled document, we will assume the partialPath\n * is a Windows path only when the VS Code is running on Windows, and not remote session; else, posix path.\n *\n * If the currently active document is not an untitled document, we will assume the partialPath\n * is a Windows path when the current uri is local file where the first character of fsPath of the\n * current uri is not \"/\"; otherwise, posix path. fsPath can return C:\\path\\avc.txt or \\\\drive\\location\\abc.txt\n * on Windows.\n *\n * This is to maximize usability of the combination of Windows and posix machine using remote while browsing\n * file on both local and remote.\n *\n * @param partialPath A string of relative path to the directory of the currentUri,\n * or an absolute path in the environment of the currentUri.\n * ~/ can be used only if active document is local document, or local untitled document.\n * @param currentUri A uri of the currently active document.\n * @param isRemote A boolean to indicate if the current instance is in remote.\n * @return A PathDetail.\n */\nfunction getPathDetails(partialPath, currentUri, isRemote) {\n    let isWindows;\n    if (currentUri.scheme === 'untitled') {\n        // Assume remote server is nix only\n        isWindows = path === path.win32 && !isRemote;\n    }\n    else {\n        // Assuming other schemes return full path\n        // e.g. 'file' and 'vscode-remote' both return full path\n        // Also only scheme that support Windows is 'file', so we can\n        // safely check if fsPath returns '/' as the first character\n        // (fsPath in 'vscode-remote' on Windows return \\ as separator instead of /)\n        isWindows = currentUri.scheme === 'file' && currentUri.fsPath[0] !== '/';\n    }\n    const p = isWindows ? path.win32 : path.posix;\n    if (isWindows) {\n        // normalize / to \\ on windows\n        partialPath = partialPath.replace(/\\//g, '\\\\');\n    }\n    const updatedPartialPath = partialPath;\n    if (currentUri.scheme === 'file' || (currentUri.scheme === 'untitled' && !isRemote)) {\n        // We can untildify when the scheme is 'file' or 'untitled' on local fs because\n        // because we only support opening files mounted locally.\n        partialPath = untildify(partialPath);\n    }\n    const [dirName, baseName] = separatePath(partialPath, p.sep);\n    let fullDirPath;\n    if (p.isAbsolute(dirName)) {\n        fullDirPath = dirName;\n    }\n    else {\n        fullDirPath = p.join(\n        // On Windows machine:\n        // fsPath returns Windows drive path (C:\\xxx\\) or UNC path (\\\\server\\xxx)\n        // fsPath returns path with \\ as separator even if 'vscode-remote' is connect to a linux box\n        //\n        // path will return /home/user for example even 'vscode-remote' is used on windows\n        // as we relied of our isWindows detection\n        separatePath(isWindows ? currentUri.fsPath : currentUri.path, p.sep)[0], dirName);\n    }\n    const fullPath = p.join(fullDirPath, baseName);\n    return {\n        fullPath,\n        fullDirPath,\n        dirName,\n        baseName,\n        partialPath: updatedPartialPath,\n        path: p,\n    };\n}\nexports.getPathDetails = getPathDetails;\n/**\n * Resolve the absolutePath to Uri.\n *\n * @param absolutePath A string of absolute path.\n * @param sep The separator of the absolutePath.\n * This is used to determine we should consider absolutePath a Windows path.\n * @param currentUri A uri to resolve the absolutePath to Uri.\n * @param isRemote A boolean to indicate if the current instance is in remote.\n * @return null if the absolutePath is invalid. A uri resolved with the currentUri.\n */\nfunction resolveUri(absolutePath, sep, currentUri, isRemote) {\n    const isWindows = sep === path.win32.sep;\n    if (isWindows && !/^(\\\\\\\\.+\\\\)|([a-zA-Z]:\\\\)/.test(absolutePath)) {\n        // if it is windows and but don't have either\n        // UNC path or the windows drive\n        return null;\n    }\n    if (!isWindows && absolutePath[0] !== sep) {\n        // if it is not windows, but the absolute path doesn't begin with /\n        return null;\n    }\n    const isLocalUntitled = !isRemote && currentUri.scheme === 'untitled';\n    return isWindows\n        ? // Create new local Uri when it's on windows.\n            // Only local resource is support (vscode-remote doesn't have windows path)\n            // UNC path like //server1/folder should also work.\n            vscode.Uri.file(absolutePath)\n        : currentUri.with({\n            // search local file with currently active document is a local untitled doc\n            scheme: isLocalUntitled ? 'file' : currentUri.scheme,\n            path: absolutePath,\n        });\n}\nexports.resolveUri = resolveUri;\n/**\n * Get the name of the items in a directory.\n * @param absolutePath A string of absolute path.\n * @param sep The separator of the absolutePath.\n * @param currentUri A uri of the currently active document.\n * @param isRemote A boolean to indicate if the current instance is in remote.\n * @param addCurrentAndUp A boolean to indicate if .{$sep} and ..${sep} should be add to the result\n * @return A Promise which resolves to an array of string. The array can be empty if the path specified is actual\n * empty, of if the absolutePath specified is invalid, or if any error occurred during directory reading.\n * The string in the array will have sep appended if it is a directory.\n */\nasync function readDirectory(absolutePath, sep, currentUri, isRemote, addCurrentAndUp) {\n    try {\n        const directoryUri = resolveUri(absolutePath, sep, currentUri, isRemote);\n        if (directoryUri === null) {\n            return [];\n        }\n        const directoryResult = await vscode.workspace.fs.readDirectory(directoryUri);\n        return (directoryResult\n            // Add the separator at the end to the path if it is a directory\n            .map((d) => d[0] + (d[1] === vscode.FileType.Directory ? sep : ''))\n            // Add ./ and ../ to the result if specified\n            .concat(addCurrentAndUp ? [`.${sep}`, `..${sep}`] : []));\n    }\n    catch {\n        return [];\n    }\n}\nexports.readDirectory = readDirectory;\nfunction join(...paths) {\n    return path.join(...paths);\n}\nexports.join = join;\n\n\n//# sourceURL=webpack://vim/./src/util/path.ts?")},"./src/util/specialKeys.ts":(__unused_webpack_module,exports)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.SpecialKeys = void 0;\nvar SpecialKeys;\n(function (SpecialKeys) {\n    SpecialKeys["ExtensionEnable"] = "<ExtensionEnable>";\n    SpecialKeys["ExtensionDisable"] = "<ExtensionDisable>";\n    SpecialKeys["TimeoutFinished"] = "<TimeoutFinished>";\n})(SpecialKeys || (exports.SpecialKeys = SpecialKeys = {}));\n\n\n//# sourceURL=webpack://vim/./src/util/specialKeys.ts?')},"./src/util/statusBarTextUtils.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.reportSearch = exports.reportFileInfo = exports.reportLinesYanked = exports.reportLinesChanged = exports.escapeCSSIcons = void 0;\nconst mode_1 = __webpack_require__(/*! ../mode/mode */ \"./src/mode/mode.ts\");\nconst statusBar_1 = __webpack_require__(/*! ../statusBar */ \"./src/statusBar.ts\");\nconst configuration_1 = __webpack_require__(/*! ../configuration/configuration */ \"./src/configuration/configuration.ts\");\n/**\n * Escapes substrings that would be interpreted as css icon markdown in certain\n * ui labels, including the status bar.\n */\nfunction escapeCSSIcons(text) {\n    // regex from iconLabel implementation at\n    // https://github.com/microsoft/vscode/blob/9b75bd1f813e683bf46897d85387089ec083fb24/src/vs/base/browser/ui/iconLabel/iconLabels.ts#L9\n    return text.replace(/\\\\?\\$\\([A-Za-z0-9\\-]+(?:~[A-Za-z]+)?\\)/g, '\\\\$&');\n}\nexports.escapeCSSIcons = escapeCSSIcons;\n/**\n * Shows the number of lines you just changed (with `dG`, for instance), if it\n * crosses a configured threshold.\n * @param numLinesChanged The number of lines changed\n */\nfunction reportLinesChanged(numLinesChanged, vimState) {\n    if (numLinesChanged > configuration_1.configuration.report) {\n        statusBar_1.StatusBar.setText(vimState, `${numLinesChanged} more lines`);\n    }\n    else if (-numLinesChanged > configuration_1.configuration.report) {\n        statusBar_1.StatusBar.setText(vimState, `${Math.abs(numLinesChanged)} fewer lines`);\n    }\n    else {\n        statusBar_1.StatusBar.clear(vimState);\n    }\n}\nexports.reportLinesChanged = reportLinesChanged;\n/**\n * Shows the number of lines you just yanked, if it crosses a configured threshold.\n * @param numLinesYanked The number of lines yanked\n */\nfunction reportLinesYanked(numLinesYanked, vimState) {\n    if (numLinesYanked > configuration_1.configuration.report) {\n        if (vimState.currentMode === mode_1.Mode.VisualBlock) {\n            statusBar_1.StatusBar.setText(vimState, `block of ${numLinesYanked} lines yanked`);\n        }\n        else {\n            statusBar_1.StatusBar.setText(vimState, `${numLinesYanked} lines yanked`);\n        }\n    }\n    else {\n        statusBar_1.StatusBar.clear(vimState);\n    }\n}\nexports.reportLinesYanked = reportLinesYanked;\n/**\n * Shows the active file's path and line count as well as position in the file as a percentage.\n * Triggered via `<C-g>` or `:f[ile]`.\n */\nfunction reportFileInfo(position, vimState) {\n    const doc = vimState.document;\n    const fileName = doc.isUntitled ? '[No Name]' : doc.fileName;\n    const modified = doc.isDirty ? ' [Modified]' : '';\n    if (doc.lineCount === 1 && doc.lineAt(0).text.length === 0) {\n        // TODO: Vim behaves slightly differently - seems this is only shown for new buffer that hasn't been saved to disk\n        statusBar_1.StatusBar.setText(vimState, `\"${fileName}\"${modified} --No lines in buffer--`);\n    }\n    else {\n        const progress = Math.floor(((position.line + 1) / doc.lineCount) * 100);\n        statusBar_1.StatusBar.setText(vimState, `\"${fileName}\"${modified} ${doc.lineCount} line${doc.lineCount > 1 ? 's' : ''} --${progress}%--`);\n    }\n}\nexports.reportFileInfo = reportFileInfo;\n/**\n * Shows the number of matches and current match index of a search.\n * @param matchIdx Index of current match, starting at 0\n * @param numMatches Total number of matches\n * @param vimState The current `VimState`\n */\nfunction reportSearch(matchIdx, numMatches, vimState) {\n    statusBar_1.StatusBar.setText(vimState, `match ${matchIdx + 1} of ${numMatches}`);\n}\nexports.reportSearch = reportSearch;\n\n\n//# sourceURL=webpack://vim/./src/util/statusBarTextUtils.ts?")},"./src/util/util.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isLowSurrogate = exports.isHighSurrogate = exports.assertDefined = exports.scrollView = exports.clamp = exports.getCursorsAfterSync = void 0;\nconst cursor_1 = __webpack_require__(/*! ../common/motion/cursor */ \"./src/common/motion/cursor.ts\");\n/**\n * We used to have an issue where we would do something like execute a VSCode\n * command, and would encounter race conditions because the cursor positions\n * wouldn't yet be updated. So we waited for a selection change event, but\n * this doesn't seem to be necessary any more.\n *\n * @deprecated Calls to this should probably be replaced with calls to `ModeHandler::syncCursors()` or something...\n */\nfunction getCursorsAfterSync(editor) {\n    return editor.selections.map((x) => cursor_1.Cursor.FromVSCodeSelection(x));\n}\nexports.getCursorsAfterSync = getCursorsAfterSync;\nfunction clamp(num, min, max) {\n    return Math.min(Math.max(num, min), max);\n}\nexports.clamp = clamp;\nfunction scrollView(vimState, offset) {\n    if (offset !== 0) {\n        vimState.postponedCodeViewChanges.push({\n            command: 'editorScroll',\n            args: {\n                to: offset > 0 ? 'up' : 'down',\n                by: 'line',\n                value: Math.abs(offset),\n                revealCursor: false,\n                select: false,\n            },\n        });\n    }\n}\nexports.scrollView = scrollView;\nfunction assertDefined(x, err) {\n    if (x === undefined) {\n        throw new Error(err);\n    }\n}\nexports.assertDefined = assertDefined;\nfunction isHighSurrogate(charCode) {\n    return 0xd800 <= charCode && charCode <= 0xdbff;\n}\nexports.isHighSurrogate = isHighSurrogate;\nfunction isLowSurrogate(charCode) {\n    return 0xdc00 <= charCode && charCode <= 0xdfff;\n}\nexports.isLowSurrogate = isLowSurrogate;\n\n\n//# sourceURL=webpack://vim/./src/util/util.ts?")},"./src/util/vscodeContext.ts":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.VSCodeContext = void 0;\nconst vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));\nconst logger_1 = __webpack_require__(/*! ./logger */ "./src/util/logger.ts");\n/**\n * Wrapper around VS Code\'s `setContext`.\n * The API call takes several milliseconds to seconds to complete,\n * so let\'s cache the values and only call the API when necessary.\n */\nclass VSCodeContext {\n    static async set(key, value) {\n        const prev = this.get(key);\n        if (prev !== value) {\n            logger_1.Logger.trace(`Setting key=\'${key}\' to value=\'${value}\'`);\n            this.cache.set(key, value);\n            await vscode.commands.executeCommand(\'setContext\', key, value);\n        }\n    }\n    static get(key) {\n        return this.cache.get(key);\n    }\n}\nexports.VSCodeContext = VSCodeContext;\nVSCodeContext.cache = new Map();\n\n\n//# sourceURL=webpack://vim/./src/util/vscodeContext.ts?')},"./src/vimscript/exCommand.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.ExCommand = void 0;\nconst error_1 = __webpack_require__(/*! ../error */ "./src/error.ts");\nclass ExCommand {\n    constructor() {\n        this.isRepeatableWithDot = true;\n    }\n    /**\n     * If this returns true and Neovim integration is enabled, we\'ll send this command to Neovim.\n     */\n    neovimCapable() {\n        return false;\n    }\n    async executeWithRange(vimState, range) {\n        // By default, throw E481 ("No range allowed")\n        throw error_1.VimError.fromCode(error_1.ErrorCode.NoRangeAllowed);\n    }\n}\nexports.ExCommand = ExCommand;\n\n\n//# sourceURL=webpack://vim/./src/vimscript/exCommand.ts?')},"./src/vimscript/exCommandParser.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.exCommandParser = exports.commandNameParser = exports.NoOpCommand = exports.builtinExCommands = void 0;\n// eslint-disable-next-line id-denylist\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ \"./node_modules/parsimmon/build/parsimmon.umd.min.js\");\nconst ascii_1 = __webpack_require__(/*! ../cmd_line/commands/ascii */ \"./src/cmd_line/commands/ascii.ts\");\nconst bang_1 = __webpack_require__(/*! ../cmd_line/commands/bang */ \"./src/cmd_line/commands/bang.ts\");\nconst breakpoints_1 = __webpack_require__(/*! ../cmd_line/commands/breakpoints */ \"./src/cmd_line/commands/breakpoints.ts\");\nconst bufferDelete_1 = __webpack_require__(/*! ../cmd_line/commands/bufferDelete */ \"./src/cmd_line/commands/bufferDelete.ts\");\nconst close_1 = __webpack_require__(/*! ../cmd_line/commands/close */ \"./src/cmd_line/commands/close.ts\");\nconst copy_1 = __webpack_require__(/*! ../cmd_line/commands/copy */ \"./src/cmd_line/commands/copy.ts\");\nconst delete_1 = __webpack_require__(/*! ../cmd_line/commands/delete */ \"./src/cmd_line/commands/delete.ts\");\nconst digraph_1 = __webpack_require__(/*! ../cmd_line/commands/digraph */ \"./src/cmd_line/commands/digraph.ts\");\nconst file_1 = __webpack_require__(/*! ../cmd_line/commands/file */ \"./src/cmd_line/commands/file.ts\");\nconst fileInfo_1 = __webpack_require__(/*! ../cmd_line/commands/fileInfo */ \"./src/cmd_line/commands/fileInfo.ts\");\nconst goto_1 = __webpack_require__(/*! ../cmd_line/commands/goto */ \"./src/cmd_line/commands/goto.ts\");\nconst gotoLine_1 = __webpack_require__(/*! ../cmd_line/commands/gotoLine */ \"./src/cmd_line/commands/gotoLine.ts\");\nconst history_1 = __webpack_require__(/*! ../cmd_line/commands/history */ \"./src/cmd_line/commands/history.ts\");\nconst jumps_1 = __webpack_require__(/*! ../cmd_line/commands/jumps */ \"./src/cmd_line/commands/jumps.ts\");\nconst leftRightCenter_1 = __webpack_require__(/*! ../cmd_line/commands/leftRightCenter */ \"./src/cmd_line/commands/leftRightCenter.ts\");\nconst marks_1 = __webpack_require__(/*! ../cmd_line/commands/marks */ \"./src/cmd_line/commands/marks.ts\");\nconst move_1 = __webpack_require__(/*! ../cmd_line/commands/move */ \"./src/cmd_line/commands/move.ts\");\nconst nohl_1 = __webpack_require__(/*! ../cmd_line/commands/nohl */ \"./src/cmd_line/commands/nohl.ts\");\nconst only_1 = __webpack_require__(/*! ../cmd_line/commands/only */ \"./src/cmd_line/commands/only.ts\");\nconst print_1 = __webpack_require__(/*! ../cmd_line/commands/print */ \"./src/cmd_line/commands/print.ts\");\nconst put_1 = __webpack_require__(/*! ../cmd_line/commands/put */ \"./src/cmd_line/commands/put.ts\");\nconst quit_1 = __webpack_require__(/*! ../cmd_line/commands/quit */ \"./src/cmd_line/commands/quit.ts\");\nconst read_1 = __webpack_require__(/*! ../cmd_line/commands/read */ \"./src/cmd_line/commands/read.ts\");\nconst redo_1 = __webpack_require__(/*! ../cmd_line/commands/redo */ \"./src/cmd_line/commands/redo.ts\");\nconst register_1 = __webpack_require__(/*! ../cmd_line/commands/register */ \"./src/cmd_line/commands/register.ts\");\nconst retab_1 = __webpack_require__(/*! ../cmd_line/commands/retab */ \"./src/cmd_line/commands/retab.ts\");\nconst set_1 = __webpack_require__(/*! ../cmd_line/commands/set */ \"./src/cmd_line/commands/set.ts\");\nconst sh_1 = __webpack_require__(/*! ../cmd_line/commands/sh */ \"./src/cmd_line/commands/sh.ts\");\nconst shift_1 = __webpack_require__(/*! ../cmd_line/commands/shift */ \"./src/cmd_line/commands/shift.ts\");\nconst smile_1 = __webpack_require__(/*! ../cmd_line/commands/smile */ \"./src/cmd_line/commands/smile.ts\");\nconst sort_1 = __webpack_require__(/*! ../cmd_line/commands/sort */ \"./src/cmd_line/commands/sort.ts\");\nconst substitute_1 = __webpack_require__(/*! ../cmd_line/commands/substitute */ \"./src/cmd_line/commands/substitute.ts\");\nconst tab_1 = __webpack_require__(/*! ../cmd_line/commands/tab */ \"./src/cmd_line/commands/tab.ts\");\nconst terminal_1 = __webpack_require__(/*! ../cmd_line/commands/terminal */ \"./src/cmd_line/commands/terminal.ts\");\nconst undo_1 = __webpack_require__(/*! ../cmd_line/commands/undo */ \"./src/cmd_line/commands/undo.ts\");\nconst vscode_1 = __webpack_require__(/*! ../cmd_line/commands/vscode */ \"./src/cmd_line/commands/vscode.ts\");\nconst wall_1 = __webpack_require__(/*! ../cmd_line/commands/wall */ \"./src/cmd_line/commands/wall.ts\");\nconst write_1 = __webpack_require__(/*! ../cmd_line/commands/write */ \"./src/cmd_line/commands/write.ts\");\nconst writequit_1 = __webpack_require__(/*! ../cmd_line/commands/writequit */ \"./src/cmd_line/commands/writequit.ts\");\nconst writequitall_1 = __webpack_require__(/*! ../cmd_line/commands/writequitall */ \"./src/cmd_line/commands/writequitall.ts\");\nconst yank_1 = __webpack_require__(/*! ../cmd_line/commands/yank */ \"./src/cmd_line/commands/yank.ts\");\nconst error_1 = __webpack_require__(/*! ../error */ \"./src/error.ts\");\nconst statusBar_1 = __webpack_require__(/*! ../statusBar */ \"./src/statusBar.ts\");\nconst exCommand_1 = __webpack_require__(/*! ./exCommand */ \"./src/vimscript/exCommand.ts\");\nconst lineRange_1 = __webpack_require__(/*! ./lineRange */ \"./src/vimscript/lineRange.ts\");\nconst parserUtils_1 = __webpack_require__(/*! ./parserUtils */ \"./src/vimscript/parserUtils.ts\");\n/**\n * A list of all builtin ex commands and their argument parsers\n * Each element is [[abbrev, rest], argParser]\n * If argParser is undefined, it's yet to be implemented (PRs are welcome!)\n *\n * This list comes directly from nvim's `:help index` (except a few additions, which are commented)\n */\nexports.builtinExCommands = [\n    [['', ''], (0, parsimmon_1.succeed)(new gotoLine_1.GotoLineCommand())],\n    [['!', ''], bang_1.BangCommand.argParser],\n    [['#', ''], print_1.PrintCommand.argParser({ printNumbers: true, printText: true })],\n    [['#!', ''], parsimmon_1.all.map((_) => new NoOpCommand())],\n    [['&', ''], undefined],\n    [['*', ''], undefined],\n    [['<', ''], shift_1.ShiftCommand.argParser('<')],\n    [['=', ''], print_1.PrintCommand.argParser({ printNumbers: true, printText: false })],\n    [['>', ''], shift_1.ShiftCommand.argParser('>')],\n    [['@', ''], undefined],\n    [['@@', ''], undefined],\n    [['N', 'ext'], undefined],\n    [['a', 'ppend'], undefined],\n    [['ab', 'breviate'], undefined],\n    [['abc', 'lear'], undefined],\n    [['abo', 'veleft'], undefined],\n    [['al', 'l'], undefined],\n    [['am', 'enu'], undefined],\n    [['an', 'oremenu'], undefined],\n    [['ar', 'gs'], undefined],\n    [['arga', 'dd'], undefined],\n    [['argd', 'elete'], undefined],\n    [['argdo', ''], undefined],\n    [['arge', 'dit'], undefined],\n    [['argg', 'lobal'], undefined],\n    [['argl', 'ocal'], undefined],\n    [['argu', 'ment'], undefined],\n    [['as', 'cii'], (0, parsimmon_1.succeed)(new ascii_1.AsciiCommand())],\n    [['au', 'tocmd'], undefined],\n    [['aug', 'roup'], undefined],\n    [['aun', 'menu'], undefined],\n    [['b', 'uffer'], tab_1.TabCommand.argParsers.tabAbsolute],\n    [['bN', 'ext'], tab_1.TabCommand.argParsers.bprev],\n    [['ba', 'll'], undefined],\n    [['bad', 'd'], undefined],\n    [['balt', ''], undefined],\n    [['bd', 'elete'], bufferDelete_1.BufferDeleteCommand.argParser],\n    [['be', 'have'], undefined],\n    [['bel', 'owright'], undefined],\n    [['bf', 'irst'], tab_1.TabCommand.argParsers.bfirst],\n    [['bl', 'ast'], tab_1.TabCommand.argParsers.blast],\n    [['bm', 'odified'], undefined],\n    [['bn', 'ext'], tab_1.TabCommand.argParsers.bnext],\n    [['bo', 'tright'], undefined],\n    [['bp', 'revious'], tab_1.TabCommand.argParsers.bprev],\n    [['br', 'ewind'], tab_1.TabCommand.argParsers.bfirst],\n    [['brea', 'k'], undefined],\n    [['breaka', 'dd'], breakpoints_1.Breakpoints.argParsers.add],\n    [['breakd', 'el'], breakpoints_1.Breakpoints.argParsers.del],\n    [['breakl', 'ist'], breakpoints_1.Breakpoints.argParsers.list],\n    [['bro', 'wse'], undefined],\n    [['bufdo', ''], undefined],\n    [['buffers', ''], undefined],\n    [['bun', 'load'], undefined],\n    [['bw', 'ipeout'], undefined],\n    [['c', 'hange'], undefined],\n    [['cN', 'ext'], undefined],\n    [['cNf', 'ile'], undefined],\n    [['ca', 'bbrev'], undefined],\n    [['cabc', 'lear'], undefined],\n    [['cabo', 've'], undefined],\n    [['cad', 'dbuffer'], undefined],\n    [['cadde', 'xpr'], undefined],\n    [['caddf', 'ile'], undefined],\n    [['caf', 'ter'], undefined],\n    [['cal', 'l'], undefined],\n    [['cat', 'ch'], undefined],\n    [['cb', 'uffer'], undefined],\n    [['cbef', 'ore'], undefined],\n    [['cbel', 'ow'], undefined],\n    [['cbo', 'ttom'], undefined],\n    [['cc', ''], undefined],\n    [['ccl', 'ose'], (0, parsimmon_1.succeed)(new vscode_1.VsCodeCommand('workbench.action.closePanel'))],\n    [['cd', ''], undefined],\n    [['cdo', ''], undefined],\n    [['ce', 'nter'], leftRightCenter_1.CenterCommand.argParser],\n    [['cex', 'pr'], undefined],\n    [['cf', 'ile'], undefined],\n    [['cfd', 'o'], undefined],\n    [['cfir', 'st'], undefined],\n    [['cg', 'etfile'], undefined],\n    [['cgetb', 'uffer'], undefined],\n    [['cgete', 'xpr'], undefined],\n    [['changes', ''], undefined],\n    [['chd', 'ir'], undefined],\n    [['che', 'ckpath'], undefined],\n    [['checkh', 'ealth'], undefined],\n    [['checkt', 'ime'], undefined],\n    [['chi', 'story'], undefined],\n    [['cl', 'ist'], undefined],\n    [['cla', 'st'], undefined],\n    [['cle', 'arjumps'], (0, parsimmon_1.succeed)(new jumps_1.ClearJumpsCommand())],\n    [['clo', 'se'], close_1.CloseCommand.argParser],\n    [['cm', 'ap'], undefined],\n    [['cmapc', 'lear'], undefined],\n    [['cme', 'nu'], undefined],\n    [['cn', 'ext'], (0, parsimmon_1.succeed)(new vscode_1.VsCodeCommand('editor.action.marker.nextInFiles'))],\n    [['cnew', 'er'], undefined],\n    [['cnf', 'ile'], (0, parsimmon_1.succeed)(new vscode_1.VsCodeCommand('editor.action.marker.nextInFiles'))],\n    [['cno', 'remap'], undefined],\n    [['cnorea', 'bbrev'], undefined],\n    [['cnoreme', 'nu'], undefined],\n    [['co', 'py'], copy_1.CopyCommand.argParser],\n    [['col', 'der'], undefined],\n    [['colo', 'rscheme'], undefined],\n    [['com', 'mand'], undefined],\n    [['comc', 'lear'], undefined],\n    [['comp', 'iler'], undefined],\n    [['con', 'tinue'], undefined],\n    [['conf', 'irm'], undefined],\n    [['cons', 't'], undefined],\n    [['cope', 'n'], (0, parsimmon_1.succeed)(new vscode_1.VsCodeCommand('workbench.panel.markers.view.focus'))],\n    [['cp', 'revious'], (0, parsimmon_1.succeed)(new vscode_1.VsCodeCommand('editor.action.marker.prevInFiles'))],\n    [['cpf', 'ile'], (0, parsimmon_1.succeed)(new vscode_1.VsCodeCommand('editor.action.marker.prevInFiles'))],\n    [['cq', 'uit'], undefined],\n    [['cr', 'ewind'], undefined],\n    [['cs', 'cope'], undefined],\n    [['cst', 'ag'], undefined],\n    [['cu', 'nmap'], undefined],\n    [['cuna', 'bbrev'], undefined],\n    [['cunme', 'nu'], undefined],\n    [['cw', 'indow'], (0, parsimmon_1.succeed)(new vscode_1.VsCodeCommand('workbench.panel.markers.view.focus'))],\n    [['d', 'elete'], delete_1.DeleteCommand.argParser],\n    [['deb', 'ug'], undefined],\n    [['debugg', 'reedy'], undefined],\n    [['delc', 'ommand'], undefined],\n    [['delf', 'unction'], undefined],\n    [['delm', 'arks'], marks_1.DeleteMarksCommand.argParser],\n    [['di', 'splay'], register_1.RegisterCommand.argParser],\n    [['dif', 'fupdate'], undefined],\n    [['diffg', 'et'], undefined],\n    [['diffo', 'ff'], undefined],\n    [['diffp', 'atch'], undefined],\n    [['diffpu', 't'], undefined],\n    [['diffs', 'plit'], undefined],\n    [['diffthis', ''], undefined],\n    [['dig', 'raphs'], digraph_1.DigraphsCommand.argParser],\n    [['dj', 'ump'], undefined],\n    [['dl', ''], undefined],\n    [['dli', 'st'], undefined],\n    [['do', 'autocmd'], undefined],\n    [['doautoa', 'll'], undefined],\n    [['dr', 'op'], undefined],\n    [['ds', 'earch'], undefined],\n    [['dsp', 'lit'], undefined],\n    [['e', 'dit'], file_1.FileCommand.argParsers.edit],\n    [['ea', 'rlier'], undefined],\n    [['ec', 'ho'], undefined],\n    [['echoe', 'rr'], undefined],\n    [['echoh', 'l'], undefined],\n    [['echom', 'sg'], undefined],\n    [['echon', ''], undefined],\n    [['el', 'se'], undefined],\n    [['elsei', 'f'], undefined],\n    [['em', 'enu'], undefined],\n    [['en', 'dif'], undefined],\n    [['endf', 'unction'], undefined],\n    [['endfo', 'r'], undefined],\n    [['endt', 'ry'], undefined],\n    [['endw', 'hile'], undefined],\n    [['ene', 'w'], file_1.FileCommand.argParsers.enew],\n    [['ev', 'al'], undefined],\n    [['ex', ''], file_1.FileCommand.argParsers.edit],\n    [['exe', 'cute'], undefined],\n    [['exi', 't'], writequit_1.WriteQuitCommand.argParser],\n    [['exu', 'sage'], undefined],\n    [['f', 'ile'], fileInfo_1.FileInfoCommand.argParser],\n    [['files', ''], undefined],\n    [['filet', 'ype'], undefined],\n    [['filt', 'er'], undefined],\n    [['fin', 'd'], undefined],\n    [['fina', 'lly'], undefined],\n    [['fini', 'sh'], undefined],\n    [['fir', 'st'], undefined],\n    [['fo', 'ld'], undefined],\n    [['foldc', 'lose'], undefined],\n    [['foldd', 'oopen'], undefined],\n    [['folddoc', 'losed'], undefined],\n    [['foldo', 'pen'], undefined],\n    [['for', ''], undefined],\n    [['fu', 'nction'], undefined],\n    [['g', 'lobal'], undefined],\n    [['go', 'to'], goto_1.GotoCommand.argParser],\n    [['gr', 'ep'], undefined],\n    [['grepa', 'dd'], undefined],\n    [['gu', 'i'], undefined],\n    [['gv', 'im'], undefined],\n    [['h', 'elp'], undefined],\n    [['ha', 'rdcopy'], undefined],\n    [['helpc', 'lose'], undefined],\n    [['helpg', 'rep'], undefined],\n    [['helpt', 'ags'], undefined],\n    [['hi', 'ghlight'], undefined],\n    [['hid', 'e'], undefined],\n    [['his', 'tory'], history_1.HistoryCommand.argParser],\n    [['i', 'nsert'], undefined],\n    [['ia', 'bbrev'], undefined],\n    [['iabc', 'lear'], undefined],\n    [['if', ''], undefined],\n    [['ij', 'ump'], undefined],\n    [['il', 'ist'], undefined],\n    [['im', 'ap'], undefined],\n    [['imapc', 'lear'], undefined],\n    [['ime', 'nu'], undefined],\n    [['ino', 'remap'], undefined],\n    [['inorea', 'bbrev'], undefined],\n    [['inoreme', 'nu'], undefined],\n    [['int', 'ro'], undefined],\n    [['is', 'earch'], undefined],\n    [['isp', 'lit'], undefined],\n    [['iu', 'nmap'], undefined],\n    [['iuna', 'bbrev'], undefined],\n    [['iunme', 'nu'], undefined],\n    [['j', 'oin'], undefined],\n    [['ju', 'mps'], (0, parsimmon_1.succeed)(new jumps_1.JumpsCommand())],\n    [['k', ''], undefined],\n    [['kee', 'pmarks'], undefined],\n    [['keepa', 'lt'], undefined],\n    [['keepj', 'umps'], undefined],\n    [['keepp', 'atterns'], undefined],\n    [['l', 'ist'], print_1.PrintCommand.argParser({ printNumbers: false, printText: true })],\n    [['lN', 'ext'], undefined],\n    [['lNf', 'ile'], undefined],\n    [['la', 'st'], undefined],\n    [['lab', 'ove'], undefined],\n    [['lad', 'dexpr'], undefined],\n    [['laddb', 'uffer'], undefined],\n    [['laddf', 'ile'], undefined],\n    [['laf', 'ter'], undefined],\n    [['lan', 'guage'], undefined],\n    [['lat', 'er'], undefined],\n    [['lb', 'uffer'], undefined],\n    [['lbef', 'ore'], undefined],\n    [['lbel', 'ow'], undefined],\n    [['lbo', 'ttom'], undefined],\n    [['lc', 'd'], undefined],\n    [['lch', 'dir'], undefined],\n    [['lcl', 'ose'], (0, parsimmon_1.succeed)(new vscode_1.VsCodeCommand('workbench.action.closePanel'))],\n    [['lcs', 'cope'], undefined],\n    [['ld', 'o'], undefined],\n    [['le', 'ft'], leftRightCenter_1.LeftCommand.argParser],\n    [['lefta', 'bove'], undefined],\n    [['let', ''], undefined],\n    [['lex', 'pr'], undefined],\n    [['lf', 'ile'], undefined],\n    [['lfd', 'o'], undefined],\n    [['lfir', 'st'], undefined],\n    [['lg', 'etfile'], undefined],\n    [['lgetb', 'uffer'], undefined],\n    [['lgete', 'xpr'], undefined],\n    [['lgr', 'ep'], undefined],\n    [['lgrepa', 'dd'], undefined],\n    [['lh', 'elpgrep'], undefined],\n    [['lhi', 'story'], undefined],\n    [['ll', ''], undefined],\n    [['lla', 'st'], undefined],\n    [['lli', 'st'], undefined],\n    [['lm', 'ap'], undefined],\n    [['lmak', 'e'], undefined],\n    [['lmapc', 'lear'], undefined],\n    [['ln', 'oremap'], undefined],\n    [['lne', 'xt'], (0, parsimmon_1.succeed)(new vscode_1.VsCodeCommand('editor.action.nextCommentThreadAction'))],\n    [['lnew', 'er'], undefined],\n    [['lnf', 'ile'], undefined],\n    [['lo', 'adview'], undefined],\n    [['loadk', 'eymap'], undefined],\n    [['loc', 'kmarks'], undefined],\n    [['lockv', 'ar'], undefined],\n    [['lol', 'der'], undefined],\n    [['lope', 'n'], (0, parsimmon_1.succeed)(new vscode_1.VsCodeCommand('workbench.action.focusCommentsPanel'))],\n    [['lp', 'revious'], (0, parsimmon_1.succeed)(new vscode_1.VsCodeCommand('editor.action.previousCommentThreadAction'))],\n    [['lpf', 'ile'], undefined],\n    [['lr', 'ewind'], undefined],\n    [\n        ['ls', ''],\n        (0, parsimmon_1.succeed)(new vscode_1.VsCodeCommand('workbench.action.quickOpenLeastRecentlyUsedEditorInGroup')),\n    ],\n    [['lt', 'ag'], undefined],\n    [['lu', 'nmap'], undefined],\n    [['lua', ''], undefined],\n    [['luad', 'o'], undefined],\n    [['luaf', 'ile'], undefined],\n    [['lv', 'imgrep'], undefined],\n    [['lvimgrepa', 'dd'], undefined],\n    [['lw', 'indow'], (0, parsimmon_1.succeed)(new vscode_1.VsCodeCommand('workbench.action.focusCommentsPanel'))],\n    [['m', 'ove'], move_1.MoveCommand.argParser],\n    [['ma', 'rk'], undefined],\n    [['mak', 'e'], undefined],\n    [['map', ''], undefined],\n    [['mapc', 'lear'], undefined],\n    [['marks', ''], marks_1.MarksCommand.argParser],\n    [['mat', 'ch'], undefined],\n    [['me', 'nu'], undefined],\n    [['menut', 'ranslate'], undefined],\n    [['mes', 'sages'], undefined],\n    [['mk', 'exrc'], undefined],\n    [['mks', 'ession'], undefined],\n    [['mksp', 'ell'], undefined],\n    [['mkv', 'imrc'], undefined],\n    [['mkvie', 'w'], undefined],\n    [['mod', 'e'], undefined],\n    [['n', 'ext'], undefined],\n    [['new', ''], file_1.FileCommand.argParsers.new],\n    [['nm', 'ap'], undefined],\n    [['nmapc', 'lear'], undefined],\n    [['nme', 'nu'], undefined],\n    [['nn', 'oremap'], undefined],\n    [['nnoreme', 'nu'], undefined],\n    [['no', 'remap'], undefined],\n    [['noa', 'utocmd'], undefined],\n    [['noh', 'lsearch'], (0, parsimmon_1.succeed)(new nohl_1.NohlCommand())],\n    [['norea', 'bbrev'], undefined],\n    [['noreme', 'nu'], undefined],\n    [['norm', 'al'], undefined],\n    [['nos', 'wapfile'], undefined],\n    [['nu', 'mber'], print_1.PrintCommand.argParser({ printNumbers: true, printText: true })],\n    [['nun', 'map'], undefined],\n    [['nunme', 'nu'], undefined],\n    [['ol', 'dfiles'], undefined],\n    [['om', 'ap'], undefined],\n    [['omapc', 'lear'], undefined],\n    [['ome', 'nu'], undefined],\n    [['on', 'ly'], (0, parsimmon_1.succeed)(new only_1.OnlyCommand())],\n    [['ono', 'remap'], undefined],\n    [['onoreme', 'nu'], undefined],\n    [['opt', 'ions'], undefined],\n    [['ou', 'nmap'], undefined],\n    [['ounme', 'nu'], undefined],\n    [['ow', 'nsyntax'], undefined],\n    [['p', 'rint'], print_1.PrintCommand.argParser({ printNumbers: false, printText: true })],\n    [['pa', 'ckadd'], undefined],\n    [['packl', 'oadall'], undefined],\n    [['pc', 'lose'], undefined],\n    [['pe', 'rl'], undefined],\n    [['ped', 'it'], undefined],\n    [['perld', 'o'], undefined],\n    [['perlf', 'ile'], undefined],\n    [['po', 'p'], undefined],\n    [['popu', 'p'], undefined],\n    [['pp', 'op'], undefined],\n    [['pre', 'serve'], undefined],\n    [['prev', 'ious'], undefined],\n    [['prof', 'ile'], undefined],\n    [['profd', 'el'], undefined],\n    [['ps', 'earch'], undefined],\n    [['pt', 'ag'], undefined],\n    [['ptN', 'ext'], undefined],\n    [['ptf', 'irst'], undefined],\n    [['ptj', 'ump'], undefined],\n    [['ptl', 'ast'], undefined],\n    [['ptn', 'ext'], undefined],\n    [['ptp', 'revious'], undefined],\n    [['ptr', 'ewind'], undefined],\n    [['pts', 'elect'], undefined],\n    [['pu', 't'], put_1.PutExCommand.argParser],\n    [['pw', 'd'], undefined],\n    [['py', 'thon'], undefined],\n    [['py3', ''], undefined],\n    [['py3d', 'o'], undefined],\n    [['py3f', 'ile'], undefined],\n    [['pyd', 'o'], undefined],\n    [['pyf', 'ile'], undefined],\n    [['python3', ''], undefined],\n    [['pythonx', ''], undefined],\n    [['pyx', ''], undefined],\n    [['pyxd', 'o'], undefined],\n    [['pyxf', 'ile'], undefined],\n    [['q', 'uit'], quit_1.QuitCommand.argParser(false)],\n    [['qa', 'll'], quit_1.QuitCommand.argParser(true)],\n    [['quita', 'll'], quit_1.QuitCommand.argParser(true)],\n    [['r', 'ead'], read_1.ReadCommand.argParser],\n    [['rec', 'over'], undefined],\n    [['red', 'o'], redo_1.RedoCommand.argParser],\n    [['redi', 'r'], undefined],\n    [['redr', 'aw'], undefined],\n    [['redraws', 'tatus'], undefined],\n    [['redrawt', 'abline'], undefined],\n    [['reg', 'isters'], register_1.RegisterCommand.argParser],\n    [['res', 'ize'], undefined],\n    [['ret', 'ab'], retab_1.RetabCommand.argParser],\n    [['retu', 'rn'], undefined],\n    [['rew', 'ind'], undefined],\n    [['ri', 'ght'], leftRightCenter_1.RightCommand.argParser],\n    [['rightb', 'elow'], undefined],\n    [['rsh', 'ada'], undefined],\n    [['ru', 'ntime'], undefined],\n    [['rub', 'y'], undefined],\n    [['rubyd', 'o'], undefined],\n    [['rubyf', 'ile'], undefined],\n    [['rund', 'o'], undefined],\n    [['s', 'ubstitute'], substitute_1.SubstituteCommand.argParser],\n    [['sN', 'ext'], undefined],\n    [['sa', 'rgument'], undefined],\n    [['sal', 'l'], undefined],\n    [['san', 'dbox'], undefined],\n    [['sav', 'eas'], undefined],\n    [['sb', 'uffer'], undefined],\n    [['sbN', 'ext'], undefined],\n    [['sba', 'll'], undefined],\n    [['sbf', 'irst'], undefined],\n    [['sbl', 'ast'], undefined],\n    [['sbm', 'odified'], undefined],\n    [['sbn', 'ext'], undefined],\n    [['sbp', 'revious'], undefined],\n    [['sbr', 'ewind'], undefined],\n    [['scr', 'iptnames'], undefined],\n    [['scripte', 'ncoding'], undefined],\n    [['scs', 'cope'], undefined],\n    [['se', 't'], set_1.SetCommand.argParser],\n    [['setf', 'iletype'], undefined],\n    [['setg', 'lobal'], undefined],\n    [['setl', 'ocal'], undefined],\n    [['sf', 'ind'], undefined],\n    [['sfir', 'st'], undefined],\n    [['sh', 'ell'], (0, parsimmon_1.succeed)(new sh_1.ShCommand())], // Taken from Vim; not in nvim\n    [['sig', 'n'], undefined],\n    [['sil', 'ent'], undefined],\n    [['sl', 'eep'], undefined],\n    [['sla', 'st'], undefined],\n    [['sm', 'agic'], undefined],\n    [['smap', ''], undefined],\n    [['smapc', 'lear'], undefined],\n    [['sme', 'nu'], undefined],\n    [['smile', ''], (0, parsimmon_1.succeed)(new smile_1.SmileCommand())], // Taken from Vim; not in nvim\n    [['sn', 'ext'], undefined],\n    [['sno', 'magic'], undefined],\n    [['snor', 'emap'], undefined],\n    [['snoreme', 'nu'], undefined],\n    [['so', 'urce'], undefined],\n    [['sor', 't'], sort_1.SortCommand.argParser],\n    [['sp', 'lit'], file_1.FileCommand.argParsers.split],\n    [['spe', 'llgood'], undefined],\n    [['spelld', 'ump'], undefined],\n    [['spelli', 'nfo'], undefined],\n    [['spellr', 'epall'], undefined],\n    [['spellra', 're'], undefined],\n    [['spellu', 'ndo'], undefined],\n    [['spellw', 'rong'], undefined],\n    [['spr', 'evious'], undefined],\n    [['sre', 'wind'], undefined],\n    [['st', 'op'], undefined],\n    [['sta', 'g'], undefined],\n    [['star', 'tinsert'], undefined],\n    [['startg', 'replace'], undefined],\n    [['startr', 'eplace'], undefined],\n    [['stj', 'ump'], undefined],\n    [['stopi', 'nsert'], undefined],\n    [['sts', 'elect'], undefined],\n    [['sun', 'hide'], undefined],\n    [['sunm', 'ap'], undefined],\n    [['sunme', 'nu'], undefined],\n    [['sus', 'pend'], undefined],\n    [['sv', 'iew'], undefined],\n    [['sw', 'apname'], undefined],\n    [['sy', 'ntax'], undefined],\n    [['sync', 'bind'], undefined],\n    [['synti', 'me'], undefined],\n    [['t', ''], copy_1.CopyCommand.argParser],\n    [['tN', 'ext'], undefined],\n    [['ta', 'g'], undefined],\n    [['tab', ''], undefined],\n    [['tabN', 'ext'], tab_1.TabCommand.argParsers.bprev],\n    [['tabc', 'lose'], tab_1.TabCommand.argParsers.tabclose],\n    [['tabdo', ''], undefined],\n    [['tabe', 'dit'], tab_1.TabCommand.argParsers.tabnew],\n    [['tabf', 'ind'], undefined],\n    [['tabfir', 'st'], tab_1.TabCommand.argParsers.bfirst],\n    [['tabl', 'ast'], tab_1.TabCommand.argParsers.blast],\n    [['tabm', 'ove'], tab_1.TabCommand.argParsers.tabmove],\n    [['tabn', 'ext'], tab_1.TabCommand.argParsers.bnext],\n    [['tabnew', ''], tab_1.TabCommand.argParsers.tabnew],\n    [['tabo', 'nly'], tab_1.TabCommand.argParsers.tabonly],\n    [['tabp', 'revious'], tab_1.TabCommand.argParsers.bprev],\n    [['tabr', 'ewind'], tab_1.TabCommand.argParsers.bfirst],\n    [['tabs', ''], undefined],\n    [['tags', ''], undefined],\n    [['tc', 'd'], undefined],\n    [['tch', 'dir'], undefined],\n    [['te', 'rminal'], terminal_1.TerminalCommand.argParser],\n    [['tf', 'irst'], undefined],\n    [['th', 'row'], undefined],\n    [['tj', 'ump'], undefined],\n    [['tl', 'ast'], undefined],\n    [['tm', 'enu'], undefined],\n    [['tma', 'p'], undefined],\n    [['tmapc', 'lear'], undefined],\n    [['tn', 'ext'], undefined],\n    [['tno', 'remap'], undefined],\n    [['to', 'pleft'], undefined],\n    [['tp', 'revious'], undefined],\n    [['tr', 'ewind'], undefined],\n    [['try', ''], undefined],\n    [['ts', 'elect'], undefined],\n    [['tu', 'nmenu'], undefined],\n    [['tunma', 'p'], undefined],\n    [['u', 'ndo'], undo_1.UndoCommand.argParser],\n    [['una', 'bbreviate'], undefined],\n    [['undoj', 'oin'], undefined],\n    [['undol', 'ist'], undefined],\n    [['unh', 'ide'], undefined],\n    [['unl', 'et'], undefined],\n    [['unlo', 'ckvar'], undefined],\n    [['unm', 'ap'], undefined],\n    [['unme', 'nu'], undefined],\n    [['uns', 'ilent'], undefined],\n    [['up', 'date'], write_1.WriteCommand.argParser],\n    [['v', 'global'], undefined],\n    [['ve', 'rsion'], undefined],\n    [['verb', 'ose'], undefined],\n    [['vert', 'ical'], undefined],\n    [['vi', 'sual'], undefined],\n    [['vie', 'w'], undefined],\n    [['vim', 'grep'], undefined],\n    [['vimgrepa', 'dd'], undefined],\n    [['viu', 'sage'], undefined],\n    [['vm', 'ap'], undefined],\n    [['vmapc', 'lear'], undefined],\n    [['vme', 'nu'], undefined],\n    [['vn', 'oremap'], undefined],\n    [['vne', 'w'], file_1.FileCommand.argParsers.vnew],\n    [['vnoreme', 'nu'], undefined],\n    [['vs', 'plit'], file_1.FileCommand.argParsers.vsplit],\n    [['vsc', 'ode'], vscode_1.VsCodeCommand.argParser], // Special: run VS Code command\n    [['vu', 'nmap'], undefined],\n    [['vunme', 'nu'], undefined],\n    [['w', 'rite'], write_1.WriteCommand.argParser],\n    [['wN', 'ext'], undefined],\n    [['wa', 'll'], wall_1.WallCommand.argParser],\n    [['wh', 'ile'], undefined],\n    [['wi', 'nsize'], undefined],\n    [['winc', 'md'], undefined],\n    [['windo', ''], undefined],\n    [['winp', 'os'], undefined],\n    [['wn', 'ext'], undefined],\n    [['wp', 'revious'], undefined],\n    [['wq', ''], writequit_1.WriteQuitCommand.argParser],\n    [['wqa', 'll'], writequitall_1.WriteQuitAllCommand.argParser],\n    [['wsh', 'ada'], undefined],\n    [['wu', 'ndo'], undefined],\n    [['x', 'it'], writequit_1.WriteQuitCommand.argParser],\n    [['xa', 'll'], writequitall_1.WriteQuitAllCommand.argParser],\n    [['xm', 'ap'], undefined],\n    [['xmapc', 'lear'], undefined],\n    [['xme', 'nu'], undefined],\n    [['xn', 'oremap'], undefined],\n    [['xnoreme', 'nu'], undefined],\n    [['xu', 'nmap'], undefined],\n    [['xunme', 'nu'], undefined],\n    [['y', 'ank'], yank_1.YankCommand.argParser],\n    [['z', ''], undefined],\n    [['~', ''], undefined],\n];\nclass UnimplementedCommand extends exCommand_1.ExCommand {\n    neovimCapable() {\n        // If the user has neovim integration enabled, don't stop them from using these commands\n        return true;\n    }\n    constructor(name) {\n        super();\n        this.name = name;\n    }\n    async execute(vimState) {\n        statusBar_1.StatusBar.setText(vimState, `Command :${this.name} is not yet implemented (PRs are welcome!)`, true);\n    }\n    async executeWithRange(vimState, range) {\n        await this.execute(vimState);\n    }\n}\nclass NoOpCommand extends exCommand_1.ExCommand {\n    async execute(vimState) {\n        // nothing\n    }\n}\nexports.NoOpCommand = NoOpCommand;\nfunction nameParser(name, argParser) {\n    argParser ??= parsimmon_1.all.result(new UnimplementedCommand(name[1] ? `${name[0]}[${name[1]}]` : name[0]));\n    const fullName = name[0] + name[1];\n    const p = (0, parserUtils_1.nameAbbrevParser)(name[0], name[1]).result(argParser);\n    return fullName === '' || /[a-z]$/i.test(fullName) ? p.notFollowedBy((0, parsimmon_1.regexp)(/[a-z]/i)) : p;\n}\nexports.commandNameParser = (0, parsimmon_1.alt)(...[...exports.builtinExCommands]\n    .reverse()\n    .map(([name, argParser]) => nameParser(name, argParser?.skip(parsimmon_1.optWhitespace))));\nexports.exCommandParser = parsimmon_1.optWhitespace\n    .then((0, parsimmon_1.string)(':').skip(parsimmon_1.optWhitespace).many())\n    .then((0, parsimmon_1.seq)(lineRange_1.LineRange.parser.fallback(undefined), parsimmon_1.optWhitespace, exports.commandNameParser.fallback(undefined), parsimmon_1.all))\n    .map(([lineRange, whitespace, parseArgs, args]) => {\n    if (parseArgs === undefined) {\n        throw error_1.VimError.fromCode(error_1.ErrorCode.NotAnEditorCommand, `${lineRange?.toString() ?? ''}${whitespace}${args}`);\n    }\n    const result = (0, parsimmon_1.seq)(parseArgs, parsimmon_1.optWhitespace.then(parsimmon_1.all)).parse(args);\n    if (result.status === false || result.value[1]) {\n        // TODO: All possible parsing errors are lumped into \"trailing characters\", which is wrong\n        // TODO: Implement `:help :bar`\n        // TODO: Implement `:help :comment`\n        throw error_1.VimError.fromCode(error_1.ErrorCode.TrailingCharacters);\n    }\n    return { lineRange, command: result.value[0] };\n});\n\n\n//# sourceURL=webpack://vim/./src/vimscript/exCommandParser.ts?")},"./src/vimscript/expression.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.keystrokesExpressionParser = void 0;\n// eslint-disable-next-line id-denylist\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ \"./node_modules/parsimmon/build/parsimmon.umd.min.js\");\nconst configuration_1 = __webpack_require__(/*! ../configuration/configuration */ \"./src/configuration/configuration.ts\");\nconst leaderParser = (0, parsimmon_1.regexp)(/<leader>/).map(() => configuration_1.configuration.leader); // lazy evaluation of configuration.leader\nconst specialCharacters = (0, parsimmon_1.regexp)(/<(?:Esc|C-\\w|A-\\w|C-A-\\w)>/);\nconst specialCharacterParser = (0, parsimmon_1.alt)(specialCharacters, leaderParser);\n// TODO: Move to a more general location\n// TODO: Add more special characters\nconst escapedParser = (0, parsimmon_1.string)('\\\\')\n    // eslint-disable-next-line id-denylist\n    .then(parsimmon_1.any.fallback(undefined))\n    .map((escaped) => {\n    if (escaped === undefined) {\n        return '\\\\\\\\';\n    }\n    else if (escaped === 'n') {\n        return '\\n';\n    }\n    return '\\\\' + escaped;\n});\nexports.keystrokesExpressionParser = (0, parsimmon_1.alt)(escapedParser, specialCharacterParser, (0, parsimmon_1.noneOf)('\"')).many();\n\n\n//# sourceURL=webpack://vim/./src/vimscript/expression.ts?")},"./src/vimscript/lineRange.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LineRange = exports.Address = void 0;\n// eslint-disable-next-line id-denylist\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ \"./node_modules/parsimmon/build/parsimmon.umd.min.js\");\nconst vscode_1 = __webpack_require__(/*! vscode */ \"vscode\");\nconst error_1 = __webpack_require__(/*! ../error */ \"./src/error.ts\");\nconst globalState_1 = __webpack_require__(/*! ../state/globalState */ \"./src/state/globalState.ts\");\nconst searchState_1 = __webpack_require__(/*! ../state/searchState */ \"./src/state/searchState.ts\");\nconst parserUtils_1 = __webpack_require__(/*! ./parserUtils */ \"./src/vimscript/parserUtils.ts\");\nconst pattern_1 = __webpack_require__(/*! ./pattern */ \"./src/vimscript/pattern.ts\");\nconst lineSpecifierParser = (0, parsimmon_1.alt)(parserUtils_1.numberParser.map((num) => {\n    return { type: 'number', num };\n}), (0, parsimmon_1.string)('.').result({ type: 'current_line' }), (0, parsimmon_1.string)('$').result({ type: 'last_line' }), (0, parsimmon_1.string)('%').result({ type: 'entire_file' }), (0, parsimmon_1.string)('*').result({ type: 'last_visual_range' }), (0, parsimmon_1.string)(\"'\")\n    .then(parsimmon_1.any)\n    .map((mark) => {\n    return { type: 'mark', mark };\n}), (0, parsimmon_1.string)('/')\n    .then(pattern_1.Pattern.parser({ direction: pattern_1.SearchDirection.Forward }))\n    .map((pattern) => {\n    return {\n        type: 'pattern_next',\n        pattern,\n    };\n}), (0, parsimmon_1.string)('?')\n    .then(pattern_1.Pattern.parser({ direction: pattern_1.SearchDirection.Backward }))\n    .map((pattern) => {\n    return {\n        type: 'pattern_prev',\n        pattern,\n    };\n}), (0, parsimmon_1.string)('\\\\/').result({ type: 'last_search_pattern_next' }), (0, parsimmon_1.string)('\\\\?').result({ type: 'last_search_pattern_prev' }), (0, parsimmon_1.string)('\\\\&').result({ type: 'last_substitute_pattern_next' }));\nconst offsetParser = (0, parsimmon_1.alt)((0, parsimmon_1.string)('+').then(parserUtils_1.numberParser.fallback(1)), (0, parsimmon_1.string)('-')\n    .then(parserUtils_1.numberParser.fallback(1))\n    .map((num) => -num), parserUtils_1.numberParser)\n    .skip(parsimmon_1.optWhitespace)\n    .atLeast(1)\n    .map((nums) => nums.reduce((x, y) => x + y, 0));\nclass Address {\n    constructor(specifier, offset) {\n        this.specifier = specifier;\n        this.offset = offset ?? 0;\n    }\n    resolve(vimState, side, boundsCheck = true) {\n        const line = (() => {\n            switch (this.specifier.type) {\n                case 'number':\n                    if (boundsCheck) {\n                        return this.specifier.num ? this.specifier.num - 1 : 0;\n                    }\n                    else {\n                        return this.specifier.num - 1;\n                    }\n                case 'current_line':\n                    return vimState.cursorStopPosition.line;\n                case 'last_line':\n                    return vimState.document.lineCount - 1;\n                case 'entire_file':\n                    return vimState.document.lineCount - 1;\n                case 'last_visual_range':\n                    const res = side === 'left'\n                        ? vimState.lastVisualSelection?.start.line\n                        : vimState.lastVisualSelection?.end.line;\n                    if (res === undefined) {\n                        throw error_1.VimError.fromCode(error_1.ErrorCode.MarkNotSet);\n                    }\n                    return res;\n                case 'mark':\n                    const mark = vimState.historyTracker.getMark(this.specifier.mark);\n                    if (!mark || (mark.document && mark.document !== vimState.document)) {\n                        throw error_1.VimError.fromCode(error_1.ErrorCode.MarkNotSet);\n                    }\n                    return mark.position.line;\n                case 'pattern_next':\n                    const m = this.specifier.pattern.nextMatch(vimState.document, vimState.cursorStopPosition);\n                    if (m === undefined) {\n                        // TODO: throw proper errors for nowrapscan\n                        throw error_1.VimError.fromCode(error_1.ErrorCode.PatternNotFound, this.specifier.pattern.patternString);\n                    }\n                    else {\n                        return m.start.line;\n                    }\n                case 'pattern_prev':\n                    throw new Error('Using a backward pattern in a line range is not yet supported'); // TODO\n                case 'last_search_pattern_next':\n                    if (!globalState_1.globalState.searchState) {\n                        throw error_1.VimError.fromCode(error_1.ErrorCode.NoPreviousRegularExpression);\n                    }\n                    const nextMatch = globalState_1.globalState.searchState.getNextSearchMatchPosition(vimState, vimState.cursorStopPosition, pattern_1.SearchDirection.Forward);\n                    if (nextMatch === undefined) {\n                        // TODO: throw proper errors for nowrapscan\n                        throw error_1.VimError.fromCode(error_1.ErrorCode.PatternNotFound, globalState_1.globalState.searchState.searchString);\n                    }\n                    return nextMatch.pos.line;\n                case 'last_search_pattern_prev':\n                    if (!globalState_1.globalState.searchState) {\n                        throw error_1.VimError.fromCode(error_1.ErrorCode.NoPreviousRegularExpression);\n                    }\n                    const prevMatch = globalState_1.globalState.searchState.getNextSearchMatchPosition(vimState, vimState.cursorStopPosition, pattern_1.SearchDirection.Backward);\n                    if (prevMatch === undefined) {\n                        // TODO: throw proper errors for nowrapscan\n                        throw error_1.VimError.fromCode(error_1.ErrorCode.PatternNotFound, globalState_1.globalState.searchState.searchString);\n                    }\n                    return prevMatch.pos.line;\n                case 'last_substitute_pattern_next':\n                    if (!globalState_1.globalState.substituteState) {\n                        throw error_1.VimError.fromCode(error_1.ErrorCode.NoPreviousSubstituteRegularExpression);\n                    }\n                    const searchState = globalState_1.globalState.substituteState.searchPattern\n                        ? new searchState_1.SearchState(pattern_1.SearchDirection.Forward, vimState.cursorStopPosition, globalState_1.globalState.substituteState.searchPattern.patternString, {})\n                        : undefined;\n                    const match = searchState?.getNextSearchMatchPosition(vimState, vimState.cursorStopPosition);\n                    if (match === undefined) {\n                        // TODO: throw proper errors for nowrapscan\n                        throw error_1.VimError.fromCode(error_1.ErrorCode.PatternNotFound, searchState?.searchString);\n                    }\n                    return match.pos.line;\n                default:\n                    const guard = this.specifier;\n                    throw new Error('Got unexpected LineSpecifier.type');\n            }\n        })();\n        const result = line + this.offset;\n        if (boundsCheck && (result < 0 || result > vimState.document.lineCount)) {\n            throw error_1.VimError.fromCode(error_1.ErrorCode.InvalidRange);\n        }\n        return result;\n    }\n    toString() {\n        switch (this.specifier.type) {\n            case 'number':\n                return this.specifier.num.toString();\n            case 'current_line':\n                return '.';\n            case 'last_line':\n                return '$';\n            case 'entire_file':\n                return '%';\n            case 'last_visual_range':\n                return '*';\n            case 'mark':\n                return `'${this.specifier.mark}`;\n            case 'pattern_next':\n                return `/${this.specifier.pattern}/`;\n            case 'pattern_prev':\n                return `?${this.specifier.pattern}?`;\n            case 'last_search_pattern_next':\n                return '\\\\/';\n            case 'last_search_pattern_prev':\n                return '\\\\?';\n            case 'last_substitute_pattern_next':\n                return '\\\\&';\n            default:\n                const guard = this.specifier;\n                throw new Error('Got unexpected LineSpecifier.type');\n        }\n    }\n}\nexports.Address = Address;\nAddress.parser = (0, parsimmon_1.alt)((0, parsimmon_1.seq)(lineSpecifierParser.skip(parsimmon_1.optWhitespace), offsetParser.fallback(0)), (0, parsimmon_1.seq)((0, parsimmon_1.succeed)({ type: 'current_line' }), offsetParser)).map(([specifier, offset]) => {\n    return new Address(specifier, offset);\n});\nclass LineRange {\n    constructor(start, separator, end) {\n        this.start = start;\n        this.end = end;\n        this.separator = separator;\n    }\n    resolve(vimState) {\n        // TODO: *,4 is not a valid range\n        const end = this.end ?? this.start;\n        if (end.specifier.type === 'entire_file') {\n            return { start: 0, end: vimState.document.lineCount - 1 };\n        }\n        else if (end.specifier.type === 'last_visual_range') {\n            if (vimState.lastVisualSelection === undefined) {\n                throw error_1.VimError.fromCode(error_1.ErrorCode.MarkNotSet);\n            }\n            return {\n                start: vimState.lastVisualSelection.start.line,\n                end: vimState.lastVisualSelection.end.line,\n            };\n        }\n        const left = this.start.resolve(vimState, 'left');\n        if (this.separator === ';') {\n            vimState.cursorStartPosition = vimState.cursorStopPosition = new vscode_1.Position(left, 0);\n        }\n        const right = end.resolve(vimState, 'right');\n        if (left > right) {\n            // Reverse the range to keep start < end\n            // NOTE: Vim generally makes you confirm before doing this, but we do it automatically.\n            return {\n                start: end.resolve(vimState, 'left'),\n                end: this.start.resolve(vimState, 'right'),\n            };\n        }\n        else {\n            return {\n                start: left,\n                end: end.resolve(vimState, 'right'),\n            };\n        }\n    }\n    resolveToRange(vimState) {\n        const { start, end } = this.resolve(vimState);\n        return new vscode_1.Range(new vscode_1.Position(start, 0), new vscode_1.Position(end, 0).getLineEnd());\n    }\n    toString() {\n        return `${this.start.toString()}${this.separator ?? ''}${this.end?.toString() ?? ''}`;\n    }\n}\nexports.LineRange = LineRange;\nLineRange.parser = (0, parsimmon_1.alt)((0, parsimmon_1.seq)(\n// with the start line\nAddress.parser.skip(parsimmon_1.optWhitespace), (0, parsimmon_1.seq)((0, parsimmon_1.alt)((0, parsimmon_1.string)(','), (0, parsimmon_1.string)(';')).skip(parsimmon_1.optWhitespace), Address.parser.fallback(undefined)).fallback(undefined)).map(([start, sepEnd]) => {\n    if (sepEnd) {\n        const [sep, end] = sepEnd;\n        return new LineRange(start, sep, end);\n    }\n    return new LineRange(start);\n}), (0, parsimmon_1.seq)(\n// without the start line\n(0, parsimmon_1.alt)((0, parsimmon_1.string)(','), (0, parsimmon_1.string)(';')).skip(parsimmon_1.optWhitespace), Address.parser.fallback(undefined)).map((sepEnd) => {\n    const [sep, end] = sepEnd;\n    return new LineRange(new Address({ type: 'current_line' }), sep, end);\n}));\n\n\n//# sourceURL=webpack://vim/./src/vimscript/lineRange.ts?")},"./src/vimscript/parserUtils.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fileCmdParser = exports.fileOptParser = exports.fileNameParser = exports.nameAbbrevParser = exports.bangParser = exports.integerParser = exports.numberParser = void 0;\n// eslint-disable-next-line id-denylist\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ \"./node_modules/parsimmon/build/parsimmon.umd.min.js\");\nexports.numberParser = (0, parsimmon_1.regexp)(/\\d+/).map((num) => Number.parseInt(num, 10));\nexports.integerParser = (0, parsimmon_1.regexp)(/-?\\d+/).map((num) => Number.parseInt(num, 10));\nexports.bangParser = (0, parsimmon_1.string)('!')\n    .fallback(undefined)\n    .map((bang) => bang !== undefined);\nfunction nameAbbrevParser(abbrev, rest) {\n    const suffixes = [...Array(rest.length + 1).keys()]\n        .reverse()\n        .map((idx) => rest.substring(0, idx));\n    return (0, parsimmon_1.string)(abbrev)\n        .then((0, parsimmon_1.alt)(...suffixes.map(parsimmon_1.string)))\n        .map((suffix) => abbrev + suffix);\n}\nexports.nameAbbrevParser = nameAbbrevParser;\n// TODO: `:help cmdline-special`\n// TODO: `:help filename-modifiers`\nexports.fileNameParser = (0, parsimmon_1.alt)((0, parsimmon_1.string)('\\\\').then(\n// eslint-disable-next-line id-denylist\nparsimmon_1.any.fallback(undefined).map((escaped) => {\n    if (escaped === undefined || escaped === '\\\\') {\n        return '\\\\';\n    }\n    else if (escaped === ' ') {\n        return ' ';\n    }\n    else {\n        // TODO: anything else that needs escaping?\n        return `\\\\${escaped}`;\n    }\n})), (0, parsimmon_1.regexp)(/\\S/))\n    .atLeast(1)\n    .map((chars) => chars.join(''));\nexports.fileOptParser = (0, parsimmon_1.string)('++')\n    .then((0, parsimmon_1.seq)((0, parsimmon_1.alt)((0, parsimmon_1.alt)((0, parsimmon_1.string)('ff'), (0, parsimmon_1.string)('fileformat')).result('ff'), (0, parsimmon_1.alt)((0, parsimmon_1.string)('enc'), (0, parsimmon_1.string)('encoding')).result('enc'), (0, parsimmon_1.alt)((0, parsimmon_1.string)('bin'), (0, parsimmon_1.string)('binary')).result('bin'), (0, parsimmon_1.alt)((0, parsimmon_1.string)('nobin'), (0, parsimmon_1.string)('nobinary')).result('nobin'), (0, parsimmon_1.string)('bad'), (0, parsimmon_1.string)('edit')), (0, parsimmon_1.string)('=').then((0, parsimmon_1.regexp)(/\\S+/)).fallback(undefined)))\n    .sepBy(parsimmon_1.whitespace)\n    .desc('[++opt]');\nexports.fileCmdParser = (0, parsimmon_1.string)('+')\n    .then((0, parsimmon_1.alt)(\n// Exact line number\nexports.numberParser.map((line) => ({ type: 'line_number', line })), \n// TODO: Next match of pattern\n// string('/').then(Pattern.parser({ direction: SearchDirection.Forward })),\n// TODO: Ex command\n// lazy(() => exCommandParser),\n// Last line\n(0, parsimmon_1.succeed)({ type: 'last_line' })))\n    .fallback(undefined)\n    .desc('[+cmd]');\n\n\n//# sourceURL=webpack://vim/./src/vimscript/parserUtils.ts?")},"./src/vimscript/pattern.ts":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SearchOffset = exports.Pattern = exports.SearchDirection = exports.searchStringParser = void 0;\n// eslint-disable-next-line id-denylist\nconst parsimmon_1 = __webpack_require__(/*! parsimmon */ \"./node_modules/parsimmon/build/parsimmon.umd.min.js\");\nconst vscode_1 = __webpack_require__(/*! vscode */ \"vscode\");\nconst configuration_1 = __webpack_require__(/*! ../configuration/configuration */ \"./src/configuration/configuration.ts\");\nconst textEditor_1 = __webpack_require__(/*! ../textEditor */ \"./src/textEditor.ts\");\nconst parserUtils_1 = __webpack_require__(/*! ./parserUtils */ \"./src/vimscript/parserUtils.ts\");\nfunction searchStringParser(args) {\n    return (0, parsimmon_1.seq)(Pattern.parser(args), (0, parsimmon_1.lazy)(() => SearchOffset.parser.fallback(undefined))).map(([pattern, offset]) => {\n        return { pattern, offset };\n    });\n}\nexports.searchStringParser = searchStringParser;\nvar SearchDirection;\n(function (SearchDirection) {\n    SearchDirection[SearchDirection[\"Forward\"] = 1] = \"Forward\";\n    SearchDirection[SearchDirection[\"Backward\"] = -1] = \"Backward\";\n})(SearchDirection || (exports.SearchDirection = SearchDirection = {}));\n/**\n * See `:help pattern`\n *\n * TODO(#3996): Currently, this is a thin wrapper around JavaScript's regex engine.\n *              We should either re-implement Vim's regex engine from scratch or (more likely)\n *              implement a best-effort translation from Vim's syntax to JavaScript's.\n */\nclass Pattern {\n    nextMatch(document, fromPosition) {\n        if (this.emptyBranch) {\n            const pos = fromPosition.getRightThroughLineBreaks();\n            return new vscode_1.Range(pos, pos);\n        }\n        const haystack = document.getText();\n        this.regex.lastIndex = document.offsetAt(fromPosition) + 1;\n        const match = this.regex.exec(haystack);\n        return match\n            ? new vscode_1.Range(document.positionAt(match.index), document.positionAt(match.index + match.length))\n            : undefined;\n    }\n    /**\n     * Every range in the document that matches the search string.\n     *\n     * This might not be 100% complete - @see Pattern::MAX_SEARCH_RANGES\n     */\n    allMatches(vimState, args) {\n        if (this.emptyBranch) {\n            // HACK: This pattern matches each character, but for purposes of perf when highlighting, merge them.\n            return [\n                {\n                    range: new vscode_1.Range(new vscode_1.Position(0, 0), textEditor_1.TextEditor.getDocumentEnd(vimState.document)),\n                    groups: [],\n                },\n            ];\n        }\n        let fromPosition;\n        let lineRange;\n        if ('lineRange' in args) {\n            // TODO: We should be able to get away with only getting part of the document text in this case\n            lineRange = args.lineRange.resolve(vimState);\n            fromPosition = new vscode_1.Position(lineRange.start, 0);\n        }\n        else {\n            fromPosition = args.fromPosition;\n        }\n        let haystack;\n        let searchOffset;\n        let startOffset;\n        if (this.inSelection && vimState.lastVisualSelection) {\n            // TODO: This is not exactly how Vim implements in-selection search (\\%V), see :help \\%V for more info.\n            const searchRange = new vscode_1.Range(vimState.lastVisualSelection.start, vimState.lastVisualSelection.end);\n            haystack = vimState.document.getText(searchRange);\n            searchOffset = vimState.document.offsetAt(vimState.lastVisualSelection.start);\n            startOffset = searchRange.contains(fromPosition)\n                ? vimState.document.offsetAt(fromPosition) - searchOffset\n                : 0;\n        }\n        else {\n            haystack = vimState.document.getText();\n            searchOffset = 0;\n            startOffset = vimState.document.offsetAt(fromPosition) - searchOffset;\n        }\n        this.regex.lastIndex = startOffset;\n        const start = Date.now();\n        const matchRanges = {\n            beforeWrapping: [],\n            afterWrapping: [],\n        };\n        let wrappedOver = false;\n        while (true) {\n            const match = this.regex.exec(haystack);\n            if (match) {\n                if (wrappedOver && match.index >= startOffset) {\n                    // We've found our first match again\n                    break;\n                }\n                const matchRange = new vscode_1.Range(vimState.document.positionAt(searchOffset + match.index), vimState.document.positionAt(searchOffset + match.index + match[0].length));\n                if (!this.inSelection &&\n                    lineRange &&\n                    (matchRange.start.line < lineRange.start || matchRange.end.line > lineRange.end)) {\n                    break;\n                }\n                (wrappedOver ? matchRanges.afterWrapping : matchRanges.beforeWrapping).push({\n                    range: matchRange,\n                    groups: match,\n                });\n                if (Date.now() - start > Pattern.MAX_SEARCH_TIME) {\n                    break;\n                }\n                // When we find a zero-length match, nudge the search position forward to avoid getting stuck\n                if (matchRange.start.isEqual(matchRange.end)) {\n                    this.regex.lastIndex++;\n                }\n            }\n            else if (!wrappedOver) {\n                // We need to wrap around to the back if we reach the end.\n                this.regex.lastIndex = 0;\n                wrappedOver = true;\n            }\n            else {\n                break;\n            }\n        }\n        return matchRanges.afterWrapping.concat(matchRanges.beforeWrapping);\n    }\n    static compileRegex(regexString, ignoreCase) {\n        const flags = ignoreCase ?? configuration_1.configuration.ignorecase ? 'gim' : 'gm';\n        try {\n            return new RegExp(regexString, flags);\n        }\n        catch (err) {\n            // Couldn't compile the regexp, try again with special characters escaped\n            return new RegExp(regexString.replace(Pattern.SPECIAL_CHARS_REGEX, '\\\\$&'), flags);\n        }\n    }\n    static parser(args) {\n        const delimiter = args.delimiter\n            ? args.delimiter\n            : args.direction === SearchDirection.Forward\n                ? '/'\n                : '?';\n        // TODO: Some escaped characters need special treatment\n        return (0, parsimmon_1.seqMap)((0, parsimmon_1.string)('|').result(true).fallback(false), // Leading | matches everything\n        (0, parsimmon_1.alt)((0, parsimmon_1.string)('\\\\%V').map((_) => ({ inSelection: true })), (0, parsimmon_1.string)('$').map(() => '(?:$(?<!\\\\r))'), // prevents matching \\r\\n as two lines\n        (0, parsimmon_1.string)('^').map(() => '(?:^(?<!\\\\r))'), // prevents matching \\r\\n as two lines\n        (0, parsimmon_1.string)('|')\n            .then(parsimmon_1.eof)\n            .map(() => ({ emptyBranch: true })), // Trailing | matches everything\n        (0, parsimmon_1.string)('\\\\')\n            // eslint-disable-next-line id-denylist\n            .then(parsimmon_1.any.fallback(undefined))\n            .map((escaped) => {\n            if (escaped === undefined) {\n                return '\\\\\\\\';\n            }\n            else if (escaped === delimiter) {\n                return delimiter;\n            }\n            else if (escaped === 'c') {\n                return { ignorecase: true };\n            }\n            else if (escaped === 'C') {\n                return { ignorecase: false };\n            }\n            else if (escaped === '<' || escaped === '>') {\n                // TODO: not QUITE the same\n                return '\\\\b';\n            }\n            else if (escaped === 'n') {\n                return '\\\\r?\\\\n';\n            }\n            return '\\\\' + escaped;\n        }), (0, parsimmon_1.alt)(\n        // Allow unescaped delimiter inside [], and don't transform ^ or $\n        (0, parsimmon_1.string)('\\\\')\n            // eslint-disable-next-line id-denylist\n            .then(parsimmon_1.any.fallback(undefined))\n            .map((escaped) => '\\\\' + (escaped ?? '\\\\')), (0, parsimmon_1.noneOf)(']'))\n            .many()\n            .wrap((0, parsimmon_1.string)('['), (0, parsimmon_1.string)(']'))\n            .map((result) => '[' + result.join('') + ']'), (0, parsimmon_1.noneOf)(delimiter)).many(), (0, parsimmon_1.string)(delimiter).fallback(undefined), (leadingBar, atoms, delim) => {\n            let patternString = leadingBar ? '|' : '';\n            let caseOverride;\n            let inSelection;\n            let emptyBranch = leadingBar;\n            for (const atom of atoms) {\n                if (typeof atom === 'string') {\n                    patternString += atom;\n                }\n                else {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                    if (atom.emptyBranch) {\n                        emptyBranch = true;\n                        patternString += '|';\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                    }\n                    else if (atom.ignorecase) {\n                        caseOverride = true;\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                    }\n                    else if (atom.inSelection) {\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n                        inSelection = atom.inSelection;\n                    }\n                    else if (caseOverride === undefined) {\n                        caseOverride = false;\n                    }\n                }\n            }\n            return {\n                patternString,\n                caseOverride,\n                inSelection,\n                closed: delim !== undefined,\n                emptyBranch,\n            };\n        }).map(({ patternString, caseOverride, inSelection, closed, emptyBranch }) => {\n            const ignoreCase = Pattern.getIgnoreCase(patternString, {\n                caseOverride,\n                ignoreSmartcase: args.ignoreSmartcase ?? false,\n            });\n            return new Pattern(patternString, args.direction, Pattern.compileRegex(patternString, ignoreCase), inSelection ?? false, closed, emptyBranch);\n        });\n    }\n    static getIgnoreCase(patternString, flags) {\n        if (flags.caseOverride !== undefined) {\n            return flags.caseOverride;\n        }\n        else if (configuration_1.configuration.smartcase && !flags.ignoreSmartcase && /[A-Z]/.test(patternString)) {\n            return false;\n        }\n        return configuration_1.configuration.ignorecase;\n    }\n    constructor(patternString, direction, regex, inSelection, closed, emptyBranch) {\n        this.patternString = patternString;\n        this.direction = direction;\n        // TODO: Recalculate ignorecase if relevant config changes?\n        this.regex = regex;\n        this.inSelection = inSelection;\n        this.closed = closed;\n        this.emptyBranch = emptyBranch;\n    }\n}\nexports.Pattern = Pattern;\nPattern.MAX_SEARCH_TIME = 1000;\nPattern.SPECIAL_CHARS_REGEX = /[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g;\nconst searchOffsetTypeParser = (0, parsimmon_1.oneOf)('esb')\n    .fallback(undefined)\n    .map((esb) => {\n    if (esb === undefined) {\n        return 'lines';\n    }\n    else {\n        return esb === 'e' ? 'chars_from_end' : 'chars_from_start';\n    }\n});\n/**\n * See `:help search-offset`\n */\nclass SearchOffset {\n    constructor(data) {\n        this.data = data;\n    }\n    apply(match) {\n        switch (this.data.type) {\n            case 'lines':\n                return this.data.delta === 0\n                    ? match.start\n                    : new vscode_1.Position(match.end.line + this.data.delta, 0);\n            case 'chars_from_start':\n                return match.start.getOffsetThroughLineBreaks(this.data.delta);\n            case 'chars_from_end':\n                return match.end.getOffsetThroughLineBreaks(this.data.delta - 1);\n            case 'pattern': // TODO(#3919): Support `;` offset (`:help //;`)\n            default:\n                const guard = this.data;\n                throw new Error('Unexpected SearchOffset type');\n        }\n    }\n}\nexports.SearchOffset = SearchOffset;\nSearchOffset.parser = (0, parsimmon_1.alt)((0, parsimmon_1.seq)(searchOffsetTypeParser, (0, parsimmon_1.oneOf)('+-').fallback('+'), parserUtils_1.numberParser).map(([type, sign, num]) => new SearchOffset({\n    type,\n    delta: sign === '-' ? -num : num,\n})), (0, parsimmon_1.seq)(searchOffsetTypeParser, (0, parsimmon_1.oneOf)('+-')).map(([type, sign]) => new SearchOffset({\n    type,\n    delta: sign === '-' ? -1 : 1,\n})), (0, parsimmon_1.seq)(searchOffsetTypeParser).map(([type]) => new SearchOffset({ type, delta: 0 })), (0, parsimmon_1.string)(';/')\n    .then(searchStringParser({ direction: SearchDirection.Forward }))\n    .map(({ pattern, offset }) => {\n    return new SearchOffset({\n        type: 'pattern',\n        direction: SearchDirection.Forward,\n        pattern,\n        offset,\n    });\n}), (0, parsimmon_1.string)(';?')\n    .then(searchStringParser({ direction: SearchDirection.Backward }))\n    .map(({ pattern, offset }) => {\n    return new SearchOffset({\n        type: 'pattern',\n        direction: SearchDirection.Backward,\n        pattern,\n        offset,\n    });\n}));\n\n\n//# sourceURL=webpack://vim/./src/vimscript/pattern.ts?")},"./node_modules/untildify/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nconst os = __webpack_require__(/*! os */ \"./node_modules/os-browserify/browser.js\");\n\nconst homeDirectory = os.homedir();\n\nmodule.exports = pathWithTilde => {\n\tif (typeof pathWithTilde !== 'string') {\n\t\tthrow new TypeError(`Expected a string, got ${typeof pathWithTilde}`);\n\t}\n\n\treturn homeDirectory ? pathWithTilde.replace(/^~(?=$|\\/|\\\\)/, homeDirectory) : pathWithTilde;\n};\n\n\n//# sourceURL=webpack://vim/./node_modules/untildify/index.js?")},vscode:e=>{"use strict";e.exports=require("vscode")},"./package.json":module=>{"use strict";eval('module.exports = JSON.parse(\'{"name":"vim","displayName":"Vim","description":"Vim emulation for Visual Studio Code","icon":"images/icon.png","version":"1.27.2","publisher":"vscodevim","galleryBanner":{"color":"#e3f4ff","theme":"light"},"license":"MIT","keywords":["vim","vi","vscodevim"],"repository":{"type":"git","url":"https://github.com/VSCodeVim/Vim.git"},"homepage":"https://github.com/VSCodeVim/Vim","bugs":{"url":"https://github.com/VSCodeVim/Vim/issues"},"engines":{"vscode":"^1.74.0"},"categories":["Other","Keymaps"],"extensionKind":["ui"],"sideEffects":false,"activationEvents":["onStartupFinished","onCommand:type"],"qna":"https://vscodevim.herokuapp.com/","main":"./out/extension","browser":"./out/extensionWeb","capabilities":{"untrustedWorkspaces":{"supported":true},"virtualWorkspaces":true},"contributes":{"commands":[{"command":"toggleVim","title":"Vim: Toggle Vim Mode"},{"command":"vim.showQuickpickCmdLine","title":"Vim: Show Command Line"},{"command":"vim.editVimrc","enablement":"!isWeb","title":"Vim: Edit .vimrc"}],"keybindings":[{"key":"Escape","command":"extension.vim_escape","when":"editorTextFocus && vim.active && !inDebugRepl"},{"key":"Escape","command":"notebook.cell.quitEdit","when":"inputFocus && notebookEditorFocused && !editorHasSelection && !editorHoverVisible && vim.active && vim.mode == \\\'Normal\\\'"},{"key":"Home","command":"extension.vim_home","when":"editorTextFocus && vim.active && !inDebugRepl && vim.mode != \\\'Insert\\\'"},{"key":"ctrl+home","command":"extension.vim_ctrl+home","when":"editorTextFocus && vim.active && !inDebugRepl && vim.mode != \\\'Insert\\\'"},{"key":"End","command":"extension.vim_end","when":"editorTextFocus && vim.active && !inDebugRepl && vim.mode != \\\'Insert\\\'"},{"key":"ctrl+end","command":"extension.vim_ctrl+end","when":"editorTextFocus && vim.active && !inDebugRepl && vim.mode != \\\'Insert\\\'"},{"key":"Insert","command":"extension.vim_insert","when":"editorTextFocus && vim.active && !inDebugRepl"},{"key":"Backspace","command":"extension.vim_backspace","when":"editorTextFocus && vim.active && !inDebugRepl"},{"key":"Delete","command":"extension.vim_delete","when":"editorTextFocus && vim.active && !inDebugRepl"},{"key":"tab","command":"extension.vim_tab","when":"editorTextFocus && vim.active && vim.mode != \\\'Insert\\\' && !inDebugRepl"},{"key":"shift+tab","command":"extension.vim_shift+tab","when":"editorTextFocus && vim.active && vim.mode != \\\'Insert\\\' && !inDebugRepl"},{"key":"left","command":"extension.vim_left","when":"editorTextFocus && vim.active && !inDebugRepl"},{"key":"right","command":"extension.vim_right","when":"editorTextFocus && vim.active && !inDebugRepl"},{"key":"up","command":"extension.vim_up","when":"editorTextFocus && vim.active && !inDebugRepl && !suggestWidgetVisible && !parameterHintsVisible"},{"key":"down","command":"extension.vim_down","when":"editorTextFocus && vim.active && !inDebugRepl && !suggestWidgetVisible && !parameterHintsVisible"},{"key":"g g","command":"list.focusFirst","when":"listFocus && !inputFocus"},{"key":"h","command":"list.collapse","when":"listFocus && !inputFocus"},{"key":"j","command":"list.focusDown","when":"listFocus && !inputFocus"},{"key":"k","command":"list.focusUp","when":"listFocus && !inputFocus"},{"key":"l","command":"list.select","when":"listFocus && !inputFocus"},{"key":"o","command":"list.toggleExpand","when":"listFocus && !inputFocus"},{"key":"/","command":"list.toggleKeyboardNavigation","when":"listFocus && !inputFocus && listSupportsKeyboardNavigation"},{"key":"ctrl+a","command":"extension.vim_ctrl+a","when":"editorTextFocus && vim.active && vim.use<C-a> && !inDebugRepl"},{"key":"ctrl+b","command":"extension.vim_ctrl+b","when":"editorTextFocus && vim.active && vim.use<C-b> && vim.mode != \\\'Insert\\\' && !inDebugRepl"},{"key":"ctrl+c","command":"extension.vim_ctrl+c","when":"editorTextFocus && vim.active && vim.use<C-c> && !inDebugRepl && vim.overrideCtrlC"},{"key":"ctrl+d","command":"extension.vim_ctrl+d","when":"editorTextFocus && vim.active && vim.use<C-d> && !inDebugRepl"},{"key":"ctrl+d","command":"list.focusPageDown","when":"listFocus && !inputFocus"},{"key":"ctrl+e","command":"extension.vim_ctrl+e","when":"editorTextFocus && vim.active && vim.use<C-e> && !inDebugRepl"},{"key":"ctrl+f","command":"extension.vim_ctrl+f","when":"editorTextFocus && vim.active && vim.use<C-f> && vim.mode != \\\'Insert\\\' && !inDebugRepl"},{"key":"ctrl+g","command":"extension.vim_ctrl+g","when":"editorTextFocus && vim.active && vim.use<C-g> && !inDebugRepl"},{"key":"ctrl+h","command":"extension.vim_ctrl+h","when":"editorTextFocus && vim.active && vim.use<C-h> && !inDebugRepl"},{"key":"ctrl+i","command":"extension.vim_ctrl+i","when":"editorTextFocus && vim.active && vim.use<C-i> && !inDebugRepl"},{"key":"ctrl+j","command":"extension.vim_ctrl+j","when":"editorTextFocus && vim.active && vim.use<C-j> && !inDebugRepl"},{"key":"ctrl+k","command":"extension.vim_ctrl+k","when":"editorTextFocus && vim.active && vim.use<C-k> && !inDebugRepl"},{"key":"ctrl+l","command":"extension.vim_navigateCtrlL","when":"editorTextFocus && vim.active && vim.use<C-l> && !inDebugRepl"},{"key":"ctrl+m","command":"extension.vim_ctrl+m","when":"editorTextFocus && vim.active && vim.use<C-m> && !inDebugRepl || vim.mode == \\\'CommandlineInProgress\\\' && vim.active && vim.use<C-m> && !inDebugRepl || vim.mode == \\\'SearchInProgressMode\\\' && vim.active && vim.use<C-m> && !inDebugRepl"},{"key":"ctrl+n","command":"extension.vim_ctrl+n","when":"editorTextFocus && vim.active && vim.use<C-n> && !inDebugRepl || vim.mode == \\\'CommandlineInProgress\\\' && vim.active && vim.use<C-n> && !inDebugRepl || vim.mode == \\\'SearchInProgressMode\\\' && vim.active && vim.use<C-n> && !inDebugRepl"},{"key":"ctrl+o","command":"extension.vim_ctrl+o","when":"editorTextFocus && vim.active && vim.use<C-o> && !inDebugRepl"},{"key":"ctrl+p","command":"extension.vim_ctrl+p","when":"editorTextFocus && vim.active && vim.use<C-p> && !inDebugRepl || vim.mode == \\\'CommandlineInProgress\\\' && vim.active && vim.use<C-p> && !inDebugRepl || vim.mode == \\\'SearchInProgressMode\\\' && vim.active && vim.use<C-p> && !inDebugRepl"},{"key":"ctrl+q","command":"extension.vim_winCtrlQ","when":"editorTextFocus && vim.active && vim.use<C-q> && !inDebugRepl"},{"key":"ctrl+r","command":"extension.vim_ctrl+r","when":"editorTextFocus && vim.active && vim.use<C-r> && !inDebugRepl"},{"key":"ctrl+s","command":"extension.vim_ctrl+s","when":"editorTextFocus && vim.active && vim.use<C-s> && !inDebugRepl"},{"key":"ctrl+t","command":"extension.vim_ctrl+t","when":"editorTextFocus && vim.active && vim.use<C-t> && !inDebugRepl"},{"key":"ctrl+u","command":"extension.vim_ctrl+u","when":"editorTextFocus && vim.active && vim.use<C-u> && !inDebugRepl"},{"key":"ctrl+u","command":"list.focusPageUp","when":"listFocus && !inputFocus"},{"key":"ctrl+v","command":"extension.vim_ctrl+v","when":"editorTextFocus && vim.active && vim.use<C-v> && !inDebugRepl"},{"key":"ctrl+w","command":"extension.vim_ctrl+w","when":"editorTextFocus && vim.active && vim.use<C-w> && !inDebugRepl"},{"key":"ctrl+x","command":"extension.vim_ctrl+x","when":"editorTextFocus && vim.active && vim.use<C-x> && !inDebugRepl"},{"key":"ctrl+y","command":"extension.vim_ctrl+y","when":"editorTextFocus && vim.active && vim.use<C-y> && !inDebugRepl"},{"key":"ctrl+z","command":"extension.vim_ctrl+z","when":"editorTextFocus && vim.active && vim.use<C-z> && !inDebugRepl"},{"key":"ctrl+6","command":"extension.vim_ctrl+6","when":"editorTextFocus && vim.active && vim.use<C-6> && !inDebugRepl"},{"key":"ctrl+^","command":"extension.vim_ctrl+^","when":"editorTextFocus && vim.active && vim.use<C-^> && !inDebugRepl"},{"key":"ctrl+[","command":"extension.vim_ctrl+[","when":"editorTextFocus && vim.active && vim.use<C-[> && !inDebugRepl"},{"key":"ctrl+]","command":"extension.vim_ctrl+]","when":"editorTextFocus && vim.active && vim.use<C-]> && !inDebugRepl"},{"key":"ctrl+shift+2","command":"extension.vim_ctrl+shift+2","when":"editorTextFocus && vim.active && vim.use<C-shift+2>"},{"key":"ctrl+up","command":"extension.vim_ctrl+up","when":"editorTextFocus && vim.active && vim.mode != \\\'Insert\\\' && !inDebugRepl"},{"key":"ctrl+down","command":"extension.vim_ctrl+down","when":"editorTextFocus && vim.active && vim.mode != \\\'Insert\\\' && !inDebugRepl"},{"key":"ctrl+left","command":"extension.vim_ctrl+left","when":"editorTextFocus && vim.active && vim.mode != \\\'Insert\\\' && !inDebugRepl"},{"key":"ctrl+right","command":"extension.vim_ctrl+right","when":"editorTextFocus && vim.active && vim.mode != \\\'Insert\\\' && !inDebugRepl"},{"key":"ctrl+pagedown","command":"extension.vim_ctrl+pagedown","when":"editorTextFocus && vim.active && vim.use<C-pagedown> && !inDebugRepl"},{"key":"ctrl+pageup","command":"extension.vim_ctrl+pageup","when":"editorTextFocus && vim.active && vim.use<C-pageup> && !inDebugRepl"},{"key":"ctrl+space","command":"extension.vim_ctrl+space","when":"editorTextFocus && vim.active && vim.use<C-space> && !inDebugRepl && vim.mode != \\\'Insert\\\'"},{"key":"shift+G","command":"list.focusLast","when":"listFocus && !inputFocus"},{"key":"ctrl+backspace","command":"extension.vim_ctrl+backspace","when":"editorTextFocus && vim.active && vim.use<C-BS> && vim.mode != \\\'Insert\\\' && !inDebugRepl"},{"key":"shift+backspace","command":"extension.vim_shift+backspace","when":"editorTextFocus && vim.active && vim.use<S-BS> && vim.mode != \\\'Insert\\\' && !inDebugRepl"},{"key":"cmd+left","command":"extension.vim_cmd+left","when":"editorTextFocus && vim.active && vim.use<D-left> && !inDebugRepl && vim.mode != \\\'Insert\\\'"},{"key":"cmd+right","command":"extension.vim_cmd+right","when":"editorTextFocus && vim.active && vim.use<D-right> && !inDebugRepl && vim.mode != \\\'Insert\\\'"},{"key":"cmd+a","command":"extension.vim_cmd+a","when":"editorTextFocus && vim.active && vim.use<D-a> && !inDebugRepl && vim.mode != \\\'Insert\\\'"},{"key":"cmd+c","command":"extension.vim_cmd+c","when":"editorTextFocus && vim.active && vim.use<D-c> && vim.overrideCopy && !inDebugRepl"},{"key":"cmd+d","command":"extension.vim_cmd+d","when":"editorTextFocus && vim.active && vim.use<D-d> && !inDebugRepl"},{"key":"cmd+v","command":"extension.vim_cmd+v","when":"editorTextFocus && vim.active && vim.use<D-v> && vim.mode == \\\'CommandlineInProgress\\\' && !inDebugRepl || editorTextFocus && vim.active && vim.use<D-v> && vim.mode == \\\'SearchInProgressMode\\\' && !inDebugRepl"},{"key":"ctrl+alt+down","linux":"shift+alt+down","mac":"cmd+alt+down","command":"extension.vim_cmd+alt+down","when":"editorTextFocus && vim.active && !inDebugRepl"},{"key":"ctrl+alt+up","linux":"shift+alt+up","mac":"cmd+alt+up","command":"extension.vim_cmd+alt+up","when":"editorTextFocus && vim.active && !inDebugRepl"},{"key":"j","command":"notebook.focusNextEditor","when":"vim.mode == \\\'Normal\\\' && editorTextFocus && inputFocus && notebookEditorFocused && notebookEditorCursorAtBoundary != \\\'none\\\' && notebookEditorCursorAtBoundary != \\\'top\\\'"},{"key":"k","command":"notebook.focusPreviousEditor","when":"vim.mode == \\\'Normal\\\' && editorTextFocus && inputFocus && notebookEditorFocused && notebookEditorCursorAtBoundary != \\\'bottom\\\' && notebookEditorCursorAtBoundary != \\\'none\\\'"}],"configuration":{"title":"Vim","type":"object","properties":{"vim.normalModeKeyBindings":{"type":"array","markdownDescription":"Remapped keys in Normal mode. Allows mapping to Vim commands or VS Code actions. See [README](https://github.com/VSCodeVim/Vim/#key-remapping) for details.","scope":"application"},"vim.normalModeKeyBindingsNonRecursive":{"type":"array","markdownDescription":"Non-recursive remapped keys in Normal mode. Allows mapping to Vim commands or VS Code actions. See [README](https://github.com/VSCodeVim/Vim/#key-remapping) for details.","scope":"application"},"vim.operatorPendingModeKeyBindings":{"type":"array","markdownDescription":"Remapped keys in OperatorPending mode. Allows mapping to Vim commands or VS Code actions. See [README](https://github.com/VSCodeVim/Vim/#key-remapping) for details.","scope":"application"},"vim.operatorPendingModeKeyBindingsNonRecursive":{"type":"array","markdownDescription":"Non-recursive remapped keys in OperatorPending mode. Allows mapping to Vim commands or VS Code actions. See [README](https://github.com/VSCodeVim/Vim/#key-remapping) for details.","scope":"application"},"vim.useCtrlKeys":{"type":"boolean","markdownDescription":"Enable some Vim Ctrl key commands that override otherwise common operations, like `Ctrl+C`.","default":true},"vim.leader":{"type":"string","markdownDescription":"What key should `<leader>` map to in remappings?","default":"\\\\\\\\"},"vim.searchHighlightColor":{"type":"string","markdownDescription":"Background color of non-current search matches. The color must not be opaque so as not to hide underlying decorations. Uses `#editor.findMatchHighlightColor#` from current theme if undefined."},"vim.searchHighlightTextColor":{"type":"string","markdownDescription":"Foreground color of non-current search matches."},"vim.searchMatchColor":{"type":"string","markdownDescription":"Background color of the current match. Uses `#editor.findMatchColor#` from current theme if undefined."},"vim.searchMatchTextColor":{"type":"string","markdownDescription":"Foreground color of the current match."},"vim.substitutionColor":{"type":"string","markdownDescription":"Background color of substituted text when `#editor.inccommand#` is enabled. Uses `#editor.findMatchColor#` from current theme if undefined."},"vim.substitutionTextColor":{"type":"string","markdownDescription":"Foreground color of substituted text when `#editor.inccommand#` is enabled."},"vim.highlightedyank.enable":{"type":"boolean","description":"Enable highlighting when yanking.","default":false},"vim.highlightedyank.color":{"type":"string","description":"Background color of yanked text. The color must not be opaque so as not to hide underlying decorations.","default":"rgba(250, 240, 170, 0.5)"},"vim.highlightedyank.textColor":{"type":"string","description":"Foreground color of yanked text."},"vim.highlightedyank.duration":{"type":"number","description":"Duration in milliseconds of the yank highlight.","default":200,"minimum":1},"vim.useSystemClipboard":{"type":"boolean","description":"Use system clipboard for unnamed register.","default":false},"vim.overrideCopy":{"type":"boolean","description":"Override VS Code\\\'s copy command with our own copy command, which works better with VSCodeVim. Turn this off if copying is not working.","default":true},"vim.insertModeKeyBindings":{"type":"array","markdownDescription":"Remapped keys in Insert mode. Allows mapping to Vim commands or VS Code actions. See [README](https://github.com/VSCodeVim/Vim/#key-remapping) for details.","scope":"application"},"vim.insertModeKeyBindingsNonRecursive":{"type":"array","markdownDescription":"Non-recursive keybinding overrides to use for Insert mode. Allows mapping to Vim commands or VS Code actions. See [README](https://github.com/VSCodeVim/Vim/#key-remapping) for details.","scope":"application"},"vim.visualModeKeyBindings":{"type":"array","markdownDescription":"Remapped keys in Visual mode. Allows mapping to Vim commands or VS Code actions. See [README](https://github.com/VSCodeVim/Vim/#key-remapping) for details.","scope":"application"},"vim.visualModeKeyBindingsNonRecursive":{"type":"array","markdownDescription":"Non-recursive keybinding overrides to use for Visual mode. Allows mapping to Vim commands or VS Code actions. See [README](https://github.com/VSCodeVim/Vim/#key-remapping) for details.","scope":"application"},"vim.commandLineModeKeyBindings":{"type":"array","markdownDescription":"Remapped keys in command line mode. Allows mapping to Vim commands or VS Code actions. See [README](https://github.com/VSCodeVim/Vim/#key-remapping) for details.","scope":"application"},"vim.commandLineModeKeyBindingsNonRecursive":{"type":"array","markdownDescription":"Non-recursive keybinding overrides to use for command line mode. Allows mapping to Vim commands or VS Code actions. See [README](https://github.com/VSCodeVim/Vim/#key-remapping) for details.","scope":"application"},"vim.textwidth":{"type":"number","markdownDescription":"Width to word-wrap to when using `gq`.","default":80,"scope":"language-overridable","minimum":1},"vim.timeout":{"type":"number","description":"Timeout in milliseconds for remapped commands.","default":1000,"minimum":0},"vim.maxmapdepth":{"type":"number","description":"Maximum number of times a mapping is done without resulting in a character to be used.","default":1000,"minimum":0},"vim.scroll":{"type":"number","markdownDescription":"Number of lines to scroll with `Ctrl-U` and `Ctrl-D` commands. Set to 0 to use a half page scroll.","default":0,"minimum":0},"vim.showcmd":{"type":"boolean","description":"Show the text of any command you are in the middle of writing.","default":true},"vim.showmodename":{"type":"boolean","description":"Show the name of the current mode in the statusbar.","default":true},"vim.iskeyword":{"type":"string","markdownDescription":"Keywords contain alphanumeric characters and \\\'_\\\'. If not configured, `#editor.wordSeparators#` is used."},"vim.ignorecase":{"type":"boolean","description":"Ignore case in search patterns.","default":true},"vim.smartcase":{"type":"boolean","markdownDescription":"Override the `ignorecase` option if the search pattern contains upper case characters.","default":true},"vim.matchpairs":{"type":"string","markdownDescription":"Characters that form pairs. The % command jumps from one to the other. Only character pairs are allowed that are different, thus you cannot jump between two double quotes. The characters must be separated by a colon. The pairs must be separated by a comma.","default":"(:),{:},[:]","pattern":"^(.:.)?(,.:.)*$"},"vim.camelCaseMotion.enable":{"type":"boolean","markdownDescription":"Enable the [CamelCaseMotion](https://github.com/bkad/CamelCaseMotion) plugin for Vim.","default":false},"vim.easymotion":{"type":"boolean","markdownDescription":"Enable the [EasyMotion](https://github.com/easymotion/vim-easymotion) plugin for Vim.","default":false},"vim.easymotionMarkerBackgroundColor":{"type":"string","default":"#0000","description":"Set a custom background color for EasyMotion markers."},"vim.easymotionMarkerForegroundColorOneChar":{"type":"string","default":"#ff0000","description":"Set a custom color for the text on one character long markers."},"vim.easymotionMarkerForegroundColorTwoCharFirst":{"type":"string","default":"#ffb400","description":"Set a custom color for the first character on two character long markers."},"vim.easymotionMarkerForegroundColorTwoCharSecond":{"type":"string","default":"#b98300","description":"Set a custom color for the second character on two character long markers."},"vim.easymotionIncSearchForegroundColor":{"type":"string","default":"#7fbf00","markdownDescription":"Set a custom color for the easymotion search n-character (default `<leader><leader>/`)."},"vim.easymotionDimColor":{"type":"string","default":"#777777","markdownDescription":"Set a custom color for the easymotion dimmed characters when `#vim.easymotionDimBackground#` is set to true."},"vim.easymotionDimBackground":{"type":"boolean","description":"Whether to dim other text while markers are visible.","default":true},"vim.easymotionMarkerFontWeight":{"type":"string","description":"Set the font weight of the marker text.","default":"bold"},"vim.easymotionKeys":{"type":"string","description":"Set the characters used for jump marker name.","default":"hklyuiopnm,qwertzxcvbasdgjf;"},"vim.easymotionJumpToAnywhereRegex":{"type":"string","description":"Regex matches for JumpToAnywhere motion.","default":"\\\\\\\\b[A-Za-z0-9]|[A-Za-z0-9]\\\\\\\\b|_.|#.|[a-z][A-Z]"},"vim.replaceWithRegister":{"type":"boolean","markdownDescription":"Enable the [ReplaceWithRegister](https://github.com/vim-scripts/ReplaceWithRegister) plugin for Vim.","default":false},"vim.smartRelativeLine":{"type":"boolean","markdownDescription":"`#editor.lineNumbers#` is determined by the active Vim mode, absolute when in insert mode, relative otherwise.","default":false},"vim.targets.enable":{"type":"boolean","markdownDescription":"Enable [targets.vim](https://github.com/wellle/targets.vim#quote-text-objects) plugin (not fully implemented yet).","default":false},"vim.targets.bracketObjects.enable":{"type":"boolean","markdownDescription":"Enable last/next movements for bracket objects.","default":true},"vim.targets.smartQuotes.enable":{"type":"boolean","markdownDescription":"Enable the smart quotes movements from [targets.vim](https://github.com/wellle/targets.vim#quote-text-objects).","default":true},"vim.targets.smartQuotes.breakThroughLines":{"type":"boolean","markdownDescription":"Whether to break through lines when using [n]ext/[l]ast motion, see [targets.vim#next-and-last-quote](https://github.com/wellle/targets.vim#next-and-last-quote).","default":true},"vim.targets.smartQuotes.aIncludesSurroundingSpaces":{"type":"boolean","markdownDescription":"Whether to use default Vim behavior when using `a` (e.g. `da\\\'`) which include surrounding spaces, or not, as for other text objects.","default":true},"vim.sneak":{"type":"boolean","markdownDescription":"Enable the [Sneak](https://github.com/justinmk/vim-sneak) plugin for Vim.","default":false},"vim.sneakUseIgnorecaseAndSmartcase":{"type":"boolean","markdownDescription":"Case sensitivity is determined by `#vim.ignorecase#` and `#vim.smartcase#`.","default":false},"vim.sneakReplacesF":{"type":"boolean","markdownDescription":"Use single-character [Sneak](https://github.com/justinmk/vim-sneak) instead of Vim\\\'s native `f`.","default":false},"vim.surround":{"type":"boolean","markdownDescription":"Enable the [Surround](https://github.com/tpope/vim-surround) plugin for Vim.","default":true},"vim.argumentObjectSeparators":{"type":"array","items":{"type":"string"},"markdownDescription":"Set separators for the argument text object.","default":[","]},"vim.argumentObjectOpeningDelimiters":{"type":"array","items":{"type":"string"},"markdownDescription":"Set opening delimiters for the argument text object.","default":["(","["]},"vim.argumentObjectClosingDelimiters":{"type":"array","items":{"type":"string"},"markdownDescription":"Set closing delimiters for the argument text object.","default":[")","]"]},"vim.hlsearch":{"type":"boolean","description":"Show all matches of the most recent search pattern.","default":false},"vim.inccommand":{"type":"string","markdownDescription":"Show the effects of the `:substitute` command as you type.","default":"replace","enum":["","append","replace"],"enumDescriptions":["Don\\\'t show substitutions","Show substitutions after matched text","Replace matched text with substitutions"]},"vim.incsearch":{"type":"boolean","markdownDescription":"Show where a `/` or `?` search matches as you type it.","default":true},"vim.history":{"type":"number","description":"How much search or command history should be remembered.","default":50,"minimum":1,"maximum":10000},"vim.autoindent":{"type":"boolean","description":"Indent code automatically.","default":true},"vim.joinspaces":{"type":"boolean","description":"Add two spaces after \\\'.\\\', \\\'?\\\', and \\\'!\\\' when joining or reformatting.","default":true},"vim.startInInsertMode":{"type":"boolean","description":"Start in Insert mode."},"vim.handleKeys":{"type":"object","description":"Delegate certain key combinations back to VS Code to be handled natively.","default":{"<C-d>":true,"<C-s>":false,"<C-z>":false}},"vim.statusBarColorControl":{"type":"boolean","markdownDescription":"Allow VSCodeVim to change status bar color based on mode. **NOTE:** Using this feature will have a negative impact on performance.","default":false},"vim.statusBarColors.normal":{"type":["string","array"],"description":"Status bar color when in Normal mode.","default":["#005f5f","#ffffff"]},"vim.statusBarColors.insert":{"type":["string","array"],"description":"Status bar color when in Insert mode.","default":["#5f0000","#ffffff"]},"vim.statusBarColors.visual":{"type":["string","array"],"description":"Status bar color when in Visual mode.","default":["#5f00af","#ffffff"]},"vim.statusBarColors.visualline":{"type":["string","array"],"description":"Status bar color when in VisualLine mode.","default":["#005f87","#ffffff"]},"vim.statusBarColors.visualblock":{"type":["string","array"],"description":"Status bar color when in VisualBlock mode.","default":["#86592d","#ffffff"]},"vim.statusBarColors.replace":{"type":["string","array"],"description":"Status bar color when in Replace mode.","default":["#00000","#ffffff"]},"vim.statusBarColors.commandlineinprogress":{"type":["string","array"],"description":"Status bar color when in CommandLineInProgress mode.","default":["#007acc","#ffffff"]},"vim.statusBarColors.searchinprogressmode":{"type":["string","array"],"description":"Status bar color when in SearchInProgress mode.","default":["#007acc","#ffffff"]},"vim.statusBarColors.easymotionmode":{"type":["string","array"],"description":"Status bar color when in EasyMotion mode.","default":["#007acc","#ffffff"]},"vim.statusBarColors.easymotioninputmode":{"type":["string","array"],"description":"Status bar color when in EasyMotionInput mode.","default":["#007acc","#ffffff"]},"vim.statusBarColors.surroundinputmode":{"type":["string","array"],"description":"Status bar color when in SurroundInput mode.","default":["#007acc","#ffffff"]},"vim.visualstar":{"type":"boolean","markdownDescription":"In Visual mode, start a search with `*` or `#` using the current selection.","default":false},"vim.changeWordIncludesWhitespace":{"type":"boolean","description":"Includes trailing whitespace when changing word.","default":false},"vim.foldfix":{"type":"boolean","description":"Uses a hack to move around folds properly.","default":false},"vim.mouseSelectionGoesIntoVisualMode":{"type":"boolean","description":"If enabled, dragging with the mouse activates Visual mode.","default":true},"vim.disableExtension":{"type":"boolean","description":"Disables the VSCodeVim extension. The extension will continue to be loaded and activated, but Vim functionality will be disabled.","default":false},"vim.enableNeovim":{"type":"boolean","markdownDescription":"Use Neovim to execute Ex commands. You should restart VS Code after enabling/disabling this for the changes to take effect. **NOTE:** Neovim version 0.2.0 or greater must be installed, and if the executable is not on your PATH, `#vim.neovimPath#` must be set.","default":false},"vim.neovimPath":{"type":"string","markdownDescription":"Path to Neovim executable. For example, `/usr/bin/nvim`, or  `C:\\\\\\\\Program Files\\\\\\\\Neovim\\\\\\\\bin\\\\\\\\nvim.exe`.","default":"","scope":"machine"},"vim.neovimUseConfigFile":{"type":"boolean","markdownDescription":"Use a config file for Neovim, specified by `#vim.neovimConfigPath#`.","default":false},"vim.neovimConfigPath":{"type":"string","markdownDescription":"Path to Neovim configuration file. `#vim.neovimUseConfigFile#` must be enabled. If path is left blank, Neovim will use its default config path, i.e. `~/.config/nvim/init.vim` or \\\'C:\\\\\\\\Users\\\\\\\\USERNAME\\\\\\\\AppData\\\\\\\\Local\\\\\\\\nvim\\\\\\\\init.vim\\\'.","default":"","scope":"machine"},"vim.vimrc.enable":{"type":"boolean","markdownDescription":"Use key mappings from a `.vimrc` file.","default":false},"vim.vimrc.path":{"type":"string","markdownDescription":"Path to a Vim configuration file. If unset, it will check for `$HOME/.vscodevimrc`, `$HOME/.vimrc`, `$HOME/_vimrc`, and `$HOME/.config/nvim/init.vim`, in that order."},"vim.substituteGlobalFlag":{"type":"boolean","markdownDescription":"Automatically apply the global flag, `/g`, to substitute commands. When set to true, use `/g` to mean only first match should be replaced.","default":false,"markdownDeprecationMessage":"**Deprecated**: Please use `#vim.gdefault#` instead.","deprecationMessage":"Deprecated: Please use vim.gdefault instead."},"vim.gdefault":{"type":"boolean","markdownDescription":"Automatically apply the global flag, `/g`, to substitute commands. When set to true, use `/g` to mean only first match should be replaced.","default":false},"vim.cursorStylePerMode.normal":{"type":"string","description":"Cursor style for Normal mode.","enum":["","block","block-outline","line","line-thin","underline","underline-thin"]},"vim.cursorStylePerMode.insert":{"type":"string","description":"Cursor style for Insert mode.","enum":["","block","block-outline","line","line-thin","underline","underline-thin"]},"vim.cursorStylePerMode.replace":{"type":"string","description":"Cursor style for Replace mode.","enum":["","block","block-outline","line","line-thin","underline","underline-thin"]},"vim.cursorStylePerMode.visual":{"type":"string","description":"Cursor style for Visual mode.","enum":["","block","block-outline","line","line-thin","underline","underline-thin"]},"vim.cursorStylePerMode.visualline":{"type":"string","description":"Cursor style for VisualLine mode.","enum":["","block","block-outline","line","line-thin","underline","underline-thin"]},"vim.cursorStylePerMode.visualblock":{"type":"string","description":"Cursor style for VisualBlock mode.","enum":["","block","block-outline","line","line-thin","underline","underline-thin"]},"vim.autoSwitchInputMethod.enable":{"type":"boolean","description":"If enabled, the input method switches automatically when the mode changes.","default":false},"vim.autoSwitchInputMethod.defaultIM":{"type":"string","markdownDescription":"The input method for your normal mode, find more information [here](https://github.com/VSCodeVim/Vim#input-method).","default":"","scope":"machine"},"vim.autoSwitchInputMethod.switchIMCmd":{"type":"string","description":"The shell command to switch input method.","default":"/path/to/im-select {im}","scope":"machine"},"vim.autoSwitchInputMethod.obtainIMCmd":{"type":"string","description":"The shell command to get current input method.","default":"/path/to/im-select","scope":"machine"},"vim.whichwrap":{"type":"string","description":"Comma-separated list of motion keys that should wrap to next/previous line.","default":"b,s"},"vim.report":{"type":"number","description":"Threshold for reporting number of lines changed.","default":2,"minimum":1},"vim.digraphs":{"type":"object","description":"Custom digraph shortcuts for inserting special characters, expressed as UTF16 code points.","default":{}},"vim.wrapscan":{"type":"boolean","description":"Searches wrap around the end of the file.","default":true},"vim.startofline":{"type":"boolean","markdownDescription":"When `true` the commands listed below move the cursor to the first non-blank of the line.  When `false` the cursor is kept in the same column (if possible).  This applies to the commands: `<C-d>`, `<C-u>`, `<C-b>`, `<C-f>`, `G`, `H`, `M`, `L`, `gg`, and to the commands `d`, `<<` and `>>` with a linewise operator.","default":true},"vim.showMarksInGutter":{"type":"boolean","description":"Show the currently set mark(s) in the gutter.","default":false},"vim.shell":{"type":"string","description":"Path to the shell to use for `!` and `:!` commands.","default":""}}},"languages":[{"id":"Vimscript","extensions":[".vim",".vimrc"],"configuration":"./language-configuration.json"}],"grammars":[{"language":"Vimscript","scopeName":"source.vimscript","path":"./syntaxes/vimscript.tmLanguage.json"}]},"scripts":{"vscode:prepublish":"gulp build","build":"gulp build","build-dev":"gulp build-dev","build-test":"gulp prepare-test","test":"node ./out/test/runTest.js","lint":"eslint .","lint:fix":"eslint . --fix","prettier":"prettier --write .","prettier:check":"prettier --check .","watch":"webpack -c webpack.dev.js --watch","package":"yarn run vsce package --yarn --allow-star-activation","prepare":"husky install"},"dependencies":{"diff-match-patch":"1.0.5","lodash":"^4.17.21","neovim":"4.10.1","os-browserify":"0.3.0","parsimmon":"^1.18.0","path-browserify":"1.0.1","process":"0.11.10","queue":"^6.0.2","untildify":"4.0.0","util":"0.12.5"},"devDependencies":{"@types/diff":"5.0.9","@types/diff-match-patch":"1.0.36","@types/glob":"8.1.0","@types/lodash":"4.14.202","@types/mocha":"10.0.6","@types/node":"18.19.3","@types/parsimmon":"1.10.9","@types/sinon":"17.0.2","@types/vscode":"1.74.0","@typescript-eslint/eslint-plugin":"^6.9.0","@typescript-eslint/parser":"^6.9.0","@vscode/test-electron":"2.3.8","circular-dependency-plugin":"^5.2.2","clean-webpack-plugin":"4.0.0","eslint":"^8.52.0","eslint-config-prettier":"^9.0.0","eslint-plugin-jsdoc":"^46.8.2","eslint-plugin-prefer-arrow":"^1.2.3","event-stream":"4.0.1","fork-ts-checker-webpack-plugin":"9.0.2","gulp":"4.0.2","gulp-bump":"3.2.0","gulp-git":"2.10.1","gulp-tag-version":"1.3.1","gulp-typescript":"5.0.1","husky":"^8.0.3","lint-staged":"^15.0.0","minimist":"1.2.8","mocha":"10.2.0","plugin-error":"2.0.1","prettier":"3.1.1","sinon":"17.0.1","ts-loader":"9.5.1","typescript":"5.3.3","vsce":"2.15.0","webpack":"5.89.0","webpack-cli":"5.1.4","webpack-merge":"5.10.0","webpack-stream":"7.0.0"},"lint-staged":{"*.{ts,js,json,md,yml}":"prettier --write","*.ts":"eslint --fix"}}\');\n\n//# sourceURL=webpack://vim/./package.json?')}},__webpack_module_cache__={};function __webpack_require__(e){var n=__webpack_module_cache__[e];if(void 0!==n)return n.exports;var t=__webpack_module_cache__[e]={id:e,loaded:!1,exports:{}};return __webpack_modules__[e].call(t.exports,t,t.exports,__webpack_require__),t.loaded=!0,t.exports}__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),__webpack_require__.nmd=e=>(e.paths=[],e.children||(e.children=[]),e);var __webpack_exports__=__webpack_require__("./extensionWeb.ts");return __webpack_exports__})()));